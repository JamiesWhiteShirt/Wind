; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_R2ChunkBase@@8				; ChunkBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8	; std::_Ref_count<EmptyChunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@EmptyChunk@@8			; EmptyChunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVChunk@@@8				; Chunk `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@Chunk@@8				; Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4EmptyChunk@@6B@				; EmptyChunk::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8	; std::_Ref_count<EmptyChunk> `RTTI Type Descriptor'
PUBLIC	??_R0?AVChunkBase@@@8				; ChunkBase `RTTI Type Descriptor'
PUBLIC	??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@	; std::_Ref_count<EmptyChunk>::`RTTI Complete Object Locator'
PUBLIC	??_R3EmptyChunk@@8				; EmptyChunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$_Ref_count@VEmptyChunk@@@std@@8		; std::_Ref_count<EmptyChunk>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4ChunkBase@@6B@				; ChunkBase::`RTTI Complete Object Locator'
PUBLIC	??_R2Chunk@@8					; Chunk::`RTTI Base Class Array'
PUBLIC	??_R3Chunk@@8					; Chunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3ChunkBase@@8				; ChunkBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7Chunk@@6B@					; Chunk::`vftable'
PUBLIC	??_R0?AVEmptyChunk@@@8				; EmptyChunk `RTTI Type Descriptor'
PUBLIC	??_7EmptyChunk@@6B@				; EmptyChunk::`vftable'
PUBLIC	??_R2?$_Ref_count@VEmptyChunk@@@std@@8		; std::_Ref_count<EmptyChunk>::`RTTI Base Class Array'
PUBLIC	??_7?$_Ref_count@VEmptyChunk@@@std@@6B@		; std::_Ref_count<EmptyChunk>::`vftable'
PUBLIC	??_R2EmptyChunk@@8				; EmptyChunk::`RTTI Base Class Array'
PUBLIC	??_R4Chunk@@6B@					; Chunk::`RTTI Complete Object Locator'
PUBLIC	??_7ChunkBase@@6B@				; ChunkBase::`vftable'
PUBLIC	??_R1A@?0A@EA@ChunkBase@@8			; ChunkBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@ChunkBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChunkBase@@8 DD imagerel ??_R0?AVChunkBase@@@8 ; ChunkBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_7ChunkBase@@6B@
CONST	SEGMENT
??_7ChunkBase@@6B@ DQ FLAT:??_R4ChunkBase@@6B@		; ChunkBase::`vftable'
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:?dataPtr@ChunkBase@@UEAAPEAGXZ
	DQ	FLAT:?shouldRender@ChunkBase@@UEAA_NXZ
CONST	ENDS
;	COMDAT ??_R4Chunk@@6B@
rdata$r	SEGMENT
??_R4Chunk@@6B@ DD 01H					; Chunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVChunk@@@8
	DD	imagerel ??_R3Chunk@@8
	DD	imagerel ??_R4Chunk@@6B@
rdata$r	ENDS
;	COMDAT ??_R2EmptyChunk@@8
rdata$r	SEGMENT
??_R2EmptyChunk@@8 DD imagerel ??_R1A@?0A@EA@EmptyChunk@@8 ; EmptyChunk::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ChunkBase@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count@VEmptyChunk@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VEmptyChunk@@@std@@6B@ DQ FLAT:??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@ ; std::_Ref_count<EmptyChunk>::`vftable'
	DQ	FLAT:?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
	DQ	FLAT:?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
	DQ	FLAT:??_E?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R2?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VEmptyChunk@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8 ; std::_Ref_count<EmptyChunk>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7EmptyChunk@@6B@
CONST	SEGMENT
??_7EmptyChunk@@6B@ DQ FLAT:??_R4EmptyChunk@@6B@	; EmptyChunk::`vftable'
	DQ	FLAT:?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z
	DQ	FLAT:?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z
	DQ	FLAT:?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z
	DQ	FLAT:?isEmpty@EmptyChunk@@UEAA_NXZ
	DQ	FLAT:?dataPtr@ChunkBase@@UEAAPEAGXZ
	DQ	FLAT:?shouldRender@EmptyChunk@@UEAA_NXZ
CONST	ENDS
;	COMDAT ??_R0?AVEmptyChunk@@@8
_DATA	SEGMENT
??_R0?AVEmptyChunk@@@8 DQ FLAT:??_7type_info@@6B@	; EmptyChunk `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVEmptyChunk@@', 00H
_DATA	ENDS
;	COMDAT ??_7Chunk@@6B@
CONST	SEGMENT
??_7Chunk@@6B@ DQ FLAT:??_R4Chunk@@6B@			; Chunk::`vftable'
	DQ	FLAT:?getBlock@Chunk@@UEAAPEAVBlock@@III@Z
	DQ	FLAT:?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z
	DQ	FLAT:?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z
	DQ	FLAT:?isEmpty@Chunk@@UEAA_NXZ
	DQ	FLAT:?dataPtr@Chunk@@UEAAPEAGXZ
	DQ	FLAT:?shouldRender@Chunk@@UEAA_NXZ
CONST	ENDS
;	COMDAT ??_R3ChunkBase@@8
rdata$r	SEGMENT
??_R3ChunkBase@@8 DD 00H				; ChunkBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_R3Chunk@@8
rdata$r	SEGMENT
??_R3Chunk@@8 DD 00H					; Chunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Chunk@@8
rdata$r	ENDS
;	COMDAT ??_R2Chunk@@8
rdata$r	SEGMENT
??_R2Chunk@@8 DD imagerel ??_R1A@?0A@EA@Chunk@@8	; Chunk::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ChunkBase@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4ChunkBase@@6B@
rdata$r	SEGMENT
??_R4ChunkBase@@6B@ DD 01H				; ChunkBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVChunkBase@@@8
	DD	imagerel ??_R3ChunkBase@@8
	DD	imagerel ??_R4ChunkBase@@6B@
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VEmptyChunk@@@std@@8 DD 00H		; std::_Ref_count<EmptyChunk>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3EmptyChunk@@8
rdata$r	SEGMENT
??_R3EmptyChunk@@8 DD 00H				; EmptyChunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2EmptyChunk@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@ DD 01H		; std::_Ref_count<EmptyChunk>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8
	DD	imagerel ??_R3?$_Ref_count@VEmptyChunk@@@std@@8
	DD	imagerel ??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVChunkBase@@@8
_DATA	SEGMENT
??_R0?AVChunkBase@@@8 DQ FLAT:??_7type_info@@6B@	; ChunkBase `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVChunkBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count<EmptyChunk> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Ref_count@VEmptyChunk@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4EmptyChunk@@6B@
rdata$r	SEGMENT
??_R4EmptyChunk@@6B@ DD 01H				; EmptyChunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVEmptyChunk@@@8
	DD	imagerel ??_R3EmptyChunk@@8
	DD	imagerel ??_R4EmptyChunk@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Chunk@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Chunk@@8 DD imagerel ??_R0?AVChunk@@@8	; Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Chunk@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChunk@@@8
_DATA	SEGMENT
??_R0?AVChunk@@@8 DQ FLAT:??_7type_info@@6B@		; Chunk `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVChunk@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@EmptyChunk@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@EmptyChunk@@8 DD imagerel ??_R0?AVEmptyChunk@@@8 ; EmptyChunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3EmptyChunk@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8 DD imagerel ??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8 ; std::_Ref_count<EmptyChunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ChunkBase@@8
rdata$r	SEGMENT
??_R2ChunkBase@@8 DD imagerel ??_R1A@?0A@EA@ChunkBase@@8 ; ChunkBase::`RTTI Base Class Array'
	ORG $+3
PUBLIC	??$forward@VChunkPosition@@@std@@YA$$QEAVChunkPosition@@AEAV1@@Z ; std::forward<ChunkPosition>
PUBLIC	??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAX@Z ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$?0AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64,bool>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAU01@PEAPEAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
PUBLIC	??$_Buynode_if_nil@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEBA_KXZ ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size
PUBLIC	??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_size
PUBLIC	??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >
PUBLIC	??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor'
PUBLIC	??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
PUBLIC	??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$forward@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVEmptyChunk@@PEAV_Ref_count_base@1@@Z ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
PUBLIC	??1?$_Ref_count@VEmptyChunk@@@std@@UEAA@XZ	; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>
PUBLIC	??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ ; std::_Ref_count<EmptyChunk>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ ; std::_Ref_count<EmptyChunk>::_Destroy
PUBLIC	??0?$_Ref_count@VEmptyChunk@@@std@@QEAA@PEAVEmptyChunk@@@Z ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>
PUBLIC	??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
PUBLIC	??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	?_Freenode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode0
PUBLIC	?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode0
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size
PUBLIC	??_GEmptyChunk@@QEAAPEAXI@Z			; EmptyChunk::`scalar deleting destructor'
PUBLIC	??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU31@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
PUBLIC	??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
PUBLIC	??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$forward@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_KUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>
PUBLIC	??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@AEBV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$forward@AEBVChunkPosition@@@std@@YAAEBVChunkPosition@@AEBV1@@Z ; std::forward<ChunkPosition const & __ptr64>
PUBLIC	??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
PUBLIC	??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z ; std::_Allocate<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >
PUBLIC	??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
PUBLIC	??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$addressof@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >
PUBLIC	??$?0AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEAV01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PEAPEAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_K@Z ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>
PUBLIC	??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAU01@PEAPEAX@Z ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$?0AEBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBVChunkPosition@@$$QEAV?$shared_ptr@VChunkBase@@@1@PEAPEAX@Z ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const & __ptr64,std::shared_ptr<ChunkBase> >
PUBLIC	??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>
PUBLIC	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::allocate
PUBLIC	??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??0?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >
PUBLIC	?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
PUBLIC	?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >
PUBLIC	??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Max
PUBLIC	?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEADPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Color
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::deallocate
PUBLIC	?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal
PUBLIC	??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Root
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rmost
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase
PUBLIC	??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode
PUBLIC	??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	?_Kfn@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Kfn
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@AEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound
PUBLIC	?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to
PUBLIC	?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode
PUBLIC	??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
PUBLIC	?swap@?$shared_ptr@VChunkBase@@@std@@QEAAXAEAV12@@Z ; std::shared_ptr<ChunkBase>::swap
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QEAA@XZ	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AU?$less@VChunkPosition@@@2@XZ ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Getcomp
PUBLIC	??R?$less@VChunkPosition@@@std@@QEBA_NAEBVChunkPosition@@0@Z ; std::less<ChunkPosition>::operator()
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEBVChunkPosition@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Key
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tidy
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	??1?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??1?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >
PUBLIC	??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
PUBLIC	??B?$shared_ptr@VChunkBase@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VChunkBase@@@std@@@1@HXZ ; std::shared_ptr<ChunkBase>::operator int std::_Bool_struct<std::shared_ptr<ChunkBase> >::* __ptr64
PUBLIC	??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z ; std::shared_ptr<ChunkBase>::operator=
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
PUBLIC	??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
PUBLIC	??M@YA_NAEBVChunkPosition@@0@Z			; operator<
PUBLIC	?setBlock@World@@QEAAXHHHPEAVBlock@@@Z		; World::setBlock
PUBLIC	?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
PUBLIC	??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	?shouldRender@Chunk@@UEAA_NXZ			; Chunk::shouldRender
PUBLIC	?dataPtr@Chunk@@UEAAPEAGXZ			; Chunk::dataPtr
PUBLIC	?isEmpty@Chunk@@UEAA_NXZ			; Chunk::isEmpty
PUBLIC	?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z	; Chunk::setBlockRaw
PUBLIC	?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z		; Chunk::setBlock
PUBLIC	?getBlock@Chunk@@UEAAPEAVBlock@@III@Z		; Chunk::getBlock
PUBLIC	??1Chunk@@QEAA@XZ				; Chunk::~Chunk
PUBLIC	??0Chunk@@QEAA@AEAVWorld@@HHH@Z			; Chunk::Chunk
PUBLIC	?shouldRender@EmptyChunk@@UEAA_NXZ		; EmptyChunk::shouldRender
PUBLIC	?isEmpty@EmptyChunk@@UEAA_NXZ			; EmptyChunk::isEmpty
PUBLIC	?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z	; EmptyChunk::setBlockRaw
PUBLIC	?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z	; EmptyChunk::setBlock
PUBLIC	?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z	; EmptyChunk::getBlock
PUBLIC	??1EmptyChunk@@QEAA@XZ				; EmptyChunk::~EmptyChunk
PUBLIC	??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z		; EmptyChunk::EmptyChunk
PUBLIC	?shouldRender@ChunkBase@@UEAA_NXZ		; ChunkBase::shouldRender
PUBLIC	?dataPtr@ChunkBase@@UEAAPEAGXZ			; ChunkBase::dataPtr
PUBLIC	??1ChunkBase@@QEAA@XZ				; ChunkBase::~ChunkBase
PUBLIC	??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z		; ChunkBase::ChunkBase
PUBLIC	??0ChunkPosition@@QEAA@HHH@Z			; ChunkPosition::ChunkPosition
PUBLIC	?toIndex@@YAIAEAI00@Z				; toIndex
PUBLIC	??1World@@QEAA@XZ				; World::~World
PUBLIC	??0World@@QEAA@XZ				; World::World
PUBLIC	?removeChunk@World@@QEAAXVChunkPosition@@@Z	; World::removeChunk
PUBLIC	?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; World::addChunk
PUBLIC	?setUnloaded@ChunkBase@@QEAAXXZ			; ChunkBase::setUnloaded
PUBLIC	?setLoaded@ChunkBase@@QEAAXXZ			; ChunkBase::setLoaded
PUBLIC	?getBlock@World@@QEAAPEAVBlock@@HHH@Z		; World::getBlock
PUBLIC	?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
PUBLIC	?isRenderUpdateNeeded@ChunkBase@@QEAA_NXZ	; ChunkBase::isRenderUpdateNeeded
PUBLIC	?setRenderUpdateNeeded@ChunkBase@@QEAAX_N@Z	; ChunkBase::setRenderUpdateNeeded
PUBLIC	?isUnloaded@ChunkBase@@QEAA_NXZ			; ChunkBase::isUnloaded
PUBLIC	?isLoaded@ChunkBase@@QEAA_NXZ			; ChunkBase::isLoaded
EXTRN	??_E?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z:PROC ; std::_Ref_count<EmptyChunk>::`vector deleting destructor'
_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN6
	DD	imagerel $LN6+23
	DD	imagerel $unwind$??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16+19
	DD	imagerel $LN16+54
	DD	imagerel $chain$0$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16+54
	DD	imagerel $LN16+60
	DD	imagerel $chain$1$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN22+26
	DD	imagerel $LN22+75
	DD	imagerel $chain$0$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN22+75
	DD	imagerel $LN22+89
	DD	imagerel $chain$1$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN21+19
	DD	imagerel $LN21+54
	DD	imagerel $chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN21+54
	DD	imagerel $LN21+60
	DD	imagerel $chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD imagerel $LN275
	DD	imagerel $LN275+469
	DD	imagerel $unwind$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA DD imagerel ?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA+35
	DD	imagerel $unwind$?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD imagerel $LN420
	DD	imagerel $LN420+31
	DD	imagerel $unwind$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD imagerel $LN420+31
	DD	imagerel $LN420+92
	DD	imagerel $chain$1$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD imagerel $LN420+92
	DD	imagerel $LN420+711
	DD	imagerel $chain$2$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD imagerel $LN420+711
	DD	imagerel $LN420+725
	DD	imagerel $chain$3$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD imagerel $LN420+725
	DD	imagerel $LN420+750
	DD	imagerel $chain$4$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ DD imagerel $LN98
	DD	imagerel $LN98+78
	DD	imagerel $unwind$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN39
	DD	imagerel $LN39+26
	DD	imagerel $unwind$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN39+26
	DD	imagerel $LN39+61
	DD	imagerel $chain$0$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN39+61
	DD	imagerel $LN39+79
	DD	imagerel $chain$1$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GEmptyChunk@@QEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$??_GEmptyChunk@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN23+19
	DD	imagerel $LN23+54
	DD	imagerel $chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN23+54
	DD	imagerel $LN23+60
	DD	imagerel $chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD imagerel $LN689
	DD	imagerel $LN689+800
	DD	imagerel $unwind$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA DD imagerel ?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA+35
	DD	imagerel $unwind$?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN98
	DD	imagerel $LN98+104
	DD	imagerel $unwind$??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD imagerel $LN31
	DD	imagerel $LN31+99
	DD	imagerel $unwind$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA DD imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA+59
	DD	imagerel $unwind$?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z DD imagerel $LN14
	DD	imagerel $LN14+44
	DD	imagerel $unwind$??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN25
	DD	imagerel $LN25+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN25+19
	DD	imagerel $LN25+54
	DD	imagerel $chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN25+54
	DD	imagerel $LN25+60
	DD	imagerel $chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN8
	DD	imagerel $LN8+68
	DD	imagerel $unwind$??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+30
	DD	imagerel $unwind$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+30
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ DD imagerel $LN102
	DD	imagerel $LN102+63
	DD	imagerel $unwind$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+35
	DD	imagerel $unwind$??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel $LN9
	DD	imagerel $LN9+35
	DD	imagerel $unwind$??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN50
	DD	imagerel $LN50+30
	DD	imagerel $unwind$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN50+30
	DD	imagerel $LN50+110
	DD	imagerel $chain$0$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN50+110
	DD	imagerel $LN50+126
	DD	imagerel $chain$1$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel $LN12
	DD	imagerel $LN12+35
	DD	imagerel $unwind$??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z DD imagerel $LN136
	DD	imagerel $LN136+250
	DD	imagerel $unwind$?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN20
	DD	imagerel $LN20+55
	DD	imagerel $unwind$?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN392
	DD	imagerel $LN392+37
	DD	imagerel $unwind$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN392+37
	DD	imagerel $LN392+852
	DD	imagerel $chain$2$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN392+852
	DD	imagerel $LN392+891
	DD	imagerel $chain$3$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN28
	DD	imagerel $LN28+28
	DD	imagerel $unwind$?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z DD imagerel $LN10
	DD	imagerel $LN10+42
	DD	imagerel $unwind$?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z DD imagerel $LN127
	DD	imagerel $LN127+250
	DD	imagerel $unwind$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+35
	DD	imagerel $unwind$??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16+19
	DD	imagerel $LN16+54
	DD	imagerel $chain$0$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16+54
	DD	imagerel $LN16+60
	DD	imagerel $chain$1$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+57
	DD	imagerel $LN59+86
	DD	imagerel $chain$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+86
	DD	imagerel $LN59+111
	DD	imagerel $chain$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+111
	DD	imagerel $LN59+120
	DD	imagerel $chain$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z DD imagerel $LN101
	DD	imagerel $LN101+184
	DD	imagerel $unwind$?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z DD imagerel $LN77
	DD	imagerel $LN77+158
	DD	imagerel $unwind$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN62
	DD	imagerel $LN62+41
	DD	imagerel $unwind$??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD imagerel $LN175
	DD	imagerel $LN175+320
	DD	imagerel $unwind$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN20
	DD	imagerel $LN20+35
	DD	imagerel $unwind$??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z DD imagerel $LN6
	DD	imagerel $LN6+34
	DD	imagerel $unwind$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD imagerel $LN99
	DD	imagerel $LN99+589
	DD	imagerel $unwind$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN64
	DD	imagerel $LN64+41
	DD	imagerel $unwind$??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Chunk@@QEAA@AEAVWorld@@HHH@Z DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$??0Chunk@@QEAA@AEAVWorld@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ChunkBase@@QEAA@XZ DD imagerel $LN34
	DD	imagerel $LN34+137
	DD	imagerel $unwind$??1ChunkBase@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD imagerel $LN35
	DD	imagerel $LN35+172
	DD	imagerel $unwind$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1World@@QEAA@XZ DD imagerel $LN106
	DD	imagerel $LN106+134
	DD	imagerel $unwind$??1World@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0World@@QEAA@XZ DD imagerel $LN156
	DD	imagerel $LN156+262
	DD	imagerel $unwind$??0World@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN49
	DD	imagerel $LN49+192
	DD	imagerel $unwind$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD imagerel $LN50
	DD	imagerel $LN50+195
	DD	imagerel $unwind$?getBlock@World@@QEAAPEAVBlock@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD imagerel $LN153
	DD	imagerel $LN153+339
	DD	imagerel $unwind$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD imagerel ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
	DD	0ffffffffH
	DD	imagerel ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z+212
	DD	00H
	DD	imagerel ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z+257
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 0a2011H
	DD	0116420H
	DD	010541cH
	DD	0f3418H
	DD	0f008920cH
	DD	07004e006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD imagerel ?getBlock@World@@QEAAPEAVBlock@@HHH@Z
	DD	0ffffffffH
	DD	imagerel ?getBlock@World@@QEAAPEAVBlock@@HHH@Z+60
	DD	00H
	DD	imagerel ?getBlock@World@@QEAAPEAVBlock@@HHH@Z+125
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??getBlock@World@@QEAAPEAVBlock@@HHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?getBlock@World@@QEAAPEAVBlock@@HHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?getBlock@World@@QEAAPEAVBlock@@HHH@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD 081e11H
	DD	0e641eH
	DD	0d5419H
	DD	0c3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?getBlock@World@@QEAAPEAVBlock@@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z+29
	DD	00H
	DD	imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z+61
	DD	0ffffffffH
	DD	imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z+109
	DD	00H
	DD	imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z+133
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 061a11H
	DD	0c341aH
	DD	07008520cH
	DD	050066007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0World@@QEAA@XZ DD imagerel ??0World@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0World@@QEAA@XZ+54
	DD	00H
	DD	imagerel ??0World@@QEAA@XZ+73
	DD	01H
	DD	imagerel ??0World@@QEAA@XZ+97
	DD	02H
	DD	imagerel ??0World@@QEAA@XZ+157
	DD	03H
	DD	imagerel ??0World@@QEAA@XZ+183
	DD	04H
	DD	imagerel ??0World@@QEAA@XZ+243
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0World@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0World@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0World@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0World@@QEAA@XZ@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0???0World@@QEAA@XZ@4HA
	DD	03H
	DD	imagerel ?dtor$4@?0???0World@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0World@@QEAA@XZ DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$??0World@@QEAA@XZ
	DD	00H
	DD	00H
	DD	07H
	DD	imagerel $ip2state$??0World@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0World@@QEAA@XZ DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0World@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1World@@QEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
	DD	0ffffffffH
	DD	imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z+92
	DD	00H
	DD	imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z+118
	DD	01H
	DD	imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z+139
	DD	02H
	DD	imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z+158
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ChunkBase@@QEAA@XZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Chunk@@QEAA@AEAVWorld@@HHH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
	DD	0ffffffffH
	DD	imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z+71
	DD	00H
	DD	imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z+296
	DD	01H
	DD	imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z+418
	DD	00H
	DD	imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z+516
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD 0a2911H
	DD	0193429H
	DD	0f016f21dH
	DD	0d012e014H
	DD	0700ec010H
	DD	0500c600dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD imagerel ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
	DD	0ffffffffH
	DD	imagerel ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z+160
	DD	00H
	DD	imagerel ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z+202
	DD	01H
	DD	imagerel ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z+251
	DD	00H
	DD	imagerel ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z+298
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD 061811H
	DD	0126418H
	DD	0113414H
	DD	07004d208H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z DD 020501H
	DD	023405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	096405H
	DD	imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z DD 041401H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN392
	DD	imagerel $LN392+37
	DD	imagerel $unwind$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 066021H
	DD	097460H
	DD	04e40eH
	DD	083405H
	DD	imagerel $LN392
	DD	imagerel $LN392+37
	DD	imagerel $unwind$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 030c01H
	DD	0f008420cH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z DD 060f01H
	DD	03740fH
	DD	02640aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 021H
	DD	imagerel $LN50
	DD	imagerel $LN50+30
	DD	imagerel $unwind$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN50
	DD	imagerel $LN50+30
	DD	imagerel $unwind$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 060f01H
	DD	08640fH
	DD	07540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 040f01H
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 021H
	DD	imagerel $LN25
	DD	imagerel $LN25+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN25
	DD	imagerel $LN25+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD imagerel ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z+30
	DD	00H
	DD	imagerel ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z+88
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA+14
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 041819H
	DD	083418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD imagerel ??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z+29
	DD	00H
	DD	imagerel ??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z+634
	DD	0ffffffffH
	DD	imagerel ??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z+674
	DD	00H
	DD	imagerel ?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 041419H
	DD	0c3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GEmptyChunk@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 021H
	DD	imagerel $LN39
	DD	imagerel $LN39+26
	DD	imagerel $unwind$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN39
	DD	imagerel $LN39+26
	DD	imagerel $unwind$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 040a01H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD 020021H
	DD	066400H
	DD	imagerel $LN420
	DD	imagerel $LN420+31
	DD	imagerel $unwind$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD 040021H
	DD	077400H
	DD	066400H
	DD	imagerel $LN420
	DD	imagerel $LN420+31
	DD	imagerel $unwind$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD 021H
	DD	imagerel $LN420
	DD	imagerel $LN420+31
	DD	imagerel $unwind$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD 042021H
	DD	077420H
	DD	066405H
	DD	imagerel $LN420
	DD	imagerel $LN420+31
	DD	imagerel $unwind$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD imagerel ??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z+38
	DD	00H
	DD	imagerel ?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
	DD	03H
	DD	imagerel $ip2state$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z DD 081d19H
	DD	0e641dH
	DD	0d3418H
	DD	0f006720aH
	DD	07002e004H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD 020521H
	DD	066405H
	DD	imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isLoaded@ChunkBase@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isLoaded@ChunkBase@@QEAA_NXZ PROC			; ChunkBase::isLoaded, COMDAT

; 75   : 	return loaded;

  00000	0f b6 41 09	 movzx	 eax, BYTE PTR [rcx+9]

; 76   : }

  00004	c3		 ret	 0
?isLoaded@ChunkBase@@QEAA_NXZ ENDP			; ChunkBase::isLoaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isUnloaded@ChunkBase@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isUnloaded@ChunkBase@@QEAA_NXZ PROC			; ChunkBase::isUnloaded, COMDAT

; 85   : 	return unloaded;

  00000	0f b6 41 0a	 movzx	 eax, BYTE PTR [rcx+10]

; 86   : }

  00004	c3		 ret	 0
?isUnloaded@ChunkBase@@QEAA_NXZ ENDP			; ChunkBase::isUnloaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setRenderUpdateNeeded@ChunkBase@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
flag$ = 16
?setRenderUpdateNeeded@ChunkBase@@QEAAX_N@Z PROC	; ChunkBase::setRenderUpdateNeeded, COMDAT

; 95   : 	renderUpdateNeeded = flag;

  00000	88 51 08	 mov	 BYTE PTR [rcx+8], dl

; 96   : }

  00003	c3		 ret	 0
?setRenderUpdateNeeded@ChunkBase@@QEAAX_N@Z ENDP	; ChunkBase::setRenderUpdateNeeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isRenderUpdateNeeded@ChunkBase@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isRenderUpdateNeeded@ChunkBase@@QEAA_NXZ PROC		; ChunkBase::isRenderUpdateNeeded, COMDAT

; 100  : 	return renderUpdateNeeded;

  00000	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]

; 101  : }

  00004	c3		 ret	 0
?isRenderUpdateNeeded@ChunkBase@@QEAA_NXZ ENDP		; ChunkBase::isRenderUpdateNeeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 112
$T4 = 112
this$ = 112
__$ReturnUdt$ = 120
x$ = 128
y$ = 136
z$ = 144
?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z PROC ; World::getChunk, COMDAT

; 197  : {

$LN153:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000c	48 c7 40 d8 fe
	ff ff ff	 mov	 QWORD PTR [rax-40], -2
  00014	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00018	48 89 68 18	 mov	 QWORD PTR [rax+24], rbp
  0001c	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  00020	41 8b f9	 mov	 edi, r9d
  00023	41 8b f0	 mov	 esi, r8d
  00026	4c 8b f2	 mov	 r14, rdx
  00029	45 33 ff	 xor	 r15d, r15d
  0002c	44 89 7c 24 30	 mov	 DWORD PTR $T1[rsp], r15d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00031	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]

; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));
; 1593 : 		}
; 1594 : 
; 1595 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1596 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1597 : 		return (_Eqrange(_Keyval));
; 1598 : 		}
; 1599 : 
; 1600 : 	void swap(_Myt& _Right)
; 1601 : 		{	// exchange contents with _Right
; 1602 : 		if (this == &_Right)
; 1603 : 			;	// same object, do nothing
; 1604 : 		else if (this->_Getal() == _Right._Getal())
; 1605 : 			{	// same allocator, swap control information
; 1606 : 			this->_Swap_all(_Right);
; 1607 : 			this->_Swapcomp(_Right._Getcomp());
; 1608 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1609 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1610 : 			}
; 1611 : 
; 1612 :  #if _HAS_CPP0X
; 1613 : 		else if (_Alty::propagate_on_container_swap::value)
; 1614 : 			{	// swap allocators and control information
; 1615 : 			this->_Swap_alloc(_Right);
; 1616 : 			this->_Swapcomp(_Right._Getcomp());
; 1617 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1618 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1619 : 			}
; 1620 :  #endif /* _HAS_CPP0X */
; 1621 : 
; 1622 : 		else
; 1623 : 			{	// different allocator, do multiple copies
; 1624 : 			_Myt _Temp(this->_Getcomp(), get_allocator());
; 1625 : 			_Temp._Copy(*this, true_type());
; 1626 : 
; 1627 : 			this->_Setcomp(_Right._Getcomp());
; 1628 : 			clear();
; 1629 : 			_Copy(_Right, true_type());
; 1630 : 
; 1631 : 			_Right._Setcomp(_Temp._Getcomp());
; 1632 : 			_Right.clear();
; 1633 : 			_Right._Copy(_Temp, true_type());
; 1634 : 			}
; 1635 : 		}
; 1636 : 
; 1637 : protected:
; 1638 : 	template<class _Valty>
; 1639 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Valty>
; 1645 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1646 : 		{	// node doesn't exist, make it
; 1647 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1648 : 		}
; 1649 : 
; 1650 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1651 : 		{	// node exists, destroy it
; 1652 : 		this->_Getal().destroy(
; 1653 : 			_STD addressof(this->_Myval(_Newnode)));
; 1654 : 
; 1655 : 		this->_Getal().deallocate(_Newnode, 1);
; 1656 : 		}
; 1657 : 
; 1658 : 	void _Destroy_if_not_nil(_Nil)
; 1659 : 		{	// node doesn't exist, do nothing
; 1660 : 		}
; 1661 : 
; 1662 : 	template<class _Valty,
; 1663 : 		class _Nodety>
; 1664 : 		iterator _Insert_hint(const_iterator _Where,
; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN
; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)
; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())
; 1729 : 				{	// insert at beginning if before first element
; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1734 : 				}
; 1735 : 			else if (_Where == end())
; 1736 : 				{	// insert at end if after last element
; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1741 : 				}
; 1742 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1743 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1754 : 				}
; 1755 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1757 : 				&& (++(_Next = _Where) == end()
; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);
; 1771 : 		_RERAISE;
; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1776 : 		}
; 1777 : 
; 1778 : 	template<class _Valty,
; 1779 : 		class _Nodety>
; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN
; 1784 : 		_Nodeptr _Trynode = _Root();
; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))
; 1789 : 			{	// look for leaf to insert before (_Addleft) or after
; 1790 : 			_Wherenode = _Trynode;
; 1791 : 			if (_Leftish)
; 1792 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1793 : 					this->_Key(_Trynode),
; 1794 : 					this->_Kfn(_Val));	// favor left end
; 1795 : 			else
; 1796 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1797 : 					this->_Kfn(_Val),
; 1798 : 					this->_Key(_Trynode));	// favor right end
; 1799 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1800 : 				: this->_Right(_Trynode);
; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)
; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())
; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1813 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1814 : 			else
; 1815 : 				--_Where;	// need to test if insert before is okay
; 1816 : 
; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1821 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1822 : 			else
; 1823 : 				{	// duplicate, don't insert
; 1824 : 				_Destroy_if_not_nil(_Newnode);
; 1825 : 				return (_Pairib(_Where, false));
; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);
; 1830 : 		_RERAISE;
; 1831 : 		_CATCH_END
; 1832 : 		}
; 1833 : 
; 1834 : 	template<class _Valty,
; 1835 : 		class _Nodety>
; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)
; 1840 : 			{	// tree would get too big, fail
; 1841 : 			_Destroy_if_not_nil(_Node);
; 1842 : 			_Xlength_error("map/set<T> too long");
; 1843 : 			}
; 1844 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1845 : 			_STD forward<_Valty>(_Val));
; 1846 : 
; 1847 : 		++this->_Mysize;
; 1848 : 		_Newnode->_Parent = _Wherenode;
; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)
; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;
; 1853 : 			_Lmost() = _Newnode;
; 1854 : 			_Rmost() = _Newnode;
; 1855 : 			}
; 1856 : 		else if (_Addleft)
; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;
; 1859 : 			if (_Wherenode == _Lmost())
; 1860 : 				_Lmost() = _Newnode;
; 1861 : 			}
; 1862 : 		else
; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;
; 1865 : 			if (_Wherenode == _Rmost())
; 1866 : 				_Rmost() = _Newnode;
; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1879 : 					this->_Color(_Wherenode) = this->_Black;
; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;
; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1883 : 					}
; 1884 : 				else
; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);
; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up
; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;
; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1896 : 					}
; 1897 : 				}
; 1898 : 			else
; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1905 : 					this->_Color(_Wherenode) = this->_Black;
; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;
; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1909 : 					}
; 1910 : 				else
; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);
; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up
; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;
; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1926 : 		return (iterator(_Newnode, this));
; 1927 : 		}
; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();

  00035	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00039	4c 8b c1	 mov	 r8, rcx

; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  0003c	8b ac 24 90 00
	00 00		 mov	 ebp, DWORD PTR z$[rsp]
  00043	44 38 78 19	 cmp	 BYTE PTR [rax+25], r15b
  00047	75 36		 jne	 SHORT $LN20@getChunk
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL21@getChunk:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00050	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  00053	3b d6		 cmp	 edx, esi
  00055	7c 1e		 jl	 SHORT $LN150@getChunk

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00057	75 14		 jne	 SHORT $LN19@getChunk

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  00059	8b 50 24	 mov	 edx, DWORD PTR [rax+36]
  0005c	41 3b d1	 cmp	 edx, r9d
  0005f	7c 14		 jl	 SHORT $LN150@getChunk

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00061	75 0a		 jne	 SHORT $LN19@getChunk

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00063	39 68 28	 cmp	 DWORD PTR [rax+40], ebp
  00066	0f 9c c2	 setl	 dl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00069	84 d2		 test	 dl, dl
  0006b	75 08		 jne	 SHORT $LN150@getChunk
$LN19@getChunk:

; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;

  0006d	4c 8b c0	 mov	 r8, rax

; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00070	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00073	eb 04		 jmp	 SHORT $LN18@getChunk
$LN150@getChunk:

; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00075	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN18@getChunk:

; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00079	44 38 78 19	 cmp	 BYTE PTR [rax+25], r15b
  0007d	74 d1		 je	 SHORT $LL21@getChunk
$LN20@getChunk:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0007f	4c 3b c1	 cmp	 r8, rcx

; 1550 : 					? end() : _Where);

  00082	74 2c		 je	 SHORT $LN14@getChunk
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00084	41 8b 40 20	 mov	 eax, DWORD PTR [r8+32]
  00088	3b f0		 cmp	 esi, eax
  0008a	7c 24		 jl	 SHORT $LN14@getChunk

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  0008c	75 16		 jne	 SHORT $LN151@getChunk

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0008e	41 8b 40 24	 mov	 eax, DWORD PTR [r8+36]
  00092	44 3b c8	 cmp	 r9d, eax
  00095	7c 19		 jl	 SHORT $LN14@getChunk

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00097	75 0b		 jne	 SHORT $LN151@getChunk

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00099	41 3b 68 28	 cmp	 ebp, DWORD PTR [r8+40]
  0009d	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1550 : 					? end() : _Where);

  000a0	84 c0		 test	 al, al
  000a2	75 0c		 jne	 SHORT $LN14@getChunk
$LN151@getChunk:
  000a4	4c 89 44 24 70	 mov	 QWORD PTR $T3[rsp], r8
  000a9	48 8d 44 24 70	 lea	 rax, QWORD PTR $T3[rsp]
  000ae	eb 0a		 jmp	 SHORT $LN15@getChunk
$LN14@getChunk:

; 44   : 		{	// construct with node pointer _Pnode

  000b0	48 89 4c 24 38	 mov	 QWORD PTR $T2[rsp], rcx

; 1550 : 					? end() : _Where);

  000b5	48 8d 44 24 38	 lea	 rax, QWORD PTR $T2[rsp]
$LN15@getChunk:
  000ba	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000bd	48 3b c1	 cmp	 rax, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 200  : 	if(chunk == chunkMap.end())

  000c0	75 53		 jne	 SHORT $LN2@getChunk

; 202  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  000c2	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  000c7	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000cc	48 8b d8	 mov	 rbx, rax
  000cf	48 89 44 24 70	 mov	 QWORD PTR $T4[rsp], rax
  000d4	48 85 c0	 test	 rax, rax
  000d7	74 25		 je	 SHORT $LN5@getChunk

; 107  : {

  000d9	89 6c 24 20	 mov	 DWORD PTR [rsp+32], ebp
  000dd	44 8b cf	 mov	 r9d, edi
  000e0	44 8b c6	 mov	 r8d, esi
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  000f9	48 89 03	 mov	 QWORD PTR [rbx], rax

; 202  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  000fc	eb 03		 jmp	 SHORT $LN6@getChunk
$LN5@getChunk:
  000fe	49 8b df	 mov	 rbx, r15
$LN6@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00101	4d 89 3e	 mov	 QWORD PTR [r14], r15
  00104	4d 89 7e 08	 mov	 QWORD PTR [r14+8], r15

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00108	48 8b d3	 mov	 rdx, rbx
  0010b	49 8b ce	 mov	 rcx, r14
  0010e	e8 00 00 00 00	 call	 ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 202  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  00113	eb 21		 jmp	 SHORT $LN152@getChunk
$LN2@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00115	4d 89 3e	 mov	 QWORD PTR [r14], r15
  00118	4d 89 7e 08	 mov	 QWORD PTR [r14+8], r15

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  0011c	4c 8b 40 38	 mov	 r8, QWORD PTR [rax+56]
  00120	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00124	4d 85 c0	 test	 r8, r8
  00127	74 05		 je	 SHORT $LN146@getChunk

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00129	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN146@getChunk:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0012e	49 8b ce	 mov	 rcx, r14
  00131	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN152@getChunk:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 206  : 		return chunk->second;

  00136	49 8b c6	 mov	 rax, r14

; 207  : 	}
; 208  : }

  00139	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  0013e	49 8b 5b 28	 mov	 rbx, QWORD PTR [r11+40]
  00142	49 8b 6b 30	 mov	 rbp, QWORD PTR [r11+48]
  00146	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  0014a	49 8b e3	 mov	 rsp, r11
  0014d	41 5f		 pop	 r15
  0014f	41 5e		 pop	 r14
  00151	5f		 pop	 rdi
  00152	c3		 ret	 0
?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ENDP ; World::getChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 112
$T4 = 112
this$ = 112
__$ReturnUdt$ = 120
x$ = 128
y$ = 136
z$ = 144
?dtor$0@?0??getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z@4HA PROC ; `World::getChunk'::`1'::dtor$0
  00000	48 8b 8a 70 00
	00 00		 mov	 rcx, QWORD PTR $T4[rdx]
  00007	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$0@?0??getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z@4HA ENDP ; `World::getChunk'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@World@@QEAAPEAVBlock@@HHH@Z
_TEXT	SEGMENT
$T1 = 48
chunk$ = 56
this$ = 96
x$ = 104
y$ = 112
z$ = 120
?getBlock@World@@QEAAPEAVBlock@@HHH@Z PROC		; World::getBlock, COMDAT

; 228  : {

$LN50:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 30
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00014	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00019	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  0001e	41 8b f9	 mov	 edi, r9d
  00021	41 8b f0	 mov	 esi, r8d
  00024	8b ea		 mov	 ebp, edx

; 229  : 	std::shared_ptr<ChunkBase> chunk = getChunkFromBlockCoordinate(x, y, z);

  00026	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  0002b	45 8b c8	 mov	 r9d, r8d
  0002e	44 8b c2	 mov	 r8d, edx
  00031	48 8d 54 24 38	 lea	 rdx, QWORD PTR chunk$[rsp]
  00036	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  0003b	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  0003c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR chunk$[rsp]
  00041	48 85 db	 test	 rbx, rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 231  : 	if(chunk == nullptr || chunk->isEmpty() || !chunk->isLoaded())

  00044	74 30		 je	 SHORT $LN1@getBlock
  00046	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00049	48 8b cb	 mov	 rcx, rbx
  0004c	ff 50 18	 call	 QWORD PTR [rax+24]
  0004f	84 c0		 test	 al, al
  00051	75 23		 jne	 SHORT $LN1@getBlock
  00053	38 43 09	 cmp	 BYTE PTR [rbx+9], al
  00056	74 1e		 je	 SHORT $LN1@getBlock

; 236  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  00058	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0005b	83 e7 0f	 and	 edi, 15
  0005e	83 e6 0f	 and	 esi, 15
  00061	83 e5 0f	 and	 ebp, 15
  00064	44 8b cf	 mov	 r9d, edi
  00067	44 8b c6	 mov	 r8d, esi
  0006a	8b d5		 mov	 edx, ebp
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	ff 10		 call	 QWORD PTR [rax]
  00071	48 8b f8	 mov	 rdi, rax
  00074	eb 07		 jmp	 SHORT $LN6@getBlock
$LN1@getBlock:
  00076	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?air@Blocks@@3PEAVBlockAir@@EA ; Blocks::air
$LN6@getBlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR chunk$[rsp+8]
  00082	48 85 c9	 test	 rcx, rcx
  00085	74 24		 je	 SHORT $LN49@getBlock

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00087	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  0008b	75 1e		 jne	 SHORT $LN49@getBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR chunk$[rsp+8]
  00092	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00095	48 8b cb	 mov	 rcx, rbx
  00098	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0009a	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0009e	75 0b		 jne	 SHORT $LN49@getBlock

; 128  : 			_Delete_this();

  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR chunk$[rsp+8]
  000a5	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000a8	ff 50 08	 call	 QWORD PTR [rax+8]
$LN49@getBlock:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 236  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  000ab	48 8b c7	 mov	 rax, rdi

; 237  : }

  000ae	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000b3	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000b8	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000bd	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
?getBlock@World@@QEAAPEAVBlock@@HHH@Z ENDP		; World::getBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
chunk$ = 56
this$ = 96
x$ = 104
y$ = 112
z$ = 120
?dtor$0@?0??getBlock@World@@QEAAPEAVBlock@@HHH@Z@4HA PROC ; `World::getBlock'::`1'::dtor$0
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??getBlock@World@@QEAAPEAVBlock@@HHH@Z@4HA ENDP ; `World::getBlock'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setLoaded@ChunkBase@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?setLoaded@ChunkBase@@QEAAXXZ PROC			; ChunkBase::setLoaded, COMDAT

; 70   : 	loaded = true;

  00000	c6 41 09 01	 mov	 BYTE PTR [rcx+9], 1

; 71   : }

  00004	c3		 ret	 0
?setLoaded@ChunkBase@@QEAAXXZ ENDP			; ChunkBase::setLoaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setUnloaded@ChunkBase@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?setUnloaded@ChunkBase@@QEAAXXZ PROC			; ChunkBase::setUnloaded, COMDAT

; 80   : 	unloaded = true;

  00000	c6 41 0a 01	 mov	 BYTE PTR [rcx+10], 1

; 81   : }

  00004	c3		 ret	 0
?setUnloaded@ChunkBase@@QEAAXXZ ENDP			; ChunkBase::setUnloaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 80
this$ = 80
chunk$ = 88
?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; World::addChunk, COMDAT

; 269  : {

$LN49:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000c	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00015	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0001a	48 8b fa	 mov	 rdi, rdx

; 270  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  0001d	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 44   : 		{	// construct with node pointer _Pnode

  00021	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00024	48 8b 2a	 mov	 rbp, QWORD PTR [rdx]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 270  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  00027	4c 8d 45 18	 lea	 r8, QWORD PTR [rbp+24]
  0002b	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00030	48 8b ce	 mov	 rcx, rsi
  00033	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00038	48 39 18	 cmp	 QWORD PTR [rax], rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 270  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  0003b	74 30		 je	 SHORT $LN1@addChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0003d	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  00041	48 85 ff	 test	 rdi, rdi
  00044	74 23		 je	 SHORT $LN31@addChunk

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00046	83 c8 ff	 or	 eax, -1
  00049	f0 0f c1 47 08	 lock xadd DWORD PTR [rdi+8], eax
  0004e	ff c8		 dec	 eax
  00050	75 17		 jne	 SHORT $LN31@addChunk

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00052	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00055	48 8b cf	 mov	 rcx, rdi
  00058	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0005a	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0005e	75 09		 jne	 SHORT $LN31@addChunk

; 128  : 			_Delete_this();

  00060	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00063	48 8b cf	 mov	 rcx, rdi
  00066	ff 50 08	 call	 QWORD PTR [rax+8]
$LN31@addChunk:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 272  : 		return false;

  00069	32 c0		 xor	 al, al
  0006b	eb 46		 jmp	 SHORT $LN2@addChunk
$LN1@addChunk:

; 273  : 	}
; 274  : 	
; 275  : 	chunkMap[chunk->pos] = chunk;

  0006d	48 8d 55 18	 lea	 rdx, QWORD PTR [rbp+24]
  00071	48 8b ce	 mov	 rcx, rsi
  00074	e8 00 00 00 00	 call	 ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
  00079	48 8b c8	 mov	 rcx, rax
  0007c	48 8b d7	 mov	 rdx, rdi
  0007f	e8 00 00 00 00	 call	 ??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z ; std::shared_ptr<ChunkBase>::operator=
  00084	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00085	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  00089	48 85 ff	 test	 rdi, rdi
  0008c	74 23		 je	 SHORT $LN46@addChunk

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0008e	83 c8 ff	 or	 eax, -1
  00091	f0 0f c1 47 08	 lock xadd DWORD PTR [rdi+8], eax
  00096	ff c8		 dec	 eax
  00098	75 17		 jne	 SHORT $LN46@addChunk

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0009a	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0009d	48 8b cf	 mov	 rcx, rdi
  000a0	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000a2	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  000a6	75 09		 jne	 SHORT $LN46@addChunk

; 128  : 			_Delete_this();

  000a8	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000ab	48 8b cf	 mov	 rcx, rdi
  000ae	ff 50 08	 call	 QWORD PTR [rax+8]
$LN46@addChunk:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 277  : 	return true;

  000b1	b0 01		 mov	 al, 1
$LN2@addChunk:

; 278  : }

  000b3	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000b8	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000bc	5f		 pop	 rdi
  000bd	5e		 pop	 rsi
  000be	5d		 pop	 rbp
  000bf	c3		 ret	 0
?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; World::addChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 80
this$ = 80
chunk$ = 88
?dtor$0@?0??addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `World::addChunk'::`1'::dtor$0
  00000	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `World::addChunk'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?removeChunk@World@@QEAAXVChunkPosition@@@Z
_TEXT	SEGMENT
this$ = 8
cp$ = 16
?removeChunk@World@@QEAAXVChunkPosition@@@Z PROC	; World::removeChunk, COMDAT

; 282  : 	chunkMap.erase(cp);

  00000	48 83 c1 08	 add	 rcx, 8
  00004	e9 00 00 00 00	 jmp	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
?removeChunk@World@@QEAAXVChunkPosition@@@Z ENDP	; World::removeChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0World@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0World@@QEAA@XZ PROC					; World::World, COMDAT

; 187  : {

$LN156:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001d	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00020	ba 02 00 00 00	 mov	 edx, 2
  00025	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0002a	85 c0		 test	 eax, eax
  0002c	74 08		 je	 SHORT $LN15@World

; 33   : 		_Throw_C_error(_Res);

  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00035	90		 npad	 1
$LN15@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 573  : 		this->_Myhead = 0;

  00036	33 f6		 xor	 esi, esi
  00038	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi

; 574  : 		this->_Mysize = 0;

  0003c	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00040	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00045	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 187  : {

  00049	48 8d 4b 18	 lea	 rcx, QWORD PTR [rbx+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0004d	8d 56 02	 lea	 edx, QWORD PTR [rsi+2]
  00050	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00055	85 c0		 test	 eax, eax
  00057	74 08		 je	 SHORT $LN42@World

; 33   : 		_Throw_C_error(_Res);

  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00060	90		 npad	 1
$LN42@World:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 187  : {

  00061	48 8d 7b 20	 lea	 rdi, QWORD PTR [rbx+32]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  00065	48 89 37	 mov	 QWORD PTR [rdi], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00068	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 779  : 		_Mapsize = 0;

  0006c	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 780  : 		_Myoff = 0;

  00070	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi

; 781  : 		_Mysize = 0;

  00074	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00078	b9 10 00 00 00	 mov	 ecx, 16
  0007d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00082	48 85 c0	 test	 rax, rax
  00085	75 06		 jne	 SHORT $LN66@World

; 29   : 		_Xbad_alloc();	// report no memory

  00087	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0008c	cc		 int	 3
$LN66@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  0008d	48 89 07	 mov	 QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00090	48 89 30	 mov	 QWORD PTR [rax], rsi
  00093	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00097	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0009a	48 89 38	 mov	 QWORD PTR [rax], rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 187  : {

  0009d	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  000a1	ba 02 00 00 00	 mov	 edx, 2
  000a6	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  000ab	85 c0		 test	 eax, eax
  000ad	74 08		 je	 SHORT $LN102@World

; 33   : 		_Throw_C_error(_Res);

  000af	8b c8		 mov	 ecx, eax
  000b1	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  000b6	90		 npad	 1
$LN102@World:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 187  : {

  000b7	48 8d 7b 50	 lea	 rdi, QWORD PTR [rbx+80]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  000bb	48 89 37	 mov	 QWORD PTR [rdi], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  000be	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 779  : 		_Mapsize = 0;

  000c2	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 780  : 		_Myoff = 0;

  000c6	48 89 77 18	 mov	 QWORD PTR [rdi+24], rsi

; 781  : 		_Mysize = 0;

  000ca	48 89 77 20	 mov	 QWORD PTR [rdi+32], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000ce	b9 10 00 00 00	 mov	 ecx, 16
  000d3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d8	48 85 c0	 test	 rax, rax
  000db	75 06		 jne	 SHORT $LN126@World

; 29   : 		_Xbad_alloc();	// report no memory

  000dd	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000e2	cc		 int	 3
$LN126@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000e3	48 89 07	 mov	 QWORD PTR [rdi], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000e6	48 89 30	 mov	 QWORD PTR [rax], rsi
  000e9	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  000ed	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000f0	48 89 38	 mov	 QWORD PTR [rax], rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 189  : }

  000f3	48 8b c3	 mov	 rax, rbx
  000f6	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000fb	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00100	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00104	5f		 pop	 rdi
  00105	c3		 ret	 0
$LN155@World:
??0World@@QEAA@XZ ENDP					; World::World
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0World@@QEAA@XZ@4HA PROC			; `World::World'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$0@?0???0World@@QEAA@XZ@4HA ENDP			; `World::World'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???0World@@QEAA@XZ@4HA PROC			; `World::World'::`1'::dtor$1
  0000c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00013	48 83 c1 08	 add	 rcx, 8
  00017	e9 00 00 00 00	 jmp	 ??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
?dtor$1@?0???0World@@QEAA@XZ@4HA ENDP			; `World::World'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$2@?0???0World@@QEAA@XZ@4HA PROC			; `World::World'::`1'::dtor$2
  0001c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00023	48 83 c1 18	 add	 rcx, 24
  00027	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$2@?0???0World@@QEAA@XZ@4HA ENDP			; `World::World'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$3@?0???0World@@QEAA@XZ@4HA PROC			; `World::World'::`1'::dtor$3
  0002c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00033	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00037	e9 00 00 00 00	 jmp	 ??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ
?dtor$3@?0???0World@@QEAA@XZ@4HA ENDP			; `World::World'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$4@?0???0World@@QEAA@XZ@4HA PROC			; `World::World'::`1'::dtor$4
  0003c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00043	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00047	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$4@?0???0World@@QEAA@XZ@4HA ENDP			; `World::World'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1World@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 48
this$ = 48
??1World@@QEAA@XZ PROC					; World::~World, COMDAT

; 192  : {

$LN106:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  0000d	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00011	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00016	48 8b 4f 50	 mov	 rcx, QWORD PTR [rdi+80]
  0001a	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0001f	48 8d 4f 48	 lea	 rcx, QWORD PTR [rdi+72]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00023	48 c7 47 50 00
	00 00 00	 mov	 QWORD PTR [rdi+80], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0002b	e8 00 00 00 00	 call	 _Mtx_destroy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00030	48 8d 4f 20	 lea	 rcx, QWORD PTR [rdi+32]
  00034	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00039	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  0003d	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00042	48 8d 4f 18	 lea	 rcx, QWORD PTR [rdi+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00046	48 c7 47 20 00
	00 00 00	 mov	 QWORD PTR [rdi+32], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0004e	e8 00 00 00 00	 call	 _Mtx_destroy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  00053	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  00057	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  0005c	4d 8b c8	 mov	 r9, r8
  0005f	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00062	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]
  00066	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0006b	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0006f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00074	48 8b cf	 mov	 rcx, rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 194  : }

  00077	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5f		 pop	 rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00081	e9 00 00 00 00	 jmp	 _Mtx_destroy
??1World@@QEAA@XZ ENDP					; World::~World
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?toIndex@@YAIAEAI00@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
z$ = 24
?toIndex@@YAIAEAI00@Z PROC				; toIndex, COMDAT

; 6    : 	return x << 8 | y << 4 | z;

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	c1 e0 04	 shl	 eax, 4
  00005	0b 02		 or	 eax, DWORD PTR [rdx]
  00007	c1 e0 04	 shl	 eax, 4
  0000a	41 0b 00	 or	 eax, DWORD PTR [r8]

; 7    : }

  0000d	c3		 ret	 0
?toIndex@@YAIAEAI00@Z ENDP				; toIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0ChunkPosition@@QEAA@HHH@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
??0ChunkPosition@@QEAA@HHH@Z PROC			; ChunkPosition::ChunkPosition, COMDAT

; 11   : {

  00000	89 11		 mov	 DWORD PTR [rcx], edx
  00002	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d
  00006	44 89 49 08	 mov	 DWORD PTR [rcx+8], r9d

; 12   : 
; 13   : }

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0ChunkPosition@@QEAA@HHH@Z ENDP			; ChunkPosition::ChunkPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z PROC		; ChunkBase::ChunkBase, COMDAT

; 54   : {

$LN35:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkBase@@6B@
  00022	48 89 01	 mov	 QWORD PTR [rcx], rax
  00025	66 c7 41 08 00
	00		 mov	 WORD PTR [rcx+8], 0
  0002b	c6 41 0a 00	 mov	 BYTE PTR [rcx+10], 0
  0002f	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 11   : {

  00033	44 89 41 18	 mov	 DWORD PTR [rcx+24], r8d
  00037	44 89 49 1c	 mov	 DWORD PTR [rcx+28], r9d
  0003b	8b 44 24 60	 mov	 eax, DWORD PTR zPos$[rsp]
  0003f	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 54   : {

  00042	48 83 c1 28	 add	 rcx, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00046	ba 02 00 00 00	 mov	 edx, 2
  0004b	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00050	85 c0		 test	 eax, eax
  00052	74 08		 je	 SHORT $LN15@ChunkBase

; 33   : 		_Throw_C_error(_Res);

  00054	8b c8		 mov	 ecx, eax
  00056	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005b	90		 npad	 1
$LN15@ChunkBase:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0005c	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00060	ba 02 00 00 00	 mov	 edx, 2
  00065	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0006a	85 c0		 test	 eax, eax
  0006c	74 08		 je	 SHORT $LN24@ChunkBase

; 33   : 		_Throw_C_error(_Res);

  0006e	8b c8		 mov	 ecx, eax
  00070	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00075	90		 npad	 1
$LN24@ChunkBase:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00076	48 8d 4b 38	 lea	 rcx, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0007a	33 ff		 xor	 edi, edi
  0007c	48 89 39	 mov	 QWORD PTR [rcx], rdi
  0007f	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);
; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00083	33 d2		 xor	 edx, edx
  00085	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  0008a	90		 npad	 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0008b	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0008f	48 89 39	 mov	 QWORD PTR [rcx], rdi
  00092	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);
; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00096	33 d2		 xor	 edx, edx
  00098	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  0009d	90		 npad	 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 56   : }

  0009e	48 8b c3	 mov	 rax, rbx
  000a1	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z ENDP		; ChunkBase::ChunkBase
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
?dtor$0@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA PROC	; `ChunkBase::ChunkBase'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0000b	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$0@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA ENDP	; `ChunkBase::ChunkBase'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
?dtor$1@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA PROC	; `ChunkBase::ChunkBase'::`1'::dtor$1
  00010	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00017	48 83 c1 30	 add	 rcx, 48			; 00000030H
  0001b	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$1@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA ENDP	; `ChunkBase::ChunkBase'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
?dtor$2@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA PROC	; `ChunkBase::ChunkBase'::`1'::dtor$2
  00020	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00027	48 83 c1 38	 add	 rcx, 56			; 00000038H
  0002b	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
?dtor$2@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA ENDP	; `ChunkBase::ChunkBase'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1ChunkBase@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ChunkBase@@QEAA@XZ PROC				; ChunkBase::~ChunkBase, COMDAT

; 59   : {

$LN34:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkBase@@6B@
  00016	48 8b f1	 mov	 rsi, rcx
  00019	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0001c	48 8b 59 50	 mov	 rbx, QWORD PTR [rcx+80]
  00020	48 85 db	 test	 rbx, rbx
  00023	74 1d		 je	 SHORT $LN11@ChunkBase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00025	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00029	75 17		 jne	 SHORT $LN11@ChunkBase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002e	48 8b cb	 mov	 rcx, rbx
  00031	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00033	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00037	75 09		 jne	 SHORT $LN11@ChunkBase

; 128  : 			_Delete_this();

  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	48 8b cb	 mov	 rcx, rbx
  0003f	ff 50 08	 call	 QWORD PTR [rax+8]
$LN11@ChunkBase:

; 345  : 		if (_Rep != 0)

  00042	48 8b 5e 40	 mov	 rbx, QWORD PTR [rsi+64]
  00046	48 85 db	 test	 rbx, rbx
  00049	74 1d		 je	 SHORT $LN22@ChunkBase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0004b	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0004f	75 17		 jne	 SHORT $LN22@ChunkBase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00051	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00054	48 8b cb	 mov	 rcx, rbx
  00057	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00059	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0005d	75 09		 jne	 SHORT $LN22@ChunkBase

; 128  : 			_Delete_this();

  0005f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00062	48 8b cb	 mov	 rcx, rbx
  00065	ff 50 08	 call	 QWORD PTR [rax+8]
$LN22@ChunkBase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00068	48 8d 4e 30	 lea	 rcx, QWORD PTR [rsi+48]
  0006c	e8 00 00 00 00	 call	 _Mtx_destroy
  00071	48 8d 4e 28	 lea	 rcx, QWORD PTR [rsi+40]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 61   : }

  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00084	e9 00 00 00 00	 jmp	 _Mtx_destroy
??1ChunkBase@@QEAA@XZ ENDP				; ChunkBase::~ChunkBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?dataPtr@ChunkBase@@UEAAPEAGXZ
_TEXT	SEGMENT
this$ = 8
?dataPtr@ChunkBase@@UEAAPEAGXZ PROC			; ChunkBase::dataPtr, COMDAT

; 65   : 	return nullptr;

  00000	33 c0		 xor	 eax, eax

; 66   : }

  00002	c3		 ret	 0
?dataPtr@ChunkBase@@UEAAPEAGXZ ENDP			; ChunkBase::dataPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@ChunkBase@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?shouldRender@ChunkBase@@UEAA_NXZ PROC			; ChunkBase::shouldRender, COMDAT

; 90   : 	return false;

  00000	32 c0		 xor	 al, al

; 91   : }

  00002	c3		 ret	 0
?shouldRender@ChunkBase@@UEAA_NXZ ENDP			; ChunkBase::shouldRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z
_TEXT	SEGMENT
this$ = 64
world$dead$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z PROC		; EmptyChunk::EmptyChunk, COMDAT

; 107  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	8b 44 24 60	 mov	 eax, DWORD PTR zPos$[rsp]
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00011	48 8b d9	 mov	 rbx, rcx
  00014	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00018	e8 00 00 00 00	 call	 ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  00024	48 89 03	 mov	 QWORD PTR [rbx], rax

; 108  : 
; 109  : }

  00027	48 8b c3	 mov	 rax, rbx
  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z ENDP		; EmptyChunk::EmptyChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1EmptyChunk@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1EmptyChunk@@QEAA@XZ PROC				; EmptyChunk::~EmptyChunk, COMDAT

; 112  : {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 113  : 
; 114  : }

  0000a	e9 00 00 00 00	 jmp	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
??1EmptyChunk@@QEAA@XZ ENDP				; EmptyChunk::~EmptyChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z PROC		; EmptyChunk::getBlock, COMDAT

; 118  : 	return Blocks::air;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?air@Blocks@@3PEAVBlockAir@@EA ; Blocks::air

; 119  : }

  00007	c3		 ret	 0
?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z ENDP		; EmptyChunk::getBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
block$ = 40
?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z PROC	; EmptyChunk::setBlock, COMDAT

; 123  : 
; 124  : }

  00000	c2 00 00	 ret	 0
?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z ENDP	; EmptyChunk::setBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
block$ = 40
?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z PROC	; EmptyChunk::setBlockRaw, COMDAT

; 128  : 
; 129  : }

  00000	c2 00 00	 ret	 0
?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z ENDP	; EmptyChunk::setBlockRaw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isEmpty@EmptyChunk@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isEmpty@EmptyChunk@@UEAA_NXZ PROC			; EmptyChunk::isEmpty, COMDAT

; 133  : 	return true;

  00000	b0 01		 mov	 al, 1

; 134  : }

  00002	c3		 ret	 0
?isEmpty@EmptyChunk@@UEAA_NXZ ENDP			; EmptyChunk::isEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@EmptyChunk@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?shouldRender@EmptyChunk@@UEAA_NXZ PROC			; EmptyChunk::shouldRender, COMDAT

; 138  : 	return false;

  00000	32 c0		 xor	 al, al

; 139  : }

  00002	c3		 ret	 0
?shouldRender@EmptyChunk@@UEAA_NXZ ENDP			; EmptyChunk::shouldRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0Chunk@@QEAA@AEAVWorld@@HHH@Z
_TEXT	SEGMENT
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
??0Chunk@@QEAA@AEAVWorld@@HHH@Z PROC			; Chunk::Chunk, COMDAT

; 145  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	8b 44 24 60	 mov	 eax, DWORD PTR zPos$[rsp]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00011	e8 00 00 00 00	 call	 ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  0001d	48 89 03	 mov	 QWORD PTR [rbx], rax
  00020	33 c0		 xor	 eax, eax
  00022	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax

; 146  : 
; 147  : }

  00026	48 8b c3	 mov	 rax, rbx
  00029	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
??0Chunk@@QEAA@AEAVWorld@@HHH@Z ENDP			; Chunk::Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1Chunk@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Chunk@@QEAA@XZ PROC					; Chunk::~Chunk, COMDAT

; 150  : {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 151  : 
; 152  : }

  0000a	e9 00 00 00 00	 jmp	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
??1Chunk@@QEAA@XZ ENDP					; Chunk::~Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@Chunk@@UEAAPEAVBlock@@III@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
?getBlock@Chunk@@UEAAPEAVBlock@@III@Z PROC		; Chunk::getBlock, COMDAT

; 156  : 	return Blocks::blockArray[data[toIndex(x, y, z)]];

  00000	c1 e2 04	 shl	 edx, 4
  00003	41 8b c1	 mov	 eax, r9d
  00006	41 0b d0	 or	 edx, r8d

; 6    : 	return x << 8 | y << 4 | z;

  00009	c1 e2 04	 shl	 edx, 4
  0000c	48 0b d0	 or	 rdx, rax

; 156  : 	return Blocks::blockArray[data[toIndex(x, y, z)]];

  0000f	0f b7 44 51 60	 movzx	 eax, WORD PTR [rcx+rdx*2+96]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?blockArray@Blocks@@3PAPEAVBlock@@A ; Blocks::blockArray
  0001b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 157  : }

  0001f	c3		 ret	 0
?getBlock@Chunk@@UEAAPEAVBlock@@III@Z ENDP		; Chunk::getBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
block$ = 40
?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z PROC		; Chunk::setBlock, COMDAT

; 161  : 	data[toIndex(x, y, z)] = block->id;

  00000	c1 e2 04	 shl	 edx, 4
  00003	41 8b c1	 mov	 eax, r9d
  00006	44 0b c2	 or	 r8d, edx

; 6    : 	return x << 8 | y << 4 | z;

  00009	41 c1 e0 04	 shl	 r8d, 4
  0000d	4c 0b c0	 or	 r8, rax

; 161  : 	data[toIndex(x, y, z)] = block->id;

  00010	48 8b 44 24 28	 mov	 rax, QWORD PTR block$[rsp]
  00015	0f b7 50 08	 movzx	 edx, WORD PTR [rax+8]
  00019	66 42 89 54 41
	60		 mov	 WORD PTR [rcx+r8*2+96], dx

; 162  : }

  0001f	c3		 ret	 0
?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z ENDP		; Chunk::setBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
block$ = 40
?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z PROC		; Chunk::setBlockRaw, COMDAT

; 166  : 	data[toIndex(x, y, z)] = block->id;

  00000	c1 e2 04	 shl	 edx, 4
  00003	41 8b c1	 mov	 eax, r9d
  00006	44 0b c2	 or	 r8d, edx

; 6    : 	return x << 8 | y << 4 | z;

  00009	41 c1 e0 04	 shl	 r8d, 4
  0000d	4c 0b c0	 or	 r8, rax

; 166  : 	data[toIndex(x, y, z)] = block->id;

  00010	48 8b 44 24 28	 mov	 rax, QWORD PTR block$[rsp]
  00015	0f b7 50 08	 movzx	 edx, WORD PTR [rax+8]
  00019	66 42 89 54 41
	60		 mov	 WORD PTR [rcx+r8*2+96], dx

; 167  : }

  0001f	c3		 ret	 0
?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z ENDP		; Chunk::setBlockRaw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isEmpty@Chunk@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isEmpty@Chunk@@UEAA_NXZ PROC				; Chunk::isEmpty, COMDAT

; 171  : 	return false;

  00000	32 c0		 xor	 al, al

; 172  : }

  00002	c3		 ret	 0
?isEmpty@Chunk@@UEAA_NXZ ENDP				; Chunk::isEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?dataPtr@Chunk@@UEAAPEAGXZ
_TEXT	SEGMENT
this$ = 8
?dataPtr@Chunk@@UEAAPEAGXZ PROC				; Chunk::dataPtr, COMDAT

; 176  : 	return data;

  00000	48 8d 41 60	 lea	 rax, QWORD PTR [rcx+96]

; 177  : }

  00004	c3		 ret	 0
?dataPtr@Chunk@@UEAAPEAGXZ ENDP				; Chunk::dataPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@Chunk@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?shouldRender@Chunk@@UEAA_NXZ PROC			; Chunk::shouldRender, COMDAT

; 181  : 	return true;

  00000	b0 01		 mov	 al, 1

; 182  : }

  00002	c3		 ret	 0
?shouldRender@Chunk@@UEAA_NXZ ENDP			; Chunk::shouldRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 48
this$ = 48
??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ PROC ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT
$LN64:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  00006	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00009	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	4d 8b c8	 mov	 r9, r8
  00014	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00017	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0001c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5b		 pop	 rbx
  00024	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ENDP ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
__$ReturnUdt$ = 88
x$ = 96
y$ = 104
z$ = 112
?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z PROC ; World::getChunkFromBlockCoordinate, COMDAT

; 211  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 212  : 	return getChunk(x >> 4, y >> 4, z >> 4);

  00006	8b 44 24 70	 mov	 eax, DWORD PTR z$[rsp]
  0000a	41 c1 f9 04	 sar	 r9d, 4
  0000e	41 c1 f8 04	 sar	 r8d, 4
  00012	c1 f8 04	 sar	 eax, 4
  00015	48 8b da	 mov	 rbx, rdx
  00018	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00020	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00024	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  00029	48 8b c3	 mov	 rax, rbx

; 213  : }

  0002c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ENDP ; World::getChunkFromBlockCoordinate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
_TEXT	SEGMENT
i$1$ = 48
tv534 = 52
tv537 = 56
tv536 = 60
c$1 = 72
$T2 = 88
chunk$ = 104
this$ = 192
x$ = 200
y$ = 208
z$ = 216
block$ = 224
?setBlock@World@@QEAAXHHHPEAVBlock@@@Z PROC		; World::setBlock, COMDAT

; 240  : {

$LN99:
  00000	48 8b c4	 mov	 rax, rsp
  00003	44 89 48 20	 mov	 DWORD PTR [rax+32], r9d
  00007	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 55		 push	 r13
  00012	41 56		 push	 r14
  00014	41 57		 push	 r15
  00016	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0001d	48 c7 40 88 fe
	ff ff ff	 mov	 QWORD PTR [rax-120], -2
  00025	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00029	41 8b e9	 mov	 ebp, r9d
  0002c	45 8b e0	 mov	 r12d, r8d
  0002f	44 8b ea	 mov	 r13d, edx

; 241  : 	std::shared_ptr<ChunkBase> chunk = getChunkFromBlockCoordinate(x, y, z);

  00032	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00037	45 8b c8	 mov	 r9d, r8d
  0003a	44 8b c2	 mov	 r8d, edx
  0003d	48 8d 50 b0	 lea	 rdx, QWORD PTR [rax-80]
  00041	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  00046	90		 npad	 1

; 242  : 
; 243  : 	if(!chunk->isEmpty() && chunk->isLoaded())

  00047	4c 8b 7c 24 68	 mov	 r15, QWORD PTR chunk$[rsp]
  0004c	49 8b 07	 mov	 rax, QWORD PTR [r15]
  0004f	49 8b cf	 mov	 rcx, r15
  00052	ff 50 18	 call	 QWORD PTR [rax+24]
  00055	84 c0		 test	 al, al
  00057	0f 85 a7 01 00
	00		 jne	 $LN8@setBlock
  0005d	41 38 47 09	 cmp	 BYTE PTR [r15+9], al
  00061	0f 84 9d 01 00
	00		 je	 $LN8@setBlock

; 244  : 	{
; 245  : 		bool sameBlock = chunk->getBlock(x & 0xf, y & 0xf, z & 0xf) == block;

  00067	83 e5 0f	 and	 ebp, 15
  0006a	41 8b f4	 mov	 esi, r12d
  0006d	83 e6 0f	 and	 esi, 15
  00070	41 8b fd	 mov	 edi, r13d
  00073	83 e7 0f	 and	 edi, 15
  00076	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00079	44 8b cd	 mov	 r9d, ebp
  0007c	44 8b c6	 mov	 r8d, esi
  0007f	8b d7		 mov	 edx, edi
  00081	49 8b cf	 mov	 rcx, r15
  00084	ff 10		 call	 QWORD PTR [rax]
  00086	4c 8b 94 24 e0
	00 00 00	 mov	 r10, QWORD PTR block$[rsp]
  0008e	49 3b c2	 cmp	 rax, r10
  00091	0f 94 c3	 sete	 bl

; 246  : 		chunk->setBlock(x & 0xf, y & 0xf, z & 0xf, block);

  00094	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00097	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  0009c	44 8b cd	 mov	 r9d, ebp
  0009f	44 8b c6	 mov	 r8d, esi
  000a2	8b d7		 mov	 edx, edi
  000a4	49 8b cf	 mov	 rcx, r15
  000a7	ff 50 08	 call	 QWORD PTR [rax+8]

; 247  : 		if(!sameBlock)

  000aa	84 db		 test	 bl, bl
  000ac	0f 85 52 01 00
	00		 jne	 $LN8@setBlock

; 248  : 		{
; 249  : 			for(int i = x - 1; i <= x + 1; i++)

  000b2	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  000b6	89 44 24 30	 mov	 DWORD PTR i$1$[rsp], eax
  000ba	41 8d 4d 01	 lea	 ecx, DWORD PTR [r13+1]
  000be	89 4c 24 38	 mov	 DWORD PTR tv537[rsp], ecx
  000c2	3b c1		 cmp	 eax, ecx
  000c4	0f 8f 3a 01 00
	00		 jg	 $LN8@setBlock
  000ca	41 8d 54 24 ff	 lea	 edx, DWORD PTR [r12-1]
  000cf	89 54 24 3c	 mov	 DWORD PTR tv536[rsp], edx
  000d3	45 8d 6c 24 01	 lea	 r13d, DWORD PTR [r12+1]
  000d8	33 db		 xor	 ebx, ebx
  000da	4c 8b a4 24 c0
	00 00 00	 mov	 r12, QWORD PTR this$[rsp]
$LL10@setBlock:

; 250  : 			{
; 251  : 				for(int j = y - 1; j <= y + 1; j++)

  000e2	8b ea		 mov	 ebp, edx
  000e4	41 3b d5	 cmp	 edx, r13d
  000e7	0f 8f 09 01 00
	00		 jg	 $LN9@setBlock
  000ed	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR z$[rsp]
  000f4	8d 4a ff	 lea	 ecx, DWORD PTR [rdx-1]
  000f7	89 4c 24 34	 mov	 DWORD PTR tv534[rsp], ecx
  000fb	44 8d 7a 01	 lea	 r15d, DWORD PTR [rdx+1]
  000ff	90		 npad	 1
$LL7@setBlock:

; 253  : 					for(int k = z - 1; k <= z + 1; k++)

  00100	8b f1		 mov	 esi, ecx
  00102	41 3b cf	 cmp	 ecx, r15d
  00105	0f 8f d8 00 00
	00		 jg	 $LN6@setBlock
  0010b	0f 1f 44 00 00	 npad	 5
$LL4@setBlock:

; 254  : 					{
; 255  : 						std::shared_ptr<ChunkBase> c = getChunkFromBlockCoordinate(i, j, k);

  00110	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00114	44 8b cd	 mov	 r9d, ebp
  00117	44 8b c0	 mov	 r8d, eax
  0011a	48 8d 54 24 48	 lea	 rdx, QWORD PTR c$1[rsp]
  0011f	49 8b cc	 mov	 rcx, r12
  00122	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  00127	90		 npad	 1

; 256  : 						if(!c->isEmpty())

  00128	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp]
  0012d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00130	48 8b cf	 mov	 rcx, rdi
  00133	ff 50 18	 call	 QWORD PTR [rax+24]
  00136	84 c0		 test	 al, al
  00138	75 63		 jne	 SHORT $LN98@setBlock

; 95   : 	renderUpdateNeeded = flag;

  0013a	c6 47 08 01	 mov	 BYTE PTR [rdi+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0013e	48 89 5c 24 58	 mov	 QWORD PTR $T2[rsp], rbx
  00143	48 89 5c 24 60	 mov	 QWORD PTR $T2[rsp+8], rbx

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00148	48 8b 5c 24 50	 mov	 rbx, QWORD PTR c$1[rsp+8]
  0014d	48 85 db	 test	 rbx, rbx
  00150	74 35		 je	 SHORT $LN63@setBlock

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00152	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00156	48 8b 5c 24 60	 mov	 rbx, QWORD PTR $T2[rsp+8]
  0015b	48 85 db	 test	 rbx, rbx
  0015e	74 1d		 je	 SHORT $LN97@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00160	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00164	75 17		 jne	 SHORT $LN97@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00166	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00169	48 8b cb	 mov	 rcx, rbx
  0016c	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0016e	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00172	75 09		 jne	 SHORT $LN97@setBlock

; 128  : 			_Delete_this();

  00174	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00177	48 8b cb	 mov	 rcx, rbx
  0017a	ff 50 08	 call	 QWORD PTR [rax+8]
$LN97@setBlock:
  0017d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp]
  00182	48 8b 5c 24 50	 mov	 rbx, QWORD PTR c$1[rsp+8]
$LN63@setBlock:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00187	48 89 5c 24 60	 mov	 QWORD PTR $T2[rsp+8], rbx

; 427  : 		_Ptr = _Other_ptr;

  0018c	48 89 7c 24 58	 mov	 QWORD PTR $T2[rsp], rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 259  : 							requestQuickChunkDraw(c);

  00191	48 8d 4c 24 58	 lea	 rcx, QWORD PTR $T2[rsp]
  00196	e8 00 00 00 00	 call	 ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestQuickChunkDraw
  0019b	eb 05		 jmp	 SHORT $LN1@setBlock
$LN98@setBlock:
  0019d	48 8b 5c 24 50	 mov	 rbx, QWORD PTR c$1[rsp+8]
$LN1@setBlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001a2	48 85 db	 test	 rbx, rbx
  001a5	74 24		 je	 SHORT $LN3@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  001a7	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  001ab	75 1e		 jne	 SHORT $LN3@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  001ad	48 8b 5c 24 50	 mov	 rbx, QWORD PTR c$1[rsp+8]
  001b2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001b5	48 8b cb	 mov	 rcx, rbx
  001b8	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  001ba	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  001be	75 0b		 jne	 SHORT $LN3@setBlock

; 128  : 			_Delete_this();

  001c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$1[rsp+8]
  001c5	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001c8	ff 50 08	 call	 QWORD PTR [rax+8]
$LN3@setBlock:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 253  : 					for(int k = z - 1; k <= z + 1; k++)

  001cb	ff c6		 inc	 esi
  001cd	41 3b f7	 cmp	 esi, r15d
  001d0	8b 44 24 30	 mov	 eax, DWORD PTR i$1$[rsp]
  001d4	bb 00 00 00 00	 mov	 ebx, 0
  001d9	0f 8e 31 ff ff
	ff		 jle	 $LL4@setBlock
  001df	8b 4c 24 34	 mov	 ecx, DWORD PTR tv534[rsp]
$LN6@setBlock:

; 250  : 			{
; 251  : 				for(int j = y - 1; j <= y + 1; j++)

  001e3	ff c5		 inc	 ebp
  001e5	41 3b ed	 cmp	 ebp, r13d
  001e8	0f 8e 12 ff ff
	ff		 jle	 $LL7@setBlock
  001ee	8b 4c 24 38	 mov	 ecx, DWORD PTR tv537[rsp]
  001f2	8b 54 24 3c	 mov	 edx, DWORD PTR tv536[rsp]
$LN9@setBlock:

; 248  : 		{
; 249  : 			for(int i = x - 1; i <= x + 1; i++)

  001f6	ff c0		 inc	 eax
  001f8	89 44 24 30	 mov	 DWORD PTR i$1$[rsp], eax
  001fc	3b c1		 cmp	 eax, ecx
  001fe	0f 8e de fe ff
	ff		 jle	 $LL10@setBlock
$LN8@setBlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00204	48 8b 4c 24 70	 mov	 rcx, QWORD PTR chunk$[rsp+8]
  00209	48 85 c9	 test	 rcx, rcx
  0020c	74 24		 je	 SHORT $LN85@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0020e	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00212	75 1e		 jne	 SHORT $LN85@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00214	48 8b 5c 24 70	 mov	 rbx, QWORD PTR chunk$[rsp+8]
  00219	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0021c	48 8b cb	 mov	 rcx, rbx
  0021f	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00221	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00225	75 0b		 jne	 SHORT $LN85@setBlock

; 128  : 			_Delete_this();

  00227	48 8b 4c 24 70	 mov	 rcx, QWORD PTR chunk$[rsp+8]
  0022c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0022f	ff 50 08	 call	 QWORD PTR [rax+8]
$LN85@setBlock:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 266  : }

  00232	48 8b 9c 24 c8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+200]
  0023a	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00241	41 5f		 pop	 r15
  00243	41 5e		 pop	 r14
  00245	41 5d		 pop	 r13
  00247	41 5c		 pop	 r12
  00249	5f		 pop	 rdi
  0024a	5e		 pop	 rsi
  0024b	5d		 pop	 rbp
  0024c	c3		 ret	 0
?setBlock@World@@QEAAXHHHPEAVBlock@@@Z ENDP		; World::setBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 48
tv534 = 52
tv537 = 56
tv536 = 60
c$1 = 72
$T2 = 88
chunk$ = 104
this$ = 192
x$ = 200
y$ = 208
z$ = 216
block$ = 224
?dtor$0@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA PROC ; `World::setBlock'::`1'::dtor$0
  00000	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA ENDP ; `World::setBlock'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 48
tv534 = 52
tv537 = 56
tv536 = 60
c$1 = 72
$T2 = 88
chunk$ = 104
this$ = 192
x$ = 200
y$ = 208
z$ = 216
block$ = 224
?dtor$1@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA PROC ; `World::setBlock'::`1'::dtor$1
  0000c	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR c$1[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$1@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA ENDP ; `World::setBlock'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??M@YA_NAEBVChunkPosition@@0@Z
_TEXT	SEGMENT
cp1$ = 8
cp2$ = 16
??M@YA_NAEBVChunkPosition@@0@Z PROC			; operator<, COMDAT

; 287  : 	if(cp1.x < cp2.x)

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	4c 8b c1	 mov	 r8, rcx
  00005	8b 0a		 mov	 ecx, DWORD PTR [rdx]
  00007	3b c1		 cmp	 eax, ecx
  00009	7d 03		 jge	 SHORT $LN9@operator
$LN11@operator:

; 288  : 	{
; 289  : 		return true;

  0000b	b0 01		 mov	 al, 1

; 304  : }

  0000d	c3		 ret	 0
$LN9@operator:

; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  0000e	75 1a		 jne	 SHORT $LN1@operator

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  00010	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00014	8b 4a 04	 mov	 ecx, DWORD PTR [rdx+4]
  00017	3b c1		 cmp	 eax, ecx
  00019	7c f0		 jl	 SHORT $LN11@operator

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  0001b	75 0d		 jne	 SHORT $LN1@operator

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0001d	8b 4a 08	 mov	 ecx, DWORD PTR [rdx+8]
  00020	33 c0		 xor	 eax, eax
  00022	41 39 48 08	 cmp	 DWORD PTR [r8+8], ecx
  00026	0f 9c c0	 setl	 al

; 304  : }

  00029	c3		 ret	 0
$LN1@operator:

; 300  : 		}
; 301  : 	}
; 302  : 
; 303  : 	return false;

  0002a	32 c0		 xor	 al, al

; 304  : }

  0002c	c3		 ret	 0
??M@YA_NAEBVChunkPosition@@0@Z ENDP			; operator<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>, COMDAT

; 499  : 	shared_ptr(nullptr_t)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00008	33 d2		 xor	 edx, edx
  0000a	48 8b d9	 mov	 rbx, rcx

; 282  : 		{	// construct

  0000d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00010	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00014	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>

; 502  : 		}

  00019	48 8b c3	 mov	 rax, rbx
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
;	COMDAT ??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ PROC ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 92   : 		{	// construct empty map from defaults

$LN20:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 573  : 		this->_Myhead = 0;

  00006	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 92   : 		{	// construct empty map from defaults

  00008	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 573  : 		this->_Myhead = 0;

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 574  : 		this->_Mysize = 0;

  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00012	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00017	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 93   : 		}

  0001a	48 8b c3	 mov	 rax, rbx
  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??0?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ENDP ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
;	COMDAT ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = 56
$T2 = 72
$T3 = 128
this$ = 128
_Keyval$ = 136
??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z PROC ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[], COMDAT

; 191  : 		{	// find element matching _Keyval or insert with default mapped

$LN175:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00008	48 c7 40 b8 fe
	ff ff ff	 mov	 QWORD PTR [rax-72], -2
  00010	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00014	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  00018	48 8b f9	 mov	 rdi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  0001b	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1164 : 		}
; 1165 : 
; 1166 : #define _TREE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		_Pairib emplace(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* try to insert value_type(_Val...), favoring right side */ \
; 1171 : 		_Nodeptr _Newnode = this->_Buynode(LIST(_FORWARD_ARG)); \
; 1172 : 		return (_Insert_nohint(false, \
; 1173 : 			this->_Myval(_Newnode), _Newnode)); \
; 1174 : 		} \
; 1175 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1176 : 		iterator emplace_hint(const_iterator _Where \
; 1177 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1178 : 		{	/* insert value_type(_Val...) at _Where */ \
; 1179 : 		_Nodeptr _Newnode = this->_Buynode(LIST(_FORWARD_ARG)); \
; 1180 : 		return (_Insert_hint(_Where, \
; 1181 : 			this->_Myval(_Newnode), _Newnode)); \
; 1182 : 		}
; 1183 : 
; 1184 : _VARIADIC_EXPAND_0X(_TREE_EMPLACE, , , , )
; 1185 : #undef _TREE_EMPLACE
; 1186 : 
; 1187 : 	~_Tree() _NOEXCEPT
; 1188 : 		{	// destroy tree
; 1189 : 		_Tidy();
; 1190 : 		}
; 1191 : 
; 1192 : 	_Myt& operator=(const _Myt& _Right)
; 1193 : 		{	// replace contents from _Right
; 1194 : 		if (this != &_Right)
; 1195 : 			{	// different, assign it
; 1196 :  #if _HAS_CPP0X
; 1197 : 			clear();
; 1198 : 			if (this->_Getal() != _Right._Getal()
; 1199 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1200 : 				this->_Change_alloc(_Right._Getal());
; 1201 :  #endif /* _HAS_CPP0X */
; 1202 : 
; 1203 : 			this->_Setcomp(_Right._Getcomp());
; 1204 : 			_Copy(_Right, false_type());
; 1205 : 			}
; 1206 : 		return (*this);
; 1207 : 		}
; 1208 : 
; 1209 : 	iterator begin() _NOEXCEPT
; 1210 : 		{	// return iterator for beginning of mutable sequence
; 1211 : 		return (iterator(_Lmost(), this));
; 1212 : 		}
; 1213 : 
; 1214 : 	const_iterator begin() const _NOEXCEPT
; 1215 : 		{	// return iterator for beginning of nonmutable sequence
; 1216 : 		return (const_iterator(_Lmost(), this));
; 1217 : 		}
; 1218 : 
; 1219 : 	iterator end() _NOEXCEPT
; 1220 : 		{	// return iterator for end of mutable sequence
; 1221 : 		return (iterator(this->_Myhead, this));
; 1222 : 		}
; 1223 : 
; 1224 : 	const_iterator end() const _NOEXCEPT
; 1225 : 		{	// return iterator for end of nonmutable sequence
; 1226 : 		return (const_iterator(this->_Myhead, this));
; 1227 : 		}
; 1228 : 
; 1229 : 	reverse_iterator rbegin() _NOEXCEPT
; 1230 : 		{	// return iterator for beginning of reversed mutable sequence
; 1231 : 		return (reverse_iterator(end()));
; 1232 : 		}
; 1233 : 
; 1234 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1235 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1236 : 		return (const_reverse_iterator(end()));
; 1237 : 		}
; 1238 : 
; 1239 : 	reverse_iterator rend() _NOEXCEPT
; 1240 : 		{	// return iterator for end of reversed mutable sequence
; 1241 : 		return (reverse_iterator(begin()));
; 1242 : 		}
; 1243 : 
; 1244 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1245 : 		{	// return iterator for end of reversed nonmutable sequence
; 1246 : 		return (const_reverse_iterator(begin()));
; 1247 : 		}
; 1248 : 
; 1249 :  #if _HAS_CPP0X
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 :  #endif /* _HAS_CPP0X */
; 1270 : 
; 1271 : 	size_type size() const _NOEXCEPT
; 1272 : 		{	// return length of sequence
; 1273 : 		return (this->_Mysize);
; 1274 : 		}
; 1275 : 
; 1276 : 	size_type max_size() const _NOEXCEPT
; 1277 : 		{	// return maximum possible length of sequence
; 1278 : 		return (this->_Getal().max_size());
; 1279 : 		}
; 1280 : 
; 1281 : 	bool empty() const _NOEXCEPT
; 1282 : 		{	// return true only if sequence is empty
; 1283 : 		return (size() == 0);
; 1284 : 		}
; 1285 : 
; 1286 : 	allocator_type get_allocator() const _NOEXCEPT
; 1287 : 		{	// return allocator object for values
; 1288 : 		return (this->_Getal());
; 1289 : 		}
; 1290 : 
; 1291 : 	key_compare key_comp() const
; 1292 : 		{	// return object for comparing keys
; 1293 : 		return (this->_Getcomp());
; 1294 : 		}
; 1295 : 
; 1296 : 	value_compare value_comp() const
; 1297 : 		{	// return object for comparing values
; 1298 : 		return (value_compare(key_comp()));
; 1299 : 		}
; 1300 : 
; 1301 : 	_Pairib insert(const value_type& _Val)
; 1302 : 		{	// try to insert node with value _Val, favoring right side
; 1303 : 		return (_Insert_nohint(false,
; 1304 : 			_Val, _Nil_obj));
; 1305 : 		}
; 1306 : 
; 1307 : 	iterator insert(const_iterator _Where,
; 1308 : 		const value_type& _Val)
; 1309 : 		{	// try to insert node with value _Val using _Where as a hint
; 1310 : 		return (_Insert_hint(_Where,
; 1311 : 			_Val, _Nil_obj));
; 1312 : 		}
; 1313 : 
; 1314 : 	template<class _Iter>
; 1315 : 		void insert(_Iter _First, _Iter _Last)
; 1316 : 		{	// insert [_First, _Last) one at a time
; 1317 : 		_DEBUG_RANGE(_First, _Last);
; 1318 : 		for (; _First != _Last; ++_First)
; 1319 : 			insert(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	iterator erase(const_iterator _Where)
; 1323 : 		{	// erase element at _Where
; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))
; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");
; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1335 : 		++_Where;	// save successor iterator for return
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;
; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1346 : 		else
; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)
; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1355 : 			if (!this->_Isnil(_Fixnode))
; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)
; 1359 : 				_Root() = _Fixnode;	// link down from root
; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1362 : 			else
; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right
; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)
; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)
; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1375 : 			}
; 1376 : 		else
; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up
; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down
; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))
; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1385 : 			else
; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's
; 1389 : 				if (!this->_Isnil(_Fixnode))
; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down
; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up
; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)
; 1399 : 				_Root() = _Pnode;	// link down from root
; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left
; 1403 : 			else
; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right
; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up
; 1409 : 			_STD swap(this->_Color(_Pnode),
; 1410 : 				this->_Color(_Erasednode));	// recolor it
; 1411 : 			}
; 1412 : 
; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1421 : 					if (this->_Color(_Pnode) == this->_Red)
; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;
; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1425 : 						_Lrotate(_Fixnodeparent);
; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))
; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;
; 1435 : 						_Fixnode = _Fixnodeparent;
; 1436 : 						}
; 1437 : 					else
; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)
; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1443 : 							this->_Color(_Pnode) = this->_Red;
; 1444 : 							_Rrotate(_Pnode);
; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1451 : 						_Lrotate(_Fixnodeparent);
; 1452 : 						break;	// tree now recolored/rebalanced
; 1453 : 						}
; 1454 : 					}
; 1455 : 				else
; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1458 : 					if (this->_Color(_Pnode) == this->_Red)
; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;
; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1462 : 						_Rrotate(_Fixnodeparent);
; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))
; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;
; 1473 : 						_Fixnode = _Fixnodeparent;
; 1474 : 						}
; 1475 : 					else
; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1480 : 							this->_Color(_Pnode) = this->_Red;
; 1481 : 							_Lrotate(_Pnode);
; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1488 : 						_Rrotate(_Fixnodeparent);
; 1489 : 						break;	// tree now recolored/rebalanced
; 1490 : 						}
; 1491 : 					}
; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1494 : 			}
; 1495 : 
; 1496 : 		this->_Getal().destroy(
; 1497 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1498 : 
; 1499 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1500 : 
; 1501 : 		if (0 < this->_Mysize)
; 1502 : 			--this->_Mysize;
; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1505 : 		}
; 1506 : 
; 1507 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1508 : 		{	// erase [_First, _Last)
; 1509 : 		if (_First == begin() && _Last == end())
; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());
; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)
; 1517 : 				erase(_First++);
; 1518 : 			return (iterator(_First._Ptr, this));
; 1519 : 			}
; 1520 : 		}
; 1521 : 
; 1522 : 	size_type erase(const key_type& _Keyval)
; 1523 : 		{	// erase and count all that match _Keyval
; 1524 : 		_Pairii _Where = equal_range(_Keyval);
; 1525 : 		size_type _Num = 0;
; 1526 : 		_Distance(_Where.first, _Where.second, _Num);
; 1527 : 		erase(_Where.first, _Where.second);
; 1528 : 		return (_Num);
; 1529 : 		}
; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;
; 1539 : 		_Lmost() = this->_Myhead;
; 1540 : 		_Rmost() = this->_Myhead;
; 1541 : 		this->_Mysize = 0;
; 1542 : 		}
; 1543 : 
; 1544 : 	iterator find(const key_type& _Keyval)
; 1545 : 		{	// find an element in mutable sequence that matches _Keyval
; 1546 : 		iterator _Where = lower_bound(_Keyval);
; 1547 : 		return (_Where == end()
; 1548 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1549 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1550 : 					? end() : _Where);
; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));
; 1593 : 		}
; 1594 : 
; 1595 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1596 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1597 : 		return (_Eqrange(_Keyval));
; 1598 : 		}
; 1599 : 
; 1600 : 	void swap(_Myt& _Right)
; 1601 : 		{	// exchange contents with _Right
; 1602 : 		if (this == &_Right)
; 1603 : 			;	// same object, do nothing
; 1604 : 		else if (this->_Getal() == _Right._Getal())
; 1605 : 			{	// same allocator, swap control information
; 1606 : 			this->_Swap_all(_Right);
; 1607 : 			this->_Swapcomp(_Right._Getcomp());
; 1608 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1609 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1610 : 			}
; 1611 : 
; 1612 :  #if _HAS_CPP0X
; 1613 : 		else if (_Alty::propagate_on_container_swap::value)
; 1614 : 			{	// swap allocators and control information
; 1615 : 			this->_Swap_alloc(_Right);
; 1616 : 			this->_Swapcomp(_Right._Getcomp());
; 1617 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1618 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1619 : 			}
; 1620 :  #endif /* _HAS_CPP0X */
; 1621 : 
; 1622 : 		else
; 1623 : 			{	// different allocator, do multiple copies
; 1624 : 			_Myt _Temp(this->_Getcomp(), get_allocator());
; 1625 : 			_Temp._Copy(*this, true_type());
; 1626 : 
; 1627 : 			this->_Setcomp(_Right._Getcomp());
; 1628 : 			clear();
; 1629 : 			_Copy(_Right, true_type());
; 1630 : 
; 1631 : 			_Right._Setcomp(_Temp._Getcomp());
; 1632 : 			_Right.clear();
; 1633 : 			_Right._Copy(_Temp, true_type());
; 1634 : 			}
; 1635 : 		}
; 1636 : 
; 1637 : protected:
; 1638 : 	template<class _Valty>
; 1639 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Valty>
; 1645 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1646 : 		{	// node doesn't exist, make it
; 1647 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1648 : 		}
; 1649 : 
; 1650 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1651 : 		{	// node exists, destroy it
; 1652 : 		this->_Getal().destroy(
; 1653 : 			_STD addressof(this->_Myval(_Newnode)));
; 1654 : 
; 1655 : 		this->_Getal().deallocate(_Newnode, 1);
; 1656 : 		}
; 1657 : 
; 1658 : 	void _Destroy_if_not_nil(_Nil)
; 1659 : 		{	// node doesn't exist, do nothing
; 1660 : 		}
; 1661 : 
; 1662 : 	template<class _Valty,
; 1663 : 		class _Nodety>
; 1664 : 		iterator _Insert_hint(const_iterator _Where,
; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN
; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)
; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())
; 1729 : 				{	// insert at beginning if before first element
; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1734 : 				}
; 1735 : 			else if (_Where == end())
; 1736 : 				{	// insert at end if after last element
; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1741 : 				}
; 1742 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1743 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1754 : 				}
; 1755 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1757 : 				&& (++(_Next = _Where) == end()
; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);
; 1771 : 		_RERAISE;
; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1776 : 		}
; 1777 : 
; 1778 : 	template<class _Valty,
; 1779 : 		class _Nodety>
; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN
; 1784 : 		_Nodeptr _Trynode = _Root();
; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))
; 1789 : 			{	// look for leaf to insert before (_Addleft) or after
; 1790 : 			_Wherenode = _Trynode;
; 1791 : 			if (_Leftish)
; 1792 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1793 : 					this->_Key(_Trynode),
; 1794 : 					this->_Kfn(_Val));	// favor left end
; 1795 : 			else
; 1796 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1797 : 					this->_Kfn(_Val),
; 1798 : 					this->_Key(_Trynode));	// favor right end
; 1799 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1800 : 				: this->_Right(_Trynode);
; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)
; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())
; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1813 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1814 : 			else
; 1815 : 				--_Where;	// need to test if insert before is okay
; 1816 : 
; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1821 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1822 : 			else
; 1823 : 				{	// duplicate, don't insert
; 1824 : 				_Destroy_if_not_nil(_Newnode);
; 1825 : 				return (_Pairib(_Where, false));
; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);
; 1830 : 		_RERAISE;
; 1831 : 		_CATCH_END
; 1832 : 		}
; 1833 : 
; 1834 : 	template<class _Valty,
; 1835 : 		class _Nodety>
; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)
; 1840 : 			{	// tree would get too big, fail
; 1841 : 			_Destroy_if_not_nil(_Node);
; 1842 : 			_Xlength_error("map/set<T> too long");
; 1843 : 			}
; 1844 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1845 : 			_STD forward<_Valty>(_Val));
; 1846 : 
; 1847 : 		++this->_Mysize;
; 1848 : 		_Newnode->_Parent = _Wherenode;
; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)
; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;
; 1853 : 			_Lmost() = _Newnode;
; 1854 : 			_Rmost() = _Newnode;
; 1855 : 			}
; 1856 : 		else if (_Addleft)
; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;
; 1859 : 			if (_Wherenode == _Lmost())
; 1860 : 				_Lmost() = _Newnode;
; 1861 : 			}
; 1862 : 		else
; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;
; 1865 : 			if (_Wherenode == _Rmost())
; 1866 : 				_Rmost() = _Newnode;
; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1879 : 					this->_Color(_Wherenode) = this->_Black;
; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;
; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1883 : 					}
; 1884 : 				else
; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);
; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up
; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;
; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1896 : 					}
; 1897 : 				}
; 1898 : 			else
; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1905 : 					this->_Color(_Wherenode) = this->_Black;
; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;
; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1909 : 					}
; 1910 : 				else
; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);
; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up
; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;
; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1926 : 		return (iterator(_Newnode, this));
; 1927 : 		}
; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();

  0001e	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  00022	48 8b d8	 mov	 rbx, rax

; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00025	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0
  0002a	75 3f		 jne	 SHORT $LN11@operator
  0002c	44 8b 12	 mov	 r10d, DWORD PTR [rdx]
  0002f	90		 npad	 1
$LL12@operator:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00030	45 8b 48 20	 mov	 r9d, DWORD PTR [r8+32]
  00034	45 3b ca	 cmp	 r9d, r10d
  00037	7c 27		 jl	 SHORT $LN170@operator

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00039	75 1d		 jne	 SHORT $LN10@operator

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0003b	41 8b 48 24	 mov	 ecx, DWORD PTR [r8+36]
  0003f	44 8b 4a 04	 mov	 r9d, DWORD PTR [rdx+4]
  00043	41 3b c9	 cmp	 ecx, r9d
  00046	7c 18		 jl	 SHORT $LN170@operator

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00048	75 0e		 jne	 SHORT $LN10@operator

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0004a	8b 4a 08	 mov	 ecx, DWORD PTR [rdx+8]
  0004d	41 39 48 28	 cmp	 DWORD PTR [r8+40], ecx
  00051	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00054	84 c9		 test	 cl, cl
  00056	75 08		 jne	 SHORT $LN170@operator
$LN10@operator:

; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;

  00058	49 8b d8	 mov	 rbx, r8

; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0005b	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0005e	eb 04		 jmp	 SHORT $LN9@operator
$LN170@operator:

; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00060	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
$LN9@operator:

; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00064	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0
  00069	74 c5		 je	 SHORT $LL12@operator
$LN11@operator:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0006b	48 3b d8	 cmp	 rbx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 194  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  0006e	74 30		 je	 SHORT $LN1@operator
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00070	8b 02		 mov	 eax, DWORD PTR [rdx]
  00072	8b 4b 20	 mov	 ecx, DWORD PTR [rbx+32]
  00075	3b c1		 cmp	 eax, ecx
  00077	7c 27		 jl	 SHORT $LN1@operator

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00079	0f 85 ab 00 00
	00		 jne	 $LN174@operator

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0007f	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00082	8b 4b 24	 mov	 ecx, DWORD PTR [rbx+36]
  00085	3b c1		 cmp	 eax, ecx
  00087	7c 17		 jl	 SHORT $LN1@operator

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00089	0f 85 9b 00 00
	00		 jne	 $LN174@operator

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0008f	8b 43 28	 mov	 eax, DWORD PTR [rbx+40]
  00092	39 42 08	 cmp	 DWORD PTR [rdx+8], eax
  00095	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 194  : 			|| this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

  00098	84 c0		 test	 al, al
  0009a	0f 84 8a 00 00
	00		 je	 $LN174@operator
$LN1@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 138  : 		{	// construct from moved values

  000a0	8b 02		 mov	 eax, DWORD PTR [rdx]
  000a2	89 44 24 48	 mov	 DWORD PTR $T2[rsp], eax
  000a6	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  000a9	89 44 24 4c	 mov	 DWORD PTR $T2[rsp+4], eax
  000ad	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  000b0	89 44 24 50	 mov	 DWORD PTR $T2[rsp+8], eax

; 48   : 	_Left = _Move(_Right);

  000b4	33 c0		 xor	 eax, eax
  000b6	48 89 44 24 60	 mov	 QWORD PTR $T2[rsp+24], rax

; 49   : 	_Right = _Move(_Tmp);

  000bb	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp+8], rax

; 48   : 	_Left = _Move(_Right);

  000c0	48 89 44 24 58	 mov	 QWORD PTR $T2[rsp+16], rax

; 49   : 	_Right = _Move(_Tmp);

  000c5	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1161 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  000ca	48 8d 54 24 48	 lea	 rdx, QWORD PTR $T2[rsp]
  000cf	48 8b cf	 mov	 rcx, rdi
  000d2	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  000d7	4c 8d 48 20	 lea	 r9, QWORD PTR [rax+32]

; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));

  000db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e0	4c 8b c3	 mov	 r8, rbx
  000e3	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR $T3[rsp]
  000eb	48 8b cf	 mov	 rcx, rdi
  000ee	e8 00 00 00 00	 call	 ??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 198  : 					mapped_type()));

  000f3	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR $T3[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T2[rsp+24]
  00100	48 85 c9	 test	 rcx, rcx
  00103	74 25		 je	 SHORT $LN142@operator

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00105	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00109	75 1f		 jne	 SHORT $LN142@operator

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0010b	48 8b 7c 24 60	 mov	 rdi, QWORD PTR $T2[rsp+24]
  00110	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00113	48 8b cf	 mov	 rcx, rdi
  00116	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00118	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0011c	75 0c		 jne	 SHORT $LN142@operator

; 128  : 			_Delete_this();

  0011e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T2[rsp+24]
  00123	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00126	ff 50 08	 call	 QWORD PTR [rax+8]
  00129	90		 npad	 1
$LN142@operator:
$LN174@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 199  : 		return (_Where->second);

  0012a	48 8d 43 30	 lea	 rax, QWORD PTR [rbx+48]

; 200  : 		}

  0012e	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  00133	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00137	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  0013b	49 8b e3	 mov	 rsp, r11
  0013e	5f		 pop	 rdi
  0013f	c3		 ret	 0
??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ENDP ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 56
$T2 = 72
$T3 = 128
this$ = 128
_Keyval$ = 136
?dtor$0@?0???A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA PROC ; `std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]'::`1'::dtor$0
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0???A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA ENDP ; `std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 56
$T2 = 72
$T3 = 128
this$ = 128
_Keyval$ = 136
?dtor$1@?0???A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA PROC ; `std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]'::`1'::dtor$1
  0000c	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR $T2[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
?dtor$1@?0???A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA ENDP ; `std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 48
this$ = 48
??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT

; 1188 : 		{	// destroy tree

$LN62:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1191 : 
; 1192 : 	_Myt& operator=(const _Myt& _Right)
; 1193 : 		{	// replace contents from _Right
; 1194 : 		if (this != &_Right)
; 1195 : 			{	// different, assign it
; 1196 :  #if _HAS_CPP0X
; 1197 : 			clear();
; 1198 : 			if (this->_Getal() != _Right._Getal()
; 1199 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1200 : 				this->_Change_alloc(_Right._Getal());
; 1201 :  #endif /* _HAS_CPP0X */
; 1202 : 
; 1203 : 			this->_Setcomp(_Right._Getcomp());
; 1204 : 			_Copy(_Right, false_type());
; 1205 : 			}
; 1206 : 		return (*this);
; 1207 : 		}
; 1208 : 
; 1209 : 	iterator begin() _NOEXCEPT
; 1210 : 		{	// return iterator for beginning of mutable sequence
; 1211 : 		return (iterator(_Lmost(), this));
; 1212 : 		}
; 1213 : 
; 1214 : 	const_iterator begin() const _NOEXCEPT
; 1215 : 		{	// return iterator for beginning of nonmutable sequence
; 1216 : 		return (const_iterator(_Lmost(), this));
; 1217 : 		}
; 1218 : 
; 1219 : 	iterator end() _NOEXCEPT
; 1220 : 		{	// return iterator for end of mutable sequence
; 1221 : 		return (iterator(this->_Myhead, this));
; 1222 : 		}
; 1223 : 
; 1224 : 	const_iterator end() const _NOEXCEPT
; 1225 : 		{	// return iterator for end of nonmutable sequence
; 1226 : 		return (const_iterator(this->_Myhead, this));
; 1227 : 		}
; 1228 : 
; 1229 : 	reverse_iterator rbegin() _NOEXCEPT
; 1230 : 		{	// return iterator for beginning of reversed mutable sequence
; 1231 : 		return (reverse_iterator(end()));
; 1232 : 		}
; 1233 : 
; 1234 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1235 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1236 : 		return (const_reverse_iterator(end()));
; 1237 : 		}
; 1238 : 
; 1239 : 	reverse_iterator rend() _NOEXCEPT
; 1240 : 		{	// return iterator for end of reversed mutable sequence
; 1241 : 		return (reverse_iterator(begin()));
; 1242 : 		}
; 1243 : 
; 1244 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1245 : 		{	// return iterator for end of reversed nonmutable sequence
; 1246 : 		return (const_reverse_iterator(begin()));
; 1247 : 		}
; 1248 : 
; 1249 :  #if _HAS_CPP0X
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 :  #endif /* _HAS_CPP0X */
; 1270 : 
; 1271 : 	size_type size() const _NOEXCEPT
; 1272 : 		{	// return length of sequence
; 1273 : 		return (this->_Mysize);
; 1274 : 		}
; 1275 : 
; 1276 : 	size_type max_size() const _NOEXCEPT
; 1277 : 		{	// return maximum possible length of sequence
; 1278 : 		return (this->_Getal().max_size());
; 1279 : 		}
; 1280 : 
; 1281 : 	bool empty() const _NOEXCEPT
; 1282 : 		{	// return true only if sequence is empty
; 1283 : 		return (size() == 0);
; 1284 : 		}
; 1285 : 
; 1286 : 	allocator_type get_allocator() const _NOEXCEPT
; 1287 : 		{	// return allocator object for values
; 1288 : 		return (this->_Getal());
; 1289 : 		}
; 1290 : 
; 1291 : 	key_compare key_comp() const
; 1292 : 		{	// return object for comparing keys
; 1293 : 		return (this->_Getcomp());
; 1294 : 		}
; 1295 : 
; 1296 : 	value_compare value_comp() const
; 1297 : 		{	// return object for comparing values
; 1298 : 		return (value_compare(key_comp()));
; 1299 : 		}
; 1300 : 
; 1301 : 	_Pairib insert(const value_type& _Val)
; 1302 : 		{	// try to insert node with value _Val, favoring right side
; 1303 : 		return (_Insert_nohint(false,
; 1304 : 			_Val, _Nil_obj));
; 1305 : 		}
; 1306 : 
; 1307 : 	iterator insert(const_iterator _Where,
; 1308 : 		const value_type& _Val)
; 1309 : 		{	// try to insert node with value _Val using _Where as a hint
; 1310 : 		return (_Insert_hint(_Where,
; 1311 : 			_Val, _Nil_obj));
; 1312 : 		}
; 1313 : 
; 1314 : 	template<class _Iter>
; 1315 : 		void insert(_Iter _First, _Iter _Last)
; 1316 : 		{	// insert [_First, _Last) one at a time
; 1317 : 		_DEBUG_RANGE(_First, _Last);
; 1318 : 		for (; _First != _Last; ++_First)
; 1319 : 			insert(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	iterator erase(const_iterator _Where)
; 1323 : 		{	// erase element at _Where
; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))
; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");
; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1335 : 		++_Where;	// save successor iterator for return
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;
; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1346 : 		else
; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)
; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1355 : 			if (!this->_Isnil(_Fixnode))
; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)
; 1359 : 				_Root() = _Fixnode;	// link down from root
; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1362 : 			else
; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right
; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)
; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)
; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1375 : 			}
; 1376 : 		else
; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up
; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down
; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))
; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1385 : 			else
; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's
; 1389 : 				if (!this->_Isnil(_Fixnode))
; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down
; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up
; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)
; 1399 : 				_Root() = _Pnode;	// link down from root
; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left
; 1403 : 			else
; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right
; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up
; 1409 : 			_STD swap(this->_Color(_Pnode),
; 1410 : 				this->_Color(_Erasednode));	// recolor it
; 1411 : 			}
; 1412 : 
; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1421 : 					if (this->_Color(_Pnode) == this->_Red)
; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;
; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1425 : 						_Lrotate(_Fixnodeparent);
; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))
; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;
; 1435 : 						_Fixnode = _Fixnodeparent;
; 1436 : 						}
; 1437 : 					else
; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)
; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1443 : 							this->_Color(_Pnode) = this->_Red;
; 1444 : 							_Rrotate(_Pnode);
; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1451 : 						_Lrotate(_Fixnodeparent);
; 1452 : 						break;	// tree now recolored/rebalanced
; 1453 : 						}
; 1454 : 					}
; 1455 : 				else
; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1458 : 					if (this->_Color(_Pnode) == this->_Red)
; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;
; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1462 : 						_Rrotate(_Fixnodeparent);
; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))
; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;
; 1473 : 						_Fixnode = _Fixnodeparent;
; 1474 : 						}
; 1475 : 					else
; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1480 : 							this->_Color(_Pnode) = this->_Red;
; 1481 : 							_Lrotate(_Pnode);
; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1488 : 						_Rrotate(_Fixnodeparent);
; 1489 : 						break;	// tree now recolored/rebalanced
; 1490 : 						}
; 1491 : 					}
; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1494 : 			}
; 1495 : 
; 1496 : 		this->_Getal().destroy(
; 1497 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1498 : 
; 1499 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1500 : 
; 1501 : 		if (0 < this->_Mysize)
; 1502 : 			--this->_Mysize;
; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1505 : 		}
; 1506 : 
; 1507 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1508 : 		{	// erase [_First, _Last)
; 1509 : 		if (_First == begin() && _Last == end())
; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());
; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)
; 1517 : 				erase(_First++);
; 1518 : 			return (iterator(_First._Ptr, this));
; 1519 : 			}
; 1520 : 		}
; 1521 : 
; 1522 : 	size_type erase(const key_type& _Keyval)
; 1523 : 		{	// erase and count all that match _Keyval
; 1524 : 		_Pairii _Where = equal_range(_Keyval);
; 1525 : 		size_type _Num = 0;
; 1526 : 		_Distance(_Where.first, _Where.second, _Num);
; 1527 : 		erase(_Where.first, _Where.second);
; 1528 : 		return (_Num);
; 1529 : 		}
; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;
; 1539 : 		_Lmost() = this->_Myhead;
; 1540 : 		_Rmost() = this->_Myhead;
; 1541 : 		this->_Mysize = 0;
; 1542 : 		}
; 1543 : 
; 1544 : 	iterator find(const key_type& _Keyval)
; 1545 : 		{	// find an element in mutable sequence that matches _Keyval
; 1546 : 		iterator _Where = lower_bound(_Keyval);
; 1547 : 		return (_Where == end()
; 1548 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1549 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1550 : 					? end() : _Where);
; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));
; 1593 : 		}
; 1594 : 
; 1595 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1596 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1597 : 		return (_Eqrange(_Keyval));
; 1598 : 		}
; 1599 : 
; 1600 : 	void swap(_Myt& _Right)
; 1601 : 		{	// exchange contents with _Right
; 1602 : 		if (this == &_Right)
; 1603 : 			;	// same object, do nothing
; 1604 : 		else if (this->_Getal() == _Right._Getal())
; 1605 : 			{	// same allocator, swap control information
; 1606 : 			this->_Swap_all(_Right);
; 1607 : 			this->_Swapcomp(_Right._Getcomp());
; 1608 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1609 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1610 : 			}
; 1611 : 
; 1612 :  #if _HAS_CPP0X
; 1613 : 		else if (_Alty::propagate_on_container_swap::value)
; 1614 : 			{	// swap allocators and control information
; 1615 : 			this->_Swap_alloc(_Right);
; 1616 : 			this->_Swapcomp(_Right._Getcomp());
; 1617 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1618 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1619 : 			}
; 1620 :  #endif /* _HAS_CPP0X */
; 1621 : 
; 1622 : 		else
; 1623 : 			{	// different allocator, do multiple copies
; 1624 : 			_Myt _Temp(this->_Getcomp(), get_allocator());
; 1625 : 			_Temp._Copy(*this, true_type());
; 1626 : 
; 1627 : 			this->_Setcomp(_Right._Getcomp());
; 1628 : 			clear();
; 1629 : 			_Copy(_Right, true_type());
; 1630 : 
; 1631 : 			_Right._Setcomp(_Temp._Getcomp());
; 1632 : 			_Right.clear();
; 1633 : 			_Right._Copy(_Temp, true_type());
; 1634 : 			}
; 1635 : 		}
; 1636 : 
; 1637 : protected:
; 1638 : 	template<class _Valty>
; 1639 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Valty>
; 1645 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1646 : 		{	// node doesn't exist, make it
; 1647 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1648 : 		}
; 1649 : 
; 1650 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1651 : 		{	// node exists, destroy it
; 1652 : 		this->_Getal().destroy(
; 1653 : 			_STD addressof(this->_Myval(_Newnode)));
; 1654 : 
; 1655 : 		this->_Getal().deallocate(_Newnode, 1);
; 1656 : 		}
; 1657 : 
; 1658 : 	void _Destroy_if_not_nil(_Nil)
; 1659 : 		{	// node doesn't exist, do nothing
; 1660 : 		}
; 1661 : 
; 1662 : 	template<class _Valty,
; 1663 : 		class _Nodety>
; 1664 : 		iterator _Insert_hint(const_iterator _Where,
; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN
; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)
; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())
; 1729 : 				{	// insert at beginning if before first element
; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1734 : 				}
; 1735 : 			else if (_Where == end())
; 1736 : 				{	// insert at end if after last element
; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1741 : 				}
; 1742 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1743 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1754 : 				}
; 1755 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1757 : 				&& (++(_Next = _Where) == end()
; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);
; 1771 : 		_RERAISE;
; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1776 : 		}
; 1777 : 
; 1778 : 	template<class _Valty,
; 1779 : 		class _Nodety>
; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN
; 1784 : 		_Nodeptr _Trynode = _Root();
; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))
; 1789 : 			{	// look for leaf to insert before (_Addleft) or after
; 1790 : 			_Wherenode = _Trynode;
; 1791 : 			if (_Leftish)
; 1792 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1793 : 					this->_Key(_Trynode),
; 1794 : 					this->_Kfn(_Val));	// favor left end
; 1795 : 			else
; 1796 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1797 : 					this->_Kfn(_Val),
; 1798 : 					this->_Key(_Trynode));	// favor right end
; 1799 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1800 : 				: this->_Right(_Trynode);
; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)
; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())
; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1813 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1814 : 			else
; 1815 : 				--_Where;	// need to test if insert before is okay
; 1816 : 
; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1821 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1822 : 			else
; 1823 : 				{	// duplicate, don't insert
; 1824 : 				_Destroy_if_not_nil(_Newnode);
; 1825 : 				return (_Pairib(_Where, false));
; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);
; 1830 : 		_RERAISE;
; 1831 : 		_CATCH_END
; 1832 : 		}
; 1833 : 
; 1834 : 	template<class _Valty,
; 1835 : 		class _Nodety>
; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)
; 1840 : 			{	// tree would get too big, fail
; 1841 : 			_Destroy_if_not_nil(_Node);
; 1842 : 			_Xlength_error("map/set<T> too long");
; 1843 : 			}
; 1844 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1845 : 			_STD forward<_Valty>(_Val));
; 1846 : 
; 1847 : 		++this->_Mysize;
; 1848 : 		_Newnode->_Parent = _Wherenode;
; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)
; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;
; 1853 : 			_Lmost() = _Newnode;
; 1854 : 			_Rmost() = _Newnode;
; 1855 : 			}
; 1856 : 		else if (_Addleft)
; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;
; 1859 : 			if (_Wherenode == _Lmost())
; 1860 : 				_Lmost() = _Newnode;
; 1861 : 			}
; 1862 : 		else
; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;
; 1865 : 			if (_Wherenode == _Rmost())
; 1866 : 				_Rmost() = _Newnode;
; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1879 : 					this->_Color(_Wherenode) = this->_Black;
; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;
; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1883 : 					}
; 1884 : 				else
; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);
; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up
; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;
; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1896 : 					}
; 1897 : 				}
; 1898 : 			else
; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1905 : 					this->_Color(_Wherenode) = this->_Black;
; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;
; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1909 : 					}
; 1910 : 				else
; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);
; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up
; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;
; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1926 : 		return (iterator(_Newnode, this));
; 1927 : 		}
; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();
; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))
; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;
; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate
; 2105 : 		}
; 2106 : 
; 2107 : 	_Nodeptr& _Lmost() const
; 2108 : 		{	// return leftmost node in nonmutable tree
; 2109 : 		return (this->_Left(this->_Myhead));
; 2110 : 		}
; 2111 : 
; 2112 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2113 : 		{	// promote right node to root of subtree
; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2120 : 
; 2121 : 		if (_Wherenode == _Root())
; 2122 : 			_Root() = _Pnode;
; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2125 : 		else
; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;
; 2129 : 		this->_Parent(_Wherenode) = _Pnode;
; 2130 : 		}
; 2131 : 
; 2132 : 	_Nodeptr& _Rmost() const
; 2133 : 		{	// return rightmost node in nonmutable tree
; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}
; 2136 : 
; 2137 : 	_Nodeptr& _Root() const
; 2138 : 		{	// return root of nonmutable tree
; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}
; 2141 : 
; 2142 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2143 : 		{	// promote left node to root of subtree
; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2150 : 
; 2151 : 		if (_Wherenode == _Root())
; 2152 : 			_Root() = _Pnode;
; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2155 : 		else
; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;
; 2159 : 		this->_Parent(_Wherenode) = _Pnode;
; 2160 : 		}
; 2161 : 
; 2162 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2163 : 		{	// find leftmost node greater than _Keyval
; 2164 : 		_Nodeptr _Pnode = _Root();
; 2165 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2166 : 
; 2167 : 		while (!this->_Isnil(_Pnode))
; 2168 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2169 : 				{	// _Pnode greater than _Keyval, remember it
; 2170 : 				_Wherenode = _Pnode;
; 2171 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2172 : 				}
; 2173 : 			else
; 2174 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2175 : 
; 2176 : 		return (_Wherenode);	// return best remembered candidate
; 2177 : 		}
; 2178 : 
; 2179 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2180 : 		{	// find leftmost node greater than _Keyval
; 2181 : 		_Nodeptr _Pnode = _Root();
; 2182 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2183 : 
; 2184 : 		while (!this->_Isnil(_Pnode))
; 2185 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2186 : 				{	// _Pnode greater than _Keyval, remember it
; 2187 : 				_Wherenode = _Pnode;
; 2188 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2189 : 				}
; 2190 : 			else
; 2191 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2192 : 
; 2193 : 		return (_Wherenode);	// return best remembered candidate
; 2194 : 		}
; 2195 : 
; 2196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2197 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2198 : 		{	// orphan iterators with specified node pointers
; 2199 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2200 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2201 : 		if (_Pnext != 0)
; 2202 : 			while (*_Pnext != 0)
; 2203 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2204 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2205 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2206 : 				else
; 2207 : 					{	// orphan the iterator
; 2208 : 					(*_Pnext)->_Clrcont();
; 2209 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2210 : 					}
; 2211 : 		}
; 2212 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2213 : 
; 2214 : 	void _Tidy()
; 2215 : 		{	// free all storage
; 2216 : 		erase(begin(), end());

  00006	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00009	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]

; 1188 : 		{	// destroy tree

  0000e	48 8b d9	 mov	 rbx, rcx

; 1191 : 
; 1192 : 	_Myt& operator=(const _Myt& _Right)
; 1193 : 		{	// replace contents from _Right
; 1194 : 		if (this != &_Right)
; 1195 : 			{	// different, assign it
; 1196 :  #if _HAS_CPP0X
; 1197 : 			clear();
; 1198 : 			if (this->_Getal() != _Right._Getal()
; 1199 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1200 : 				this->_Change_alloc(_Right._Getal());
; 1201 :  #endif /* _HAS_CPP0X */
; 1202 : 
; 1203 : 			this->_Setcomp(_Right._Getcomp());
; 1204 : 			_Copy(_Right, false_type());
; 1205 : 			}
; 1206 : 		return (*this);
; 1207 : 		}
; 1208 : 
; 1209 : 	iterator begin() _NOEXCEPT
; 1210 : 		{	// return iterator for beginning of mutable sequence
; 1211 : 		return (iterator(_Lmost(), this));
; 1212 : 		}
; 1213 : 
; 1214 : 	const_iterator begin() const _NOEXCEPT
; 1215 : 		{	// return iterator for beginning of nonmutable sequence
; 1216 : 		return (const_iterator(_Lmost(), this));
; 1217 : 		}
; 1218 : 
; 1219 : 	iterator end() _NOEXCEPT
; 1220 : 		{	// return iterator for end of mutable sequence
; 1221 : 		return (iterator(this->_Myhead, this));
; 1222 : 		}
; 1223 : 
; 1224 : 	const_iterator end() const _NOEXCEPT
; 1225 : 		{	// return iterator for end of nonmutable sequence
; 1226 : 		return (const_iterator(this->_Myhead, this));
; 1227 : 		}
; 1228 : 
; 1229 : 	reverse_iterator rbegin() _NOEXCEPT
; 1230 : 		{	// return iterator for beginning of reversed mutable sequence
; 1231 : 		return (reverse_iterator(end()));
; 1232 : 		}
; 1233 : 
; 1234 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1235 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1236 : 		return (const_reverse_iterator(end()));
; 1237 : 		}
; 1238 : 
; 1239 : 	reverse_iterator rend() _NOEXCEPT
; 1240 : 		{	// return iterator for end of reversed mutable sequence
; 1241 : 		return (reverse_iterator(begin()));
; 1242 : 		}
; 1243 : 
; 1244 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1245 : 		{	// return iterator for end of reversed nonmutable sequence
; 1246 : 		return (const_reverse_iterator(begin()));
; 1247 : 		}
; 1248 : 
; 1249 :  #if _HAS_CPP0X
; 1250 : 	const_iterator cbegin() const _NOEXCEPT
; 1251 : 		{	// return iterator for beginning of nonmutable sequence
; 1252 : 		return (((const _Myt *)this)->begin());
; 1253 : 		}
; 1254 : 
; 1255 : 	const_iterator cend() const _NOEXCEPT
; 1256 : 		{	// return iterator for end of nonmutable sequence
; 1257 : 		return (((const _Myt *)this)->end());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1261 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1262 : 		return (((const _Myt *)this)->rbegin());
; 1263 : 		}
; 1264 : 
; 1265 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1266 : 		{	// return iterator for end of reversed nonmutable sequence
; 1267 : 		return (((const _Myt *)this)->rend());
; 1268 : 		}
; 1269 :  #endif /* _HAS_CPP0X */
; 1270 : 
; 1271 : 	size_type size() const _NOEXCEPT
; 1272 : 		{	// return length of sequence
; 1273 : 		return (this->_Mysize);
; 1274 : 		}
; 1275 : 
; 1276 : 	size_type max_size() const _NOEXCEPT
; 1277 : 		{	// return maximum possible length of sequence
; 1278 : 		return (this->_Getal().max_size());
; 1279 : 		}
; 1280 : 
; 1281 : 	bool empty() const _NOEXCEPT
; 1282 : 		{	// return true only if sequence is empty
; 1283 : 		return (size() == 0);
; 1284 : 		}
; 1285 : 
; 1286 : 	allocator_type get_allocator() const _NOEXCEPT
; 1287 : 		{	// return allocator object for values
; 1288 : 		return (this->_Getal());
; 1289 : 		}
; 1290 : 
; 1291 : 	key_compare key_comp() const
; 1292 : 		{	// return object for comparing keys
; 1293 : 		return (this->_Getcomp());
; 1294 : 		}
; 1295 : 
; 1296 : 	value_compare value_comp() const
; 1297 : 		{	// return object for comparing values
; 1298 : 		return (value_compare(key_comp()));
; 1299 : 		}
; 1300 : 
; 1301 : 	_Pairib insert(const value_type& _Val)
; 1302 : 		{	// try to insert node with value _Val, favoring right side
; 1303 : 		return (_Insert_nohint(false,
; 1304 : 			_Val, _Nil_obj));
; 1305 : 		}
; 1306 : 
; 1307 : 	iterator insert(const_iterator _Where,
; 1308 : 		const value_type& _Val)
; 1309 : 		{	// try to insert node with value _Val using _Where as a hint
; 1310 : 		return (_Insert_hint(_Where,
; 1311 : 			_Val, _Nil_obj));
; 1312 : 		}
; 1313 : 
; 1314 : 	template<class _Iter>
; 1315 : 		void insert(_Iter _First, _Iter _Last)
; 1316 : 		{	// insert [_First, _Last) one at a time
; 1317 : 		_DEBUG_RANGE(_First, _Last);
; 1318 : 		for (; _First != _Last; ++_First)
; 1319 : 			insert(end(), *_First);
; 1320 : 		}
; 1321 : 
; 1322 : 	iterator erase(const_iterator _Where)
; 1323 : 		{	// erase element at _Where
; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))
; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");
; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1335 : 		++_Where;	// save successor iterator for return
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;
; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))
; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree
; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))
; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree
; 1346 : 		else
; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree
; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)
; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1355 : 			if (!this->_Isnil(_Fixnode))
; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up
; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)
; 1359 : 				_Root() = _Fixnode;	// link down from root
; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)
; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left
; 1362 : 			else
; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right
; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)
; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)
; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1375 : 			}
; 1376 : 		else
; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up
; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down
; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))
; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased
; 1385 : 			else
; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's
; 1389 : 				if (!this->_Isnil(_Fixnode))
; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up
; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down
; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down
; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up
; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)
; 1399 : 				_Root() = _Pnode;	// link down from root
; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left
; 1403 : 			else
; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right
; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up
; 1409 : 			_STD swap(this->_Color(_Pnode),
; 1410 : 				this->_Color(_Erasednode));	// recolor it
; 1411 : 			}
; 1412 : 
; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)
; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))
; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))
; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);
; 1421 : 					if (this->_Color(_Pnode) == this->_Red)
; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;
; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1425 : 						_Lrotate(_Fixnodeparent);
; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);
; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))
; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;
; 1435 : 						_Fixnode = _Fixnodeparent;
; 1436 : 						}
; 1437 : 					else
; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)
; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1443 : 							this->_Color(_Pnode) = this->_Red;
; 1444 : 							_Rrotate(_Pnode);
; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);
; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1451 : 						_Lrotate(_Fixnodeparent);
; 1452 : 						break;	// tree now recolored/rebalanced
; 1453 : 						}
; 1454 : 					}
; 1455 : 				else
; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1458 : 					if (this->_Color(_Pnode) == this->_Red)
; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;
; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1462 : 						_Rrotate(_Fixnodeparent);
; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);
; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))
; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;
; 1473 : 						_Fixnode = _Fixnodeparent;
; 1474 : 						}
; 1475 : 					else
; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1480 : 							this->_Color(_Pnode) = this->_Red;
; 1481 : 							_Lrotate(_Pnode);
; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);
; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1488 : 						_Rrotate(_Fixnodeparent);
; 1489 : 						break;	// tree now recolored/rebalanced
; 1490 : 						}
; 1491 : 					}
; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black
; 1494 : 			}
; 1495 : 
; 1496 : 		this->_Getal().destroy(
; 1497 : 			_STD addressof(this->_Myval(_Erasednode)));	// delete erased node
; 1498 : 
; 1499 : 		this->_Getal().deallocate(_Erasednode, 1);
; 1500 : 
; 1501 : 		if (0 < this->_Mysize)
; 1502 : 			--this->_Mysize;
; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator
; 1505 : 		}
; 1506 : 
; 1507 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1508 : 		{	// erase [_First, _Last)
; 1509 : 		if (_First == begin() && _Last == end())
; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());
; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)
; 1517 : 				erase(_First++);
; 1518 : 			return (iterator(_First._Ptr, this));
; 1519 : 			}
; 1520 : 		}
; 1521 : 
; 1522 : 	size_type erase(const key_type& _Keyval)
; 1523 : 		{	// erase and count all that match _Keyval
; 1524 : 		_Pairii _Where = equal_range(_Keyval);
; 1525 : 		size_type _Num = 0;
; 1526 : 		_Distance(_Where.first, _Where.second, _Num);
; 1527 : 		erase(_Where.first, _Where.second);
; 1528 : 		return (_Num);
; 1529 : 		}
; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;
; 1539 : 		_Lmost() = this->_Myhead;
; 1540 : 		_Rmost() = this->_Myhead;
; 1541 : 		this->_Mysize = 0;
; 1542 : 		}
; 1543 : 
; 1544 : 	iterator find(const key_type& _Keyval)
; 1545 : 		{	// find an element in mutable sequence that matches _Keyval
; 1546 : 		iterator _Where = lower_bound(_Keyval);
; 1547 : 		return (_Where == end()
; 1548 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1549 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1550 : 					? end() : _Where);
; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));
; 1593 : 		}
; 1594 : 
; 1595 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1596 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1597 : 		return (_Eqrange(_Keyval));
; 1598 : 		}
; 1599 : 
; 1600 : 	void swap(_Myt& _Right)
; 1601 : 		{	// exchange contents with _Right
; 1602 : 		if (this == &_Right)
; 1603 : 			;	// same object, do nothing
; 1604 : 		else if (this->_Getal() == _Right._Getal())
; 1605 : 			{	// same allocator, swap control information
; 1606 : 			this->_Swap_all(_Right);
; 1607 : 			this->_Swapcomp(_Right._Getcomp());
; 1608 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1609 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1610 : 			}
; 1611 : 
; 1612 :  #if _HAS_CPP0X
; 1613 : 		else if (_Alty::propagate_on_container_swap::value)
; 1614 : 			{	// swap allocators and control information
; 1615 : 			this->_Swap_alloc(_Right);
; 1616 : 			this->_Swapcomp(_Right._Getcomp());
; 1617 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1618 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1619 : 			}
; 1620 :  #endif /* _HAS_CPP0X */
; 1621 : 
; 1622 : 		else
; 1623 : 			{	// different allocator, do multiple copies
; 1624 : 			_Myt _Temp(this->_Getcomp(), get_allocator());
; 1625 : 			_Temp._Copy(*this, true_type());
; 1626 : 
; 1627 : 			this->_Setcomp(_Right._Getcomp());
; 1628 : 			clear();
; 1629 : 			_Copy(_Right, true_type());
; 1630 : 
; 1631 : 			_Right._Setcomp(_Temp._Getcomp());
; 1632 : 			_Right.clear();
; 1633 : 			_Right._Copy(_Temp, true_type());
; 1634 : 			}
; 1635 : 		}
; 1636 : 
; 1637 : protected:
; 1638 : 	template<class _Valty>
; 1639 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Valty>
; 1645 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1646 : 		{	// node doesn't exist, make it
; 1647 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1648 : 		}
; 1649 : 
; 1650 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1651 : 		{	// node exists, destroy it
; 1652 : 		this->_Getal().destroy(
; 1653 : 			_STD addressof(this->_Myval(_Newnode)));
; 1654 : 
; 1655 : 		this->_Getal().deallocate(_Newnode, 1);
; 1656 : 		}
; 1657 : 
; 1658 : 	void _Destroy_if_not_nil(_Nil)
; 1659 : 		{	// node doesn't exist, do nothing
; 1660 : 		}
; 1661 : 
; 1662 : 	template<class _Valty,
; 1663 : 		class _Nodety>
; 1664 : 		iterator _Insert_hint(const_iterator _Where,
; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN
; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)
; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())
; 1729 : 				{	// insert at beginning if before first element
; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1734 : 				}
; 1735 : 			else if (_Where == end())
; 1736 : 				{	// insert at end if after last element
; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1741 : 				}
; 1742 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1743 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1754 : 				}
; 1755 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1757 : 				&& (++(_Next = _Where) == end()
; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);
; 1771 : 		_RERAISE;
; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1776 : 		}
; 1777 : 
; 1778 : 	template<class _Valty,
; 1779 : 		class _Nodety>
; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN
; 1784 : 		_Nodeptr _Trynode = _Root();
; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))
; 1789 : 			{	// look for leaf to insert before (_Addleft) or after
; 1790 : 			_Wherenode = _Trynode;
; 1791 : 			if (_Leftish)
; 1792 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1793 : 					this->_Key(_Trynode),
; 1794 : 					this->_Kfn(_Val));	// favor left end
; 1795 : 			else
; 1796 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1797 : 					this->_Kfn(_Val),
; 1798 : 					this->_Key(_Trynode));	// favor right end
; 1799 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1800 : 				: this->_Right(_Trynode);
; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)
; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())
; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1813 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1814 : 			else
; 1815 : 				--_Where;	// need to test if insert before is okay
; 1816 : 
; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1821 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1822 : 			else
; 1823 : 				{	// duplicate, don't insert
; 1824 : 				_Destroy_if_not_nil(_Newnode);
; 1825 : 				return (_Pairib(_Where, false));
; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);
; 1830 : 		_RERAISE;
; 1831 : 		_CATCH_END
; 1832 : 		}
; 1833 : 
; 1834 : 	template<class _Valty,
; 1835 : 		class _Nodety>
; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)
; 1840 : 			{	// tree would get too big, fail
; 1841 : 			_Destroy_if_not_nil(_Node);
; 1842 : 			_Xlength_error("map/set<T> too long");
; 1843 : 			}
; 1844 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1845 : 			_STD forward<_Valty>(_Val));
; 1846 : 
; 1847 : 		++this->_Mysize;
; 1848 : 		_Newnode->_Parent = _Wherenode;
; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)
; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;
; 1853 : 			_Lmost() = _Newnode;
; 1854 : 			_Rmost() = _Newnode;
; 1855 : 			}
; 1856 : 		else if (_Addleft)
; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;
; 1859 : 			if (_Wherenode == _Lmost())
; 1860 : 				_Lmost() = _Newnode;
; 1861 : 			}
; 1862 : 		else
; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;
; 1865 : 			if (_Wherenode == _Rmost())
; 1866 : 				_Rmost() = _Newnode;
; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1879 : 					this->_Color(_Wherenode) = this->_Black;
; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;
; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1883 : 					}
; 1884 : 				else
; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);
; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up
; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;
; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1896 : 					}
; 1897 : 				}
; 1898 : 			else
; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1905 : 					this->_Color(_Wherenode) = this->_Black;
; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;
; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1909 : 					}
; 1910 : 				else
; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);
; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up
; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;
; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1926 : 		return (iterator(_Newnode, this));
; 1927 : 		}
; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();
; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))
; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;
; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate
; 2105 : 		}
; 2106 : 
; 2107 : 	_Nodeptr& _Lmost() const
; 2108 : 		{	// return leftmost node in nonmutable tree
; 2109 : 		return (this->_Left(this->_Myhead));
; 2110 : 		}
; 2111 : 
; 2112 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2113 : 		{	// promote right node to root of subtree
; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);
; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);
; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))
; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2120 : 
; 2121 : 		if (_Wherenode == _Root())
; 2122 : 			_Root() = _Pnode;
; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2125 : 		else
; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;
; 2129 : 		this->_Parent(_Wherenode) = _Pnode;
; 2130 : 		}
; 2131 : 
; 2132 : 	_Nodeptr& _Rmost() const
; 2133 : 		{	// return rightmost node in nonmutable tree
; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}
; 2136 : 
; 2137 : 	_Nodeptr& _Root() const
; 2138 : 		{	// return root of nonmutable tree
; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}
; 2141 : 
; 2142 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2143 : 		{	// promote left node to root of subtree
; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);
; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);
; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))
; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);
; 2150 : 
; 2151 : 		if (_Wherenode == _Root())
; 2152 : 			_Root() = _Pnode;
; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
; 2155 : 		else
; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;
; 2159 : 		this->_Parent(_Wherenode) = _Pnode;
; 2160 : 		}
; 2161 : 
; 2162 : 	_Nodeptr _Ubound(const key_type& _Keyval) const
; 2163 : 		{	// find leftmost node greater than _Keyval
; 2164 : 		_Nodeptr _Pnode = _Root();
; 2165 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2166 : 
; 2167 : 		while (!this->_Isnil(_Pnode))
; 2168 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2169 : 				{	// _Pnode greater than _Keyval, remember it
; 2170 : 				_Wherenode = _Pnode;
; 2171 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2172 : 				}
; 2173 : 			else
; 2174 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2175 : 
; 2176 : 		return (_Wherenode);	// return best remembered candidate
; 2177 : 		}
; 2178 : 
; 2179 : 	_Nodeptr _Ubound(const key_type& _Keyval)
; 2180 : 		{	// find leftmost node greater than _Keyval
; 2181 : 		_Nodeptr _Pnode = _Root();
; 2182 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2183 : 
; 2184 : 		while (!this->_Isnil(_Pnode))
; 2185 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2186 : 				{	// _Pnode greater than _Keyval, remember it
; 2187 : 				_Wherenode = _Pnode;
; 2188 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2189 : 				}
; 2190 : 			else
; 2191 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2192 : 
; 2193 : 		return (_Wherenode);	// return best remembered candidate
; 2194 : 		}
; 2195 : 
; 2196 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2197 : 	void _Orphan_ptr(_Myt& _Cont, _Nodeptr _Ptr) const
; 2198 : 		{	// orphan iterators with specified node pointers
; 2199 : 		_Lockit _Lock(_LOCK_DEBUG);
; 2200 : 		const_iterator **_Pnext = (const_iterator **)_Cont._Getpfirst();
; 2201 : 		if (_Pnext != 0)
; 2202 : 			while (*_Pnext != 0)
; 2203 : 				if ((*_Pnext)->_Ptr == this->_Myhead
; 2204 : 					|| _Ptr != 0 && (*_Pnext)->_Ptr != _Ptr)
; 2205 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
; 2206 : 				else
; 2207 : 					{	// orphan the iterator
; 2208 : 					(*_Pnext)->_Clrcont();
; 2209 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
; 2210 : 					}
; 2211 : 		}
; 2212 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2213 : 
; 2214 : 	void _Tidy()
; 2215 : 		{	// free all storage
; 2216 : 		erase(begin(), end());

  00011	4d 8b c8	 mov	 r9, r8
  00014	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00017	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0001c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1190 : 		}

  0001f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00023	5b		 pop	 rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00024	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
$T2 = 80
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT

; 1523 : 		{	// erase and count all that match _Keyval

$LN77:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;
; 1539 : 		_Lmost() = this->_Myhead;
; 1540 : 		_Rmost() = this->_Myhead;
; 1541 : 		this->_Mysize = 0;
; 1542 : 		}
; 1543 : 
; 1544 : 	iterator find(const key_type& _Keyval)
; 1545 : 		{	// find an element in mutable sequence that matches _Keyval
; 1546 : 		iterator _Where = lower_bound(_Keyval);
; 1547 : 		return (_Where == end()
; 1548 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1549 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1550 : 					? end() : _Where);
; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));

  0000a	4c 8b c2	 mov	 r8, rdx
  0000d	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]

; 1523 : 		{	// erase and count all that match _Keyval

  00012	48 8b f9	 mov	 rdi, rcx

; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());
; 1538 : 		_Root() = this->_Myhead;
; 1539 : 		_Lmost() = this->_Myhead;
; 1540 : 		_Rmost() = this->_Myhead;
; 1541 : 		this->_Mysize = 0;
; 1542 : 		}
; 1543 : 
; 1544 : 	iterator find(const key_type& _Keyval)
; 1545 : 		{	// find an element in mutable sequence that matches _Keyval
; 1546 : 		iterator _Where = lower_bound(_Keyval);
; 1547 : 		return (_Where == end()
; 1548 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1549 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1550 : 					? end() : _Where);
; 1551 : 		}
; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));

  00015	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange

; 1524 : 		_Pairii _Where = equal_range(_Keyval);
; 1525 : 		size_type _Num = 0;

  0001a	33 db		 xor	 ebx, ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0001c	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0001f	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00023	49 8b c0	 mov	 rax, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00026	4d 3b c1	 cmp	 r8, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00029	74 58		 je	 SHORT $LN21@erase
  0002b	0f 1f 44 00 00	 npad	 5
$LL32@erase:

; 799  : 		++_Off;

  00030	48 ff c3	 inc	 rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00033	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00037	75 45		 jne	 SHORT $LN71@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00039	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0003d	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00041	75 1b		 jne	 SHORT $LN68@erase

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00043	48 8b c1	 mov	 rax, rcx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00046	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00049	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0004d	75 2f		 jne	 SHORT $LN71@erase
  0004f	90		 npad	 1
$LL47@erase:

; 621  : 			_Pnode = _Left(_Pnode);

  00050	48 8b c1	 mov	 rax, rcx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00053	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00056	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0005a	74 f4		 je	 SHORT $LL47@erase

; 65   : 		else

  0005c	eb 20		 jmp	 SHORT $LN71@erase
$LN68@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0005e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00062	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00066	75 13		 jne	 SHORT $LN75@erase
$LL31@erase:
  00068	48 3b 41 10	 cmp	 rax, QWORD PTR [rcx+16]
  0006c	75 0d		 jne	 SHORT $LN75@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0006e	48 8b c1	 mov	 rax, rcx
  00071	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00075	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00079	74 ed		 je	 SHORT $LL31@erase
$LN75@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0007b	48 8b c1	 mov	 rax, rcx
$LN71@erase:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0007e	49 3b c1	 cmp	 rax, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00081	75 ad		 jne	 SHORT $LL32@erase
$LN21@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1527 : 		erase(_Where.first, _Where.second);

  00083	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00088	48 8b cf	 mov	 rcx, rdi
  0008b	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase

; 1528 : 		return (_Num);

  00090	48 8b c3	 mov	 rax, rbx

; 1529 : 		}

  00093	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00098	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = 8
$T2 = 8
this$ = 8
__$ReturnUdt$ = 16
_Keyval$ = 24
?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find, COMDAT

; 1545 : 		{	// find an element in mutable sequence that matches _Keyval

$LN101:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00005	4c 8b 19	 mov	 r11, QWORD PTR [rcx]

; 1545 : 		{	// find an element in mutable sequence that matches _Keyval

  00008	48 8b da	 mov	 rbx, rdx

; 1552 : 
; 1553 : 	const_iterator find(const key_type& _Keyval) const
; 1554 : 		{	// find an element in nonmutable sequence that matches _Keyval
; 1555 : 		const_iterator _Where = lower_bound(_Keyval);
; 1556 : 		return (_Where == end()
; 1557 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1558 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1559 : 					? end() : _Where);
; 1560 : 		}
; 1561 : 
; 1562 : 	size_type count(const key_type& _Keyval) const
; 1563 : 		{	// count all elements that match _Keyval
; 1564 : 		_Paircc _Ans = equal_range(_Keyval);
; 1565 : 		size_type _Num = 0;
; 1566 : 		_Distance(_Ans.first, _Ans.second, _Num);
; 1567 : 		return (_Num);
; 1568 : 		}
; 1569 : 
; 1570 : 	iterator lower_bound(const key_type& _Keyval)
; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree
; 1572 : 		return (iterator(_Lbound(_Keyval), this));
; 1573 : 		}
; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));
; 1593 : 		}
; 1594 : 
; 1595 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1596 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1597 : 		return (_Eqrange(_Keyval));
; 1598 : 		}
; 1599 : 
; 1600 : 	void swap(_Myt& _Right)
; 1601 : 		{	// exchange contents with _Right
; 1602 : 		if (this == &_Right)
; 1603 : 			;	// same object, do nothing
; 1604 : 		else if (this->_Getal() == _Right._Getal())
; 1605 : 			{	// same allocator, swap control information
; 1606 : 			this->_Swap_all(_Right);
; 1607 : 			this->_Swapcomp(_Right._Getcomp());
; 1608 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1609 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1610 : 			}
; 1611 : 
; 1612 :  #if _HAS_CPP0X
; 1613 : 		else if (_Alty::propagate_on_container_swap::value)
; 1614 : 			{	// swap allocators and control information
; 1615 : 			this->_Swap_alloc(_Right);
; 1616 : 			this->_Swapcomp(_Right._Getcomp());
; 1617 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1618 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1619 : 			}
; 1620 :  #endif /* _HAS_CPP0X */
; 1621 : 
; 1622 : 		else
; 1623 : 			{	// different allocator, do multiple copies
; 1624 : 			_Myt _Temp(this->_Getcomp(), get_allocator());
; 1625 : 			_Temp._Copy(*this, true_type());
; 1626 : 
; 1627 : 			this->_Setcomp(_Right._Getcomp());
; 1628 : 			clear();
; 1629 : 			_Copy(_Right, true_type());
; 1630 : 
; 1631 : 			_Right._Setcomp(_Temp._Getcomp());
; 1632 : 			_Right.clear();
; 1633 : 			_Right._Copy(_Temp, true_type());
; 1634 : 			}
; 1635 : 		}
; 1636 : 
; 1637 : protected:
; 1638 : 	template<class _Valty>
; 1639 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Valty>
; 1645 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1646 : 		{	// node doesn't exist, make it
; 1647 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1648 : 		}
; 1649 : 
; 1650 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1651 : 		{	// node exists, destroy it
; 1652 : 		this->_Getal().destroy(
; 1653 : 			_STD addressof(this->_Myval(_Newnode)));
; 1654 : 
; 1655 : 		this->_Getal().deallocate(_Newnode, 1);
; 1656 : 		}
; 1657 : 
; 1658 : 	void _Destroy_if_not_nil(_Nil)
; 1659 : 		{	// node doesn't exist, do nothing
; 1660 : 		}
; 1661 : 
; 1662 : 	template<class _Valty,
; 1663 : 		class _Nodety>
; 1664 : 		iterator _Insert_hint(const_iterator _Where,
; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN
; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)
; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())
; 1729 : 				{	// insert at beginning if before first element
; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1734 : 				}
; 1735 : 			else if (_Where == end())
; 1736 : 				{	// insert at end if after last element
; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1741 : 				}
; 1742 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1743 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1754 : 				}
; 1755 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1757 : 				&& (++(_Next = _Where) == end()
; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);
; 1771 : 		_RERAISE;
; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1776 : 		}
; 1777 : 
; 1778 : 	template<class _Valty,
; 1779 : 		class _Nodety>
; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN
; 1784 : 		_Nodeptr _Trynode = _Root();
; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))
; 1789 : 			{	// look for leaf to insert before (_Addleft) or after
; 1790 : 			_Wherenode = _Trynode;
; 1791 : 			if (_Leftish)
; 1792 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1793 : 					this->_Key(_Trynode),
; 1794 : 					this->_Kfn(_Val));	// favor left end
; 1795 : 			else
; 1796 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1797 : 					this->_Kfn(_Val),
; 1798 : 					this->_Key(_Trynode));	// favor right end
; 1799 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1800 : 				: this->_Right(_Trynode);
; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)
; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())
; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1813 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1814 : 			else
; 1815 : 				--_Where;	// need to test if insert before is okay
; 1816 : 
; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1821 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1822 : 			else
; 1823 : 				{	// duplicate, don't insert
; 1824 : 				_Destroy_if_not_nil(_Newnode);
; 1825 : 				return (_Pairib(_Where, false));
; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);
; 1830 : 		_RERAISE;
; 1831 : 		_CATCH_END
; 1832 : 		}
; 1833 : 
; 1834 : 	template<class _Valty,
; 1835 : 		class _Nodety>
; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)
; 1840 : 			{	// tree would get too big, fail
; 1841 : 			_Destroy_if_not_nil(_Node);
; 1842 : 			_Xlength_error("map/set<T> too long");
; 1843 : 			}
; 1844 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1845 : 			_STD forward<_Valty>(_Val));
; 1846 : 
; 1847 : 		++this->_Mysize;
; 1848 : 		_Newnode->_Parent = _Wherenode;
; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)
; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;
; 1853 : 			_Lmost() = _Newnode;
; 1854 : 			_Rmost() = _Newnode;
; 1855 : 			}
; 1856 : 		else if (_Addleft)
; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;
; 1859 : 			if (_Wherenode == _Lmost())
; 1860 : 				_Lmost() = _Newnode;
; 1861 : 			}
; 1862 : 		else
; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;
; 1865 : 			if (_Wherenode == _Rmost())
; 1866 : 				_Rmost() = _Newnode;
; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1879 : 					this->_Color(_Wherenode) = this->_Black;
; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;
; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1883 : 					}
; 1884 : 				else
; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);
; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up
; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;
; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1896 : 					}
; 1897 : 				}
; 1898 : 			else
; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1905 : 					this->_Color(_Wherenode) = this->_Black;
; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;
; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1909 : 					}
; 1910 : 				else
; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);
; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up
; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;
; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1926 : 		return (iterator(_Newnode, this));
; 1927 : 		}
; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();

  0000b	49 8b 43 08	 mov	 rax, QWORD PTR [r11+8]

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails

  0000f	4d 8b cb	 mov	 r9, r11

; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00012	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00016	75 3f		 jne	 SHORT $LN9@find
  00018	45 8b 10	 mov	 r10d, DWORD PTR [r8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL10@find:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00020	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00023	41 3b ca	 cmp	 ecx, r10d
  00026	7c 25		 jl	 SHORT $LN97@find

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00028	75 1b		 jne	 SHORT $LN8@find

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0002a	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  0002d	41 8b 50 04	 mov	 edx, DWORD PTR [r8+4]
  00031	3b ca		 cmp	 ecx, edx
  00033	7c 18		 jl	 SHORT $LN97@find

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00035	75 0e		 jne	 SHORT $LN8@find

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00037	41 8b 48 08	 mov	 ecx, DWORD PTR [r8+8]
  0003b	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  0003e	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00041	84 c9		 test	 cl, cl
  00043	75 08		 jne	 SHORT $LN97@find
$LN8@find:

; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;

  00045	4c 8b c8	 mov	 r9, rax

; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00048	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004b	eb 04		 jmp	 SHORT $LN7@find
$LN97@find:

; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  0004d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN7@find:

; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00051	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00055	74 c9		 je	 SHORT $LL10@find
$LN9@find:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00057	4d 3b cb	 cmp	 r9, r11

; 1550 : 					? end() : _Where);

  0005a	74 43		 je	 SHORT $LN3@find
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  0005c	41 8b 00	 mov	 eax, DWORD PTR [r8]
  0005f	41 8b 49 20	 mov	 ecx, DWORD PTR [r9+32]
  00063	3b c1		 cmp	 eax, ecx
  00065	7c 38		 jl	 SHORT $LN3@find

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00067	75 1d		 jne	 SHORT $LN98@find

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  00069	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  0006d	41 8b 49 24	 mov	 ecx, DWORD PTR [r9+36]
  00071	3b c1		 cmp	 eax, ecx
  00073	7c 2a		 jl	 SHORT $LN3@find

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00075	75 0f		 jne	 SHORT $LN98@find

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00077	41 8b 41 28	 mov	 eax, DWORD PTR [r9+40]
  0007b	41 39 40 08	 cmp	 DWORD PTR [r8+8], eax
  0007f	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1550 : 					? end() : _Where);

  00082	84 c0		 test	 al, al
  00084	75 19		 jne	 SHORT $LN3@find
$LN98@find:
  00086	48 8d 44 24 08	 lea	 rax, QWORD PTR $T2[rsp]
  0008b	4c 89 4c 24 08	 mov	 QWORD PTR $T1[rsp], r9
  00090	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00093	48 89 03	 mov	 QWORD PTR [rbx], rax
  00096	48 8b c3	 mov	 rax, rbx

; 1551 : 		}

  00099	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]
  0009e	c3		 ret	 0
$LN3@find:

; 1550 : 					? end() : _Where);

  0009f	48 8d 44 24 08	 lea	 rax, QWORD PTR $T2[rsp]

; 44   : 		{	// construct with node pointer _Pnode

  000a4	4c 89 5c 24 08	 mov	 QWORD PTR $T2[rsp], r11

; 1550 : 					? end() : _Where);

  000a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ac	48 89 03	 mov	 QWORD PTR [rbx], rax
  000af	48 8b c3	 mov	 rax, rbx

; 1551 : 		}

  000b2	48 8b 5c 24 10	 mov	 rbx, QWORD PTR [rsp+16]
  000b7	c3		 ret	 0
?find@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::shared_ptr<ChunkBase>::operator=, COMDAT

; 627  : 		{	// assign shared ownership of resource owned by _Right

$LN59:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 627  : 		{	// assign shared ownership of resource owned by _Right

  0000d	48 8b f9	 mov	 rdi, rcx

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00010	48 85 c0	 test	 rax, rax
  00013	74 04		 je	 SHORT $LN20@operator

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00015	f0 ff 40 08	 lock inc DWORD PTR [rax+8]
$LN20@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00019	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]

; 49   : 	_Right = _Move(_Tmp);

  0001d	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  00021	4c 89 07	 mov	 QWORD PTR [rdi], r8

; 48   : 	_Left = _Move(_Right);

  00024	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp+8], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00029	48 85 c9	 test	 rcx, rcx
  0002c	74 41		 je	 SHORT $LN56@operator

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0002e	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00032	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00037	75 28		 jne	 SHORT $LN55@operator
  00039	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003e	48 8b 5c 24 28	 mov	 rbx, QWORD PTR $T1[rsp+8]
  00043	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0004b	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00054	75 0b		 jne	 SHORT $LN55@operator

; 128  : 			_Delete_this();

  00056	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp+8]
  0005b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0005e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN55@operator:

; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);

  00061	48 8b c7	 mov	 rax, rdi
  00064	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 630  : 		}

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN56@operator:

; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);

  0006f	48 8b c7	 mov	 rax, rdi

; 630  : 		}

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::shared_ptr<ChunkBase>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??B?$shared_ptr@VChunkBase@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VChunkBase@@@std@@@1@HXZ
_TEXT	SEGMENT
this$ = 8
??B?$shared_ptr@VChunkBase@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VChunkBase@@@std@@@1@HXZ PROC ; std::shared_ptr<ChunkBase>::operator int std::_Bool_struct<std::shared_ptr<ChunkBase> >::* __ptr64, COMDAT

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 f7 d8	 neg	 rax
  00006	1b c0		 sbb	 eax, eax
  00008	f7 d8		 neg	 eax
  0000a	ff c8		 dec	 eax

; 704  : 		}

  0000c	c3		 ret	 0
??B?$shared_ptr@VChunkBase@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VChunkBase@@@std@@@1@HXZ ENDP ; std::shared_ptr<ChunkBase>::operator int std::_Bool_struct<std::shared_ptr<ChunkBase> >::* __ptr64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->, COMDAT

; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 20	 add	 rax, 32			; 00000020H

; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}

  00007	c3		 ret	 0
??C?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ PROC ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >, COMDAT
$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 18	 mov	 rbx, QWORD PTR [rcx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN11@pair

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN14@pair

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN14@pair

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN14@pair:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN11@pair:
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ENDP ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??1?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Parg$dead$ = 56
_Al$dead$ = 64
??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT

; 1071 : 		{	// construct empty tree

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 573  : 		this->_Myhead = 0;

  00006	33 c0		 xor	 eax, eax

; 1071 : 		{	// construct empty tree

  00008	48 8b d9	 mov	 rbx, rcx

; 573  : 		this->_Myhead = 0;

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 574  : 		this->_Mysize = 0;

  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00012	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00017	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1072 : 		}

  0001a	48 8b c3	 mov	 rax, rbx
  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??0?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
__$ReturnUdt$ = 56
_First$ = 64
_Last$ = 72
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT

; 1508 : 		{	// erase [_First, _Last)

$LN127:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b fa	 mov	 rdi, rdx

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00017	48 8b 11	 mov	 rdx, QWORD PTR [rcx]

; 1508 : 		{	// erase [_First, _Last)

  0001a	48 8b d9	 mov	 rbx, rcx

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0001d	4c 3b 02	 cmp	 r8, QWORD PTR [rdx]

; 1509 : 		if (_First == begin() && _Last == end())

  00020	75 41		 jne	 SHORT $LN115@erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00022	4c 3b ca	 cmp	 r9, rdx

; 1509 : 		if (_First == begin() && _Last == end())

  00025	75 3c		 jne	 SHORT $LN115@erase

; 1521 : 
; 1522 : 	size_type erase(const key_type& _Keyval)
; 1523 : 		{	// erase and count all that match _Keyval
; 1524 : 		_Pairii _Where = equal_range(_Keyval);
; 1525 : 		size_type _Num = 0;
; 1526 : 		_Distance(_Where.first, _Where.second, _Num);
; 1527 : 		erase(_Where.first, _Where.second);
; 1528 : 		return (_Num);
; 1529 : 		}
; 1530 : 
; 1531 : 	void clear() _NOEXCEPT
; 1532 : 		{	// erase all
; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());

  00027	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0002b	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00030	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1538 : 		_Root() = this->_Myhead;

  00033	48 89 40 08	 mov	 QWORD PTR [rax+8], rax

; 1539 : 		_Lmost() = this->_Myhead;

  00037	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003a	48 89 00	 mov	 QWORD PTR [rax], rax

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  0003d	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1540 : 		_Rmost() = this->_Myhead;

  00040	48 89 40 10	 mov	 QWORD PTR [rax+16], rax

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00044	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1541 : 		this->_Mysize = 0;

  00047	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0

; 44   : 		{	// construct with node pointer _Pnode

  0004f	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 1518 : 			return (iterator(_First._Ptr, this));

  00052	48 8b c7	 mov	 rax, rdi

; 44   : 		{	// construct with node pointer _Pnode

  00055	48 89 0f	 mov	 QWORD PTR [rdi], rcx

; 1519 : 			}
; 1520 : 		}

  00058	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN115@erase:

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00063	4d 3b c1	 cmp	 r8, r9

; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());
; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)

  00066	0f 84 7d 00 00
	00		 je	 $LN1@erase
  0006c	0f 1f 40 00	 npad	 4
$LL2@erase:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00070	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;

  00075	49 8b c0	 mov	 rax, r8

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00078	75 53		 jne	 SHORT $LN77@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0007a	49 8b 50 10	 mov	 rdx, QWORD PTR [r8+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0007e	80 7a 19 00	 cmp	 BYTE PTR [rdx+25], 0
  00082	75 1f		 jne	 SHORT $LN117@erase

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00084	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00087	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0008b	75 0f		 jne	 SHORT $LN91@erase
  0008d	0f 1f 00	 npad	 3
$LL92@erase:

; 621  : 			_Pnode = _Left(_Pnode);

  00090	48 8b d1	 mov	 rdx, rcx

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00093	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00096	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0009a	74 f4		 je	 SHORT $LL92@erase
$LN91@erase:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0009c	48 89 54 24 40	 mov	 QWORD PTR _First$[rsp], rdx

; 65   : 		else

  000a1	eb 2a		 jmp	 SHORT $LN77@erase
$LN117@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  000a3	49 8b 48 08	 mov	 rcx, QWORD PTR [r8+8]
  000a7	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  000ab	75 1b		 jne	 SHORT $LN124@erase
  000ad	0f 1f 00	 npad	 3
$LL76@erase:
  000b0	4c 3b 41 10	 cmp	 r8, QWORD PTR [rcx+16]
  000b4	75 12		 jne	 SHORT $LN124@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  000b6	48 89 4c 24 40	 mov	 QWORD PTR _First$[rsp], rcx
  000bb	4c 8b c1	 mov	 r8, rcx
  000be	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000c2	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  000c6	74 e8		 je	 SHORT $LL76@erase
$LN124@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  000c8	48 89 4c 24 40	 mov	 QWORD PTR _First$[rsp], rcx
$LN77@erase:

; 1517 : 				erase(_First++);

  000cd	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  000d2	4c 8b c0	 mov	 r8, rax
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase

; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000dd	4c 8b 44 24 40	 mov	 r8, QWORD PTR _First$[rsp]
  000e2	4c 3b 44 24 48	 cmp	 r8, QWORD PTR _Last$[rsp]

; 1510 : 			{	// erase all
; 1511 : 			clear();
; 1512 : 			return (begin());
; 1513 : 			}
; 1514 : 		else
; 1515 : 			{	// partial erase, one at a time
; 1516 : 			while (_First != _Last)

  000e7	75 87		 jne	 SHORT $LL2@erase
$LN1@erase:

; 1519 : 			}
; 1520 : 		}

  000e9	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]

; 44   : 		{	// construct with node pointer _Pnode

  000ee	4c 89 07	 mov	 QWORD PTR [rdi], r8

; 1518 : 			return (iterator(_First._Ptr, this));

  000f1	48 8b c7	 mov	 rax, rdi

; 1519 : 			}
; 1520 : 		}

  000f4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f8	5f		 pop	 rdi
  000f9	c3		 ret	 0
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Keyval$ = 24
?lower_bound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound, COMDAT

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	4c 8b 09	 mov	 r9, QWORD PTR [rcx]

; 1571 : 		{	// find leftmost node not less than _Keyval in mutable tree

  00003	4c 8b da	 mov	 r11, rdx

; 1574 : 
; 1575 : 	const_iterator lower_bound(const key_type& _Keyval) const
; 1576 : 		{	// find leftmost node not less than _Keyval in nonmutable tree
; 1577 : 		return (const_iterator(_Lbound(_Keyval), this));
; 1578 : 		}
; 1579 : 
; 1580 : 	iterator upper_bound(const key_type& _Keyval)
; 1581 : 		{	// find leftmost node greater than _Keyval in mutable tree
; 1582 : 		return (iterator(_Ubound(_Keyval), this));
; 1583 : 		}
; 1584 : 
; 1585 : 	const_iterator upper_bound(const key_type& _Keyval) const
; 1586 : 		{	// find leftmost node greater than _Keyval in nonmutable tree
; 1587 : 		return (const_iterator(_Ubound(_Keyval), this));
; 1588 : 		}
; 1589 : 
; 1590 : 	_Pairii equal_range(const key_type& _Keyval)
; 1591 : 		{	// find range equivalent to _Keyval in mutable tree
; 1592 : 		return (_Eqrange(_Keyval));
; 1593 : 		}
; 1594 : 
; 1595 : 	_Paircc equal_range(const key_type& _Keyval) const
; 1596 : 		{	// find range equivalent to _Keyval in nonmutable tree
; 1597 : 		return (_Eqrange(_Keyval));
; 1598 : 		}
; 1599 : 
; 1600 : 	void swap(_Myt& _Right)
; 1601 : 		{	// exchange contents with _Right
; 1602 : 		if (this == &_Right)
; 1603 : 			;	// same object, do nothing
; 1604 : 		else if (this->_Getal() == _Right._Getal())
; 1605 : 			{	// same allocator, swap control information
; 1606 : 			this->_Swap_all(_Right);
; 1607 : 			this->_Swapcomp(_Right._Getcomp());
; 1608 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1609 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1610 : 			}
; 1611 : 
; 1612 :  #if _HAS_CPP0X
; 1613 : 		else if (_Alty::propagate_on_container_swap::value)
; 1614 : 			{	// swap allocators and control information
; 1615 : 			this->_Swap_alloc(_Right);
; 1616 : 			this->_Swapcomp(_Right._Getcomp());
; 1617 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1618 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1619 : 			}
; 1620 :  #endif /* _HAS_CPP0X */
; 1621 : 
; 1622 : 		else
; 1623 : 			{	// different allocator, do multiple copies
; 1624 : 			_Myt _Temp(this->_Getcomp(), get_allocator());
; 1625 : 			_Temp._Copy(*this, true_type());
; 1626 : 
; 1627 : 			this->_Setcomp(_Right._Getcomp());
; 1628 : 			clear();
; 1629 : 			_Copy(_Right, true_type());
; 1630 : 
; 1631 : 			_Right._Setcomp(_Temp._Getcomp());
; 1632 : 			_Right.clear();
; 1633 : 			_Right._Copy(_Temp, true_type());
; 1634 : 			}
; 1635 : 		}
; 1636 : 
; 1637 : protected:
; 1638 : 	template<class _Valty>
; 1639 : 		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);
; 1642 : 		}
; 1643 : 
; 1644 : 	template<class _Valty>
; 1645 : 		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
; 1646 : 		{	// node doesn't exist, make it
; 1647 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));
; 1648 : 		}
; 1649 : 
; 1650 : 	void _Destroy_if_not_nil(_Nodeptr _Newnode)
; 1651 : 		{	// node exists, destroy it
; 1652 : 		this->_Getal().destroy(
; 1653 : 			_STD addressof(this->_Myval(_Newnode)));
; 1654 : 
; 1655 : 		this->_Getal().deallocate(_Newnode, 1);
; 1656 : 		}
; 1657 : 
; 1658 : 	void _Destroy_if_not_nil(_Nil)
; 1659 : 		{	// node doesn't exist, do nothing
; 1660 : 		}
; 1661 : 
; 1662 : 	template<class _Valty,
; 1663 : 		class _Nodety>
; 1664 : 		iterator _Insert_hint(const_iterator _Where,
; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN
; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)
; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree
; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())
; 1729 : 				{	// insert at beginning if before first element
; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1734 : 				}
; 1735 : 			else if (_Where == end())
; 1736 : 				{	// insert at end if after last element
; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1741 : 				}
; 1742 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1743 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),
; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1754 : 				}
; 1755 : 			else if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1756 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1757 : 				&& (++(_Next = _Where) == end()
; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);
; 1771 : 		_RERAISE;
; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);
; 1776 : 		}
; 1777 : 
; 1778 : 	template<class _Valty,
; 1779 : 		class _Nodety>
; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,
; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN
; 1784 : 		_Nodeptr _Trynode = _Root();
; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;
; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty
; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))
; 1789 : 			{	// look for leaf to insert before (_Addleft) or after
; 1790 : 			_Wherenode = _Trynode;
; 1791 : 			if (_Leftish)
; 1792 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),
; 1793 : 					this->_Key(_Trynode),
; 1794 : 					this->_Kfn(_Val));	// favor left end
; 1795 : 			else
; 1796 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),
; 1797 : 					this->_Kfn(_Val),
; 1798 : 					this->_Key(_Trynode));	// favor right end
; 1799 : 			_Trynode = _Addleft ? this->_Left(_Trynode)
; 1800 : 				: this->_Right(_Trynode);
; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)
; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())
; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,
; 1813 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1814 : 			else
; 1815 : 				--_Where;	// need to test if insert before is okay
; 1816 : 
; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),
; 1818 : 				this->_Key(_Where._Mynode()),
; 1819 : 				this->_Kfn(_Val)))
; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1821 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1822 : 			else
; 1823 : 				{	// duplicate, don't insert
; 1824 : 				_Destroy_if_not_nil(_Newnode);
; 1825 : 				return (_Pairib(_Where, false));
; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);
; 1830 : 		_RERAISE;
; 1831 : 		_CATCH_END
; 1832 : 		}
; 1833 : 
; 1834 : 	template<class _Valty,
; 1835 : 		class _Nodety>
; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)
; 1840 : 			{	// tree would get too big, fail
; 1841 : 			_Destroy_if_not_nil(_Node);
; 1842 : 			_Xlength_error("map/set<T> too long");
; 1843 : 			}
; 1844 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1845 : 			_STD forward<_Valty>(_Val));
; 1846 : 
; 1847 : 		++this->_Mysize;
; 1848 : 		_Newnode->_Parent = _Wherenode;
; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)
; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;
; 1853 : 			_Lmost() = _Newnode;
; 1854 : 			_Rmost() = _Newnode;
; 1855 : 			}
; 1856 : 		else if (_Addleft)
; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;
; 1859 : 			if (_Wherenode == _Lmost())
; 1860 : 				_Lmost() = _Newnode;
; 1861 : 			}
; 1862 : 		else
; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;
; 1865 : 			if (_Wherenode == _Rmost())
; 1866 : 				_Rmost() = _Newnode;
; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1879 : 					this->_Color(_Wherenode) = this->_Black;
; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;
; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1883 : 					}
; 1884 : 				else
; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);
; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up
; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;
; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
; 1896 : 					}
; 1897 : 				}
; 1898 : 			else
; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)
; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1905 : 					this->_Color(_Wherenode) = this->_Black;
; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;
; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1909 : 					}
; 1910 : 				else
; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);
; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up
; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;
; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black
; 1926 : 		return (iterator(_Newnode, this));
; 1927 : 		}
; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();

  00006	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  0000a	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0000e	75 41		 jne	 SHORT $LN50@lower_boun
  00010	45 8b 10	 mov	 r10d, DWORD PTR [r8]
$LL6@lower_boun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00013	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00016	41 3b ca	 cmp	 ecx, r10d
  00019	7c 25		 jl	 SHORT $LN49@lower_boun

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  0001b	75 1b		 jne	 SHORT $LN4@lower_boun

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0001d	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00020	41 8b 50 04	 mov	 edx, DWORD PTR [r8+4]
  00024	3b ca		 cmp	 ecx, edx
  00026	7c 18		 jl	 SHORT $LN49@lower_boun

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00028	75 0e		 jne	 SHORT $LN4@lower_boun

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0002a	41 8b 48 08	 mov	 ecx, DWORD PTR [r8+8]
  0002e	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00031	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00034	84 c9		 test	 cl, cl
  00036	75 08		 jne	 SHORT $LN49@lower_boun
$LN4@lower_boun:

; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;

  00038	4c 8b c8	 mov	 r9, rax

; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	eb 04		 jmp	 SHORT $LN3@lower_boun
$LN49@lower_boun:

; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00040	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN3@lower_boun:

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00044	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00048	74 c9		 je	 SHORT $LL6@lower_boun

; 44   : 		{	// construct with node pointer _Pnode

  0004a	4d 89 0b	 mov	 QWORD PTR [r11], r9

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  0004d	49 8b c3	 mov	 rax, r11

; 1573 : 		}

  00050	c3		 ret	 0
$LN50@lower_boun:

; 44   : 		{	// construct with node pointer _Pnode

  00051	4c 89 0a	 mov	 QWORD PTR [rdx], r9

; 1572 : 		return (iterator(_Lbound(_Keyval), this));

  00054	49 8b c3	 mov	 rax, r11

; 1573 : 		}

  00057	c3		 ret	 0
?lower_bound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
_Keyval$ = 80
?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range, COMDAT

; 1591 : 		{	// find range equivalent to _Keyval in mutable tree

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b da	 mov	 rbx, rdx

; 1592 : 		return (_Eqrange(_Keyval));

  00009	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  0000e	e8 00 00 00 00	 call	 ?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00013	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00016	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001a	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1592 : 		return (_Eqrange(_Keyval));

  0001e	48 8b c3	 mov	 rax, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00021	48 89 0b	 mov	 QWORD PTR [rbx], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1593 : 		}

  00024	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
?equal_range@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
$T1 = 48
this$ = 48
?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tidy, COMDAT

; 2215 : 		{	// free all storage

$LN28:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2216 : 		erase(begin(), end());

  00004	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00007	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  0000c	4d 8b c8	 mov	 r9, r8
  0000f	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00012	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase

; 2217 : 		}

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
?_Tidy@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEBVChunkPosition@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Pnode$ = 16
?_Key@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEBVChunkPosition@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Key, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 56   : 		return (_Val.first);

  00000	48 8d 42 20	 lea	 rax, QWORD PTR [rdx+32]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2227 : 		}

  00004	c3		 ret	 0
?_Key@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEBVChunkPosition@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??R?$less@VChunkPosition@@@std@@QEBA_NAEBVChunkPosition@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_Left$ = 16
_Right$ = 24
??R?$less@VChunkPosition@@@std@@QEBA_NAEBVChunkPosition@@0@Z PROC ; std::less<ChunkPosition>::operator(), COMDAT
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	41 8b 08	 mov	 ecx, DWORD PTR [r8]
  00005	3b c1		 cmp	 eax, ecx
  00007	7d 03		 jge	 SHORT $LN11@operator
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 180  : 		return (_Left < _Right);

  00009	b0 01		 mov	 al, 1

; 181  : 		}

  0000b	c3		 ret	 0
$LN11@operator:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 291  : 	else if(cp1.x == cp2.x)

  0000c	75 18		 jne	 SHORT $LN3@operator

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0000e	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00011	41 8b 48 04	 mov	 ecx, DWORD PTR [r8+4]
  00015	3b c1		 cmp	 eax, ecx
  00017	7c f0		 jl	 SHORT $LN13@operator

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00019	75 0b		 jne	 SHORT $LN3@operator

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0001b	41 8b 40 08	 mov	 eax, DWORD PTR [r8+8]
  0001f	39 42 08	 cmp	 DWORD PTR [rdx+8], eax
  00022	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 181  : 		}

  00025	c3		 ret	 0
$LN3@operator:

; 180  : 		return (_Left < _Right);

  00026	32 c0		 xor	 al, al

; 181  : 		}

  00028	c3		 ret	 0
??R?$less@VChunkPosition@@@std@@QEBA_NAEBVChunkPosition@@0@Z ENDP ; std::less<ChunkPosition>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AU?$less@VChunkPosition@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AU?$less@VChunkPosition@@@2@XZ PROC ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Getcomp, COMDAT

; 1012 : 		return (key_compare());

  00000	48 8b c2	 mov	 rax, rdx

; 1013 : 		}

  00003	c3		 ret	 0
?_Getcomp@?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AU?$less@VChunkPosition@@@2@XZ ENDP ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$shared_ptr@VChunkBase@@@std@@QEAA@XZ PROC		; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT

; 282  : 		{	// construct

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ENDP		; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?swap@?$shared_ptr@VChunkBase@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
?swap@?$shared_ptr@VChunkBase@@@std@@QEAAXAEAV12@@Z PROC ; std::shared_ptr<ChunkBase>::swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 677  : 		}

  0001c	c3		 ret	 0
?swap@?$shared_ptr@VChunkBase@@@std@@QEAAXAEAV12@@Z ENDP ; std::shared_ptr<ChunkBase>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*, COMDAT

; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 20	 add	 rax, 32			; 00000020H

; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}

  00007	c3		 ret	 0
??D?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode, COMDAT

; 123  : 		return (_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 124  : 		}

  00003	c3		 ret	 0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to, COMDAT

; 233  : 		return (_STD addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 234  : 		}

  00003	c3		 ret	 0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Where$ = 80
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT

; 1323 : 		{	// erase element at _Where

$LN392:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	56		 push	 rsi
  00006	41 57		 push	 r15
  00008	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1324 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1325 : 		if (_Where._Getcont() != this || this->_Isnil(_Where._Mynode()))
; 1326 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1327 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1328 : 		++_Where;	// save successor iterator for return
; 1329 : 		_Orphan_ptr(*this, _Erasednode);
; 1330 : 
; 1331 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1332 : 		if (this->_Isnil(_Where._Mynode()))

  0000c	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0
  00011	4c 8b fa	 mov	 r15, rdx
  00014	48 8b f1	 mov	 rsi, rcx
  00017	0f 85 51 03 00
	00		 jne	 $LN390@erase

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0001d	49 8b 50 10	 mov	 rdx, QWORD PTR [r8+16]

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00021	49 8d 48 10	 lea	 rcx, QWORD PTR [r8+16]
  00025	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0002a	80 7a 19 00	 cmp	 BYTE PTR [rdx+25], 0
  0002e	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);

  00033	4d 8b f0	 mov	 r14, r8

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00036	75 17		 jne	 SHORT $LN370@erase

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00038	48 8b 02	 mov	 rax, QWORD PTR [rdx]

; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  0003b	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0003f	75 37		 jne	 SHORT $LN386@erase
$LL72@erase:

; 621  : 			_Pnode = _Left(_Pnode);

  00041	48 8b d0	 mov	 rdx, rax

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00044	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00047	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0004b	74 f4		 je	 SHORT $LL72@erase

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else

  0004d	eb 29		 jmp	 SHORT $LN386@erase
$LN370@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0004f	49 8b 50 08	 mov	 rdx, QWORD PTR [r8+8]
  00053	80 7a 19 00	 cmp	 BYTE PTR [rdx+25], 0
  00057	75 1f		 jne	 SHORT $LN386@erase
  00059	0f 1f 80 00 00
	00 00		 npad	 7
$LL56@erase:
  00060	4c 3b 42 10	 cmp	 r8, QWORD PTR [rdx+16]
  00064	75 12		 jne	 SHORT $LN386@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  00066	48 89 54 24 50	 mov	 QWORD PTR _Where$[rsp], rdx
  0006b	4c 8b c2	 mov	 r8, rdx
  0006e	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00072	80 7a 19 00	 cmp	 BYTE PTR [rdx+25], 0
  00076	74 e8		 je	 SHORT $LL56@erase
$LN386@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00078	48 89 54 24 50	 mov	 QWORD PTR _Where$[rsp], rdx

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0007d	4d 8b 06	 mov	 r8, QWORD PTR [r14]
  00080	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 1334 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1335 : 		++_Where;	// save successor iterator for return
; 1336 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1337 : 
; 1338 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1339 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1340 : 		_Nodeptr _Pnode = _Erasednode;
; 1341 : 
; 1342 : 		if (this->_Isnil(this->_Left(_Pnode)))

  00085	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0
  0008a	74 05		 je	 SHORT $LN39@erase

; 1343 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

  0008c	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 1344 : 		else if (this->_Isnil(this->_Right(_Pnode)))

  0008f	eb 1b		 jmp	 SHORT $LN384@erase
$LN39@erase:
  00091	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00094	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00098	74 05		 je	 SHORT $LN37@erase

; 1345 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

  0009a	49 8b f8	 mov	 rdi, r8

; 1346 : 		else

  0009d	eb 0d		 jmp	 SHORT $LN384@erase
$LN37@erase:

; 1347 : 			{	// two subtrees, must lift successor node to replace erased
; 1348 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1349 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

  0009f	48 8b 7a 10	 mov	 rdi, QWORD PTR [rdx+16]

; 1350 : 			}
; 1351 : 
; 1352 : 		if (_Pnode == _Erasednode)

  000a3	49 3b d6	 cmp	 rdx, r14
  000a6	0f 85 a7 00 00
	00		 jne	 $LN35@erase
$LN384@erase:

; 1353 : 			{	// at most one subtree, relink it
; 1354 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1355 : 			if (!this->_Isnil(_Fixnode))

  000ac	80 7f 19 00	 cmp	 BYTE PTR [rdi+25], 0
  000b0	49 8b 5e 08	 mov	 rbx, QWORD PTR [r14+8]
  000b4	75 04		 jne	 SHORT $LN34@erase

; 1356 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

  000b6	48 89 5f 08	 mov	 QWORD PTR [rdi+8], rbx
$LN34@erase:

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  000ba	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 1357 : 
; 1358 : 			if (_Root() == _Erasednode)

  000bd	4c 39 70 08	 cmp	 QWORD PTR [rax+8], r14
  000c1	75 06		 jne	 SHORT $LN33@erase

; 1359 : 				_Root() = _Fixnode;	// link down from root

  000c3	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi

; 1360 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

  000c7	eb 0e		 jmp	 SHORT $LN30@erase
$LN33@erase:
  000c9	4c 39 33	 cmp	 QWORD PTR [rbx], r14
  000cc	75 05		 jne	 SHORT $LN31@erase

; 1361 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

  000ce	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 1362 : 			else

  000d1	eb 04		 jmp	 SHORT $LN30@erase
$LN31@erase:

; 1363 : 				this->_Right(_Fixnodeparent) =
; 1364 : 					_Fixnode;	// link down to right

  000d3	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi
$LN30@erase:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  000d7	48 8b 16	 mov	 rdx, QWORD PTR [rsi]

; 1365 : 
; 1366 : 			if (_Lmost() == _Erasednode)

  000da	4c 39 32	 cmp	 QWORD PTR [rdx], r14
  000dd	75 30		 jne	 SHORT $LN29@erase

; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  000df	80 7f 19 00	 cmp	 BYTE PTR [rdi+25], 0
  000e3	74 05		 je	 SHORT $LN43@erase
  000e5	48 8b cb	 mov	 rcx, rbx
  000e8	eb 22		 jmp	 SHORT $LN129@erase
$LN43@erase:

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  000ea	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  000ed	48 8b cf	 mov	 rcx, rdi

; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  000f0	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  000f4	75 16		 jne	 SHORT $LN129@erase
  000f6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL130@erase:

; 621  : 			_Pnode = _Left(_Pnode);

  00100	48 8b c8	 mov	 rcx, rax

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00103	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00106	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0010a	74 f4		 je	 SHORT $LL130@erase
$LN129@erase:

; 1367 : 				_Lmost() = this->_Isnil(_Fixnode)
; 1368 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1369 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree

  0010c	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN29@erase:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  0010f	48 8b 16	 mov	 rdx, QWORD PTR [rsi]

; 1370 : 
; 1371 : 			if (_Rmost() == _Erasednode)

  00112	4c 39 72 10	 cmp	 QWORD PTR [rdx+16], r14
  00116	0f 85 a3 00 00
	00		 jne	 $LN217@erase

; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  0011c	80 7f 19 00	 cmp	 BYTE PTR [rdi+25], 0
  00120	74 0c		 je	 SHORT $LN45@erase
  00122	48 8b cb	 mov	 rcx, rbx
  00125	48 89 5a 10	 mov	 QWORD PTR [rdx+16], rbx

; 1375 : 			}
; 1376 : 		else

  00129	e9 91 00 00 00	 jmp	 $LN217@erase
$LN45@erase:

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0012e	48 8b 47 10	 mov	 rax, QWORD PTR [rdi+16]

; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  00132	48 8b cf	 mov	 rcx, rdi

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00135	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00139	75 12		 jne	 SHORT $LN149@erase
  0013b	0f 1f 44 00 00	 npad	 5
$LL150@erase:

; 614  : 			_Pnode = _Right(_Pnode);

  00140	48 8b c8	 mov	 rcx, rax

; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00143	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00147	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0014b	74 f3		 je	 SHORT $LL150@erase
$LN149@erase:

; 1372 : 				_Rmost() = this->_Isnil(_Fixnode)
; 1373 : 					? _Fixnodeparent	// largest is parent of erased node
; 1374 : 					: this->_Max(_Fixnode);	// largest in relinked subtree

  0014d	48 89 4a 10	 mov	 QWORD PTR [rdx+16], rcx

; 1375 : 			}
; 1376 : 		else

  00151	eb 6c		 jmp	 SHORT $LN217@erase
$LN35@erase:

; 1377 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1378 : 			this->_Parent(this->_Left(_Erasednode)) =
; 1379 : 				_Pnode;	// link left up

  00153	49 89 50 08	 mov	 QWORD PTR [r8+8], rdx

; 1380 : 			this->_Left(_Pnode) =
; 1381 : 				this->_Left(_Erasednode);	// link successor down

  00157	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0015a	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1382 : 
; 1383 : 			if (_Pnode == this->_Right(_Erasednode))

  0015d	48 3b 11	 cmp	 rdx, QWORD PTR [rcx]
  00160	75 05		 jne	 SHORT $LN26@erase

; 1384 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

  00162	48 8b da	 mov	 rbx, rdx

; 1385 : 			else

  00165	eb 1f		 jmp	 SHORT $LN25@erase
$LN26@erase:

; 1386 : 				{	// successor further down, link in place of erased
; 1387 : 				_Fixnodeparent =
; 1388 : 					this->_Parent(_Pnode);	// parent is successor's
; 1389 : 				if (!this->_Isnil(_Fixnode))

  00167	80 7f 19 00	 cmp	 BYTE PTR [rdi+25], 0
  0016b	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0016f	75 04		 jne	 SHORT $LN24@erase

; 1390 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

  00171	48 89 5f 08	 mov	 QWORD PTR [rdi+8], rbx
$LN24@erase:

; 1391 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

  00175	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 1392 : 				this->_Right(_Pnode) =
; 1393 : 					this->_Right(_Erasednode);	// link next down

  00178	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0017b	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 1394 : 				this->_Parent(this->_Right(_Erasednode)) =
; 1395 : 					_Pnode;	// right up

  0017f	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00182	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx
$LN25@erase:

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00186	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 1396 : 				}
; 1397 : 
; 1398 : 			if (_Root() == _Erasednode)

  00189	4c 39 70 08	 cmp	 QWORD PTR [rax+8], r14
  0018d	75 06		 jne	 SHORT $LN23@erase

; 1399 : 				_Root() = _Pnode;	// link down from root

  0018f	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx

; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  00193	eb 12		 jmp	 SHORT $LN20@erase
$LN23@erase:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00195	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]

; 1400 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

  00199	4c 39 30	 cmp	 QWORD PTR [rax], r14
  0019c	75 05		 jne	 SHORT $LN21@erase

; 1401 : 				this->_Left(this->_Parent(_Erasednode)) =
; 1402 : 					_Pnode;	// link down to left

  0019e	48 89 10	 mov	 QWORD PTR [rax], rdx

; 1403 : 			else

  001a1	eb 04		 jmp	 SHORT $LN20@erase
$LN21@erase:

; 1404 : 				this->_Right(this->_Parent(_Erasednode)) =
; 1405 : 					_Pnode;	// link down to right

  001a3	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
$LN20@erase:

; 1406 : 
; 1407 : 			this->_Parent(_Pnode) =
; 1408 : 				this->_Parent(_Erasednode);	// link successor up

  001a7	49 8b 46 08	 mov	 rax, QWORD PTR [r14+8]
  001ab	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  001af	41 0f b6 46 18	 movzx	 eax, BYTE PTR [r14+24]
  001b4	0f b6 4a 18	 movzx	 ecx, BYTE PTR [rdx+24]
  001b8	88 42 18	 mov	 BYTE PTR [rdx+24], al

; 49   : 	_Right = _Move(_Tmp);

  001bb	41 88 4e 18	 mov	 BYTE PTR [r14+24], cl
$LN217@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1413 : 		if (this->_Color(_Erasednode) == this->_Black)

  001bf	41 80 7e 18 01	 cmp	 BYTE PTR [r14+24], 1
  001c4	0f 85 44 01 00
	00		 jne	 $LN19@erase

; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  001ca	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  001cd	48 3b 78 08	 cmp	 rdi, QWORD PTR [rax+8]
  001d1	0f 84 33 01 00
	00		 je	 $LN16@erase
  001d7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL18@erase:
  001e0	80 7f 18 01	 cmp	 BYTE PTR [rdi+24], 1
  001e4	0f 85 20 01 00
	00		 jne	 $LN16@erase

; 1418 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

  001ea	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  001ed	48 3b f9	 cmp	 rdi, rcx
  001f0	0f 85 85 00 00
	00		 jne	 $LN15@erase

; 1419 : 					{	// fixup left subtree
; 1420 : 					_Pnode = this->_Right(_Fixnodeparent);

  001f6	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]

; 1421 : 					if (this->_Color(_Pnode) == this->_Red)

  001fa	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  001fe	75 17		 jne	 SHORT $LN14@erase

; 1422 : 						{	// rotate red up from right subtree
; 1423 : 						this->_Color(_Pnode) = this->_Black;

  00200	c6 41 18 01	 mov	 BYTE PTR [rcx+24], 1

; 1424 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1425 : 						_Lrotate(_Fixnodeparent);

  00204	48 8b d3	 mov	 rdx, rbx
  00207	48 8b ce	 mov	 rcx, rsi
  0020a	c6 43 18 00	 mov	 BYTE PTR [rbx+24], 0
  0020e	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate

; 1426 : 						_Pnode = this->_Right(_Fixnodeparent);

  00213	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
$LN14@erase:

; 1427 : 						}
; 1428 : 
; 1429 : 					if (this->_Isnil(_Pnode))

  00217	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0021b	0f 85 93 00 00
	00		 jne	 $LN388@erase

; 1430 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1431 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1432 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

  00221	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00224	80 78 18 01	 cmp	 BYTE PTR [rax+24], 1
  00228	75 0a		 jne	 SHORT $LN11@erase
  0022a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0022e	80 78 18 01	 cmp	 BYTE PTR [rax+24], 1
  00232	74 7c		 je	 SHORT $LN389@erase
$LN11@erase:

; 1433 : 						{	// redden right subtree with black children
; 1434 : 						this->_Color(_Pnode) = this->_Red;
; 1435 : 						_Fixnode = _Fixnodeparent;
; 1436 : 						}
; 1437 : 					else
; 1438 : 						{	// must rearrange right subtree
; 1439 : 						if (this->_Color(this->_Right(_Pnode))
; 1440 : 							== this->_Black)

  00234	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00238	80 78 18 01	 cmp	 BYTE PTR [rax+24], 1
  0023c	75 1a		 jne	 SHORT $LN9@erase

; 1441 : 							{	// rotate red up from left sub-subtree
; 1442 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

  0023e	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1443 : 							this->_Color(_Pnode) = this->_Red;
; 1444 : 							_Rrotate(_Pnode);

  00241	48 8b d1	 mov	 rdx, rcx
  00244	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
  00248	c6 41 18 00	 mov	 BYTE PTR [rcx+24], 0
  0024c	48 8b ce	 mov	 rcx, rsi
  0024f	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate

; 1445 : 							_Pnode = this->_Right(_Fixnodeparent);

  00254	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
$LN9@erase:

; 1446 : 							}
; 1447 : 
; 1448 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  00258	0f b6 43 18	 movzx	 eax, BYTE PTR [rbx+24]

; 1449 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1450 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;
; 1451 : 						_Lrotate(_Fixnodeparent);

  0025c	48 8b d3	 mov	 rdx, rbx
  0025f	88 41 18	 mov	 BYTE PTR [rcx+24], al
  00262	c6 43 18 01	 mov	 BYTE PTR [rbx+24], 1
  00266	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0026a	48 8b ce	 mov	 rcx, rsi
  0026d	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
  00271	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate

; 1452 : 						break;	// tree now recolored/rebalanced

  00276	e9 8f 00 00 00	 jmp	 $LN16@erase
$LN15@erase:

; 1453 : 						}
; 1454 : 					}
; 1455 : 				else
; 1456 : 					{	// fixup right subtree
; 1457 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1458 : 					if (this->_Color(_Pnode) == this->_Red)

  0027b	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  0027f	75 16		 jne	 SHORT $LN7@erase

; 1459 : 						{	// rotate red up from left subtree
; 1460 : 						this->_Color(_Pnode) = this->_Black;

  00281	c6 41 18 01	 mov	 BYTE PTR [rcx+24], 1

; 1461 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1462 : 						_Rrotate(_Fixnodeparent);

  00285	48 8b d3	 mov	 rdx, rbx
  00288	48 8b ce	 mov	 rcx, rsi
  0028b	c6 43 18 00	 mov	 BYTE PTR [rbx+24], 0
  0028f	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate

; 1463 : 						_Pnode = this->_Left(_Fixnodeparent);

  00294	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN7@erase:

; 1464 : 						}
; 1465 : 
; 1466 : 					if (this->_Isnil(_Pnode))

  00297	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0029b	75 17		 jne	 SHORT $LN388@erase

; 1467 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1468 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1469 : 						this->_Black
; 1470 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

  0029d	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  002a1	80 78 18 01	 cmp	 BYTE PTR [rax+24], 1
  002a5	75 23		 jne	 SHORT $LN4@erase
  002a7	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002aa	80 78 18 01	 cmp	 BYTE PTR [rax+24], 1
  002ae	75 1a		 jne	 SHORT $LN4@erase
$LN389@erase:

; 1471 : 						{	// redden left subtree with black children
; 1472 : 						this->_Color(_Pnode) = this->_Red;

  002b0	c6 41 18 00	 mov	 BYTE PTR [rcx+24], 0
$LN388@erase:

; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  002b4	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 1473 : 						_Fixnode = _Fixnodeparent;

  002b7	48 8b fb	 mov	 rdi, rbx
  002ba	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  002be	48 3b 78 08	 cmp	 rdi, QWORD PTR [rax+8]
  002c2	0f 85 18 ff ff
	ff		 jne	 $LL18@erase

; 1414 : 			{	// erasing black link, must recolor/rebalance tree
; 1415 : 			for (; _Fixnode != _Root()
; 1416 : 				&& this->_Color(_Fixnode) == this->_Black;
; 1417 : 				_Fixnodeparent = this->_Parent(_Fixnode))

  002c8	eb 40		 jmp	 SHORT $LN16@erase
$LN4@erase:

; 1474 : 						}
; 1475 : 					else
; 1476 : 						{	// must rearrange left subtree
; 1477 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

  002ca	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002cd	80 78 18 01	 cmp	 BYTE PTR [rax+24], 1
  002d1	75 1a		 jne	 SHORT $LN2@erase

; 1478 : 							{	// rotate red up from right sub-subtree
; 1479 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

  002d3	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 1480 : 							this->_Color(_Pnode) = this->_Red;
; 1481 : 							_Lrotate(_Pnode);

  002d7	48 8b d1	 mov	 rdx, rcx
  002da	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
  002de	c6 41 18 00	 mov	 BYTE PTR [rcx+24], 0
  002e2	48 8b ce	 mov	 rcx, rsi
  002e5	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate

; 1482 : 							_Pnode = this->_Left(_Fixnodeparent);

  002ea	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN2@erase:

; 1483 : 							}
; 1484 : 
; 1485 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

  002ed	0f b6 43 18	 movzx	 eax, BYTE PTR [rbx+24]

; 1486 : 						this->_Color(_Fixnodeparent) = this->_Black;
; 1487 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;
; 1488 : 						_Rrotate(_Fixnodeparent);

  002f1	48 8b d3	 mov	 rdx, rbx
  002f4	88 41 18	 mov	 BYTE PTR [rcx+24], al
  002f7	c6 43 18 01	 mov	 BYTE PTR [rbx+24], 1
  002fb	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002fe	48 8b ce	 mov	 rcx, rsi
  00301	c6 40 18 01	 mov	 BYTE PTR [rax+24], 1
  00305	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate
$LN16@erase:

; 1489 : 						break;	// tree now recolored/rebalanced
; 1490 : 						}
; 1491 : 					}
; 1492 : 
; 1493 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

  0030a	c6 47 18 01	 mov	 BYTE PTR [rdi+24], 1
$LN19@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0030e	49 8b 5e 38	 mov	 rbx, QWORD PTR [r14+56]
  00312	48 85 db	 test	 rbx, rbx
  00315	74 1d		 je	 SHORT $LN352@erase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00317	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0031b	75 17		 jne	 SHORT $LN352@erase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0031d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00320	48 8b cb	 mov	 rcx, rbx
  00323	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00325	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00329	75 09		 jne	 SHORT $LN352@erase

; 128  : 			_Delete_this();

  0032b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0032e	48 8b cb	 mov	 rcx, rbx
  00331	ff 50 08	 call	 QWORD PTR [rax+8]
$LN352@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00334	49 8b ce	 mov	 rcx, r14
  00337	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1501 : 		if (0 < this->_Mysize)

  0033c	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00340	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  00345	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0034a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0034f	48 85 c0	 test	 rax, rax
  00352	74 07		 je	 SHORT $LN1@erase

; 1502 : 			--this->_Mysize;

  00354	48 ff c8	 dec	 rax
  00357	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
$LN1@erase:

; 44   : 		{	// construct with node pointer _Pnode

  0035b	48 8b 44 24 50	 mov	 rax, QWORD PTR _Where$[rsp]
  00360	49 89 07	 mov	 QWORD PTR [r15], rax

; 1503 : 
; 1504 : 		return (iterator(_Where._Ptr, this));	// return successor iterator

  00363	49 8b c7	 mov	 rax, r15

; 1505 : 		}

  00366	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0036a	41 5f		 pop	 r15
  0036c	5e		 pop	 rsi
  0036d	c3		 ret	 0
$LN390@erase:

; 1333 : 			_Xout_of_range("invalid map/set<T> iterator");

  0036e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
  00375	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  0037a	cc		 int	 3
$LN387@erase:
?erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear, COMDAT

; 1532 : 		{	// erase all

$LN20:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1533 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1534 : 		this->_Orphan_ptr(*this, 0);
; 1535 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1536 : 
; 1537 : 		_Erase(_Root());

  00006	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00010	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00015	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1538 : 		_Root() = this->_Myhead;

  00018	48 89 40 08	 mov	 QWORD PTR [rax+8], rax

; 1539 : 		_Lmost() = this->_Myhead;

  0001c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001f	48 89 00	 mov	 QWORD PTR [rax], rax

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00022	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1540 : 		_Rmost() = this->_Myhead;

  00025	48 89 40 10	 mov	 QWORD PTR [rax+16], rax

; 1541 : 		this->_Mysize = 0;

  00029	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0

; 1542 : 		}

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Keyval$ = 24
?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange, COMDAT

; 2025 : 		{	// find leftmost node not less than _Keyval

$LN136:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  0000f	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 2025 : 		{	// find leftmost node not less than _Keyval

  00012	48 8b f2	 mov	 rsi, rdx

; 2026 : 		_Nodeptr _Pnode = _Root();

  00015	4c 8b 4f 08	 mov	 r9, QWORD PTR [rdi+8]

; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails

  00019	48 8b df	 mov	 rbx, rdi

; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))

  0001c	41 80 79 19 00	 cmp	 BYTE PTR [r9+25], 0
  00021	49 8b c1	 mov	 rax, r9
  00024	75 6d		 jne	 SHORT $LN8@Eqrange
  00026	45 8b 10	 mov	 r10d, DWORD PTR [r8]
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@Eqrange:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00030	8b 50 20	 mov	 edx, DWORD PTR [rax+32]
  00033	41 3b d2	 cmp	 edx, r10d
  00036	7c 51		 jl	 SHORT $LN132@Eqrange

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00038	75 1c		 jne	 SHORT $LN7@Eqrange

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0003a	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  0003d	45 8b 58 04	 mov	 r11d, DWORD PTR [r8+4]
  00041	41 3b cb	 cmp	 ecx, r11d
  00044	7c 43		 jl	 SHORT $LN132@Eqrange

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00046	75 0e		 jne	 SHORT $LN7@Eqrange

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00048	41 8b 48 08	 mov	 ecx, DWORD PTR [r8+8]
  0004c	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  0004f	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00052	84 c9		 test	 cl, cl
  00054	75 33		 jne	 SHORT $LN132@Eqrange
$LN7@Eqrange:

; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

  00056	80 7b 19 00	 cmp	 BYTE PTR [rbx+25], 0
  0005a	74 25		 je	 SHORT $LN5@Eqrange
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  0005c	44 3b d2	 cmp	 r10d, edx
  0005f	7c 1d		 jl	 SHORT $LN133@Eqrange

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00061	75 1e		 jne	 SHORT $LN5@Eqrange

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  00063	41 8b 48 04	 mov	 ecx, DWORD PTR [r8+4]
  00067	8b 50 24	 mov	 edx, DWORD PTR [rax+36]
  0006a	3b ca		 cmp	 ecx, edx
  0006c	7c 10		 jl	 SHORT $LN133@Eqrange

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  0006e	75 11		 jne	 SHORT $LN5@Eqrange

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00070	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00073	41 39 48 08	 cmp	 DWORD PTR [r8+8], ecx
  00077	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

  0007a	84 c9		 test	 cl, cl
  0007c	74 03		 je	 SHORT $LN5@Eqrange
$LN133@Eqrange:

; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it

  0007e	48 8b d8	 mov	 rbx, rax
$LN5@Eqrange:

; 2039 : 				_Lonode = _Pnode;

  00081	48 8b f8	 mov	 rdi, rax

; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  00084	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00087	eb 04		 jmp	 SHORT $LN6@Eqrange
$LN132@Eqrange:

; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00089	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN6@Eqrange:

; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))

  0008d	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00091	74 9d		 je	 SHORT $LL9@Eqrange
$LN8@Eqrange:

; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound

  00093	80 7b 19 00	 cmp	 BYTE PTR [rbx+25], 0
  00097	75 03		 jne	 SHORT $LN13@Eqrange
  00099	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
$LN13@Eqrange:

; 2045 : 		while (!this->_Isnil(_Pnode))

  0009c	41 80 79 19 00	 cmp	 BYTE PTR [r9+25], 0
  000a1	75 3d		 jne	 SHORT $LN3@Eqrange
  000a3	41 8b 10	 mov	 edx, DWORD PTR [r8]
$LL4@Eqrange:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  000a6	41 8b 41 20	 mov	 eax, DWORD PTR [r9+32]
  000aa	3b d0		 cmp	 edx, eax
  000ac	7c 25		 jl	 SHORT $LN134@Eqrange

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  000ae	75 1d		 jne	 SHORT $LN2@Eqrange

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  000b0	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  000b4	41 8b 49 24	 mov	 ecx, DWORD PTR [r9+36]
  000b8	3b c1		 cmp	 eax, ecx
  000ba	7c 17		 jl	 SHORT $LN134@Eqrange

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  000bc	75 0f		 jne	 SHORT $LN2@Eqrange

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  000be	41 8b 41 28	 mov	 eax, DWORD PTR [r9+40]
  000c2	41 39 40 08	 cmp	 DWORD PTR [r8+8], eax
  000c6	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

  000c9	84 c0		 test	 al, al
  000cb	75 06		 jne	 SHORT $LN134@Eqrange
$LN2@Eqrange:

; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  000cd	4d 8b 49 10	 mov	 r9, QWORD PTR [r9+16]
  000d1	eb 06		 jmp	 SHORT $LN1@Eqrange
$LN134@Eqrange:

; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;

  000d3	49 8b d9	 mov	 rbx, r9

; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  000d6	4d 8b 09	 mov	 r9, QWORD PTR [r9]
$LN1@Eqrange:

; 2045 : 		while (!this->_Isnil(_Pnode))

  000d9	41 80 79 19 00	 cmp	 BYTE PTR [r9+25], 0
  000de	74 c6		 je	 SHORT $LL4@Eqrange
$LN3@Eqrange:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000e0	48 89 3e	 mov	 QWORD PTR [rsi], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2057 : 		}

  000e3	48 8b 7c 24 18	 mov	 rdi, QWORD PTR [rsp+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000e8	48 89 5e 08	 mov	 QWORD PTR [rsi+8], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2057 : 		}

  000ec	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000f1	48 8b c6	 mov	 rax, rsi
  000f4	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
  000f9	c3		 ret	 0
?_Eqrange@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Eqrange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
this$ = 8
_Keyval$ = 16
?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@AEBVChunkPosition@@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound, COMDAT

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 2091 : 		{	// find leftmost node not less than _Keyval

  00003	4c 8b d2	 mov	 r10, rdx

; 2092 : 		_Nodeptr _Pnode = _Root();

  00006	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  0000a	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0000e	75 3a		 jne	 SHORT $LN40@Lbound
  00010	44 8b 0a	 mov	 r9d, DWORD PTR [rdx]
$LL4@Lbound:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00013	8b 48 20	 mov	 ecx, DWORD PTR [rax+32]
  00016	41 3b c9	 cmp	 ecx, r9d
  00019	7c 25		 jl	 SHORT $LN39@Lbound

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  0001b	75 1b		 jne	 SHORT $LN2@Lbound

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0001d	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00020	41 8b 52 04	 mov	 edx, DWORD PTR [r10+4]
  00024	3b ca		 cmp	 ecx, edx
  00026	7c 18		 jl	 SHORT $LN39@Lbound

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00028	75 0e		 jne	 SHORT $LN2@Lbound

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0002a	41 8b 4a 08	 mov	 ecx, DWORD PTR [r10+8]
  0002e	39 48 28	 cmp	 DWORD PTR [rax+40], ecx
  00031	0f 9c c1	 setl	 cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

  00034	84 c9		 test	 cl, cl
  00036	75 08		 jne	 SHORT $LN39@Lbound
$LN2@Lbound:

; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;

  00038	4c 8b c0	 mov	 r8, rax

; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	eb 04		 jmp	 SHORT $LN1@Lbound
$LN39@Lbound:

; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

  00040	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
$LN1@Lbound:

; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))

  00044	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00048	74 c9		 je	 SHORT $LL4@Lbound
$LN40@Lbound:

; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate

  0004a	49 8b c0	 mov	 rax, r8

; 2105 : 		}

  0004d	c3		 ret	 0
?_Lbound@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@AEBVChunkPosition@@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lbound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Val$ = 16
?_Kfn@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Kfn, COMDAT

; 2221 : 		return (_Traits::_Kfn(_Val));

  00000	48 8b c2	 mov	 rax, rdx

; 2222 : 		}

  00003	c3		 ret	 0
?_Kfn@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
_Al$dead$ = 64
??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT

; 1007 : 		{	// construct ordering predicate

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 573  : 		this->_Myhead = 0;

  00006	33 c0		 xor	 eax, eax

; 1007 : 		{	// construct ordering predicate

  00008	48 8b d9	 mov	 rbx, rcx

; 573  : 		this->_Myhead = 0;

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 574  : 		this->_Mysize = 0;

  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00012	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00017	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1008 : 		}

  0001a	48 8b c3	 mov	 rax, rbx
  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??0?$_Tree_comp@$0A@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBU?$less@VChunkPosition@@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Tree_comp<0,std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Pnode$ = 16
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?_Freeheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 277  : 		_Myiter _Tmp = *this;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	4c 8b c1	 mov	 r8, rcx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00006	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0

; 277  : 		_Myiter _Tmp = *this;

  0000a	48 89 02	 mov	 QWORD PTR [rdx], rax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  0000d	75 4a		 jne	 SHORT $LN43@operator

; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0000f	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00013	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00017	75 1c		 jne	 SHORT $LN38@operator

; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00019	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  0001c	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00020	75 0c		 jne	 SHORT $LN21@operator
$LL22@operator:

; 621  : 			_Pnode = _Left(_Pnode);

  00022	48 8b c8	 mov	 rcx, rax

; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00028	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0002c	74 f4		 je	 SHORT $LL22@operator
$LN21@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002e	49 89 08	 mov	 QWORD PTR [r8], rcx

; 278  : 		++*this;
; 279  : 		return (_Tmp);

  00031	48 8b c2	 mov	 rax, rdx

; 280  : 		}

  00034	c3		 ret	 0
$LN38@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00035	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00039	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0003d	75 17		 jne	 SHORT $LN5@operator
  0003f	90		 npad	 1
$LL6@operator:
  00040	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00044	49 39 08	 cmp	 QWORD PTR [r8], rcx
  00047	75 0d		 jne	 SHORT $LN5@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  00049	49 89 00	 mov	 QWORD PTR [r8], rax
  0004c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00050	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00054	74 ea		 je	 SHORT $LL6@operator
$LN5@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00056	49 89 00	 mov	 QWORD PTR [r8], rax
$LN43@operator:

; 278  : 		++*this;
; 279  : 		return (_Tmp);

  00059	48 8b c2	 mov	 rax, rdx

; 280  : 		}

  0005c	c3		 ret	 0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 48
_Rootnode$ = 56
?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase, COMDAT

; 2060 : 		{	// free entire subtree, recursively

$LN50:
  00000	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  0000f	80 7a 19 00	 cmp	 BYTE PTR [rdx+25], 0
  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8b e9	 mov	 rbp, rcx
  00019	48 8b fa	 mov	 rdi, rdx
  0001c	75 50		 jne	 SHORT $LN1@Erase
  0001e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
$LL3@Erase:

; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));

  00023	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00027	48 8b cd	 mov	 rcx, rbp
  0002a	e8 00 00 00 00	 call	 ?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0002f	48 8b 5e 38	 mov	 rbx, QWORD PTR [rsi+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2065 : 			_Pnode = this->_Left(_Pnode);

  00033	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00036	48 85 db	 test	 rbx, rbx
  00039	74 1d		 je	 SHORT $LN37@Erase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0003b	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0003f	75 17		 jne	 SHORT $LN37@Erase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00041	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00044	48 8b cb	 mov	 rcx, rbx
  00047	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00049	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004d	75 09		 jne	 SHORT $LN37@Erase

; 128  : 			_Delete_this();

  0004f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00052	48 8b cb	 mov	 rcx, rbx
  00055	ff 50 08	 call	 QWORD PTR [rax+8]
$LN37@Erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00058	48 8b ce	 mov	 rcx, rsi
  0005b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

  00060	80 7f 19 00	 cmp	 BYTE PTR [rdi+25], 0
  00064	48 8b f7	 mov	 rsi, rdi
  00067	74 ba		 je	 SHORT $LL3@Erase
  00069	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@Erase:

; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}

  0006e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00073	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
?_Erase@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Wherenode$ = 16
?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate, COMDAT

; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00000	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]

; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  00004	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00007	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 588  : 		return ((char&)_Pnode->_Isnil);

  0000b	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  0000e	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00012	75 04		 jne	 SHORT $LN5@Lrotate

; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  00014	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx
$LN5@Lrotate:

; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00018	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0001c	49 89 40 08	 mov	 QWORD PTR [r8+8], rax

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 2120 : 
; 2121 : 		if (_Wherenode == _Root())

  00023	48 3b 50 08	 cmp	 rdx, QWORD PTR [rax+8]
  00027	75 0c		 jne	 SHORT $LN4@Lrotate

; 2122 : 			_Root() = _Pnode;

  00029	4c 89 40 08	 mov	 QWORD PTR [rax+8], r8

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  0002d	49 89 10	 mov	 QWORD PTR [r8], rdx

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  00030	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 2130 : 		}

  00034	c3		 ret	 0
$LN4@Lrotate:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00035	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00039	48 3b 10	 cmp	 rdx, QWORD PTR [rax]
  0003c	75 0b		 jne	 SHORT $LN2@Lrotate

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0003e	4c 89 00	 mov	 QWORD PTR [rax], r8

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  00041	49 89 10	 mov	 QWORD PTR [r8], rdx

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  00044	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 2130 : 		}

  00048	c3		 ret	 0
$LN2@Lrotate:

; 2125 : 		else
; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00049	4c 89 40 10	 mov	 QWORD PTR [rax+16], r8

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  0004d	49 89 10	 mov	 QWORD PTR [r8], rdx

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  00050	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 2130 : 		}

  00054	c3		 ret	 0
?_Lrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Rmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rmost, COMDAT

; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}

  00007	c3		 ret	 0
?_Rmost@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Root@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Root, COMDAT

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 08	 add	 rax, 8

; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}

  00007	c3		 ret	 0
?_Root@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$ = 8
_Wherenode$ = 16
?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate, COMDAT

; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  00000	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  00003	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]
  00007	48 89 02	 mov	 QWORD PTR [rdx], rax

; 588  : 		return ((char&)_Pnode->_Isnil);

  0000a	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]

; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0000e	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00012	75 04		 jne	 SHORT $LN5@Rrotate

; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00014	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx
$LN5@Rrotate:

; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00018	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0001c	49 89 40 08	 mov	 QWORD PTR [r8+8], rax

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00020	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 2150 : 
; 2151 : 		if (_Wherenode == _Root())

  00023	48 3b 50 08	 cmp	 rdx, QWORD PTR [rax+8]
  00027	75 0d		 jne	 SHORT $LN4@Rrotate

; 2152 : 			_Root() = _Pnode;

  00029	4c 89 40 08	 mov	 QWORD PTR [rax+8], r8

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  0002d	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  00031	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 2160 : 		}

  00035	c3		 ret	 0
$LN4@Rrotate:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00036	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  0003a	48 3b 50 10	 cmp	 rdx, QWORD PTR [rax+16]
  0003e	75 0d		 jne	 SHORT $LN2@Rrotate

; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00040	4c 89 40 10	 mov	 QWORD PTR [rax+16], r8

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  00044	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  00048	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 2160 : 		}

  0004c	c3		 ret	 0
$LN2@Rrotate:

; 2155 : 		else
; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  0004d	4c 89 00	 mov	 QWORD PTR [rax], r8

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  00050	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  00054	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 2160 : 		}

  00058	c3		 ret	 0
?_Rrotate@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 893  : 		{	// construct from allocator

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 573  : 		this->_Myhead = 0;

  00006	33 c0		 xor	 eax, eax

; 893  : 		{	// construct from allocator

  00008	48 8b d9	 mov	 rbx, rcx

; 573  : 		this->_Myhead = 0;

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 574  : 		this->_Mysize = 0;

  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);
; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))
; 621  : 			_Pnode = _Left(_Pnode);
; 622  : 		return (_Pnode);
; 623  : 		}
; 624  : 
; 625  : 	_Nodeptr _Myhead;	// pointer to head node
; 626  : 	size_type _Mysize;	// number of elements
; 627  : 	};
; 628  : 
; 629  : 		// TEMPLATE CLASS _Tree_alloc
; 630  : template<bool _Al_has_storage,
; 631  : 	class _Alloc_types>
; 632  : 	class _Tree_alloc
; 633  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 634  : 	{	// base class for tree to hold allocator with storage
; 635  : public:
; 636  : 	typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 637  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 638  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 639  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 640  : 	typedef typename _Alloc_types::_Node _Node;
; 641  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 642  : 
; 643  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 644  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 645  : 		: _Alnod(_Al)
; 646  : 		{	// construct head node, allocator from _Al
; 647  : 		this->_Myhead = _Buyheadnode();
; 648  : 		}
; 649  : 
; 650  : 	~_Tree_alloc() _NOEXCEPT
; 651  : 		{	// destroy head node
; 652  : 		_Freeheadnode(this->_Myhead);
; 653  : 		}
; 654  : 
; 655  : 	void _Change_alloc(const _Alty& _Al)
; 656  : 		{	// replace old allocator
; 657  : 		_Alnod = _Al;
; 658  : 		}
; 659  : 
; 660  : 	void _Swap_alloc(_Myt& _Right)
; 661  : 		{	// swap allocators
; 662  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 663  : 		}
; 664  : 
; 665  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 666  : 	_Tree_alloc(const _Alloc& _Al = _Alloc())
; 667  : 		: _Alnod(_Al)
; 668  : 		{	// construct allocators from _Al
; 669  : 		this->_Myhead = _Buyheadnode();
; 670  : 		_TRY_BEGIN
; 671  : 		_Alloc_proxy();
; 672  : 		_CATCH_ALL
; 673  : 		_Freeheadnode(this->_Myhead);
; 674  : 		_RERAISE;
; 675  : 		_CATCH_END
; 676  : 		}
; 677  : 
; 678  : 	~_Tree_alloc() _NOEXCEPT
; 679  : 		{	// destroy proxy
; 680  : 		_Freeheadnode(this->_Myhead);
; 681  : 		_Free_proxy();
; 682  : 		}
; 683  : 
; 684  : 	void _Change_alloc(const _Alty& _Al)
; 685  : 		{	// replace old allocator
; 686  : 		_Free_proxy();
; 687  : 		_Alnod = _Al;
; 688  : 		_Alloc_proxy();
; 689  : 		}
; 690  : 
; 691  : 	void _Swap_alloc(_Myt& _Right)
; 692  : 		{	// swap allocators
; 693  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 694  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 695  : 		}
; 696  : 
; 697  : 	void _Alloc_proxy()
; 698  : 		{	// construct proxy from _Alnod
; 699  : 		typename _Alty::template rebind<_Container_proxy>::other
; 700  : 			_Alproxy(_Alnod);
; 701  : 		this->_Myproxy = _Alproxy.allocate(1);
; 702  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 703  : 		this->_Myproxy->_Mycont = this;
; 704  : 		}
; 705  : 
; 706  : 	void _Free_proxy()
; 707  : 		{	// destroy proxy
; 708  : 		typename _Alty::template rebind<_Container_proxy>::other
; 709  : 			_Alproxy(_Alnod);
; 710  : 		this->_Orphan_all();
; 711  : 		_Alproxy.destroy(this->_Myproxy);
; 712  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 713  : 		this->_Myproxy = 0;
; 714  : 		}
; 715  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 716  : 
; 717  : 	_Nodeptr _Buyheadnode()
; 718  : 		{	// get head node using current allocator
; 719  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 720  : 
; 721  : 		_TRY_BEGIN
; 722  : 		_Alnod.construct(
; 723  : 			_STD addressof(this->_Left(_Pnode)), _Pnode);
; 724  : 		_Alnod.construct(
; 725  : 			_STD addressof(this->_Parent(_Pnode)), _Pnode);
; 726  : 		_Alnod.construct(
; 727  : 			_STD addressof(this->_Right(_Pnode)), _Pnode);
; 728  : 		_CATCH_ALL
; 729  : 		_Alnod.deallocate(_Pnode, 1);
; 730  : 		_RERAISE;
; 731  : 		_CATCH_END
; 732  : 
; 733  : 		this->_Color(_Pnode) = this->_Black;
; 734  : 		this->_Isnil(_Pnode) = true;
; 735  : 		return (_Pnode);
; 736  : 		}
; 737  : 
; 738  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 739  : 		{	// free head node using current allocator
; 740  : 		_Alnod.destroy(
; 741  : 			_STD addressof(this->_Left(_Pnode)));
; 742  : 		_Alnod.destroy(
; 743  : 			_STD addressof(this->_Parent(_Pnode)));
; 744  : 		_Alnod.destroy(
; 745  : 			_STD addressof(this->_Right(_Pnode)));
; 746  : 		_Alnod.deallocate(_Pnode, 1);
; 747  : 		}
; 748  : 
; 749  : 	_Alty& _Getal()
; 750  : 		{	// get reference to allocator
; 751  : 		return (_Alnod);
; 752  : 		}
; 753  : 
; 754  : 	const _Alty& _Getal() const
; 755  : 		{	// get reference to allocator
; 756  : 		return (_Alnod);
; 757  : 		}
; 758  : 
; 759  : 	_Alty _Alnod;	// allocator object for stored elements
; 760  : 	};
; 761  : 
; 762  : 		// TEMPLATE CLASS _Tree_alloc
; 763  : template<class _Alloc_types>
; 764  : 	class _Tree_alloc<false, _Alloc_types>
; 765  : 		: public _Tree_val<typename _Alloc_types::_Val_types>
; 766  : 	{	// base class for tree to hold allocator with no storage
; 767  : public:
; 768  : 	typedef _Tree_alloc<false, _Alloc_types> _Myt;
; 769  : 	typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
; 770  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 771  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 772  : 	typedef typename _Alloc_types::_Node _Node;
; 773  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 774  : 
; 775  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())
; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00012	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00017	48 89 03	 mov	 QWORD PTR [rbx], rax

; 894  : 		}

  0001a	48 8b c3	 mov	 rax, rbx
  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??0?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal, COMDAT

; 874  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 875  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEADPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEADPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Color, COMDAT

; 583  : 		return ((char&)_Pnode->_Color);

  00000	48 8d 41 18	 lea	 rax, QWORD PTR [rcx+24]

; 584  : 		}

  00004	c3		 ret	 0
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEADPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Max, COMDAT

; 588  : 		return ((char&)_Pnode->_Isnil);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00004	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00008	75 13		 jne	 SHORT $LN14@Max
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL2@Max:

; 614  : 			_Pnode = _Right(_Pnode);

  00010	48 8b c8	 mov	 rcx, rax

; 588  : 		return ((char&)_Pnode->_Isnil);

  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00017	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0001b	74 f3		 je	 SHORT $LL2@Max
$LN14@Max:

; 615  : 		return (_Pnode);

  0001d	48 8b c1	 mov	 rax, rcx

; 616  : 		}

  00020	c3		 ret	 0
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 573  : 		this->_Myhead = 0;

  00006	33 c0		 xor	 eax, eax

; 776  : 	_Tree_alloc(const _Alloc& = _Alloc())

  00008	48 8b d9	 mov	 rbx, rcx

; 573  : 		this->_Myhead = 0;

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 574  : 		this->_Mysize = 0;

  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 777  : 		{	// construct head node, allocator from _Al
; 778  : 		this->_Myhead = _Buyheadnode();

  00012	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
  00017	48 89 03	 mov	 QWORD PTR [rbx], rax

; 779  : 		}

  0001a	48 8b c3	 mov	 rax, rbx
  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??0?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$dead$ = 48
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ PROC ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode, COMDAT

; 841  : 		{	// get head node using current allocator

$LN102:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00009	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0000e	48 85 c0	 test	 rax, rax
  00011	74 26		 je	 SHORT $LN100@Buyheadnod
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00013	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00017	48 89 00	 mov	 QWORD PTR [rax], rax
  0001a	48 85 c9	 test	 rcx, rcx
  0001d	74 03		 je	 SHORT $LN61@Buyheadnod
  0001f	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN61@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00022	48 8d 48 10	 lea	 rcx, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00026	48 85 c9	 test	 rcx, rcx
  00029	74 03		 je	 SHORT $LN83@Buyheadnod
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN83@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 856  : 		this->_Color(_Pnode) = this->_Black;

  0002e	66 c7 40 18 01
	01		 mov	 WORD PTR [rax+24], 257	; 00000101H

; 859  : 		}

  00034	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00038	c3		 ret	 0
$LN100@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00039	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0003e	cc		 int	 3
$LN99@Buyheadnod:
?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ENDP ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 574  : 		this->_Mysize = 0;

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 575  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00009	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0000e	48 85 c0	 test	 rax, rax
  00011	74 05		 je	 SHORT $LN15@allocate

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00018	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0001d	cc		 int	 3
$LN14@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00009	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0000e	48 85 c0	 test	 rax, rax
  00011	74 05		 je	 SHORT $LN12@allocate

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00018	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0001d	cc		 int	 3
$LN11@allocate:
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z
_TEXT	SEGMENT
this$ = 48
_Px$ = 56
??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>, COMDAT

; 485  : 		explicit shared_ptr(_Ux *_Px)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00008	48 8b d9	 mov	 rbx, rcx

; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00012	e8 00 00 00 00	 call	 ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>

; 488  : 		}

  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0AEBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBVChunkPosition@@$$QEAV?$shared_ptr@VChunkBase@@@1@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
__formal$dead$ = 32
??$?0AEBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBVChunkPosition@@$$QEAV?$shared_ptr@VChunkBase@@@1@PEAPEAX@Z PROC ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const & __ptr64,std::shared_ptr<ChunkBase> >, COMDAT

; 138  : 		{	// construct from moved values

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	4c 8b c9	 mov	 r9, rcx
  00005	89 01		 mov	 DWORD PTR [rcx], eax
  00007	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  0000a	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0000d	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  00010	48 8d 51 10	 lea	 rdx, QWORD PTR [rcx+16]
  00014	89 41 08	 mov	 DWORD PTR [rcx+8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00017	33 c9		 xor	 ecx, ecx
  00019	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0001c	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00020	49 3b d0	 cmp	 rdx, r8
  00023	74 18		 je	 SHORT $LN36@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00025	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00029	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0002d	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  00031	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00034	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00037	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  0003a	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN36@shared_ptr:

; 139  : 		}

  0003d	49 8b c1	 mov	 rax, r9
  00040	c3		 ret	 0
??$?0AEBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBVChunkPosition@@$$QEAV?$shared_ptr@VChunkBase@@@1@PEAPEAX@Z ENDP ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const & __ptr64,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Where$ = 80
_Val$ = 88
??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 1157 : 		typename enable_if<is_convertible<_Valty, value_type>::value,

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b fa	 mov	 rdi, rdx

; 1158 : 			iterator>::type
; 1159 : 		insert(const_iterator _Where, _Valty&& _Val)
; 1160 : 		{	// try to insert node with value _Val using _Where as a hint
; 1161 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val));

  00012	49 8b d1	 mov	 rdx, r9
  00015	48 8b d9	 mov	 rbx, rcx
  00018	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >

; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));

  0001d	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Where$[rsp]
  00022	48 8b d7	 mov	 rdx, rdi

; 608  : 		return ((reference)_Pnode->_Myval);

  00025	4c 8d 48 20	 lea	 r9, QWORD PTR [rax+32]

; 1162 : 		return (_Insert_hint(_Where,
; 1163 : 			this->_Myval(_Newnode), _Newnode));

  00029	48 8b cb	 mov	 rcx, rbx
  0002c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00031	e8 00 00 00 00	 call	 ??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>

; 1164 : 		}

  00036	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0003b	48 8b c7	 mov	 rax, rdi
  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAU01@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAU01@PEAPEAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 182  : 		{	// construct from moved compatible pair

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 183  : 		}

  0000e	48 8b c1	 mov	 rax, rcx
  00011	c3		 ret	 0
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAU01@PEAPEAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_K@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_K@Z PROC ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 3b ca	 cmp	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00003	74 61		 je	 SHORT $LN5@Distance
  00005	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL16@Distance:

; 799  : 		++_Off;

  00010	49 ff c1	 inc	 r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00013	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00017	75 45		 jne	 SHORT $LN55@Distance

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00019	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0001d	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00021	75 1b		 jne	 SHORT $LN52@Distance

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00023	48 8b c8	 mov	 rcx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00029	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0002d	75 2f		 jne	 SHORT $LN55@Distance
  0002f	90		 npad	 1
$LL31@Distance:

; 621  : 			_Pnode = _Left(_Pnode);

  00030	48 8b c8	 mov	 rcx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00036	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0003a	74 f4		 je	 SHORT $LL31@Distance

; 65   : 		else

  0003c	eb 20		 jmp	 SHORT $LN55@Distance
$LN52@Distance:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0003e	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00042	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00046	75 13		 jne	 SHORT $LN14@Distance
$LL15@Distance:
  00048	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  0004c	75 0d		 jne	 SHORT $LN14@Distance

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0004e	48 8b c8	 mov	 rcx, rax
  00051	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00055	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00059	74 ed		 je	 SHORT $LL15@Distance
$LN14@Distance:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0005b	48 8b c8	 mov	 rcx, rax
$LN55@Distance:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  0005e	48 3b ca	 cmp	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00061	75 ad		 jne	 SHORT $LL16@Distance
  00063	4d 89 08	 mov	 QWORD PTR [r8], r9
$LN5@Distance:

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 832  : 	}

  00066	f3 c3		 fatret	 0
??$_Distance@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_K@Z ENDP ; std::_Distance<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 907  : 		void destroy(_Ty *_Ptr)

$LN25:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN20@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN23@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN23@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN23@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN20@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 910  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEAV01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
__formal$dead$ = 32
??$?0AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEAV01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PEAPEAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>, COMDAT

; 138  : 		{	// construct from moved values

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00009	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 139  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEAV01@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PEAPEAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64,std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >, COMDAT

; 55   : 		{	// extract key from element value
; 56   : 		return (_Val.first);

  00000	48 8b c1	 mov	 rax, rcx

; 57   : 		}

  00003	c3		 ret	 0
??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN11@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN11@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z PROC ; std::_Allocate<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 ff ff ff
	ff ff ff ff 03	 mov	 rax, 288230376151711743	; 03ffffffffffffffH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 13		 ja	 SHORT $LN12@Allocate
  00013	48 c1 e1 06	 shl	 rcx, 6
  00017	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00026	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002b	cc		 int	 3
$LN11@Allocate:
??$_Allocate@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z ENDP ; std::_Allocate<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>, COMDAT

; 708  : 		void _Resetp(_Ux *_Px)

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  0001e	b9 18 00 00 00	 mov	 ecx, 24
  00023	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00028	48 85 c0	 test	 rax, rax
  0002b	74 1c		 je	 SHORT $LN5@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0002d	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1
  00034	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$_Ref_count@VEmptyChunk@@@std@@6B@
  00042	48 89 08	 mov	 QWORD PTR [rax], rcx
  00045	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
$LN5@Resetp:

; 717  : 
; 718  : 	template<class _Ux,
; 719  : 		class _Dx>
; 720  : 		void _Resetp(_Ux *_Px, _Dx _Dt)
; 721  : 		{	// release, take ownership of _Px, deleter _Dt
; 722  : 		_TRY_BEGIN	// allocate control block and reset
; 723  : 		_Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
; 724  : 		_CATCH_ALL	// allocation failed, delete resource
; 725  : 		_Dt(_Px);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : //#if _HAS_CPP0X
; 731  : 	template<class _Ux,
; 732  : 		class _Dx,
; 733  : 		class _Alloc>
; 734  : 		void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 735  : 		{	// release, take ownership of _Px, deleter _Dt, allocator _Ax
; 736  : 		typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
; 737  : 		typename _Alloc::template rebind<_Refd>::other _Al = _Ax;
; 738  : 
; 739  : 		_TRY_BEGIN	// allocate control block and reset
; 740  : 		_Refd *_Ptr = _Al.allocate(1);
; 741  : 		::new (_Ptr) _Refd(_Px, _Dt, _Al);
; 742  : 		_Resetp0(_Px, _Ptr);
; 743  : 		_CATCH_ALL	// allocation failed, delete resource
; 744  : 		_Dt(_Px);
; 745  : 		_RERAISE;
; 746  : 		_CATCH_END
; 747  : 		}
; 748  : //#endif /* _HAS_CPP0X */
; 749  : 
; 750  : public:
; 751  : 	template<class _Ux>
; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00049	4c 8b c0	 mov	 r8, rax
  0004c	48 8b d3	 mov	 rdx, rbx
  0004f	48 8b cf	 mov	 rcx, rdi
  00052	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
  00057	90		 npad	 1

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;
; 714  : 		_RERAISE;
; 715  : 		_CATCH_END
; 716  : 		}

  00058	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN30@Resetp:
??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA PROC ; `std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>'::`1'::catch$0

; 712  : 		_CATCH_ALL	// allocation failed, delete resource

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000b	48 8b ea	 mov	 rbp, rdx
__catch$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z$0:

; 713  : 		delete _Px;

  0000e	48 8b 5d 48	 mov	 rbx, QWORD PTR _Px$[rbp]
  00012	48 85 db	 test	 rbx, rbx
  00015	74 1a		 je	 SHORT $LN25@catch$0
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 112  : {

  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  0001e	48 89 03	 mov	 QWORD PTR [rbx], rax

; 113  : 
; 114  : }

  00021	48 8b cb	 mov	 rcx, rbx
  00024	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN25@catch$0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 714  : 		_RERAISE;

  00031	33 d2		 xor	 edx, edx
  00033	33 c9		 xor	 ecx, ecx
  00035	e8 00 00 00 00	 call	 _CxxThrowException
  0003a	90		 npad	 1
?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA ENDP ; `std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEBVChunkPosition@@@std@@YAAEBVChunkPosition@@AEBV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBVChunkPosition@@@std@@YAAEBVChunkPosition@@AEBV1@@Z PROC ; std::forward<ChunkPosition const & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEBVChunkPosition@@@std@@YAAEBVChunkPosition@@AEBV1@@Z ENDP ; std::forward<ChunkPosition const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z PROC ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_V0$ = 56
??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 945  : _VARIADIC_EXPAND_0X(_TREE_BUYNODE, , , , )

$LN98:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx
  00009	e8 00 00 00 00	 call	 ?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode0

; 608  : 		return ((reference)_Pnode->_Myval);

  0000e	48 8d 50 20	 lea	 rdx, QWORD PTR [rax+32]

; 945  : _VARIADIC_EXPAND_0X(_TREE_BUYNODE, , , , )

  00012	4c 8b c0	 mov	 r8, rax
  00015	66 c7 40 18 00
	00		 mov	 WORD PTR [rax+24], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0001b	48 85 d2	 test	 rdx, rdx
  0001e	74 3f		 je	 SHORT $LN63@Buynode
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00020	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00022	48 83 c2 10	 add	 rdx, 16
  00026	4c 8d 4b 10	 lea	 r9, QWORD PTR [rbx+16]
  0002a	89 4a f0	 mov	 DWORD PTR [rdx-16], ecx
  0002d	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  00030	89 4a f4	 mov	 DWORD PTR [rdx-12], ecx
  00033	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]
  00036	89 4a f8	 mov	 DWORD PTR [rdx-8], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00039	33 c9		 xor	 ecx, ecx
  0003b	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0003e	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00042	49 3b d1	 cmp	 rdx, r9
  00045	74 18		 je	 SHORT $LN63@Buynode
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00047	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  0004b	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0004f	49 89 49 08	 mov	 QWORD PTR [r9+8], rcx

; 48   : 	_Left = _Move(_Right);

  00053	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00056	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00059	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  0005c	49 89 09	 mov	 QWORD PTR [r9], rcx
$LN63@Buynode:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 945  : _VARIADIC_EXPAND_0X(_TREE_BUYNODE, , , , )

  0005f	49 8b c0	 mov	 rax, r8
  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5b		 pop	 rbx
  00067	c3		 ret	 0
??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
this$ = 96
__$ReturnUdt$ = 104
_Where$ = 112
_Val$ = 120
_Newnode$ = 128
??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 1664 : 		iterator _Insert_hint(const_iterator _Where,

$LN689:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 30
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00014	4d 8b d1	 mov	 r10, r9
  00017	48 8b da	 mov	 rbx, rdx
  0001a	4c 8b d9	 mov	 r11, rcx

; 1665 : 			_Valty&& _Val, _Nodety _Newnode)
; 1666 : 		{	// try to insert node using _Where as a hint
; 1667 : 		const_iterator _Next;
; 1668 : 		bool _Leftish = false;	// assume nearest point is end of sequence
; 1669 : 
; 1670 : 		_TRY_BEGIN
; 1671 : 
; 1672 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1673 : 		if (_Where._Getcont() != this)
; 1674 : 			_DEBUG_ERROR("map/set insert iterator outside range");
; 1675 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1676 : 
; 1677 : 		if (size() == 0)

  0001d	48 83 79 08 00	 cmp	 QWORD PTR [rcx+8], 0
  00022	75 20		 jne	 SHORT $LN33@Insert_hin

; 1678 : 			return (_Insert_at(true, this->_Myhead,
; 1679 : 				_STD forward<_Valty>(_Val), _Newnode));	// empty tree

  00024	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Newnode$[rsp]
  0002c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00031	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
  00034	41 b0 01	 mov	 r8b, 1
  00037	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
  0003c	48 8b c3	 mov	 rax, rbx
  0003f	e9 d0 02 00 00	 jmp	 $LN35@Insert_hin
$LN33@Insert_hin:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00044	48 8b 09	 mov	 rcx, QWORD PTR [rcx]

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00047	4c 3b 01	 cmp	 r8, QWORD PTR [rcx]

; 1680 : 		else if (this->_Multi)
; 1681 : 			{	// insert even if duplicate
; 1682 : 			if (_Where == begin())
; 1683 : 				{	// insert at beginning if before first element
; 1684 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1685 : 					this->_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 1686 : 					return (_Insert_at(true, _Where._Mynode(),
; 1687 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1688 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1689 : 				}
; 1690 : 			else if (_Where == end())
; 1691 : 				{	// insert at end if after last element
; 1692 : 				if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1693 : 					this->_Kfn(_Val), this->_Key(_Rmost())))
; 1694 : 					return (_Insert_at(false, _Rmost(),
; 1695 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1696 : 				}
; 1697 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1698 : 				this->_Key(_Where._Mynode()), this->_Kfn(_Val))
; 1699 : 				&& !_DEBUG_LT_PRED(this->_Getcomp(),
; 1700 : 					this->_Kfn(_Val),
; 1701 : 					this->_Key((--(_Next = _Where))._Mynode())))
; 1702 : 				{	// insert before _Where
; 1703 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))
; 1704 : 					return (_Insert_at(false, _Next._Mynode(),
; 1705 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1706 : 				else
; 1707 : 					return (_Insert_at(true, _Where._Mynode(),
; 1708 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1709 : 				}
; 1710 : 			else if (!_DEBUG_LT_PRED(this->_Getcomp(),
; 1711 : 				this->_Kfn(_Val), this->_Key(_Where._Mynode()))
; 1712 : 				&& (++(_Next = _Where) == end()
; 1713 : 					|| !_DEBUG_LT_PRED(this->_Getcomp(),
; 1714 : 						this->_Key(_Next._Mynode()), this->_Kfn(_Val))))
; 1715 : 				{	// insert after _Where
; 1716 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))
; 1717 : 					return (_Insert_at(false, _Where._Mynode(),
; 1718 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1719 : 				else
; 1720 : 					return (_Insert_at(true, _Next._Mynode(),
; 1721 : 						_STD forward<_Valty>(_Val), _Newnode));
; 1722 : 				}
; 1723 : 			else
; 1724 : 				_Leftish = true;	// nearest point is beginning of sequence
; 1725 : 			}
; 1726 : 		else
; 1727 : 			{	// insert only if unique
; 1728 : 			if (_Where == begin())

  0004a	75 59		 jne	 SHORT $LN14@Insert_hin
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  0004c	41 8b 01	 mov	 eax, DWORD PTR [r9]
  0004f	41 8b 48 20	 mov	 ecx, DWORD PTR [r8+32]
  00053	3b c1		 cmp	 eax, ecx
  00055	7c 2b		 jl	 SHORT $LN683@Insert_hin

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00057	0f 85 1d 02 00
	00		 jne	 $LN1@Insert_hin

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0005d	41 8b 41 04	 mov	 eax, DWORD PTR [r9+4]
  00061	41 8b 48 24	 mov	 ecx, DWORD PTR [r8+36]
  00065	3b c1		 cmp	 eax, ecx
  00067	7c 19		 jl	 SHORT $LN683@Insert_hin

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00069	0f 85 0b 02 00
	00		 jne	 $LN1@Insert_hin

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0006f	41 8b 40 28	 mov	 eax, DWORD PTR [r8+40]
  00073	41 39 41 08	 cmp	 DWORD PTR [r9+8], eax
  00077	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1730 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  0007a	84 c0		 test	 al, al
  0007c	0f 84 f8 01 00
	00		 je	 $LN1@Insert_hin
$LN683@Insert_hin:

; 1731 : 					this->_Kfn(_Val), this->_Key(_Where._Mynode())))
; 1732 : 					return (_Insert_at(true, _Where._Mynode(),
; 1733 : 						_STD forward<_Valty>(_Val), _Newnode));

  00082	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Newnode$[rsp]
  0008a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008f	4d 8b c8	 mov	 r9, r8
  00092	41 b0 01	 mov	 r8b, 1
  00095	49 8b cb	 mov	 rcx, r11
  00098	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
  0009d	48 8b c3	 mov	 rax, rbx
  000a0	e9 6f 02 00 00	 jmp	 $LN35@Insert_hin
$LN14@Insert_hin:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  000a5	4c 3b c1	 cmp	 r8, rcx

; 1734 : 				}
; 1735 : 			else if (_Where == end())

  000a8	75 5a		 jne	 SHORT $LN11@Insert_hin
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\map

; 56   : 		return (_Val.first);

  000aa	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  000ae	41 8b 41 20	 mov	 eax, DWORD PTR [r9+32]
  000b2	41 8b 0a	 mov	 ecx, DWORD PTR [r10]
  000b5	3b c1		 cmp	 eax, ecx
  000b7	7c 2b		 jl	 SHORT $LN684@Insert_hin

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  000b9	0f 85 bb 01 00
	00		 jne	 $LN1@Insert_hin

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  000bf	41 8b 41 24	 mov	 eax, DWORD PTR [r9+36]
  000c3	41 8b 4a 04	 mov	 ecx, DWORD PTR [r10+4]
  000c7	3b c1		 cmp	 eax, ecx
  000c9	7c 19		 jl	 SHORT $LN684@Insert_hin

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  000cb	0f 85 a9 01 00
	00		 jne	 $LN1@Insert_hin

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  000d1	41 8b 42 08	 mov	 eax, DWORD PTR [r10+8]
  000d5	41 39 41 28	 cmp	 DWORD PTR [r9+40], eax
  000d9	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1737 : 				if (_DEBUG_LT_PRED(this->_Getcomp(),

  000dc	84 c0		 test	 al, al
  000de	0f 84 96 01 00
	00		 je	 $LN1@Insert_hin
$LN684@Insert_hin:

; 1738 : 					this->_Key(_Rmost()), this->_Kfn(_Val)))
; 1739 : 					return (_Insert_at(false, _Rmost(),
; 1740 : 						_STD forward<_Valty>(_Val), _Newnode));

  000e4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Newnode$[rsp]
  000ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f1	45 33 c0	 xor	 r8d, r8d
  000f4	49 8b cb	 mov	 rcx, r11
  000f7	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
  000fc	48 8b c3	 mov	 rax, rbx
  000ff	e9 10 02 00 00	 jmp	 $LN35@Insert_hin
$LN11@Insert_hin:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00104	41 8b 39	 mov	 edi, DWORD PTR [r9]
  00107	41 8b 40 20	 mov	 eax, DWORD PTR [r8+32]
  0010b	3b f8		 cmp	 edi, eax
  0010d	7c 2b		 jl	 SHORT $LN685@Insert_hin

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  0010f	0f 85 bb 00 00
	00		 jne	 $LN8@Insert_hin

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  00115	41 8b 41 04	 mov	 eax, DWORD PTR [r9+4]
  00119	41 8b 50 24	 mov	 edx, DWORD PTR [r8+36]
  0011d	3b c2		 cmp	 eax, edx
  0011f	7c 19		 jl	 SHORT $LN685@Insert_hin

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00121	0f 85 a9 00 00
	00		 jne	 $LN8@Insert_hin

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00127	41 8b 40 28	 mov	 eax, DWORD PTR [r8+40]
  0012b	41 39 41 08	 cmp	 DWORD PTR [r9+8], eax
  0012f	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  00132	84 c0		 test	 al, al
  00134	0f 84 96 00 00
	00		 je	 $LN8@Insert_hin
$LN685@Insert_hin:
  0013a	49 8b c0	 mov	 rax, r8

; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))

  0013d	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0
  00142	74 06		 je	 SHORT $LN490@Insert_hin

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  00144	4d 8b 48 10	 mov	 r9, QWORD PTR [r8+16]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  00148	eb 53		 jmp	 SHORT $LN483@Insert_hin
$LN490@Insert_hin:

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0014a	4d 8b 08	 mov	 r9, QWORD PTR [r8]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0014d	41 80 79 19 00	 cmp	 BYTE PTR [r9+25], 0
  00152	75 1b		 jne	 SHORT $LN672@Insert_hin

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00154	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00158	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0015c	75 3f		 jne	 SHORT $LN483@Insert_hin
  0015e	66 90		 npad	 2
$LL504@Insert_hin:

; 614  : 			_Pnode = _Right(_Pnode);

  00160	4c 8b c8	 mov	 r9, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00163	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00167	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0016b	74 f3		 je	 SHORT $LL504@Insert_hin

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else

  0016d	eb 2e		 jmp	 SHORT $LN483@Insert_hin
$LN672@Insert_hin:

; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  0016f	49 8b 50 08	 mov	 rdx, QWORD PTR [r8+8]
  00173	80 7a 19 00	 cmp	 BYTE PTR [rdx+25], 0
  00177	75 19		 jne	 SHORT $LN485@Insert_hin
  00179	0f 1f 80 00 00
	00 00		 npad	 7
$LL486@Insert_hin:
  00180	48 3b 02	 cmp	 rax, QWORD PTR [rdx]
  00183	75 0d		 jne	 SHORT $LN485@Insert_hin

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00185	48 8b c2	 mov	 rax, rdx

; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00188	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  0018c	80 7a 19 00	 cmp	 BYTE PTR [rdx+25], 0
  00190	74 ee		 je	 SHORT $LL486@Insert_hin
$LN485@Insert_hin:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00192	4c 8b c8	 mov	 r9, rax
  00195	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00199	4c 0f 44 ca	 cmove	 r9, rdx
$LN483@Insert_hin:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  0019d	41 8b 41 20	 mov	 eax, DWORD PTR [r9+32]
  001a1	3b c7		 cmp	 eax, edi
  001a3	0f 8c 33 01 00
	00		 jl	 $LN686@Insert_hin

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  001a9	75 25		 jne	 SHORT $LN8@Insert_hin

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  001ab	41 8b 41 24	 mov	 eax, DWORD PTR [r9+36]
  001af	41 8b 52 04	 mov	 edx, DWORD PTR [r10+4]
  001b3	3b c2		 cmp	 eax, edx
  001b5	0f 8c 21 01 00
	00		 jl	 $LN686@Insert_hin

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  001bb	75 13		 jne	 SHORT $LN8@Insert_hin

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  001bd	41 8b 42 08	 mov	 eax, DWORD PTR [r10+8]
  001c1	41 39 41 28	 cmp	 DWORD PTR [r9+40], eax
  001c5	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1744 : 				&& _DEBUG_LT_PRED(this->_Getcomp(),

  001c8	84 c0		 test	 al, al
  001ca	0f 85 0c 01 00
	00		 jne	 $LN686@Insert_hin
$LN8@Insert_hin:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  001d0	41 8b 40 20	 mov	 eax, DWORD PTR [r8+32]
  001d4	3b c7		 cmp	 eax, edi
  001d6	7c 27		 jl	 SHORT $LN687@Insert_hin

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  001d8	0f 85 9c 00 00
	00		 jne	 $LN1@Insert_hin

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  001de	41 8b 40 24	 mov	 eax, DWORD PTR [r8+36]
  001e2	41 8b 52 04	 mov	 edx, DWORD PTR [r10+4]
  001e6	3b c2		 cmp	 eax, edx
  001e8	7c 15		 jl	 SHORT $LN687@Insert_hin

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  001ea	0f 85 8a 00 00
	00		 jne	 $LN1@Insert_hin

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  001f0	41 8b 42 08	 mov	 eax, DWORD PTR [r10+8]
  001f4	41 39 40 28	 cmp	 DWORD PTR [r8+40], eax
  001f8	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  001fb	84 c0		 test	 al, al
  001fd	74 7b		 je	 SHORT $LN1@Insert_hin
$LN687@Insert_hin:
  001ff	4d 8b c8	 mov	 r9, r8

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00202	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0
  00207	75 45		 jne	 SHORT $LN597@Insert_hin

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00209	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0020d	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00211	75 1b		 jne	 SHORT $LN674@Insert_hin

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00213	4c 8b c8	 mov	 r9, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00216	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00219	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0021d	75 2f		 jne	 SHORT $LN597@Insert_hin
  0021f	90		 npad	 1
$LL612@Insert_hin:

; 621  : 			_Pnode = _Left(_Pnode);

  00220	4c 8b c8	 mov	 r9, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00223	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00226	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0022a	74 f4		 je	 SHORT $LL612@Insert_hin

; 65   : 		else

  0022c	eb 20		 jmp	 SHORT $LN597@Insert_hin
$LN674@Insert_hin:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  0022e	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00232	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00236	75 13		 jne	 SHORT $LN595@Insert_hin
$LL596@Insert_hin:
  00238	4c 3b 48 10	 cmp	 r9, QWORD PTR [rax+16]
  0023c	75 0d		 jne	 SHORT $LN595@Insert_hin

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  0023e	4c 8b c8	 mov	 r9, rax

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00241	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00245	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00249	74 ed		 je	 SHORT $LL596@Insert_hin
$LN595@Insert_hin:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  0024b	4c 8b c8	 mov	 r9, rax
$LN597@Insert_hin:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  0024e	4c 3b c9	 cmp	 r9, rcx

; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  00251	74 4f		 je	 SHORT $LN3@Insert_hin
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00253	41 8b 41 20	 mov	 eax, DWORD PTR [r9+32]
  00257	3b f8		 cmp	 edi, eax
  00259	7c 47		 jl	 SHORT $LN3@Insert_hin

; 288  : 	{
; 289  : 		return true;
; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  0025b	75 1d		 jne	 SHORT $LN1@Insert_hin

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  0025d	41 8b 42 04	 mov	 eax, DWORD PTR [r10+4]
  00261	41 8b 49 24	 mov	 ecx, DWORD PTR [r9+36]
  00265	3b c1		 cmp	 eax, ecx
  00267	7c 39		 jl	 SHORT $LN3@Insert_hin

; 294  : 		{
; 295  : 			return true;
; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00269	75 0f		 jne	 SHORT $LN1@Insert_hin

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  0026b	41 8b 41 28	 mov	 eax, DWORD PTR [r9+40]
  0026f	41 39 42 08	 cmp	 DWORD PTR [r10+8], eax
  00273	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1758 : 					|| _DEBUG_LT_PRED(this->_Getcomp(),

  00276	84 c0		 test	 al, al
  00278	75 28		 jne	 SHORT $LN3@Insert_hin
$LN1@Insert_hin:

; 1767 : 				}
; 1768 : 			}
; 1769 : 		_CATCH_ALL
; 1770 : 		_Destroy_if_not_nil(_Newnode);
; 1771 : 		_RERAISE;
; 1772 : 		_CATCH_END
; 1773 : 
; 1774 : 		return (_Insert_nohint(_Leftish,
; 1775 : 			_STD forward<_Valty>(_Val), _Newnode).first);

  0027a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Newnode$[rsp]
  00282	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00287	4d 8b ca	 mov	 r9, r10
  0028a	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T2[rsp]
  0028f	49 8b cb	 mov	 rcx, r11
  00292	e8 00 00 00 00	 call	 ??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
  00297	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0029a	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0029d	48 8b c3	 mov	 rax, rbx
  002a0	eb 72		 jmp	 SHORT $LN35@Insert_hin
$LN3@Insert_hin:

; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  002a2	49 8b 40 10	 mov	 rax, QWORD PTR [r8+16]

; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));

  002a6	48 8b d3	 mov	 rdx, rbx
  002a9	49 8b cb	 mov	 rcx, r11

; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  002ac	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0

; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));

  002b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Newnode$[rsp]
  002b8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax

; 1759 : 						this->_Kfn(_Val), this->_Key(_Next._Mynode()))))
; 1760 : 				{	// insert after _Where
; 1761 : 				if (this->_Isnil(this->_Right(_Where._Mynode())))

  002bd	74 10		 je	 SHORT $LN2@Insert_hin

; 1762 : 					return (_Insert_at(false, _Where._Mynode(),
; 1763 : 						_STD forward<_Valty>(_Val), _Newnode));

  002bf	4d 8b c8	 mov	 r9, r8
  002c2	45 33 c0	 xor	 r8d, r8d
  002c5	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
  002ca	48 8b c3	 mov	 rax, rbx
  002cd	eb 45		 jmp	 SHORT $LN35@Insert_hin
$LN2@Insert_hin:

; 1764 : 				else
; 1765 : 					return (_Insert_at(true, _Next._Mynode(),
; 1766 : 						_STD forward<_Valty>(_Val), _Newnode));

  002cf	41 b0 01	 mov	 r8b, 1
  002d2	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
  002d7	48 8b c3	 mov	 rax, rbx
  002da	eb 38		 jmp	 SHORT $LN35@Insert_hin
$LN686@Insert_hin:

; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  002dc	49 8b 41 10	 mov	 rax, QWORD PTR [r9+16]

; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));

  002e0	48 8b d3	 mov	 rdx, rbx
  002e3	49 8b cb	 mov	 rcx, r11

; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  002e6	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0

; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));

  002ea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Newnode$[rsp]
  002f2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax

; 1745 : 					this->_Key((--(_Next = _Where))._Mynode()),
; 1746 : 					this->_Kfn(_Val)))
; 1747 : 				{	// insert before _Where
; 1748 : 				if (this->_Isnil(this->_Right(_Next._Mynode())))

  002f7	74 0d		 je	 SHORT $LN7@Insert_hin

; 1749 : 					return (_Insert_at(false, _Next._Mynode(),
; 1750 : 						_STD forward<_Valty>(_Val), _Newnode));

  002f9	45 33 c0	 xor	 r8d, r8d
  002fc	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
  00301	48 8b c3	 mov	 rax, rbx
  00304	eb 0e		 jmp	 SHORT $LN35@Insert_hin
$LN7@Insert_hin:

; 1751 : 				else
; 1752 : 					return (_Insert_at(true, _Where._Mynode(),
; 1753 : 						_STD forward<_Valty>(_Val), _Newnode));

  00306	4d 8b c8	 mov	 r9, r8
  00309	41 b0 01	 mov	 r8b, 1
  0030c	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
  00311	48 8b c3	 mov	 rax, rbx
$LN35@Insert_hin:

; 1776 : 		}

  00314	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00319	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0031d	5f		 pop	 rdi
  0031e	c3		 ret	 0
  0031f	cc		 int	 3
$LN688@Insert_hin:
??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
this$ = 96
__$ReturnUdt$ = 104
_Where$ = 112
_Val$ = 120
_Newnode$ = 128
?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>'::`1'::catch$0

; 1769 : 		_CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z$0:

; 1770 : 		_Destroy_if_not_nil(_Newnode);

  0000d	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Newnode$[rbp]
  00014	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil

; 1771 : 		_RERAISE;

  00019	33 d2		 xor	 edx, edx
  0001b	33 c9		 xor	 ecx, ecx
  0001d	e8 00 00 00 00	 call	 _CxxThrowException
  00022	90		 npad	 1
?catch$0@?0???$_Insert_hint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_hint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@AEBV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$dead$ = 16
??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@AEBV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 399  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 400  : 	return (_Cat);

  00000	48 8b c1	 mov	 rax, rcx

; 401  : 	}

  00003	c3		 ret	 0
??$_Iter_cat@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@AEBV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_KUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
__formal$dead$ = 32
??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_KUbidirectional_iterator_tag@0@@Z PROC ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>, COMDAT

; 797  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00005	48 3b ca	 cmp	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00008	74 6e		 je	 SHORT $LN1@Distance2
  0000a	4d 8b 08	 mov	 r9, QWORD PTR [r8]
  0000d	0f 1f 00	 npad	 3
$LL12@Distance2:

; 799  : 		++_Off;

  00010	49 ff c1	 inc	 r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00013	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00017	75 57		 jne	 SHORT $LN51@Distance2

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00019	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  0001d	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00021	75 20		 jne	 SHORT $LN48@Distance2

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  00023	48 8b c8	 mov	 rcx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00029	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0002d	75 0d		 jne	 SHORT $LN26@Distance2
  0002f	90		 npad	 1
$LL27@Distance2:

; 621  : 			_Pnode = _Left(_Pnode);

  00030	48 8b c8	 mov	 rcx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00033	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00036	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0003a	74 f4		 je	 SHORT $LL27@Distance2
$LN26@Distance2:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0003c	48 89 4c 24 08	 mov	 QWORD PTR _First$[rsp], rcx

; 65   : 		else

  00041	eb 2d		 jmp	 SHORT $LN51@Distance2
$LN48@Distance2:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00043	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00047	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0004b	75 1b		 jne	 SHORT $LN10@Distance2
  0004d	0f 1f 00	 npad	 3
$LL11@Distance2:
  00050	48 3b 48 10	 cmp	 rcx, QWORD PTR [rax+16]
  00054	75 12		 jne	 SHORT $LN10@Distance2

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  00056	48 89 44 24 08	 mov	 QWORD PTR _First$[rsp], rax
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00062	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00066	74 e8		 je	 SHORT $LL11@Distance2
$LN10@Distance2:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00068	48 8b c8	 mov	 rcx, rax
  0006b	48 89 44 24 08	 mov	 QWORD PTR _First$[rsp], rax
$LN51@Distance2:

; 336  : 		return (this->_Ptr == _Right._Ptr);

  00070	48 3b ca	 cmp	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00073	75 9b		 jne	 SHORT $LL12@Distance2
  00075	4d 89 08	 mov	 QWORD PTR [r8], r9
$LN1@Distance2:

; 800  : 	}

  00078	f3 c3		 fatret	 0
??$_Distance2@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_KUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

$LN23:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN18@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN21@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN21@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN21@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN18@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 758  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);
; 758  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN7@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN7@construct:

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??_GEmptyChunk@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GEmptyChunk@@QEAAPEAXI@Z PROC			; EmptyChunk::`scalar deleting destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 112  : {

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax

; 113  : 
; 114  : }

  00013	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00018	48 8b cb	 mov	 rcx, rbx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00020	48 8b c3	 mov	 rax, rbx
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??_GEmptyChunk@@QEAAPEAXI@Z ENDP			; EmptyChunk::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size, COMDAT

; 1273 : 		return (this->_Mysize);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1274 : 		}

  00004	c3		 ret	 0
?size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Newnode$ = 56
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil, COMDAT

; 1651 : 		{	// node exists, destroy it

$LN39:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0000a	48 8b 5a 38	 mov	 rbx, QWORD PTR [rdx+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1651 : 		{	// node exists, destroy it

  0000e	48 8b f2	 mov	 rsi, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00011	48 85 db	 test	 rbx, rbx
  00014	74 27		 je	 SHORT $LN28@Destroy_if

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00016	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0001a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0001f	75 17		 jne	 SHORT $LN37@Destroy_if

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00021	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00024	48 8b cb	 mov	 rcx, rbx
  00027	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00029	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0002d	75 09		 jne	 SHORT $LN37@Destroy_if

; 128  : 			_Delete_this();

  0002f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00032	48 8b cb	 mov	 rcx, rbx
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
$LN37@Destroy_if:
  00038	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN28@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0003d	48 8b ce	 mov	 rcx, rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1656 : 		}

  00040	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5e		 pop	 rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0004a	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 48
?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode0, COMDAT

; 897  : 		{	// allocate a non-value node

$LN98:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00009	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0000e	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00013	48 8b d0	 mov	 rdx, rax
  00016	48 85 c0	 test	 rax, rax
  00019	74 2d		 je	 SHORT $LN96@Buynode0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0001b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  0001e	48 8d 4a 08	 lea	 rcx, QWORD PTR [rdx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00022	48 89 02	 mov	 QWORD PTR [rdx], rax
  00025	48 85 c9	 test	 rcx, rcx
  00028	74 06		 je	 SHORT $LN61@Buynode0
  0002a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002d	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN61@Buynode0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00030	48 8d 4a 10	 lea	 rcx, QWORD PTR [rdx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00034	48 85 c9	 test	 rcx, rcx
  00037	74 06		 je	 SHORT $LN83@Buynode0
  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN83@Buynode0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 912  : 		return (_Pnode);

  0003f	48 8b c2	 mov	 rax, rdx

; 913  : 		}

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
$LN96@Buynode0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00048	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0004d	cc		 int	 3
$LN95@Buynode0:
?_Buynode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Pnode$ = 16
?_Freenode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode0, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?_Freenode0@?$_Tree_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_Tree_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 411  : 		{	// preincrement

  00003	48 8b d1	 mov	 rdx, rcx

; 60   : 		if (_Mytree::_Isnil(_Ptr))

  00006	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0000a	75 4d		 jne	 SHORT $LN43@operator

; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  0000c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

  00010	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00014	75 1d		 jne	 SHORT $LN38@operator

; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00019	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0001d	75 0d		 jne	 SHORT $LN21@operator
  0001f	90		 npad	 1
$LL22@operator:

; 621  : 			_Pnode = _Left(_Pnode);

  00020	48 8b c8	 mov	 rcx, rax

; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00023	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))
; 614  : 			_Pnode = _Right(_Pnode);
; 615  : 		return (_Pnode);
; 616  : 		}
; 617  : 
; 618  : 	static _Nodeptr _Min(_Nodeptr _Pnode)
; 619  : 		{	// return leftmost node in subtree at _Pnode
; 620  : 		while (!_Isnil(_Left(_Pnode)))

  00026	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0002a	74 f4		 je	 SHORT $LL22@operator
$LN21@operator:

; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree

  0002c	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);

  0002f	48 8b c2	 mov	 rax, rdx

; 414  : 		}

  00032	c3		 ret	 0
$LN38@operator:

; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

  00033	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00037	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0003b	75 19		 jne	 SHORT $LN5@operator
  0003d	0f 1f 00	 npad	 3
$LL6@operator:
  00040	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00044	48 39 0a	 cmp	 QWORD PTR [rdx], rcx
  00047	75 0d		 jne	 SHORT $LN5@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

  00049	48 89 02	 mov	 QWORD PTR [rdx], rax
  0004c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00050	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00054	74 ea		 je	 SHORT $LL6@operator
$LN5@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

  00056	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN43@operator:

; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);

  00059	48 8b c2	 mov	 rax, rdx

; 414  : 		}

  0005c	c3		 ret	 0
??E?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 39   : 		{	// construct with null node pointer

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 210  : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	c3		 ret	 0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--, COMDAT

; 283  : 		{	// predecrement

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);

  00009	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--

; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);

  0000e	48 8b c3	 mov	 rax, rbx

; 312  : 		}

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	c3		 ret	 0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VEmptyChunk@@@std@@QEAA@PEAVEmptyChunk@@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
??0?$_Ref_count@VEmptyChunk@@@std@@QEAA@PEAVEmptyChunk@@@Z PROC ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>, COMDAT

; 155  : 		{	// construct

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_Ref_count@VEmptyChunk@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00007	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [rcx+8], 1
  0000e	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 156  : 		}

  00018	48 8b c1	 mov	 rax, rcx
  0001b	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  0001f	c3		 ret	 0
??0?$_Ref_count@VEmptyChunk@@@std@@QEAA@PEAVEmptyChunk@@@Z ENDP ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ PROC	; std::_Ref_count<EmptyChunk>::_Destroy, COMDAT

; 160  : 		{	// destroy managed resource

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 161  : 		delete _Ptr;

  00006	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 1f		 je	 SHORT $LN5@Destroy
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 112  : {

  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@

; 113  : 
; 114  : }

  00016	48 8b cb	 mov	 rcx, rbx
  00019	48 89 03	 mov	 QWORD PTR [rbx], rax
  0001c	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00021	48 8b cb	 mov	 rcx, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 162  : 		}

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
$LN5@Destroy:
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ ENDP	; std::_Ref_count<EmptyChunk>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ PROC ; std::_Ref_count<EmptyChunk>::_Delete_this, COMDAT

; 166  : 		delete this;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 0c		 je	 SHORT $LN3@Delete_thi
  00005	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00008	ba 01 00 00 00	 mov	 edx, 1
  0000d	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
$LN3@Delete_thi:

; 167  : 		}

  00011	f3 c3		 fatret	 0
?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ ENDP ; std::_Ref_count<EmptyChunk>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z PROC	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor', COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN8@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN8@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z ENDP	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VEmptyChunk@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Ref_count@VEmptyChunk@@@std@@UEAA@XZ PROC		; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>, COMDAT

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1?$_Ref_count@VEmptyChunk@@@std@@UEAA@XZ ENDP		; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>, COMDAT

; 39   : 		{	// construct with null node pointer

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 40   : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	c3		 ret	 0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--, COMDAT

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 84   : 		{	// predecrement

  00003	48 8b d1	 mov	 rdx, rcx

; 85   : 		if (_Mytree::_Isnil(_Ptr))

  00006	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0000a	74 0b		 je	 SHORT $LN8@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  0000c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax

; 100  : 			}
; 101  : 		return (*this);

  00013	48 8b c1	 mov	 rax, rcx

; 102  : 		}

  00016	c3		 ret	 0
$LN8@operator:

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00017	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  0001a	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0001e	75 24		 jne	 SHORT $LN40@operator

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00020	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00024	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00028	75 44		 jne	 SHORT $LN21@operator
  0002a	66 0f 1f 44 00
	00		 npad	 6
$LL22@operator:

; 614  : 			_Pnode = _Right(_Pnode);

  00030	48 8b c8	 mov	 rcx, rax

; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00033	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);
; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);
; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  00037	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0003b	74 f3		 je	 SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0003d	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 100  : 			}
; 101  : 		return (*this);

  00040	48 8b c2	 mov	 rax, rdx

; 102  : 		}

  00043	c3		 ret	 0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00044	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00048	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0004c	75 17		 jne	 SHORT $LN3@operator
  0004e	66 90		 npad	 2
$LL4@operator:
  00050	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00053	48 39 02	 cmp	 QWORD PTR [rdx], rax
  00056	75 0d		 jne	 SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00058	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0005b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0005f	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00063	74 eb		 je	 SHORT $LL4@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00065	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00068	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  0006c	75 03		 jne	 SHORT $LN45@operator
$LN21@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

  0006e	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN45@operator:

; 100  : 			}
; 101  : 		return (*this);

  00071	48 8b c2	 mov	 rax, rdx

; 102  : 		}

  00074	c3		 ret	 0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVEmptyChunk@@PEAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
_Rx$ = 24
??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVEmptyChunk@@PEAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>, COMDAT

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00000	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVEmptyChunk@@PEAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 42		 je	 SHORT $LN44@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	48 83 c2 10	 add	 rdx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0000c	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0000e	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  00011	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00015	49 83 c0 10	 add	 r8, 16
  00019	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  0001c	41 8b 40 f8	 mov	 eax, DWORD PTR [r8-8]
  00020	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00023	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00026	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0002a	49 3b d0	 cmp	 rdx, r8
  0002d	74 18		 je	 SHORT $LN44@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0002f	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00033	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00037	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0003b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0003e	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00041	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00044	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN44@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00047	f3 c3		 fatret	 0
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z PROC ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Addleft$ = 64
_Wherenode$ = 72
_Val$dead$ = 80
_Node$ = 88
??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 1836 : 		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,

$LN420:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1837 : 		_Valty&& _Val, _Nodety _Node)
; 1838 : 		{	// add node with value next to _Wherenode, to left if _Addleft
; 1839 : 		if (max_size() - 1 <= this->_Mysize)

  00006	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0000a	4c 8b d1	 mov	 r10, rcx
  0000d	48 b9 fe ff ff
	ff ff ff ff 03	 mov	 rcx, 288230376151711742	; 03fffffffffffffeH
  00017	48 8b da	 mov	 rbx, rdx
  0001a	48 3b c1	 cmp	 rax, rcx
  0001d	72 3d		 jb	 SHORT $LN17@Insert_at
  0001f	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00024	48 8b 74 24 58	 mov	 rsi, QWORD PTR _Node$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00029	48 8b 5e 38	 mov	 rbx, QWORD PTR [rsi+56]
  0002d	48 85 db	 test	 rbx, rbx
  00030	0f 84 9f 02 00
	00		 je	 $LN57@Insert_at

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00036	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0003a	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0003f	0f 85 8b 02 00
	00		 jne	 $LN414@Insert_at

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00045	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00048	48 8b cb	 mov	 rcx, rbx
  0004b	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0004d	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00051	0f 85 79 02 00
	00		 jne	 $LN414@Insert_at
  00057	e9 6b 02 00 00	 jmp	 $LN418@Insert_at
$LN17@Insert_at:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1848 : 		_Newnode->_Parent = _Wherenode;

  0005c	4c 8b 5c 24 58	 mov	 r11, QWORD PTR _Node$[rsp]
  00061	48 ff c0	 inc	 rax
  00064	49 89 42 08	 mov	 QWORD PTR [r10+8], rax
  00068	4d 89 4b 08	 mov	 QWORD PTR [r11+8], r9

; 1849 : 
; 1850 : 		if (_Wherenode == this->_Myhead)

  0006c	49 8b 02	 mov	 rax, QWORD PTR [r10]
  0006f	4c 3b c8	 cmp	 r9, rax
  00072	75 0f		 jne	 SHORT $LN16@Insert_at

; 1851 : 			{	// first node in tree, just set head values
; 1852 : 			_Root() = _Newnode;

  00074	4c 89 58 08	 mov	 QWORD PTR [rax+8], r11

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00078	49 8b 02	 mov	 rax, QWORD PTR [r10]

; 1853 : 			_Lmost() = _Newnode;

  0007b	4c 89 18	 mov	 QWORD PTR [rax], r11

; 1854 : 			_Rmost() = _Newnode;

  0007e	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00081	eb 22		 jmp	 SHORT $LN416@Insert_at
$LN16@Insert_at:

; 1855 : 			}
; 1856 : 		else if (_Addleft)

  00083	45 84 c0	 test	 r8b, r8b
  00086	74 10		 je	 SHORT $LN14@Insert_at

; 1857 : 			{	// add to left of _Wherenode
; 1858 : 			this->_Left(_Wherenode) = _Newnode;

  00088	4d 89 19	 mov	 QWORD PTR [r9], r11

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  0008b	49 8b 02	 mov	 rax, QWORD PTR [r10]

; 1859 : 			if (_Wherenode == _Lmost())

  0008e	4c 3b 08	 cmp	 r9, QWORD PTR [rax]
  00091	75 16		 jne	 SHORT $LN11@Insert_at

; 1860 : 				_Lmost() = _Newnode;

  00093	4c 89 18	 mov	 QWORD PTR [rax], r11

; 1861 : 			}
; 1862 : 		else

  00096	eb 11		 jmp	 SHORT $LN11@Insert_at
$LN14@Insert_at:

; 1863 : 			{	// add to right of _Wherenode
; 1864 : 			this->_Right(_Wherenode) = _Newnode;

  00098	4d 89 59 10	 mov	 QWORD PTR [r9+16], r11

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  0009c	49 8b 02	 mov	 rax, QWORD PTR [r10]

; 1865 : 			if (_Wherenode == _Rmost())

  0009f	4c 3b 48 10	 cmp	 r9, QWORD PTR [rax+16]
  000a3	75 04		 jne	 SHORT $LN11@Insert_at
$LN416@Insert_at:

; 1866 : 				_Rmost() = _Newnode;

  000a5	4c 89 58 10	 mov	 QWORD PTR [rax+16], r11
$LN11@Insert_at:

; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  000a9	49 8b 4b 08	 mov	 rcx, QWORD PTR [r11+8]
  000ad	49 8b c3	 mov	 rax, r11
  000b0	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  000b4	0f 85 f6 01 00
	00		 jne	 $LN9@Insert_at
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL10@Insert_at:

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  000c0	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  000c4	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]

; 1871 : 			if (this->_Parent(_Pnode)
; 1872 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

  000c8	49 8b 10	 mov	 rdx, QWORD PTR [r8]
  000cb	48 3b ca	 cmp	 rcx, rdx
  000ce	0f 85 f1 00 00
	00		 jne	 $LN8@Insert_at

; 1873 : 				{	// fixup red-red in left subtree
; 1874 : 				_Wherenode =
; 1875 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));

  000d4	49 8b 50 10	 mov	 rdx, QWORD PTR [r8+16]

; 1876 : 				if (this->_Color(_Wherenode) == this->_Red)

  000d8	80 7a 18 00	 cmp	 BYTE PTR [rdx+24], 0
  000dc	75 21		 jne	 SHORT $LN7@Insert_at

; 1877 : 					{	// parent has two red children, blacken both
; 1878 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  000de	c6 41 18 01	 mov	 BYTE PTR [rcx+24], 1

; 1879 : 					this->_Color(_Wherenode) = this->_Black;

  000e2	c6 42 18 01	 mov	 BYTE PTR [rdx+24], 1

; 1880 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1881 : 						= this->_Red;

  000e6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000ea	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  000ee	c6 42 18 00	 mov	 BYTE PTR [rdx+24], 0

; 1882 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  000f2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000f6	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1883 : 					}
; 1884 : 				else

  000fa	e9 a3 01 00 00	 jmp	 $LN354@Insert_at
$LN7@Insert_at:

; 1885 : 					{	// parent has red and black children
; 1886 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

  000ff	48 3b 41 10	 cmp	 rax, QWORD PTR [rcx+16]
  00103	75 4b		 jne	 SHORT $LN149@Insert_at

; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();
; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))
; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;
; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate
; 2105 : 		}
; 2106 : 
; 2107 : 	_Nodeptr& _Lmost() const
; 2108 : 		{	// return leftmost node in nonmutable tree
; 2109 : 		return (this->_Left(this->_Myhead));
; 2110 : 		}
; 2111 : 
; 2112 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2113 : 		{	// promote right node to root of subtree
; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  00105	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]

; 1887 : 						{	// rotate right child to left
; 1888 : 						_Pnode = this->_Parent(_Pnode);

  00109	48 8b c1	 mov	 rax, rcx

; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0010c	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  0010f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00113	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]

; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00116	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0011a	75 04		 jne	 SHORT $LN148@Insert_at

; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  0011c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN148@Insert_at:

; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00120	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00124	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00128	49 8b 0a	 mov	 rcx, QWORD PTR [r10]

; 2120 : 
; 2121 : 		if (_Wherenode == _Root())

  0012b	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  0012f	75 06		 jne	 SHORT $LN147@Insert_at

; 2122 : 			_Root() = _Pnode;

  00131	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00135	eb 12		 jmp	 SHORT $LN144@Insert_at
$LN147@Insert_at:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00137	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  0013b	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  0013e	75 05		 jne	 SHORT $LN145@Insert_at

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00140	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 2125 : 		else

  00143	eb 04		 jmp	 SHORT $LN144@Insert_at
$LN145@Insert_at:

; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00145	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
$LN144@Insert_at:

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  00149	48 89 02	 mov	 QWORD PTR [rdx], rax

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  0014c	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx
$LN149@Insert_at:

; 1889 : 						_Lrotate(_Pnode);
; 1890 : 						}
; 1891 : 					this->_Color(this->_Parent(_Pnode)) =
; 1892 : 						this->_Black;	// propagate red up

  00150	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00154	c6 41 18 01	 mov	 BYTE PTR [rcx+24], 1

; 1893 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1894 : 						this->_Red;

  00158	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0015c	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00160	c6 42 18 00	 mov	 BYTE PTR [rdx+24], 0

; 1895 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

  00164	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00168	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]

; 2130 : 		}
; 2131 : 
; 2132 : 	_Nodeptr& _Rmost() const
; 2133 : 		{	// return rightmost node in nonmutable tree
; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}
; 2136 : 
; 2137 : 	_Nodeptr& _Root() const
; 2138 : 		{	// return root of nonmutable tree
; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}
; 2141 : 
; 2142 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2143 : 		{	// promote left node to root of subtree
; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  0016c	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  0016f	49 8b 48 10	 mov	 rcx, QWORD PTR [r8+16]
  00173	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00176	49 8b 48 10	 mov	 rcx, QWORD PTR [r8+16]

; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  0017a	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0017e	75 04		 jne	 SHORT $LN211@Insert_at

; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00180	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
$LN211@Insert_at:

; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00184	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00188	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  0018c	49 8b 0a	 mov	 rcx, QWORD PTR [r10]

; 2150 : 
; 2151 : 		if (_Wherenode == _Root())

  0018f	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00193	75 0d		 jne	 SHORT $LN210@Insert_at

; 2152 : 			_Root() = _Pnode;

  00195	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  00199	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx

; 1896 : 					}
; 1897 : 				}
; 1898 : 			else

  0019d	e9 fc 00 00 00	 jmp	 $LN417@Insert_at
$LN210@Insert_at:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  001a2	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  001a6	48 3b 51 10	 cmp	 rdx, QWORD PTR [rcx+16]
  001aa	75 0d		 jne	 SHORT $LN208@Insert_at

; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  001ac	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  001b0	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx

; 1896 : 					}
; 1897 : 				}
; 1898 : 			else

  001b4	e9 e5 00 00 00	 jmp	 $LN417@Insert_at
$LN208@Insert_at:

; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  001b9	4c 89 01	 mov	 QWORD PTR [rcx], r8

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  001bc	49 89 50 10	 mov	 QWORD PTR [r8+16], rdx

; 1896 : 					}
; 1897 : 				}
; 1898 : 			else

  001c0	e9 d9 00 00 00	 jmp	 $LN417@Insert_at
$LN8@Insert_at:

; 1899 : 				{	// fixup red-red in right subtree
; 1900 : 				_Wherenode =
; 1901 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1902 : 				if (this->_Color(_Wherenode) == this->_Red)

  001c5	80 7a 18 00	 cmp	 BYTE PTR [rdx+24], 0
  001c9	75 21		 jne	 SHORT $LN3@Insert_at

; 1903 : 					{	// parent has two red children, blacken both
; 1904 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

  001cb	c6 41 18 01	 mov	 BYTE PTR [rcx+24], 1

; 1905 : 					this->_Color(_Wherenode) = this->_Black;

  001cf	c6 42 18 01	 mov	 BYTE PTR [rdx+24], 1

; 1906 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1907 : 						this->_Red;

  001d3	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001d7	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  001db	c6 42 18 00	 mov	 BYTE PTR [rdx+24], 0

; 1908 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

  001df	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  001e3	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1909 : 					}
; 1910 : 				else

  001e7	e9 b6 00 00 00	 jmp	 $LN354@Insert_at
$LN3@Insert_at:

; 1911 : 					{	// parent has red and black children
; 1912 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

  001ec	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
  001ef	75 4d		 jne	 SHORT $LN291@Insert_at

; 2130 : 		}
; 2131 : 
; 2132 : 	_Nodeptr& _Rmost() const
; 2133 : 		{	// return rightmost node in nonmutable tree
; 2134 : 		return (this->_Right(this->_Myhead));
; 2135 : 		}
; 2136 : 
; 2137 : 	_Nodeptr& _Root() const
; 2138 : 		{	// return root of nonmutable tree
; 2139 : 		return (this->_Parent(this->_Myhead));
; 2140 : 		}
; 2141 : 
; 2142 : 	void _Rrotate(_Nodeptr _Wherenode)
; 2143 : 		{	// promote left node to root of subtree
; 2144 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

  001f1	48 8b 11	 mov	 rdx, QWORD PTR [rcx]

; 1913 : 						{	// rotate left child to right
; 1914 : 						_Pnode = this->_Parent(_Pnode);

  001f4	48 8b c1	 mov	 rax, rcx

; 2145 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

  001f7	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  001fb	48 89 08	 mov	 QWORD PTR [rax], rcx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  001fe	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]

; 2146 : 
; 2147 : 		if (!this->_Isnil(this->_Right(_Pnode)))

  00202	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  00206	75 04		 jne	 SHORT $LN290@Insert_at

; 2148 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

  00208	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN290@Insert_at:

; 2149 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  0020c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00210	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00214	49 8b 0a	 mov	 rcx, QWORD PTR [r10]

; 2150 : 
; 2151 : 		if (_Wherenode == _Root())

  00217	48 3b 41 08	 cmp	 rax, QWORD PTR [rcx+8]
  0021b	75 06		 jne	 SHORT $LN289@Insert_at

; 2152 : 			_Root() = _Pnode;

  0021d	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00221	eb 13		 jmp	 SHORT $LN286@Insert_at
$LN289@Insert_at:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);

  00223	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 2153 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

  00227	48 3b 41 10	 cmp	 rax, QWORD PTR [rcx+16]
  0022b	75 06		 jne	 SHORT $LN287@Insert_at

; 2154 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  0022d	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 2155 : 		else

  00231	eb 03		 jmp	 SHORT $LN286@Insert_at
$LN287@Insert_at:

; 2156 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00233	48 89 11	 mov	 QWORD PTR [rcx], rdx
$LN286@Insert_at:

; 2157 : 
; 2158 : 		this->_Right(_Pnode) = _Wherenode;

  00236	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 2159 : 		this->_Parent(_Wherenode) = _Pnode;

  0023a	48 89 50 08	 mov	 QWORD PTR [rax+8], rdx
$LN291@Insert_at:

; 1915 : 						_Rrotate(_Pnode);
; 1916 : 						}
; 1917 : 					this->_Color(this->_Parent(_Pnode)) =
; 1918 : 						this->_Black;	// propagate red up

  0023e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00242	c6 41 18 01	 mov	 BYTE PTR [rcx+24], 1

; 1919 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
; 1920 : 						this->_Red;

  00246	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0024a	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0024e	c6 42 18 00	 mov	 BYTE PTR [rdx+24], 0

; 1921 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

  00252	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00256	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]

; 1928 : 
; 1929 : 	template<class _Moveit>
; 1930 : 		void _Copy(const _Myt& _Right,
; 1931 : 			_Moveit _Movefl)
; 1932 : 		{	// copy or move entire tree from _Right
; 1933 : 		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
; 1934 : 		this->_Mysize = _Right.size();
; 1935 : 		if (!this->_Isnil(_Root()))
; 1936 : 			{	// nonempty tree, look for new smallest and largest
; 1937 : 			_Lmost() = this->_Min(_Root());
; 1938 : 			_Rmost() = this->_Max(_Root());
; 1939 : 			}
; 1940 : 		else
; 1941 : 			{	// empty tree, just tidy head pointers
; 1942 : 			_Lmost() = this->_Myhead;
; 1943 : 			_Rmost() = this->_Myhead;
; 1944 : 			}
; 1945 : 		}
; 1946 : 
; 1947 : template<class _Want_to_move,
; 1948 : 	class _Can_move>
; 1949 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move, _Can_move)
; 1950 : 		{	// copy to new node
; 1951 : 		return (this->_Buynode(this->_Myval(_Rootnode)));
; 1952 : 		}
; 1953 : 
; 1954 : 	_Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type, true_type)
; 1955 : 		{	// move to new node -- movable
; 1956 : 		return (this->_Buynode(
; 1957 : 			_STD forward<value_type>(this->_Myval(_Rootnode))));
; 1958 : 		}
; 1959 : 
; 1960 : 	template<class _Moveit>
; 1961 : 		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
; 1962 : 			_Moveit _Movefl)
; 1963 : 		{	// copy entire subtree, recursively
; 1964 : 		_Nodeptr _Newroot = this->_Myhead;	// point at nil node
; 1965 : 
; 1966 : 		if (!this->_Isnil(_Rootnode))
; 1967 : 			{	// copy or move a node, then any subtrees
; 1968 : 			_Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
; 1969 : 				typename is_move_constructible<value_type>::type());
; 1970 : 			_Pnode->_Parent = _Wherenode;
; 1971 : 			_Pnode->_Color = this->_Color(_Rootnode);
; 1972 : 			if (this->_Isnil(_Newroot))
; 1973 : 				_Newroot = _Pnode;	// memorize new root
; 1974 : 
; 1975 : 			_TRY_BEGIN
; 1976 : 			this->_Left(_Pnode) =
; 1977 : 				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
; 1978 : 			this->_Right(_Pnode) =
; 1979 : 				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
; 1980 : 			_CATCH_ALL
; 1981 : 			_Erase(_Newroot);	// subtree copy failed, bail out
; 1982 : 			_RERAISE;
; 1983 : 			_CATCH_END
; 1984 : 			}
; 1985 : 
; 1986 : 		return (_Newroot);	// return newly constructed tree
; 1987 : 		}
; 1988 : 
; 1989 : 	_Paircc _Eqrange(const key_type& _Keyval) const
; 1990 : 		{	// find leftmost node not less than _Keyval
; 1991 : 		_Nodeptr _Pnode = _Root();
; 1992 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 1993 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 1994 : 
; 1995 : 		while (!this->_Isnil(_Pnode))
; 1996 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 1997 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 1998 : 			else
; 1999 : 				{	// _Pnode not less than _Keyval, remember it
; 2000 : 				if (this->_Isnil(_Hinode)
; 2001 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2002 : 						this->_Key(_Pnode)))
; 2003 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2004 : 				_Lonode = _Pnode;
; 2005 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2006 : 				}
; 2007 : 
; 2008 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2009 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2010 : 		while (!this->_Isnil(_Pnode))
; 2011 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2012 : 				{	// _Pnode greater than _Keyval, remember it
; 2013 : 				_Hinode = _Pnode;
; 2014 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2015 : 				}
; 2016 : 			else
; 2017 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2018 : 
; 2019 : 		const_iterator _First = const_iterator(_Lonode, this);
; 2020 : 		const_iterator _Last = const_iterator(_Hinode, this);
; 2021 : 		return (_Paircc(_First, _Last));
; 2022 : 		}
; 2023 : 
; 2024 : 	_Pairii _Eqrange(const key_type& _Keyval)
; 2025 : 		{	// find leftmost node not less than _Keyval
; 2026 : 		_Nodeptr _Pnode = _Root();
; 2027 : 		_Nodeptr _Lonode = this->_Myhead;	// end() if search fails
; 2028 : 		_Nodeptr _Hinode = this->_Myhead;	// end() if search fails
; 2029 : 
; 2030 : 		while (!this->_Isnil(_Pnode))
; 2031 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2032 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2033 : 			else
; 2034 : 				{	// _Pnode not less than _Keyval, remember it
; 2035 : 				if (this->_Isnil(_Hinode)
; 2036 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,
; 2037 : 						 this->_Key(_Pnode)))
; 2038 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2039 : 				_Lonode = _Pnode;
; 2040 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2041 : 				}
; 2042 : 
; 2043 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()
; 2044 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2045 : 		while (!this->_Isnil(_Pnode))
; 2046 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))
; 2047 : 				{	// _Pnode greater than _Keyval, remember it
; 2048 : 				_Hinode = _Pnode;
; 2049 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2050 : 				}
; 2051 : 			else
; 2052 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2053 : 
; 2054 : 		iterator _First = iterator(_Lonode, this);
; 2055 : 		iterator _Last = iterator(_Hinode, this);
; 2056 : 		return (_Pairii(_First, _Last));
; 2057 : 		}
; 2058 : 
; 2059 : 	void _Erase(_Nodeptr _Rootnode)
; 2060 : 		{	// free entire subtree, recursively
; 2061 : 		for (_Nodeptr _Pnode = _Rootnode;
; 2062 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
; 2063 : 			{	// free subtrees, then node
; 2064 : 			_Erase(this->_Right(_Pnode));
; 2065 : 			_Pnode = this->_Left(_Pnode);
; 2066 : 			this->_Getal().destroy(
; 2067 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2068 : 
; 2069 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2070 : 			}
; 2071 : 		}
; 2072 : 
; 2073 : 	_Nodeptr _Lbound(const key_type& _Keyval) const
; 2074 : 		{	// find leftmost node not less than _Keyval
; 2075 : 		_Nodeptr _Pnode = _Root();
; 2076 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2077 : 
; 2078 : 		while (!this->_Isnil(_Pnode))
; 2079 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2080 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2081 : 			else
; 2082 : 				{	// _Pnode not less than _Keyval, remember it
; 2083 : 				_Wherenode = _Pnode;
; 2084 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2085 : 				}
; 2086 : 
; 2087 : 		return (_Wherenode);	// return best remembered candidate
; 2088 : 		}
; 2089 : 
; 2090 : 	_Nodeptr _Lbound(const key_type& _Keyval)
; 2091 : 		{	// find leftmost node not less than _Keyval
; 2092 : 		_Nodeptr _Pnode = _Root();
; 2093 : 		_Nodeptr _Wherenode = this->_Myhead;	// end() if search fails
; 2094 : 
; 2095 : 		while (!this->_Isnil(_Pnode))
; 2096 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))
; 2097 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree
; 2098 : 			else
; 2099 : 				{	// _Pnode not less than _Keyval, remember it
; 2100 : 				_Wherenode = _Pnode;
; 2101 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree
; 2102 : 				}
; 2103 : 
; 2104 : 		return (_Wherenode);	// return best remembered candidate
; 2105 : 		}
; 2106 : 
; 2107 : 	_Nodeptr& _Lmost() const
; 2108 : 		{	// return leftmost node in nonmutable tree
; 2109 : 		return (this->_Left(this->_Myhead));
; 2110 : 		}
; 2111 : 
; 2112 : 	void _Lrotate(_Nodeptr _Wherenode)
; 2113 : 		{	// promote right node to root of subtree
; 2114 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

  0025a	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]

; 2115 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

  0025e	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00261	48 89 4a 10	 mov	 QWORD PTR [rdx+16], rcx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))
; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost
; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))
; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree
; 96   : 			if (_Mytree::_Isnil(_Ptr))
; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  00265	49 8b 08	 mov	 rcx, QWORD PTR [r8]

; 2116 : 
; 2117 : 		if (!this->_Isnil(this->_Left(_Pnode)))

  00268	80 79 19 00	 cmp	 BYTE PTR [rcx+25], 0
  0026c	75 04		 jne	 SHORT $LN353@Insert_at

; 2118 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

  0026e	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
$LN353@Insert_at:

; 2119 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  00272	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00276	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  0027a	49 8b 0a	 mov	 rcx, QWORD PTR [r10]

; 2120 : 
; 2121 : 		if (_Wherenode == _Root())

  0027d	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00281	75 06		 jne	 SHORT $LN352@Insert_at

; 2122 : 			_Root() = _Pnode;

  00283	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  00287	eb 12		 jmp	 SHORT $LN349@Insert_at
$LN352@Insert_at:

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);

  00289	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]

; 2123 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

  0028d	48 3b 11	 cmp	 rdx, QWORD PTR [rcx]
  00290	75 05		 jne	 SHORT $LN350@Insert_at

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  00292	4c 89 01	 mov	 QWORD PTR [rcx], r8

; 2125 : 		else

  00295	eb 04		 jmp	 SHORT $LN349@Insert_at
$LN350@Insert_at:

; 2126 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  00297	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8
$LN349@Insert_at:

; 2127 : 
; 2128 : 		this->_Left(_Pnode) = _Wherenode;

  0029b	49 89 10	 mov	 QWORD PTR [r8], rdx
$LN417@Insert_at:

; 2129 : 		this->_Parent(_Wherenode) = _Pnode;

  0029e	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8
$LN354@Insert_at:

; 1867 : 			}
; 1868 : 
; 1869 : 		for (_Nodeptr _Pnode = _Newnode;
; 1870 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

  002a2	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002a6	80 79 18 00	 cmp	 BYTE PTR [rcx+24], 0
  002aa	0f 84 10 fe ff
	ff		 je	 $LL10@Insert_at
$LN9@Insert_at:

; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  002b0	49 8b 02	 mov	 rax, QWORD PTR [r10]

; 44   : 		{	// construct with node pointer _Pnode

  002b3	4c 89 1b	 mov	 QWORD PTR [rbx], r11

; 1922 : 					}
; 1923 : 				}
; 1924 : 
; 1925 : 		this->_Color(_Root()) = this->_Black;	// root is always black

  002b6	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 1926 : 		return (iterator(_Newnode, this));

  002ba	48 8b c3	 mov	 rax, rbx
  002bd	c6 41 18 01	 mov	 BYTE PTR [rcx+24], 1

; 1927 : 		}

  002c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002c5	5b		 pop	 rbx
  002c6	c3		 ret	 0
$LN418@Insert_at:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 128  : 			_Delete_this();

  002c7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002ca	48 8b cb	 mov	 rcx, rbx
  002cd	ff 50 08	 call	 QWORD PTR [rax+8]
$LN414@Insert_at:
  002d0	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
$LN57@Insert_at:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  002d5	48 8b ce	 mov	 rcx, rsi
  002d8	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1842 : 			_Xlength_error("map/set<T> too long");

  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
  002e4	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  002e9	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN415@Insert_at:
??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 96
this$ = 96
__$ReturnUdt$ = 104
_Leftish$dead$ = 112
_Val$ = 120
_Newnode$ = 128
??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 1780 : 		_Pairib _Insert_nohint(bool _Leftish,

$LN275:
  00000	40 57		 push	 rdi
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 c7 44 24 30
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00018	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  0001d	4d 8b d9	 mov	 r11, r9
  00020	4c 8b fa	 mov	 r15, rdx
  00023	48 8b f1	 mov	 rsi, rcx

; 589  : 		}
; 590  : 
; 591  : 	static _Nodepref _Left(_Nodeptr _Pnode)
; 592  : 		{	// return reference to left pointer in node
; 593  : 		return ((_Nodepref)_Pnode->_Left);
; 594  : 		}
; 595  : 
; 596  : 	static _Nodepref _Parent(_Nodeptr _Pnode)
; 597  : 		{	// return reference to parent pointer in node
; 598  : 		return ((_Nodepref)_Pnode->_Parent);

  00026	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 1781 : 			_Valty&& _Val, _Nodety _Newnode)
; 1782 : 		{	// try to insert node, on left if _Leftish
; 1783 : 		_TRY_BEGIN
; 1784 : 		_Nodeptr _Trynode = _Root();

  00029	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]

; 1785 : 		_Nodeptr _Wherenode = this->_Myhead;

  0002d	4c 8b cf	 mov	 r9, rdi

; 1786 : 		bool _Addleft = true;	// add to left of head if tree empty

  00030	41 b2 01	 mov	 r10b, 1

; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))

  00033	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0
  00038	75 51		 jne	 SHORT $LN11@Insert_noh
  0003a	41 8b 13	 mov	 edx, DWORD PTR [r11]
  0003d	0f 1f 00	 npad	 3
$LL12@Insert_noh:

; 1789 : 			{	// look for leaf to insert before (_Addleft) or after
; 1790 : 			_Wherenode = _Trynode;

  00040	4d 8b c8	 mov	 r9, r8
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  00043	41 8b 40 20	 mov	 eax, DWORD PTR [r8+32]
  00047	3b d0		 cmp	 edx, eax
  00049	7d 05		 jge	 SHORT $LN273@Insert_noh

; 288  : 	{
; 289  : 		return true;

  0004b	41 b2 01	 mov	 r10b, 1
  0004e	eb 26		 jmp	 SHORT $LN74@Insert_noh
$LN273@Insert_noh:

; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00050	75 21		 jne	 SHORT $LN68@Insert_noh

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  00052	41 8b 43 04	 mov	 eax, DWORD PTR [r11+4]
  00056	41 8b 48 24	 mov	 ecx, DWORD PTR [r8+36]
  0005a	3b c1		 cmp	 eax, ecx
  0005c	7d 05		 jge	 SHORT $LN274@Insert_noh

; 294  : 		{
; 295  : 			return true;

  0005e	41 b2 01	 mov	 r10b, 1
  00061	eb 13		 jmp	 SHORT $LN74@Insert_noh
$LN274@Insert_noh:

; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00063	75 0e		 jne	 SHORT $LN68@Insert_noh

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00065	41 8b 40 28	 mov	 eax, DWORD PTR [r8+40]
  00069	41 39 43 08	 cmp	 DWORD PTR [r11+8], eax
  0006d	41 0f 9c c2	 setl	 r10b
  00071	eb 03		 jmp	 SHORT $LN74@Insert_noh
$LN68@Insert_noh:

; 300  : 		}
; 301  : 	}
; 302  : 
; 303  : 	return false;

  00073	45 32 d2	 xor	 r10b, r10b
$LN74@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1800 : 				: this->_Right(_Trynode);

  00076	45 84 d2	 test	 r10b, r10b
  00079	74 05		 je	 SHORT $LN16@Insert_noh
  0007b	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0007e	eb 04		 jmp	 SHORT $LN17@Insert_noh
$LN16@Insert_noh:
  00080	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
$LN17@Insert_noh:

; 1787 : 
; 1788 : 		while (!this->_Isnil(_Trynode))

  00084	41 80 78 19 00	 cmp	 BYTE PTR [r8+25], 0
  00089	74 b5		 je	 SHORT $LL12@Insert_noh
$LN11@Insert_noh:

; 44   : 		{	// construct with node pointer _Pnode

  0008b	49 8b d9	 mov	 rbx, r9

; 1801 : 			}
; 1802 : 
; 1803 : 		if (this->_Multi)
; 1804 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1805 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1806 : 		else
; 1807 : 			{	// insert only if unique
; 1808 : 			iterator _Where = iterator(_Wherenode, this);
; 1809 : 			if (!_Addleft)

  0008e	45 84 d2	 test	 r10b, r10b
  00091	0f 84 93 00 00
	00		 je	 $LN136@Insert_noh

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head
; 100  : 			}
; 101  : 		return (*this);
; 102  : 		}
; 103  : 
; 104  : 	_Myiter operator--(int)
; 105  : 		{	// postdecrement
; 106  : 		_Myiter _Tmp = *this;
; 107  : 		--*this;
; 108  : 		return (_Tmp);
; 109  : 		}
; 110  : 
; 111  : 	bool operator==(const _Myiter& _Right) const
; 112  : 		{	// test for iterator equality
; 113  : 		return (_Ptr == _Right._Ptr);
; 114  : 		}
; 115  : 
; 116  : 	bool operator!=(const _Myiter& _Right) const
; 117  : 		{	// test for iterator inequality
; 118  : 		return (!(*this == _Right));
; 119  : 		}
; 120  : 
; 121  : 	_Nodeptr _Mynode() const
; 122  : 		{	// return node pointer
; 123  : 		return (_Ptr);
; 124  : 		}
; 125  : 
; 126  : 	_Nodeptr _Ptr;	// pointer to node
; 127  : 	};
; 128  : 
; 129  : 	// TEMPLATE CLASS _Tree_unchecked_iterator
; 130  : template<class _Mytree>
; 131  : 	class _Tree_unchecked_iterator
; 132  : 		: public _Tree_unchecked_const_iterator<_Mytree>
; 133  : 	{	// unchecked iterator for mutable tree
; 134  : public:
; 135  : 	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
; 136  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
; 137  : 	typedef bidirectional_iterator_tag iterator_category;
; 138  : 
; 139  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 140  : 	typedef typename _Mytree::value_type value_type;
; 141  : 	typedef typename _Mytree::difference_type difference_type;
; 142  : 	typedef typename _Mytree::pointer pointer;
; 143  : 	typedef typename _Mytree::reference reference;
; 144  : 
; 145  : 	_Tree_unchecked_iterator()
; 146  : 		{	// construct with null node
; 147  : 		}
; 148  : 
; 149  : 	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 150  : 		: _Mybase(_Pnode, _Plist)
; 151  : 		{	// construct with node pointer _Pnode
; 152  : 		}
; 153  : 
; 154  : 	reference operator*() const
; 155  : 		{	// return designated value
; 156  : 		return ((reference)**(_Mybase *)this);
; 157  : 		}
; 158  : 
; 159  : 	pointer operator->() const
; 160  : 		{	// return pointer to class object
; 161  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 162  : 		}
; 163  : 
; 164  : 	_Myiter& operator++()
; 165  : 		{	// preincrement
; 166  : 		++(*(_Mybase *)this);
; 167  : 		return (*this);
; 168  : 		}
; 169  : 
; 170  : 	_Myiter operator++(int)
; 171  : 		{	// postincrement
; 172  : 		_Myiter _Tmp = *this;
; 173  : 		++*this;
; 174  : 		return (_Tmp);
; 175  : 		}
; 176  : 
; 177  : 	_Myiter& operator--()
; 178  : 		{	// predecrement
; 179  : 		--(*(_Mybase *)this);
; 180  : 		return (*this);
; 181  : 		}
; 182  : 
; 183  : 	_Myiter operator--(int)
; 184  : 		{	// postdecrement
; 185  : 		_Myiter _Tmp = *this;
; 186  : 		--*this;
; 187  : 		return (_Tmp);
; 188  : 		}
; 189  : 	};
; 190  : 
; 191  : 	// TEMPLATE CLASS _Tree_const_iterator
; 192  : template<class _Mytree>
; 193  : 	class _Tree_const_iterator
; 194  : 		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
; 195  : 	{	// iterator for nonmutable tree
; 196  : public:
; 197  : 	typedef _Tree_const_iterator<_Mytree> _Myiter;
; 198  : 	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
; 199  : 	typedef bidirectional_iterator_tag iterator_category;
; 200  : 
; 201  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 202  : 	typedef typename _Mytree::value_type value_type;
; 203  : 	typedef typename _Mytree::difference_type difference_type;
; 204  : 	typedef typename _Mytree::const_pointer pointer;
; 205  : 	typedef typename _Mytree::const_reference reference;
; 206  : 
; 207  : 	_Tree_const_iterator()
; 208  : 		: _Mybase()
; 209  : 		{	// construct with null node pointer
; 210  : 		}
; 211  : 
; 212  : 	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 213  : 		: _Mybase(_Pnode, _Plist)
; 214  : 		{	// construct with node pointer _Pnode
; 215  : 		}
; 216  : 
; 217  : 	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;
; 218  : 
; 219  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 220  : 		{	// reset from unchecked iterator
; 221  : 		this->_Ptr = _Right._Ptr;
; 222  : 		return (*this);
; 223  : 		}
; 224  : 
; 225  : 	_Unchecked_type _Unchecked() const
; 226  : 		{	// make an unchecked iterator
; 227  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 228  : 		}
; 229  : 
; 230  : 	reference operator*() const
; 231  : 		{	// return designated value
; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		if (this->_Getcont() == 0
; 234  : 			|| this->_Ptr == 0
; 235  : 			|| this->_Ptr == ((_Mytree *)this->_Getcont())->_Myhead)
; 236  : 			{	// report error
; 237  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 238  : 			_SCL_SECURE_OUT_OF_RANGE;
; 239  : 			}
; 240  : 
; 241  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 242  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 243  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 244  : 			((_Mytree *)this->_Getcont())->_Myhead);
; 245  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 246  : 
; 247  : 		return (_Mytree::_Myval(this->_Ptr));
; 248  : 		}
; 249  : 
; 250  : 	pointer operator->() const
; 251  : 		{	// return pointer to class object
; 252  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 253  : 		}
; 254  : 
; 255  : 	_Myiter& operator++()
; 256  : 		{	// preincrement
; 257  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 258  : 		if (this->_Getcont() == 0
; 259  : 			|| this->_Ptr == 0
; 260  : 			|| _Mytree::_Isnil(this->_Ptr))
; 261  : 			{	// report error
; 262  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 263  : 			_SCL_SECURE_OUT_OF_RANGE;
; 264  : 			}
; 265  : 
; 266  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 267  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 268  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 269  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 270  : 
; 271  : 		++(*(_Mybase *)this);
; 272  : 		return (*this);
; 273  : 		}
; 274  : 
; 275  : 	_Myiter operator++(int)
; 276  : 		{	// postincrement
; 277  : 		_Myiter _Tmp = *this;
; 278  : 		++*this;
; 279  : 		return (_Tmp);
; 280  : 		}
; 281  : 
; 282  : 	_Myiter& operator--()
; 283  : 		{	// predecrement
; 284  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 285  : 		if (this->_Getcont() == 0
; 286  : 			|| this->_Ptr == 0)
; 287  : 			{	// report error
; 288  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 289  : 			_SCL_SECURE_OUT_OF_RANGE;
; 290  : 			}
; 291  : 
; 292  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 293  : 		--(*(_Mybase *)this);
; 294  : 		if (_Ptrsav == this->_Ptr)
; 295  : 			{	// report error
; 296  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 297  : 			_SCL_SECURE_OUT_OF_RANGE;
; 298  : 			}
; 299  : 
; 300  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 301  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 302  : 
; 303  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 304  : 		--(*(_Mybase *)this);
; 305  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 306  : 
; 307  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 308  : 		--(*(_Mybase *)this);
; 309  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 310  : 
; 311  : 		return (*this);
; 312  : 		}
; 313  : 
; 314  : 	_Myiter operator--(int)
; 315  : 		{	// postdecrement
; 316  : 		_Myiter _Tmp = *this;
; 317  : 		--*this;
; 318  : 		return (_Tmp);
; 319  : 		}
; 320  : 
; 321  : 	bool operator==(const _Myiter& _Right) const
; 322  : 		{	// test for iterator equality
; 323  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 324  : 		if (this->_Getcont() == 0
; 325  : 			|| this->_Getcont() != _Right._Getcont())
; 326  : 			{	// report error
; 327  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 328  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 329  : 			}
; 330  : 
; 331  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 332  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 333  : 			&& this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);

  00097	4c 3b 0f	 cmp	 r9, QWORD PTR [rdi]

; 1810 : 				;	// need to test if insert after is okay
; 1811 : 			else if (_Where == begin())

  0009a	75 30		 jne	 SHORT $LN4@Insert_noh

; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  0009c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Newnode$[rsp]
  000a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a9	41 b0 01	 mov	 r8b, 1
  000ac	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  000b1	48 8b ce	 mov	 rcx, rsi
  000b4	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bc	49 89 07	 mov	 QWORD PTR [r15], rax
  000bf	41 c6 47 08 01	 mov	 BYTE PTR [r15+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1812 : 				return (_Pairib(_Insert_at(true, _Wherenode,

  000c4	49 8b c7	 mov	 rax, r15
  000c7	e9 f4 00 00 00	 jmp	 $LN20@Insert_noh
$LN4@Insert_noh:

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mytree::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		if (_Mytree::_Isnil(_Ptr))
; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
; 63   : 			_Ptr = _Mytree::_Min(
; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))
; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree
; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())
; 72   : 			}
; 73   : 		return (*this);
; 74   : 		}
; 75   : 
; 76   : 	_Myiter operator++(int)
; 77   : 		{	// postincrement
; 78   : 		_Myiter _Tmp = *this;
; 79   : 		++*this;
; 80   : 		return (_Tmp);
; 81   : 		}
; 82   : 
; 83   : 	_Myiter& operator--()
; 84   : 		{	// predecrement
; 85   : 		if (_Mytree::_Isnil(_Ptr))

  000cc	41 80 79 19 00	 cmp	 BYTE PTR [r9+25], 0
  000d1	74 06		 je	 SHORT $LN143@Insert_noh

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

  000d3	49 8b 59 10	 mov	 rbx, QWORD PTR [r9+16]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  000d7	eb 51		 jmp	 SHORT $LN136@Insert_noh
$LN143@Insert_noh:

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  000d9	49 8b 01	 mov	 rax, QWORD PTR [r9]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

  000dc	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  000e0	75 1d		 jne	 SHORT $LN264@Insert_noh

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree

  000e2	48 8b d8	 mov	 rbx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  000e5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  000e9	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  000ed	75 3b		 jne	 SHORT $LN136@Insert_noh
  000ef	90		 npad	 1
$LL157@Insert_noh:

; 614  : 			_Pnode = _Right(_Pnode);

  000f0	48 8b d8	 mov	 rbx, rax

; 337  : 		}
; 338  : 
; 339  : 	bool operator!=(const _Myiter& _Right) const
; 340  : 		{	// test for iterator inequality
; 341  : 		return (!(*this == _Right));
; 342  : 		}
; 343  : 	};
; 344  : 
; 345  : template<class _Mytree> inline
; 346  : 	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
; 347  : 		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
; 348  : 	{	// convert to unchecked
; 349  : 	return (_Iter._Unchecked());
; 350  : 	}
; 351  : 
; 352  : template<class _Mytree> inline
; 353  : 	_Tree_const_iterator<_Mytree>&
; 354  : 		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
; 355  : 			typename _Tree_const_iterator<_Mytree>
; 356  : 				::_Unchecked_type _Right)
; 357  : 	{	// convert to checked
; 358  : 	return (_Iter._Rechecked(_Right));
; 359  : 	}
; 360  : 
; 361  : 	// TEMPLATE CLASS _Tree_iterator
; 362  : template<class _Mytree>
; 363  : 	class _Tree_iterator
; 364  : 		: public _Tree_const_iterator<_Mytree>
; 365  : 	{	// iterator for mutable tree
; 366  : public:
; 367  : 	typedef _Tree_iterator<_Mytree> _Myiter;
; 368  : 	typedef _Tree_const_iterator<_Mytree> _Mybase;
; 369  : 	typedef bidirectional_iterator_tag iterator_category;
; 370  : 
; 371  : 	typedef typename _Mytree::_Nodeptr _Nodeptr;
; 372  : 	typedef typename _Mytree::value_type value_type;
; 373  : 	typedef typename _Mytree::difference_type difference_type;
; 374  : 
; 375  : 	typedef typename _Mytree::pointer pointer;
; 376  : 	typedef typename _Mytree::reference reference;
; 377  : 
; 378  : 	_Tree_iterator()
; 379  : 		{	// construct with null node
; 380  : 		}
; 381  : 
; 382  : 	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
; 383  : 		: _Mybase(_Pnode, _Plist)
; 384  : 		{	// construct with node pointer _Pnode
; 385  : 		}
; 386  : 
; 387  : 	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;
; 388  : 
; 389  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 390  : 		{	// reset from unchecked iterator
; 391  : 		this->_Ptr = _Right._Ptr;
; 392  : 		return (*this);
; 393  : 		}
; 394  : 
; 395  : 	_Unchecked_type _Unchecked() const
; 396  : 		{	// make an unchecked iterator
; 397  : 		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
; 398  : 		}
; 399  : 
; 400  : 	reference operator*() const
; 401  : 		{	// return designated value
; 402  : 		return ((reference)**(_Mybase *)this);
; 403  : 		}
; 404  : 
; 405  : 	pointer operator->() const
; 406  : 		{	// return pointer to class object
; 407  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 408  : 		}
; 409  : 
; 410  : 	_Myiter& operator++()
; 411  : 		{	// preincrement
; 412  : 		++(*(_Mybase *)this);
; 413  : 		return (*this);
; 414  : 		}
; 415  : 
; 416  : 	_Myiter operator++(int)
; 417  : 		{	// postincrement
; 418  : 		_Myiter _Tmp = *this;
; 419  : 		++*this;
; 420  : 		return (_Tmp);
; 421  : 		}
; 422  : 
; 423  : 	_Myiter& operator--()
; 424  : 		{	// predecrement
; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);
; 427  : 		}
; 428  : 
; 429  : 	_Myiter operator--(int)
; 430  : 		{	// postdecrement
; 431  : 		_Myiter _Tmp = *this;
; 432  : 		--*this;
; 433  : 		return (_Tmp);
; 434  : 		}
; 435  : 	};
; 436  : 
; 437  : template<class _Mytree> inline
; 438  : 	typename _Tree_iterator<_Mytree>::_Unchecked_type
; 439  : 		_Unchecked(_Tree_iterator<_Mytree> _Iter)
; 440  : 	{	// convert to unchecked
; 441  : 	return (_Iter._Unchecked());
; 442  : 	}
; 443  : 
; 444  : template<class _Mytree> inline
; 445  : 	_Tree_iterator<_Mytree>&
; 446  : 		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
; 447  : 			typename _Tree_iterator<_Mytree>
; 448  : 				::_Unchecked_type _Right)
; 449  : 	{	// convert to checked
; 450  : 	return (_Iter._Rechecked(_Right));
; 451  : 	}
; 452  : 
; 453  : 		// tree TYPE WRAPPERS
; 454  : template<class _Value_type,
; 455  : 	class _Size_type,
; 456  : 	class _Difference_type,
; 457  : 	class _Pointer,
; 458  : 	class _Const_pointer,
; 459  : 	class _Reference,
; 460  : 	class _Const_reference,
; 461  : 	class _Nodeptr_type>
; 462  : 	struct _Tree_iter_types
; 463  : 	{	// wraps types needed by iterators
; 464  : 	typedef _Value_type value_type;
; 465  : 	typedef _Size_type size_type;
; 466  : 	typedef _Difference_type difference_type;
; 467  : 	typedef _Pointer pointer;
; 468  : 	typedef _Const_pointer const_pointer;
; 469  : 	typedef _Reference reference;
; 470  : 	typedef _Const_reference const_reference;
; 471  : 	typedef _Nodeptr_type _Nodeptr;
; 472  : 	};
; 473  : 
; 474  : template<class _Value_type,
; 475  : 	class _Voidptr>
; 476  : 	struct _Tree_node
; 477  : 		{	// tree node
; 478  : 		_Voidptr _Left;	// left subtree, or smallest element if head
; 479  : 		_Voidptr _Parent;	// parent, or root of tree if head
; 480  : 		_Voidptr _Right;	// right subtree, or largest element if head
; 481  : 		char _Color;	// _Red or _Black, _Black if head
; 482  : 		char _Isnil;	// true only if head (also nil) node
; 483  : 		_Value_type _Myval;	// the stored value, unused if head
; 484  : 
; 485  : 	private:
; 486  : 		_Tree_node& operator=(const _Tree_node&);
; 487  : 		};
; 488  : 
; 489  : template<class _Value_type>
; 490  : 	struct _Tree_node<_Value_type, void *>
; 491  : 		{	// tree node
; 492  : 		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
; 493  : 		_Nodeptr _Left;	// left subtree, or smallest element if head
; 494  : 		_Nodeptr _Parent;	// parent, or root of tree if head
; 495  : 		_Nodeptr _Right;	// right subtree, or largest element if head
; 496  : 		char _Color;	// _Red or _Black, _Black if head
; 497  : 		char _Isnil;	// true only if head (also nil) node
; 498  : 		_Value_type _Myval;	// the stored value, unused if head
; 499  : 
; 500  : 	private:
; 501  : 		_Tree_node& operator=(const _Tree_node&);
; 502  : 		};
; 503  : 
; 504  : template<class _Ty>
; 505  : 	struct _Tree_simple_types
; 506  : 		: public _Simple_types<_Ty>
; 507  : 	{	// wraps types needed by iterators
; 508  : 	typedef _Tree_node<_Ty, void *> _Node;
; 509  : 	typedef _Node *_Nodeptr;
; 510  : 	};
; 511  : 
; 512  : template<class _Ty,
; 513  : 	class _Alloc0>
; 514  : 	struct _Tree_base_types
; 515  : 	{	// types needed for a container base
; 516  : 	typedef _Alloc0 _Alloc;
; 517  : 	typedef _Tree_base_types<_Ty, _Alloc> _Myt;
; 518  : 
; 519  :  #if _HAS_CPP0X
; 520  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 521  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 522  : 
; 523  :  #else /* _HAS_CPP0X */
; 524  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 525  :  #endif /* _HAS_CPP0X */
; 526  : 
; 527  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 528  : 		_Voidptr;
; 529  : 	typedef _Tree_node<typename _Alty::value_type,
; 530  : 		_Voidptr> _Node;
; 531  : 
; 532  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 533  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 534  : 	typedef _Nodeptr& _Nodepref;
; 535  : 
; 536  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 537  : 		_Tree_simple_types<typename _Alty::value_type>,
; 538  : 		_Tree_iter_types<typename _Alty::value_type,
; 539  : 			typename _Alty::size_type,
; 540  : 			typename _Alty::difference_type,
; 541  : 			typename _Alty::pointer,
; 542  : 			typename _Alty::const_pointer,
; 543  : 			typename _Alty::reference,
; 544  : 			typename _Alty::const_reference,
; 545  : 			_Nodeptr> >::type
; 546  : 		_Val_types;
; 547  : 	};
; 548  : 
; 549  : 		// TEMPLATE CLASS _Tree_val
; 550  : template<class _Val_types>
; 551  : 	class _Tree_val
; 552  : 		: public _Container_base
; 553  : 	{	// base class for tree to hold data
; 554  : public:
; 555  : 	typedef _Tree_val<_Val_types> _Myt;
; 556  : 
; 557  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 558  : 	typedef _Nodeptr& _Nodepref;
; 559  : 
; 560  : 	typedef typename _Val_types::value_type value_type;
; 561  : 	typedef typename _Val_types::size_type size_type;
; 562  : 	typedef typename _Val_types::difference_type difference_type;
; 563  : 	typedef typename _Val_types::pointer pointer;
; 564  : 	typedef typename _Val_types::const_pointer const_pointer;
; 565  : 	typedef typename _Val_types::reference reference;
; 566  : 	typedef typename _Val_types::const_reference const_reference;
; 567  : 
; 568  : 	typedef _Tree_const_iterator<_Myt> const_iterator;
; 569  : 	typedef _Tree_iterator<_Myt> iterator;
; 570  : 
; 571  : 	_Tree_val()
; 572  : 		{	// initialize data
; 573  : 		this->_Myhead = 0;
; 574  : 		this->_Mysize = 0;
; 575  : 		}
; 576  : 
; 577  : 	enum _Redbl
; 578  : 		{	// colors for link to parent
; 579  : 		_Red, _Black};
; 580  : 
; 581  : 	static char& _Color(_Nodeptr _Pnode)
; 582  : 		{	// return reference to color in node
; 583  : 		return ((char&)_Pnode->_Color);
; 584  : 		}
; 585  : 
; 586  : 	static char& _Isnil(_Nodeptr _Pnode)
; 587  : 		{	// return reference to nil flag in node
; 588  : 		return ((char&)_Pnode->_Isnil);

  000f3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]

; 609  : 		}
; 610  : 
; 611  : 	static _Nodeptr _Max(_Nodeptr _Pnode)
; 612  : 		{	// return rightmost node in subtree at _Pnode
; 613  : 		while (!_Isnil(_Right(_Pnode)))

  000f7	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  000fb	74 f3		 je	 SHORT $LL157@Insert_noh

; 90   : 		else

  000fd	eb 2b		 jmp	 SHORT $LN136@Insert_noh
$LN264@Insert_noh:

; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  000ff	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  00103	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00107	75 19		 jne	 SHORT $LN138@Insert_noh
  00109	0f 1f 80 00 00
	00 00		 npad	 7
$LL139@Insert_noh:
  00110	48 3b 18	 cmp	 rbx, QWORD PTR [rax]
  00113	75 0d		 jne	 SHORT $LN138@Insert_noh

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

  00115	48 8b d8	 mov	 rbx, rax

; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

  00118	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0011c	80 78 19 00	 cmp	 BYTE PTR [rax+25], 0
  00120	74 ee		 je	 SHORT $LL139@Insert_noh
$LN138@Insert_noh:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

  00122	80 7b 19 00	 cmp	 BYTE PTR [rbx+25], 0
  00126	48 0f 44 d8	 cmove	 rbx, rax
$LN136@Insert_noh:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(cp1.x < cp2.x)

  0012a	8b 43 20	 mov	 eax, DWORD PTR [rbx+32]
  0012d	41 8b 0b	 mov	 ecx, DWORD PTR [r11]
  00130	3b c1		 cmp	 eax, ecx
  00132	7c 60		 jl	 SHORT $LN271@Insert_noh

; 290  : 	}
; 291  : 	else if(cp1.x == cp2.x)

  00134	75 1b		 jne	 SHORT $LN2@Insert_noh

; 292  : 	{
; 293  : 		if(cp1.y < cp2.y)

  00136	8b 43 24	 mov	 eax, DWORD PTR [rbx+36]
  00139	41 8b 4b 04	 mov	 ecx, DWORD PTR [r11+4]
  0013d	3b c1		 cmp	 eax, ecx
  0013f	7c 53		 jl	 SHORT $LN271@Insert_noh

; 296  : 		}
; 297  : 		else if(cp1.y == cp2.y)

  00141	75 0e		 jne	 SHORT $LN2@Insert_noh

; 298  : 		{
; 299  : 			return cp1.z < cp2.z;

  00143	41 8b 43 08	 mov	 eax, DWORD PTR [r11+8]
  00147	39 43 28	 cmp	 DWORD PTR [rbx+40], eax
  0014a	0f 9c c0	 setl	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1817 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

  0014d	84 c0		 test	 al, al
  0014f	75 43		 jne	 SHORT $LN271@Insert_noh
$LN2@Insert_noh:

; 599  : 		}
; 600  : 
; 601  : 	static _Nodepref _Right(_Nodeptr _Pnode)
; 602  : 		{	// return reference to right pointer in node
; 603  : 		return ((_Nodepref)_Pnode->_Right);
; 604  : 		}
; 605  : 
; 606  : 	static reference _Myval(_Nodeptr _Pnode)
; 607  : 		{	// return reference to value in node
; 608  : 		return ((reference)_Pnode->_Myval);

  00151	4c 8b b4 24 80
	00 00 00	 mov	 r14, QWORD PTR _Newnode$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00159	49 8b 7e 38	 mov	 rdi, QWORD PTR [r14+56]
  0015d	48 85 ff	 test	 rdi, rdi
  00160	74 1d		 je	 SHORT $LN241@Insert_noh

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00162	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  00166	75 17		 jne	 SHORT $LN241@Insert_noh

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00168	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0016b	48 8b cf	 mov	 rcx, rdi
  0016e	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00170	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  00174	75 09		 jne	 SHORT $LN241@Insert_noh

; 128  : 			_Delete_this();

  00176	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00179	48 8b cf	 mov	 rcx, rdi
  0017c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN241@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0017f	49 8b ce	 mov	 rcx, r14
  00182	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00187	49 89 1f	 mov	 QWORD PTR [r15], rbx
  0018a	41 c6 47 08 00	 mov	 BYTE PTR [r15+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1825 : 				return (_Pairib(_Where, false));

  0018f	49 8b c7	 mov	 rax, r15
  00192	eb 2c		 jmp	 SHORT $LN20@Insert_noh
$LN271@Insert_noh:

; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  00194	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Newnode$[rsp]
  0019c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a1	45 0f b6 c2	 movzx	 r8d, r10b
  001a5	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T2[rsp]
  001aa	48 8b ce	 mov	 rcx, rsi
  001ad	e8 00 00 00 00	 call	 ??$_Insert_at@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_NPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@1@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_at<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  001b2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b5	49 89 07	 mov	 QWORD PTR [r15], rax
  001b8	41 c6 47 08 01	 mov	 BYTE PTR [r15+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 1820 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

  001bd	49 8b c7	 mov	 rax, r15
$LN20@Insert_noh:

; 1826 : 				}
; 1827 : 			}
; 1828 : 		_CATCH_ALL
; 1829 : 		_Destroy_if_not_nil(_Newnode);
; 1830 : 		_RERAISE;
; 1831 : 		_CATCH_END
; 1832 : 		}

  001c0	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  001c5	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  001ca	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001ce	41 5f		 pop	 r15
  001d0	41 5e		 pop	 r14
  001d2	5f		 pop	 rdi
  001d3	c3		 ret	 0
  001d4	cc		 int	 3
$LN272@Insert_noh:
??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 96
this$ = 96
__$ReturnUdt$ = 104
_Leftish$dead$ = 112
_Val$ = 120
_Newnode$ = 128
?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA PROC ; `std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>'::`1'::catch$0

; 1828 : 		_CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z$0:

; 1829 : 		_Destroy_if_not_nil(_Newnode);

  0000d	48 8b 95 80 00
	00 00		 mov	 rdx, QWORD PTR _Newnode$[rbp]
  00014	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil

; 1830 : 		_RERAISE;

  00019	33 d2		 xor	 edx, edx
  0001b	33 c9		 xor	 ecx, ecx
  0001d	e8 00 00 00 00	 call	 _CxxThrowException
  00022	90		 npad	 1
?catch$0@?0???$_Insert_nohint@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@_NAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z@4HA ENDP ; `std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_nohint<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 621  : 		void destroy(_Uty *_Ptr)

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN16@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN19@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN19@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN19@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN3@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN3@construct:
  0000b	f3 c3		 fatret	 0
??$construct@PEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor', COMDAT
$LN22:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  0000a	48 8b 59 18	 mov	 rbx, QWORD PTR [rcx+24]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 35		 je	 SHORT $LN19@scalar

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00016	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0001a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001f	75 17		 jne	 SHORT $LN18@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00021	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00024	48 8b cb	 mov	 rcx, rbx
  00027	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00029	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0002d	75 09		 jne	 SHORT $LN18@scalar

; 128  : 			_Delete_this();

  0002f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00032	48 8b cb	 mov	 rcx, rbx
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
$LN18@scalar:
  00038	48 8b c7	 mov	 rax, rdi
  0003b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00040	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN19@scalar:
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >, COMDAT
$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 18	 mov	 rbx, QWORD PTR [rcx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN11@pair

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN14@pair

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN14@pair

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN14@pair:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN11@pair:
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_size, COMDAT

; 1278 : 		return (this->_Getal().max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 03	 mov	 rax, 288230376151711743	; 03ffffffffffffffH

; 1279 : 		}

  0000a	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 48
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--, COMDAT

; 424  : 		{	// predecrement

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 308  : 		--(*(_Mybase *)this);

  00009	e8 00 00 00 00	 call	 ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--

; 425  : 		--(*(_Mybase *)this);
; 426  : 		return (*this);

  0000e	48 8b c3	 mov	 rax, rbx

; 427  : 		}

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	c3		 ret	 0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size, COMDAT

; 914  : 		return (_Mytraits::max_size(*this));

  00000	48 b8 ff ff ff
	ff ff ff ff 03	 mov	 rax, 288230376151711743	; 03ffffffffffffffH

; 915  : 		}

  0000a	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size, COMDAT

; 762  : 		return (_Al.max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 03	 mov	 rax, 288230376151711743	; 03ffffffffffffffH

; 763  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEBA_KXZ PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::max_size, COMDAT

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	48 b8 ff ff ff
	ff ff ff ff 03	 mov	 rax, 288230376151711743	; 03ffffffffffffffH

; 629  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEBA_KXZ ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 42		 je	 SHORT $LN40@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	48 83 c2 10	 add	 rdx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0000c	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0000e	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  00011	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00015	49 83 c0 10	 add	 r8, 16
  00019	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  0001c	41 8b 40 f8	 mov	 eax, DWORD PTR [r8-8]
  00020	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00023	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00026	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0002a	49 3b d0	 cmp	 rdx, r8
  0002d	74 18		 je	 SHORT $LN40@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0002f	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00033	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00037	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0003b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0003e	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00041	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00044	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN40@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00047	f3 c3		 fatret	 0
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Node$ = 16
__formal$dead$ = 24
??$_Buynode_if_nil@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>, COMDAT

; 1640 : 		{	// node exists, just return it
; 1641 : 		return (_Node);

  00000	48 8b c2	 mov	 rax, rdx

; 1642 : 		}

  00003	c3		 ret	 0
??$_Buynode_if_nil@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Tree@V?$_Tmap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAPEAU?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
__formal$dead$ = 32
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>, COMDAT

; 138  : 		{	// construct from moved values

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  0000a	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 139  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAU01@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAU01@PEAPEAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>, COMDAT

; 182  : 		{	// construct from moved compatible pair

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	0f b6 42 08	 movzx	 eax, BYTE PTR [rdx+8]
  0000a	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 183  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAU01@PEAPEAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
__formal$dead$ = 32
??$?0AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64,bool>, COMDAT

; 138  : 		{	// construct from moved values

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  0000a	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 139  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@AEAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 42		 je	 SHORT $LN36@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	48 83 c2 10	 add	 rdx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0000c	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0000e	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  00011	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00015	49 83 c0 10	 add	 r8, 16
  00019	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  0001c	41 8b 40 f8	 mov	 eax, DWORD PTR [r8-8]
  00020	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00023	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00026	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0002a	49 3b d0	 cmp	 rdx, r8
  0002d	74 18		 je	 SHORT $LN36@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0002f	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00033	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00037	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0003b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0003e	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00041	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00044	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN36@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00047	f3 c3		 fatret	 0
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAX@Z PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >, COMDAT

; 182  : 		{	// construct from moved compatible pair

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  00006	4c 8b c1	 mov	 r8, rcx
  00009	89 01		 mov	 DWORD PTR [rcx], eax
  0000b	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  0000e	48 83 c2 10	 add	 rdx, 16
  00012	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  00015	8b 42 f8	 mov	 eax, DWORD PTR [rdx-8]
  00018	89 41 08	 mov	 DWORD PTR [rcx+8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0001b	33 c9		 xor	 ecx, ecx
  0001d	49 89 09	 mov	 QWORD PTR [r9], rcx
  00020	49 89 49 08	 mov	 QWORD PTR [r9+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00024	4c 3b ca	 cmp	 r9, rdx
  00027	74 18		 je	 SHORT $LN36@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00029	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0002d	49 89 41 08	 mov	 QWORD PTR [r9+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00031	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 48   : 	_Left = _Move(_Right);

  00035	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00038	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  0003b	49 89 01	 mov	 QWORD PTR [r9], rax

; 49   : 	_Right = _Move(_Tmp);

  0003e	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN36@shared_ptr:

; 183  : 		}

  00041	49 8b c0	 mov	 rax, r8
  00044	c3		 ret	 0
??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAX@Z ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@VChunkPosition@@@std@@YA$$QEAVChunkPosition@@AEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VChunkPosition@@@std@@YA$$QEAVChunkPosition@@AEAV1@@Z PROC ; std::forward<ChunkPosition>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@VChunkPosition@@@std@@YA$$QEAVChunkPosition@@AEAV1@@Z ENDP ; std::forward<ChunkPosition>
_TEXT	ENDS
END
