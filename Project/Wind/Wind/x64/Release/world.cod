; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_R2ChunkBase@@8				; ChunkBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8	; std::_Ref_count<EmptyChunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@EmptyChunk@@8			; EmptyChunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVChunk@@@8				; Chunk `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@Chunk@@8				; Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4EmptyChunk@@6B@				; EmptyChunk::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8	; std::_Ref_count<EmptyChunk> `RTTI Type Descriptor'
PUBLIC	??_R0?AVChunkBase@@@8				; ChunkBase `RTTI Type Descriptor'
PUBLIC	??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@	; std::_Ref_count<EmptyChunk>::`RTTI Complete Object Locator'
PUBLIC	??_R3EmptyChunk@@8				; EmptyChunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$_Ref_count@VEmptyChunk@@@std@@8		; std::_Ref_count<EmptyChunk>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4ChunkBase@@6B@				; ChunkBase::`RTTI Complete Object Locator'
PUBLIC	??_R2Chunk@@8					; Chunk::`RTTI Base Class Array'
PUBLIC	??_R3Chunk@@8					; Chunk::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3ChunkBase@@8				; ChunkBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7Chunk@@6B@					; Chunk::`vftable'
PUBLIC	??_R0?AVEmptyChunk@@@8				; EmptyChunk `RTTI Type Descriptor'
PUBLIC	??_7EmptyChunk@@6B@				; EmptyChunk::`vftable'
PUBLIC	??_R2?$_Ref_count@VEmptyChunk@@@std@@8		; std::_Ref_count<EmptyChunk>::`RTTI Base Class Array'
PUBLIC	??_7?$_Ref_count@VEmptyChunk@@@std@@6B@		; std::_Ref_count<EmptyChunk>::`vftable'
PUBLIC	??_R2EmptyChunk@@8				; EmptyChunk::`RTTI Base Class Array'
PUBLIC	??_R4Chunk@@6B@					; Chunk::`RTTI Complete Object Locator'
PUBLIC	??_7ChunkBase@@6B@				; ChunkBase::`vftable'
PUBLIC	??_R1A@?0A@EA@ChunkBase@@8			; ChunkBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
;	COMDAT ??_R1A@?0A@EA@ChunkBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ChunkBase@@8 DD imagerel ??_R0?AVChunkBase@@@8 ; ChunkBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_7ChunkBase@@6B@
CONST	SEGMENT
??_7ChunkBase@@6B@ DQ FLAT:??_R4ChunkBase@@6B@		; ChunkBase::`vftable'
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:?dataPtr@ChunkBase@@UEAAPEAGXZ
	DQ	FLAT:?shouldRender@ChunkBase@@UEAA_NXZ
CONST	ENDS
;	COMDAT ??_R4Chunk@@6B@
rdata$r	SEGMENT
??_R4Chunk@@6B@ DD 01H					; Chunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVChunk@@@8
	DD	imagerel ??_R3Chunk@@8
	DD	imagerel ??_R4Chunk@@6B@
rdata$r	ENDS
;	COMDAT ??_R2EmptyChunk@@8
rdata$r	SEGMENT
??_R2EmptyChunk@@8 DD imagerel ??_R1A@?0A@EA@EmptyChunk@@8 ; EmptyChunk::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ChunkBase@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count@VEmptyChunk@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VEmptyChunk@@@std@@6B@ DQ FLAT:??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@ ; std::_Ref_count<EmptyChunk>::`vftable'
	DQ	FLAT:?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
	DQ	FLAT:?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
	DQ	FLAT:??_E?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R2?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VEmptyChunk@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8 ; std::_Ref_count<EmptyChunk>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7EmptyChunk@@6B@
CONST	SEGMENT
??_7EmptyChunk@@6B@ DQ FLAT:??_R4EmptyChunk@@6B@	; EmptyChunk::`vftable'
	DQ	FLAT:?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z
	DQ	FLAT:?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z
	DQ	FLAT:?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z
	DQ	FLAT:?isEmpty@EmptyChunk@@UEAA_NXZ
	DQ	FLAT:?dataPtr@ChunkBase@@UEAAPEAGXZ
	DQ	FLAT:?shouldRender@EmptyChunk@@UEAA_NXZ
CONST	ENDS
;	COMDAT ??_R0?AVEmptyChunk@@@8
_DATA	SEGMENT
??_R0?AVEmptyChunk@@@8 DQ FLAT:??_7type_info@@6B@	; EmptyChunk `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVEmptyChunk@@', 00H
_DATA	ENDS
;	COMDAT ??_7Chunk@@6B@
CONST	SEGMENT
??_7Chunk@@6B@ DQ FLAT:??_R4Chunk@@6B@			; Chunk::`vftable'
	DQ	FLAT:?getBlock@Chunk@@UEAAPEAVBlock@@III@Z
	DQ	FLAT:?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z
	DQ	FLAT:?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z
	DQ	FLAT:?isEmpty@Chunk@@UEAA_NXZ
	DQ	FLAT:?dataPtr@Chunk@@UEAAPEAGXZ
	DQ	FLAT:?shouldRender@Chunk@@UEAA_NXZ
CONST	ENDS
;	COMDAT ??_R3ChunkBase@@8
rdata$r	SEGMENT
??_R3ChunkBase@@8 DD 00H				; ChunkBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2ChunkBase@@8
rdata$r	ENDS
;	COMDAT ??_R3Chunk@@8
rdata$r	SEGMENT
??_R3Chunk@@8 DD 00H					; Chunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2Chunk@@8
rdata$r	ENDS
;	COMDAT ??_R2Chunk@@8
rdata$r	SEGMENT
??_R2Chunk@@8 DD imagerel ??_R1A@?0A@EA@Chunk@@8	; Chunk::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ChunkBase@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4ChunkBase@@6B@
rdata$r	SEGMENT
??_R4ChunkBase@@6B@ DD 01H				; ChunkBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVChunkBase@@@8
	DD	imagerel ??_R3ChunkBase@@8
	DD	imagerel ??_R4ChunkBase@@6B@
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VEmptyChunk@@@std@@8 DD 00H		; std::_Ref_count<EmptyChunk>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3EmptyChunk@@8
rdata$r	SEGMENT
??_R3EmptyChunk@@8 DD 00H				; EmptyChunk::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2EmptyChunk@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@ DD 01H		; std::_Ref_count<EmptyChunk>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8
	DD	imagerel ??_R3?$_Ref_count@VEmptyChunk@@@std@@8
	DD	imagerel ??_R4?$_Ref_count@VEmptyChunk@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AVChunkBase@@@8
_DATA	SEGMENT
??_R0?AVChunkBase@@@8 DQ FLAT:??_7type_info@@6B@	; ChunkBase `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVChunkBase@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count<EmptyChunk> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Ref_count@VEmptyChunk@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4EmptyChunk@@6B@
rdata$r	SEGMENT
??_R4EmptyChunk@@6B@ DD 01H				; EmptyChunk::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVEmptyChunk@@@8
	DD	imagerel ??_R3EmptyChunk@@8
	DD	imagerel ??_R4EmptyChunk@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Chunk@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Chunk@@8 DD imagerel ??_R0?AVChunk@@@8	; Chunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3Chunk@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVChunk@@@8
_DATA	SEGMENT
??_R0?AVChunk@@@8 DQ FLAT:??_7type_info@@6B@		; Chunk `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVChunk@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@EA@EmptyChunk@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@EmptyChunk@@8 DD imagerel ??_R0?AVEmptyChunk@@@8 ; EmptyChunk::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3EmptyChunk@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VEmptyChunk@@@std@@8 DD imagerel ??_R0?AV?$_Ref_count@VEmptyChunk@@@std@@@8 ; std::_Ref_count<EmptyChunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Ref_count@VEmptyChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ChunkBase@@8
rdata$r	SEGMENT
??_R2ChunkBase@@8 DD imagerel ??_R1A@?0A@EA@ChunkBase@@8 ; ChunkBase::`RTTI Base Class Array'
	ORG $+3
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAX@Z ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >
PUBLIC	?construct@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBV32@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::construct
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
PUBLIC	??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V32@@_Alloc_construct@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBV32@@_Alloc_construct@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
PUBLIC	??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	?max_size@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEBA_KXZ ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size
PUBLIC	?max_size@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::max_size
PUBLIC	?_Incsize@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX_K@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Incsize
PUBLIC	??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >
PUBLIC	??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor'
PUBLIC	??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV21@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
PUBLIC	??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
PUBLIC	??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$move@AEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>
PUBLIC	??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$_Buynode_if_nil@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V21@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>
PUBLIC	??$forward@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
PUBLIC	??$_Insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVEmptyChunk@@PEAV_Ref_count_base@1@@Z ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>
PUBLIC	?size@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::size
PUBLIC	?size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
PUBLIC	?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Reinsert
PUBLIC	?max_load_factor@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_load_factor
PUBLIC	?load_factor@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::load_factor
PUBLIC	?bucket_count@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::bucket_count
PUBLIC	??1?$_Ref_count@VEmptyChunk@@@std@@UEAA@XZ	; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>
PUBLIC	??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ ; std::_Ref_count<EmptyChunk>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ ; std::_Ref_count<EmptyChunk>::_Destroy
PUBLIC	??0?$_Ref_count@VEmptyChunk@@@std@@QEAA@PEAVEmptyChunk@@@Z ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	?_Unchecked_splice@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@00@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_splice
PUBLIC	?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Check_size
PUBLIC	?_Insert_bucket@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0_K@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_bucket
PUBLIC	?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil
PUBLIC	??_GEmptyChunk@@QEAAPEAXI@Z			; EmptyChunk::`scalar deleting destructor'
PUBLIC	??$_Uninit_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Val_type@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@@Z ; std::_Val_type<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
PUBLIC	??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU31@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
PUBLIC	??$forward@AEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::forward<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
PUBLIC	??$_Copy_backward@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
PUBLIC	??$_Fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::_Fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Unchecked@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@@Z ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
PUBLIC	??$_Uninitialized_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
PUBLIC	??$_Move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
PUBLIC	??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0@Z ; std::_Ptr_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$?0U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Distance2@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_KUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>
PUBLIC	??$_Iter_cat@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@AEBV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAU01@PEAPEAX@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
PUBLIC	??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$emplace_front@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::emplace_front<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
PUBLIC	?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::max_size
PUBLIC	?_Unchecked_begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_begin
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::max_size
PUBLIC	?front@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::front
PUBLIC	?_Unchecked_begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Unchecked_begin
PUBLIC	??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SA_KHAEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
PUBLIC	??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEAV10@@Z ; std::_Allocate<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Allocate@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z ; std::_Allocate<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >
PUBLIC	??$_Uninitialized_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
PUBLIC	??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
PUBLIC	??$_Copy_backward@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00@Z ; std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
PUBLIC	??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Umove@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEAV21@00@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
PUBLIC	??$addressof@$$CBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const >
PUBLIC	??$_Move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00@Z ; std::_Move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
PUBLIC	??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$addressof@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ; std::addressof<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PEAPEAX@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >
PUBLIC	??$?0V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > ><std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??$_Distance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_K@Z ; std::_Distance<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>
PUBLIC	??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAU01@PEAPEAX@Z ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
PUBLIC	??$?0AEBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBVChunkPosition@@$$QEAV?$shared_ptr@VChunkBase@@@1@PEAPEAX@Z ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const & __ptr64,std::shared_ptr<ChunkBase> >
PUBLIC	??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+=
PUBLIC	?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size
PUBLIC	?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocate
PUBLIC	?allocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocate
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+=
PUBLIC	?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::allocate
PUBLIC	?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::capacity
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::allocate
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Compat
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA?AV01@_J@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+
PUBLIC	?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::allocate
PUBLIC	??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
PUBLIC	?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Orphan_range
PUBLIC	?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Xlen
PUBLIC	?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@PEAV32@_KPEBV32@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Ufill
PUBLIC	?_Grow_to@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBA_K_K@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Grow_to
PUBLIC	?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size
PUBLIC	?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::size
PUBLIC	?_Unused_capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Unused_capacity
PUBLIC	?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator!=
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator==
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
PUBLIC	??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--
PUBLIC	?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >
PUBLIC	?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
PUBLIC	?clear@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::clear
PUBLIC	?_Make_iter@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Make_iter
PUBLIC	??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??0?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAA@XZ ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >
PUBLIC	?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
PUBLIC	??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
PUBLIC	??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode
PUBLIC	?_Unchecked@?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Unchecked
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >
PUBLIC	??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::deallocate
PUBLIC	?erase@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::erase
PUBLIC	?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::insert
PUBLIC	??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_K@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator[]
PUBLIC	?end@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::end
PUBLIC	?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::begin
PUBLIC	?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >
PUBLIC	??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++
PUBLIC	??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator*
PUBLIC	?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::deallocate
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
PUBLIC	?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Destroy
PUBLIC	?_Assign_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Assign_n
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::deallocate
PUBLIC	?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@2@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal
PUBLIC	?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode
PUBLIC	??0?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::erase
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Make_iter
PUBLIC	?_Make_iter@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Make_iter
PUBLIC	?_Unchecked_end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_end
PUBLIC	?_Erase_bucket@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase_bucket
PUBLIC	?_Vec_hi@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Vec_hi
PUBLIC	?_Vec_lo@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Vec_lo
PUBLIC	??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
PUBLIC	??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator!=
PUBLIC	??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator==
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA?AV01@H@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Tidy
PUBLIC	?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::assign
PUBLIC	??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
PUBLIC	?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Prevnode
PUBLIC	??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode
PUBLIC	?_Tidy@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tidy
PUBLIC	??0?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??0?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@@Z ; std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>
PUBLIC	?_Hashval@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBA_KAEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hashval
PUBLIC	?_End@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_End
PUBLIC	?_Begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Begin
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	?_Make_iter@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Make_iter
PUBLIC	?_Make_iter@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Make_iter
PUBLIC	?_Unchecked_end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Unchecked_end
PUBLIC	??1?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	?swap@?$shared_ptr@VChunkBase@@@std@@QEAAXAEAV12@@Z ; std::shared_ptr<ChunkBase>::swap
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QEAA@XZ	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
PUBLIC	??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
PUBLIC	??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Init@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Init
PUBLIC	?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
PUBLIC	?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >
PUBLIC	??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z ; std::shared_ptr<ChunkBase>::operator=
PUBLIC	?find@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find
PUBLIC	?clear@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear
PUBLIC	?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
PUBLIC	??1?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
PUBLIC	??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
PUBLIC	??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
PUBLIC	?setBlock@World@@QEAAXHHHPEAVBlock@@@Z		; World::setBlock
PUBLIC	?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
PUBLIC	?tick@World@@QEAAXXZ				; World::tick
PUBLIC	??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
PUBLIC	?shouldRender@Chunk@@UEAA_NXZ			; Chunk::shouldRender
PUBLIC	?dataPtr@Chunk@@UEAAPEAGXZ			; Chunk::dataPtr
PUBLIC	?isEmpty@Chunk@@UEAA_NXZ			; Chunk::isEmpty
PUBLIC	?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z	; Chunk::setBlockRaw
PUBLIC	?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z		; Chunk::setBlock
PUBLIC	?getBlock@Chunk@@UEAAPEAVBlock@@III@Z		; Chunk::getBlock
PUBLIC	??1Chunk@@QEAA@XZ				; Chunk::~Chunk
PUBLIC	??0Chunk@@QEAA@AEAVWorld@@HHH@Z			; Chunk::Chunk
PUBLIC	?shouldRender@EmptyChunk@@UEAA_NXZ		; EmptyChunk::shouldRender
PUBLIC	?isEmpty@EmptyChunk@@UEAA_NXZ			; EmptyChunk::isEmpty
PUBLIC	?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z	; EmptyChunk::setBlockRaw
PUBLIC	?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z	; EmptyChunk::setBlock
PUBLIC	?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z	; EmptyChunk::getBlock
PUBLIC	??1EmptyChunk@@QEAA@XZ				; EmptyChunk::~EmptyChunk
PUBLIC	??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z		; EmptyChunk::EmptyChunk
PUBLIC	?shouldRender@ChunkBase@@UEAA_NXZ		; ChunkBase::shouldRender
PUBLIC	?dataPtr@ChunkBase@@UEAAPEAGXZ			; ChunkBase::dataPtr
PUBLIC	??1ChunkBase@@QEAA@XZ				; ChunkBase::~ChunkBase
PUBLIC	??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z		; ChunkBase::ChunkBase
PUBLIC	?toIndex@@YAIAEAI00@Z				; toIndex
PUBLIC	?_Getcont@_Iterator_base0@std@@QEBAPEBU_Container_base0@2@XZ ; std::_Iterator_base0::_Getcont
PUBLIC	??1World@@QEAA@XZ				; World::~World
PUBLIC	??0World@@QEAA@I@Z				; World::World
PUBLIC	?removeChunk@World@@QEAAXVChunkPosition@@@Z	; World::removeChunk
PUBLIC	?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; World::addChunk
PUBLIC	?setUnloaded@ChunkBase@@QEAAXXZ			; ChunkBase::setUnloaded
PUBLIC	?getSeed@World@@QEAAIXZ				; World::getSeed
PUBLIC	??8@YA_NAEBVChunkPosition@@0@Z			; operator==
PUBLIC	??0ChunkPosition@@QEAA@HHH@Z			; ChunkPosition::ChunkPosition
PUBLIC	?getBoundingBox@ChunkBase@@QEAA?AVAxisAlignedCube@geom@@XZ ; ChunkBase::getBoundingBox
PUBLIC	?setLoaded@ChunkBase@@QEAAXXZ			; ChunkBase::setLoaded
PUBLIC	?getBlock@World@@QEAAPEAVBlock@@HHH@Z		; World::getBlock
PUBLIC	?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
PUBLIC	?isRenderUpdateNeeded@ChunkBase@@QEAA_NXZ	; ChunkBase::isRenderUpdateNeeded
PUBLIC	?setRenderUpdateNeeded@ChunkBase@@QEAAX_N@Z	; ChunkBase::setRenderUpdateNeeded
PUBLIC	?isUnloaded@ChunkBase@@QEAA_NXZ			; ChunkBase::isUnloaded
PUBLIC	?isLoaded@ChunkBase@@QEAA_NXZ			; ChunkBase::isLoaded
EXTRN	??_E?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z:PROC ; std::_Ref_count<EmptyChunk>::`vector deleting destructor'
_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN74
	DD	imagerel $LN74+98
	DD	imagerel $unwind$??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Incsize@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX_K@Z DD imagerel $LN17
	DD	imagerel $LN17+53
	DD	imagerel $unwind$?_Incsize@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16+19
	DD	imagerel $LN16+54
	DD	imagerel $chain$0$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16+54
	DD	imagerel $LN16+60
	DD	imagerel $chain$1$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN22+26
	DD	imagerel $LN22+75
	DD	imagerel $chain$0$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD imagerel $LN22+75
	DD	imagerel $LN22+89
	DD	imagerel $chain$1$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN21+19
	DD	imagerel $LN21+54
	DD	imagerel $chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN21+54
	DD	imagerel $LN21+60
	DD	imagerel $chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN32
	DD	imagerel $LN32+96
	DD	imagerel $unwind$??$_Insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN63
	DD	imagerel $LN63+17
	DD	imagerel $unwind$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN63+17
	DD	imagerel $LN63+73
	DD	imagerel $chain$1$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN63+73
	DD	imagerel $LN63+79
	DD	imagerel $chain$2$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN226
	DD	imagerel $LN226+77
	DD	imagerel $unwind$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN226+77
	DD	imagerel $LN226+228
	DD	imagerel $chain$0$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD imagerel $LN226+228
	DD	imagerel $LN226+239
	DD	imagerel $chain$1$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN98
	DD	imagerel $LN98+28
	DD	imagerel $unwind$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN98+28
	DD	imagerel $LN98+60
	DD	imagerel $chain$0$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN98+60
	DD	imagerel $LN98+95
	DD	imagerel $chain$1$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN98+95
	DD	imagerel $LN98+112
	DD	imagerel $chain$2$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN98+112
	DD	imagerel $LN98+123
	DD	imagerel $chain$3$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GEmptyChunk@@QEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$??_GEmptyChunk@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN23+19
	DD	imagerel $LN23+54
	DD	imagerel $chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN23+54
	DD	imagerel $LN23+60
	DD	imagerel $chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z DD imagerel $LN304
	DD	imagerel $LN304+397
	DD	imagerel $unwind$??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$emplace_front@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN47
	DD	imagerel $LN47+102
	DD	imagerel $unwind$??$emplace_front@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD imagerel $LN31
	DD	imagerel $LN31+99
	DD	imagerel $unwind$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA DD imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA+59
	DD	imagerel $unwind$?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEAV10@@Z DD imagerel $LN14
	DD	imagerel $LN14+48
	DD	imagerel $unwind$??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z DD imagerel $LN14
	DD	imagerel $LN14+48
	DD	imagerel $unwind$??$_Allocate@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninitialized_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEAV21@00@Z DD imagerel $LN10
	DD	imagerel $LN10+26
	DD	imagerel $unwind$??$_Umove@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEAV21@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN25
	DD	imagerel $LN25+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN25+19
	DD	imagerel $LN25+54
	DD	imagerel $chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN25+54
	DD	imagerel $LN25+60
	DD	imagerel $chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD imagerel $LN90
	DD	imagerel $LN90+154
	DD	imagerel $unwind$??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+55
	DD	imagerel $unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN14
	DD	imagerel $LN14+30
	DD	imagerel $unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+55
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z DD imagerel $LN17
	DD	imagerel $LN17+30
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z DD imagerel $LN19
	DD	imagerel $LN19+55
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@PEAV32@_KPEBV32@@Z DD imagerel $LN10
	DD	imagerel $LN10+45
	DD	imagerel $unwind$?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@PEAV32@_KPEBV32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z DD imagerel $LN77
	DD	imagerel $LN77+74
	DD	imagerel $unwind$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN220
	DD	imagerel $LN220+604
	DD	imagerel $unwind$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel $LN8
	DD	imagerel $LN8+40
	DD	imagerel $unwind$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN114
	DD	imagerel $LN114+47
	DD	imagerel $unwind$?_Assign_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel $LN11
	DD	imagerel $LN11+40
	DD	imagerel $unwind$??0?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN86
	DD	imagerel $LN86+42
	DD	imagerel $unwind$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN86+42
	DD	imagerel $LN86+74
	DD	imagerel $chain$0$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN86+74
	DD	imagerel $LN86+109
	DD	imagerel $chain$1$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN86+109
	DD	imagerel $LN86+146
	DD	imagerel $chain$2$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN86+146
	DD	imagerel $LN86+161
	DD	imagerel $chain$3$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN15
	DD	imagerel $LN15+41
	DD	imagerel $unwind$?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN116
	DD	imagerel $LN116+47
	DD	imagerel $unwind$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN51
	DD	imagerel $LN51+26
	DD	imagerel $unwind$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN51+26
	DD	imagerel $LN51+61
	DD	imagerel $chain$0$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD imagerel $LN51+61
	DD	imagerel $LN51+79
	DD	imagerel $chain$1$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel $LN14
	DD	imagerel $LN14+40
	DD	imagerel $unwind$??0?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Hashval@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBA_KAEBVChunkPosition@@@Z DD imagerel $LN6
	DD	imagerel $LN6+55
	DD	imagerel $unwind$?_Hashval@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBA_KAEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD imagerel $LN109
	DD	imagerel $LN109+178
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN17
	DD	imagerel $LN17+41
	DD	imagerel $unwind$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN66
	DD	imagerel $LN66+43
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN66+43
	DD	imagerel $LN66+131
	DD	imagerel $chain$1$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN66+131
	DD	imagerel $LN66+143
	DD	imagerel $chain$2$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ DD imagerel $LN30
	DD	imagerel $LN30+27
	DD	imagerel $unwind$??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD imagerel $LN128
	DD	imagerel $LN128+83
	DD	imagerel $unwind$?_Init@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z DD imagerel $LN235
	DD	imagerel $LN235+260
	DD	imagerel $unwind$?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z DD imagerel $LN142
	DD	imagerel $LN142+229
	DD	imagerel $unwind$?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z DD imagerel $LN266
	DD	imagerel $LN266+77
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z DD imagerel $LN266+77
	DD	imagerel $LN266+320
	DD	imagerel $chain$2$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z DD imagerel $LN266+320
	DD	imagerel $LN266+335
	DD	imagerel $chain$3$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel $LN151
	DD	imagerel $LN151+196
	DD	imagerel $unwind$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16+19
	DD	imagerel $LN16+54
	DD	imagerel $chain$0$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD imagerel $LN16+54
	DD	imagerel $LN16+60
	DD	imagerel $chain$1$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+57
	DD	imagerel $LN59+86
	DD	imagerel $chain$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+86
	DD	imagerel $LN59+111
	DD	imagerel $chain$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+111
	DD	imagerel $LN59+120
	DD	imagerel $chain$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?find@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?clear@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD imagerel $LN130
	DD	imagerel $LN130+82
	DD	imagerel $unwind$?clear@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z DD imagerel $LN32
	DD	imagerel $LN32+86
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD imagerel $LN47
	DD	imagerel $LN47+58
	DD	imagerel $unwind$??1?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD imagerel $LN184
	DD	imagerel $LN184+281
	DD	imagerel $unwind$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN158
	DD	imagerel $LN158+180
	DD	imagerel $unwind$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z DD imagerel $LN6
	DD	imagerel $LN6+34
	DD	imagerel $unwind$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD imagerel $LN123
	DD	imagerel $LN123+576
	DD	imagerel $unwind$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD imagerel $LN6
	DD	imagerel $LN6+50
	DD	imagerel $unwind$?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@World@@QEAAXXZ DD imagerel $LN249
	DD	imagerel $LN249+317
	DD	imagerel $unwind$?tick@World@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD imagerel $LN49
	DD	imagerel $LN49+58
	DD	imagerel $unwind$??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0Chunk@@QEAA@AEAVWorld@@HHH@Z DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$??0Chunk@@QEAA@AEAVWorld@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z DD imagerel $LN5
	DD	imagerel $LN5+48
	DD	imagerel $unwind$??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1ChunkBase@@QEAA@XZ DD imagerel $LN34
	DD	imagerel $LN34+137
	DD	imagerel $unwind$??1ChunkBase@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD imagerel $LN35
	DD	imagerel $LN35+172
	DD	imagerel $unwind$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1World@@QEAA@XZ DD imagerel $LN138
	DD	imagerel $LN138+229
	DD	imagerel $unwind$??1World@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0World@@QEAA@I@Z DD imagerel $LN139
	DD	imagerel $LN139+341
	DD	imagerel $unwind$??0World@@QEAA@I@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?removeChunk@World@@QEAAXVChunkPosition@@@Z DD imagerel $LN34
	DD	imagerel $LN34+75
	DD	imagerel $unwind$?removeChunk@World@@QEAAXVChunkPosition@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN53
	DD	imagerel $LN53+194
	DD	imagerel $unwind$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD imagerel $LN50
	DD	imagerel $LN50+195
	DD	imagerel $unwind$?getBlock@World@@QEAAPEAVBlock@@HHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD imagerel $LN248
	DD	imagerel $LN248+617
	DD	imagerel $unwind$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD imagerel ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
	DD	0ffffffffH
	DD	imagerel ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z+495
	DD	00H
	DD	imagerel ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z+541
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
	DD	048H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 082211H
	DD	0113422H
	DD	0f0129216H
	DD	0700ee010H
	DD	0500c600dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD imagerel ?getBlock@World@@QEAAPEAVBlock@@HHH@Z
	DD	0ffffffffH
	DD	imagerel ?getBlock@World@@QEAAPEAVBlock@@HHH@Z+60
	DD	00H
	DD	imagerel ?getBlock@World@@QEAAPEAVBlock@@HHH@Z+125
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??getBlock@World@@QEAAPEAVBlock@@HHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?getBlock@World@@QEAAPEAVBlock@@HHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?getBlock@World@@QEAAPEAVBlock@@HHH@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getBlock@World@@QEAAPEAVBlock@@HHH@Z DD 081e11H
	DD	0e641eH
	DD	0d5419H
	DD	0c3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?getBlock@World@@QEAAPEAVBlock@@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z+29
	DD	00H
	DD	imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z+63
	DD	0ffffffffH
	DD	imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z+111
	DD	00H
	DD	imagerel ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z+135
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 061a11H
	DD	0c341aH
	DD	07008520cH
	DD	050066007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?removeChunk@World@@QEAAXVChunkPosition@@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0World@@QEAA@I@Z DD imagerel ??0World@@QEAA@I@Z
	DD	0ffffffffH
	DD	imagerel ??0World@@QEAA@I@Z+47
	DD	00H
	DD	imagerel ??0World@@QEAA@I@Z+82
	DD	01H
	DD	imagerel ??0World@@QEAA@I@Z+95
	DD	02H
	DD	imagerel ??0World@@QEAA@I@Z+124
	DD	03H
	DD	imagerel ??0World@@QEAA@I@Z+211
	DD	04H
	DD	imagerel ??0World@@QEAA@I@Z+240
	DD	05H
	DD	imagerel ??0World@@QEAA@I@Z+327
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0World@@QEAA@I@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0World@@QEAA@I@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0World@@QEAA@I@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0World@@QEAA@I@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0???0World@@QEAA@I@Z@4HA
	DD	03H
	DD	imagerel ?dtor$4@?0???0World@@QEAA@I@Z@4HA
	DD	04H
	DD	imagerel ?dtor$5@?0???0World@@QEAA@I@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0World@@QEAA@I@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??0World@@QEAA@I@Z
	DD	00H
	DD	00H
	DD	08H
	DD	imagerel $ip2state$??0World@@QEAA@I@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0World@@QEAA@I@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0World@@QEAA@I@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1World@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
	DD	0ffffffffH
	DD	imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z+92
	DD	00H
	DD	imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z+118
	DD	01H
	DD	imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z+139
	DD	02H
	DD	imagerel ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z+158
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1ChunkBase@@QEAA@XZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0Chunk@@QEAA@AEAVWorld@@HHH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tick@World@@QEAAXXZ DD imagerel ?tick@World@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ?tick@World@@QEAAXXZ+76
	DD	00H
	DD	imagerel ?tick@World@@QEAAXXZ+173
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tick@World@@QEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??tick@World@@QEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tick@World@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?tick@World@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?tick@World@@QEAAXXZ
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@World@@QEAAXXZ DD 081d11H
	DD	014341dH
	DD	0f008b20cH
	DD	07004e006H
	DD	050026003H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?tick@World@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
	DD	0ffffffffH
	DD	imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z+71
	DD	00H
	DD	imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z+312
	DD	01H
	DD	imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z+415
	DD	00H
	DD	imagerel ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z+503
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z DD 0a2911H
	DD	0193429H
	DD	0f016f21dH
	DD	0d012e014H
	DD	0700ec010H
	DD	0500c600dH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD imagerel ??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ+49
	DD	00H
	DD	imagerel ??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ+61
	DD	01H
	DD	imagerel ??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ+166
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0???0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ DD 041811H
	DD	0d3418H
	DD	07006720aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD imagerel ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
	DD	0ffffffffH
	DD	imagerel ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z+55
	DD	00H
	DD	imagerel ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z+97
	DD	01H
	DD	imagerel ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z+208
	DD	00H
	DD	imagerel ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z+255
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z DD 041411H
	DD	0113414H
	DD	07004d208H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	096405H
	DD	imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD imagerel ??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z+59
	DD	00H
	DD	imagerel ??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z+71
	DD	01H
	DD	imagerel ??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z+182
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 042211H
	DD	0d3422H
	DD	070107214H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z DD 021H
	DD	imagerel $LN266
	DD	imagerel $LN266+77
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z DD 060f21H
	DD	04e40fH
	DD	05540aH
	DD	0a3405H
	DD	imagerel $LN266
	DD	imagerel $LN266+77
	DD	imagerel $unwind$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z DD 041201H
	DD	0f00e5212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z DD 040a01H
	DD	0a340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN66
	DD	imagerel $LN66+43
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ DD 040a21H
	DD	07640aH
	DD	063405H
	DD	imagerel $LN66
	DD	imagerel $LN66+43
	DD	imagerel $unwind$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ DD 040b01H
	DD	08740bH
	DD	0e007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 081901H
	DD	096419H
	DD	075419H
	DD	063419H
	DD	070153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Hashval@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBA_KAEBVChunkPosition@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+26
	DD	imagerel $unwind$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN51
	DD	imagerel $LN51+26
	DD	imagerel $unwind$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z DD 040a01H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN86
	DD	imagerel $LN86+42
	DD	imagerel $unwind$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN86+42
	DD	imagerel $LN86+74
	DD	imagerel $chain$0$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 020521H
	DD	085405H
	DD	imagerel $LN86+42
	DD	imagerel $LN86+74
	DD	imagerel $chain$0$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 020521H
	DD	097405H
	DD	imagerel $LN86
	DD	imagerel $LN86+42
	DD	imagerel $unwind$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 040d01H
	DD	0e009320dH
	DD	030066007H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 0a1b01H
	DD	0f541bH
	DD	0d341bH
	DD	0f017521bH
	DD	0c013e015H
	DD	060107011H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@PEAV32@_KPEBV32@@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 021H
	DD	imagerel $LN25
	DD	imagerel $LN25+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN25
	DD	imagerel $LN25+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEAV21@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEAV10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD imagerel ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z+30
	DD	00H
	DD	imagerel ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z+88
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA+14
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z DD 041819H
	DD	083418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$emplace_front@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z DD 0a1a01H
	DD	09e41aH
	DD	08741aH
	DD	07641aH
	DD	06341aH
	DD	0f016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GEmptyChunk@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN98
	DD	imagerel $LN98+28
	DD	imagerel $unwind$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 021H
	DD	imagerel $LN98+28
	DD	imagerel $LN98+60
	DD	imagerel $chain$0$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 020521H
	DD	076405H
	DD	imagerel $LN98+28
	DD	imagerel $LN98+60
	DD	imagerel $chain$0$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 020521H
	DD	063405H
	DD	imagerel $LN98
	DD	imagerel $LN98+28
	DD	imagerel $unwind$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z DD 040a01H
	DD	08540aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN226
	DD	imagerel $LN226+77
	DD	imagerel $unwind$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 020521H
	DD	0c7405H
	DD	imagerel $LN226
	DD	imagerel $LN226+77
	DD	imagerel $unwind$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 040a01H
	DD	0d340aH
	DD	06006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN63
	DD	imagerel $LN63+17
	DD	imagerel $unwind$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 040a21H
	DD	09740aH
	DD	083405H
	DD	imagerel $LN63
	DD	imagerel $LN63+17
	DD	imagerel $unwind$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ DD 020601H
	DD	060025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD 021H
	DD	imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD 020521H
	DD	066405H
	DD	imagerel $LN22
	DD	imagerel $LN22+26
	DD	imagerel $unwind$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN16
	DD	imagerel $LN16+19
	DD	imagerel $unwind$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Incsize@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isLoaded@ChunkBase@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isLoaded@ChunkBase@@QEAA_NXZ PROC			; ChunkBase::isLoaded, COMDAT

; 75   : 	return loaded;

  00000	0f b6 41 09	 movzx	 eax, BYTE PTR [rcx+9]

; 76   : }

  00004	c3		 ret	 0
?isLoaded@ChunkBase@@QEAA_NXZ ENDP			; ChunkBase::isLoaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isUnloaded@ChunkBase@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isUnloaded@ChunkBase@@QEAA_NXZ PROC			; ChunkBase::isUnloaded, COMDAT

; 85   : 	return unloaded;

  00000	0f b6 41 0a	 movzx	 eax, BYTE PTR [rcx+10]

; 86   : }

  00004	c3		 ret	 0
?isUnloaded@ChunkBase@@QEAA_NXZ ENDP			; ChunkBase::isUnloaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setRenderUpdateNeeded@ChunkBase@@QEAAX_N@Z
_TEXT	SEGMENT
this$ = 8
flag$ = 16
?setRenderUpdateNeeded@ChunkBase@@QEAAX_N@Z PROC	; ChunkBase::setRenderUpdateNeeded, COMDAT

; 95   : 	renderUpdateNeeded = flag;

  00000	88 51 08	 mov	 BYTE PTR [rcx+8], dl

; 96   : }

  00003	c3		 ret	 0
?setRenderUpdateNeeded@ChunkBase@@QEAAX_N@Z ENDP	; ChunkBase::setRenderUpdateNeeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isRenderUpdateNeeded@ChunkBase@@QEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isRenderUpdateNeeded@ChunkBase@@QEAA_NXZ PROC		; ChunkBase::isRenderUpdateNeeded, COMDAT

; 100  : 	return renderUpdateNeeded;

  00000	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]

; 101  : }

  00004	c3		 ret	 0
?isRenderUpdateNeeded@ChunkBase@@QEAA_NXZ ENDP		; ChunkBase::isRenderUpdateNeeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 128
$T5 = 128
this$ = 128
__$ReturnUdt$ = 136
x$ = 144
y$ = 152
z$ = 160
?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z PROC ; World::getChunk, COMDAT

; 218  : {

$LN248:
  00000	48 8b c4	 mov	 rax, rsp
  00003	44 89 48 20	 mov	 DWORD PTR [rax+32], r9d
  00007	44 89 40 18	 mov	 DWORD PTR [rax+24], r8d
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00016	48 c7 40 d0 fe
	ff ff ff	 mov	 QWORD PTR [rax-48], -2
  0001e	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00022	41 8b f1	 mov	 esi, r9d
  00025	41 8b e8	 mov	 ebp, r8d
  00028	48 8b da	 mov	 rbx, rdx
  0002b	4c 8b d9	 mov	 r11, rcx
  0002e	45 33 ff	 xor	 r15d, r15d
  00031	44 89 7c 24 30	 mov	 DWORD PTR $T1[rsp], r15d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 205  : 		_Val ^= (size_t)_First[_Next];

  00036	41 0f b6 d0	 movzx	 edx, r8b
  0003a	49 b9 25 23 22
	84 e4 9c f2 cb	 mov	 r9, -3750763034362895579 ; cbf29ce484222325H
  00044	49 33 d1	 xor	 rdx, r9

; 206  : 		_Val *= _FNV_prime;

  00047	49 ba b3 01 00
	00 00 01 00 00	 mov	 r10, 1099511628211	; 00000100000001b3H
  00051	49 0f af d2	 imul	 rdx, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  00055	0f b6 40 19	 movzx	 eax, BYTE PTR [rax+25]
  00059	48 33 d0	 xor	 rdx, rax

; 206  : 		_Val *= _FNV_prime;

  0005c	49 0f af d2	 imul	 rdx, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  00060	0f b6 84 24 92
	00 00 00	 movzx	 eax, BYTE PTR x$[rsp+2]
  00068	48 33 d0	 xor	 rdx, rax

; 206  : 		_Val *= _FNV_prime;

  0006b	49 0f af d2	 imul	 rdx, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  0006f	0f b6 84 24 93
	00 00 00	 movzx	 eax, BYTE PTR x$[rsp+3]
  00077	48 33 d0	 xor	 rdx, rax

; 206  : 		_Val *= _FNV_prime;

  0007a	49 0f af d2	 imul	 rdx, r10

; 207  : 		}
; 208  : 
; 209  :  #ifdef _M_X64
; 210  : 	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 211  : 	_Val ^= _Val >> 32;

  0007e	48 8b c2	 mov	 rax, rdx
  00081	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00085	48 33 d0	 xor	 rdx, rax

; 205  : 		_Val ^= (size_t)_First[_Next];

  00088	40 0f b6 ce	 movzx	 ecx, sil
  0008c	49 33 c9	 xor	 rcx, r9

; 206  : 		_Val *= _FNV_prime;

  0008f	49 0f af ca	 imul	 rcx, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  00093	0f b6 84 24 99
	00 00 00	 movzx	 eax, BYTE PTR y$[rsp+1]
  0009b	48 33 c8	 xor	 rcx, rax

; 206  : 		_Val *= _FNV_prime;

  0009e	49 0f af ca	 imul	 rcx, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  000a2	0f b6 84 24 9a
	00 00 00	 movzx	 eax, BYTE PTR y$[rsp+2]
  000aa	48 33 c8	 xor	 rcx, rax

; 206  : 		_Val *= _FNV_prime;

  000ad	49 0f af ca	 imul	 rcx, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  000b1	0f b6 84 24 9b
	00 00 00	 movzx	 eax, BYTE PTR y$[rsp+3]
  000b9	48 33 c8	 xor	 rcx, rax

; 206  : 		_Val *= _FNV_prime;

  000bc	49 0f af ca	 imul	 rcx, r10

; 207  : 		}
; 208  : 
; 209  :  #ifdef _M_X64
; 210  : 	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 211  : 	_Val ^= _Val >> 32;

  000c0	48 8b c1	 mov	 rax, rcx
  000c3	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000c7	48 33 c8	 xor	 rcx, rax

; 205  : 		_Val ^= (size_t)_First[_Next];

  000ca	44 8b b4 24 a0
	00 00 00	 mov	 r14d, DWORD PTR z$[rsp]
  000d2	45 0f b6 c6	 movzx	 r8d, r14b
  000d6	4d 33 c1	 xor	 r8, r9

; 206  : 		_Val *= _FNV_prime;

  000d9	4d 0f af c2	 imul	 r8, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  000dd	0f b6 84 24 a1
	00 00 00	 movzx	 eax, BYTE PTR z$[rsp+1]
  000e5	4c 33 c0	 xor	 r8, rax

; 206  : 		_Val *= _FNV_prime;

  000e8	4d 0f af c2	 imul	 r8, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  000ec	0f b6 84 24 a2
	00 00 00	 movzx	 eax, BYTE PTR z$[rsp+2]
  000f4	4c 33 c0	 xor	 r8, rax

; 206  : 		_Val *= _FNV_prime;

  000f7	4d 0f af c2	 imul	 r8, r10

; 205  : 		_Val ^= (size_t)_First[_Next];

  000fb	0f b6 84 24 a3
	00 00 00	 movzx	 eax, BYTE PTR z$[rsp+3]
  00103	4c 33 c0	 xor	 r8, rax

; 206  : 		_Val *= _FNV_prime;

  00106	4d 0f af c2	 imul	 r8, r10

; 207  : 		}
; 208  : 
; 209  :  #ifdef _M_X64
; 210  : 	static_assert(sizeof(size_t) == 8, "This code is for 64-bit size_t.");
; 211  : 	_Val ^= _Val >> 32;

  0010a	49 8b c0	 mov	 rax, r8
  0010d	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00111	4c 33 c0	 xor	 r8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00114	4d 8b 4b 78	 mov	 r9, QWORD PTR [r11+120]
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.h

; 30   : 			return (hash<int>()(key.x) >> 8) ^ hash<int>()(key.y) ^ (hash<int>()(key.z) << 8);

  00118	49 c1 e0 08	 shl	 r8, 8
  0011c	48 c1 ea 08	 shr	 rdx, 8
  00120	4c 33 c2	 xor	 r8, rdx
  00123	4c 33 c1	 xor	 r8, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00126	4d 23 c1	 and	 r8, r9

; 1004 : 		if (_Maxidx <= _Num)

  00129	4d 39 83 80 00
	00 00		 cmp	 QWORD PTR [r11+128], r8
  00130	77 0d		 ja	 SHORT $LN22@getChunk

; 1005 : 			_Num -= (_Mask >> 1) + 1;

  00132	49 d1 e9	 shr	 r9, 1
  00135	48 83 c8 ff	 or	 rax, -1
  00139	49 2b c1	 sub	 rax, r9
  0013c	4c 03 c0	 add	 r8, rax
$LN22@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  0013f	49 c1 e0 04	 shl	 r8, 4
  00143	4d 8b 53 60	 mov	 r10, QWORD PTR [r11+96]
  00147	4d 03 d0	 add	 r10, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 926  : 		return (_Vec_lo(_Bucket));

  0014a	4d 8b 0a	 mov	 r9, QWORD PTR [r10]
  0014d	49 8b c1	 mov	 rax, r9
  00150	49 8b 53 50	 mov	 rdx, QWORD PTR [r11+80]
$LL60@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00154	4c 3b ca	 cmp	 r9, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 936  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

  00157	75 0d		 jne	 SHORT $LN65@getChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00159	48 8b ca	 mov	 rcx, rdx
  0015c	48 89 94 24 80
	00 00 00	 mov	 QWORD PTR $T4[rsp], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 937  : 			return (_Unchecked_end());

  00164	eb 0f		 jmp	 SHORT $LN64@getChunk
$LN65@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00166	49 8b 4a 08	 mov	 rcx, QWORD PTR [r10+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 941  : 			return (++_Ans);

  0016a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0016d	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR $T4[rsp], rcx
$LN64@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00175	48 3b c1	 cmp	 rax, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 748  : 			_Where != _End(_Bucket); ++_Where)

  00178	74 58		 je	 SHORT $LN15@getChunk
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  0017a	39 70 14	 cmp	 DWORD PTR [rax+20], esi
  0017d	41 0f 94 c0	 sete	 r8b
  00181	44 39 70 18	 cmp	 DWORD PTR [rax+24], r14d
  00185	0f 94 c1	 sete	 cl
  00188	44 22 c1	 and	 r8b, cl
  0018b	39 68 10	 cmp	 DWORD PTR [rax+16], ebp
  0018e	0f 94 c1	 sete	 cl
  00191	44 84 c1	 test	 r8b, cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 749  : 			if (!((_Traits&)*this)(this->_Kfn(*_Where), _Keyval))

  00194	75 05		 jne	 SHORT $LN224@getChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  00196	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00199	eb b9		 jmp	 SHORT $LL60@getChunk
$LN224@getChunk:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  0019b	3b 70 14	 cmp	 esi, DWORD PTR [rax+20]
  0019e	41 0f 94 c0	 sete	 r8b
  001a2	44 3b 70 18	 cmp	 r14d, DWORD PTR [rax+24]
  001a6	0f 94 c1	 sete	 cl
  001a9	44 22 c1	 and	 r8b, cl
  001ac	3b 68 10	 cmp	 ebp, DWORD PTR [rax+16]
  001af	0f 94 c1	 sete	 cl
  001b2	44 84 c1	 test	 r8b, cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 751  : 					this->_Kfn(*_Where)) ? end() : _Make_iter(_Where));

  001b5	75 0c		 jne	 SHORT $LN20@getChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  001b7	48 89 54 24 38	 mov	 QWORD PTR $T2[rsp], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 751  : 					this->_Kfn(*_Where)) ? end() : _Make_iter(_Where));

  001bc	48 8d 44 24 38	 lea	 rax, QWORD PTR $T2[rsp]
  001c1	eb 0a		 jmp	 SHORT $LN21@getChunk
$LN20@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  001c3	48 89 44 24 40	 mov	 QWORD PTR $T3[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 751  : 					this->_Kfn(*_Where)) ? end() : _Make_iter(_Where));

  001c8	48 8d 44 24 40	 lea	 rax, QWORD PTR $T3[rsp]
$LN21@getChunk:
  001cd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d0	eb 03		 jmp	 SHORT $LN174@getChunk
$LN15@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  001d2	48 8b c2	 mov	 rax, rdx
$LN174@getChunk:

; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  001d5	48 3b c2	 cmp	 rax, rdx
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 221  : 	if(chunk == chunkMap.end())

  001d8	75 57		 jne	 SHORT $LN2@getChunk

; 223  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  001da	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  001df	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  001e4	48 8b f8	 mov	 rdi, rax
  001e7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR $T5[rsp], rax
  001ef	48 85 c0	 test	 rax, rax
  001f2	74 26		 je	 SHORT $LN5@getChunk

; 112  : {

  001f4	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  001f9	44 8b ce	 mov	 r9d, esi
  001fc	44 8b c5	 mov	 r8d, ebp
  001ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00206	48 8b c8	 mov	 rcx, rax
  00209	e8 00 00 00 00	 call	 ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  0020e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  00215	48 89 07	 mov	 QWORD PTR [rdi], rax

; 223  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  00218	eb 03		 jmp	 SHORT $LN6@getChunk
$LN5@getChunk:
  0021a	49 8b ff	 mov	 rdi, r15
$LN6@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0021d	4c 89 3b	 mov	 QWORD PTR [rbx], r15
  00220	4c 89 7b 08	 mov	 QWORD PTR [rbx+8], r15

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00224	48 8b d7	 mov	 rdx, rdi
  00227	48 8b cb	 mov	 rcx, rbx
  0022a	e8 00 00 00 00	 call	 ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 223  : 		return shared_ptr<ChunkBase>(new EmptyChunk(GlobalThread::world, x, y, z));

  0022f	eb 21		 jmp	 SHORT $LN247@getChunk
$LN2@getChunk:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00231	4c 89 3b	 mov	 QWORD PTR [rbx], r15
  00234	4c 89 7b 08	 mov	 QWORD PTR [rbx+8], r15

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00238	4c 8b 40 28	 mov	 r8, QWORD PTR [rax+40]
  0023c	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00240	4d 85 c0	 test	 r8, r8
  00243	74 05		 je	 SHORT $LN218@getChunk

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00245	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN218@getChunk:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0024a	48 8b cb	 mov	 rcx, rbx
  0024d	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN247@getChunk:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 227  : 		return chunk->second;

  00252	48 8b c3	 mov	 rax, rbx

; 228  : 	}
; 229  : }

  00255	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  0025d	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00261	41 5f		 pop	 r15
  00263	41 5e		 pop	 r14
  00265	5f		 pop	 rdi
  00266	5e		 pop	 rsi
  00267	5d		 pop	 rbp
  00268	c3		 ret	 0
?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ENDP ; World::getChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
$T3 = 64
$T4 = 128
$T5 = 128
this$ = 128
__$ReturnUdt$ = 136
x$ = 144
y$ = 152
z$ = 160
?dtor$0@?0??getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z@4HA PROC ; `World::getChunk'::`1'::dtor$0
  00000	48 8b 8a 80 00
	00 00		 mov	 rcx, QWORD PTR $T5[rdx]
  00007	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$0@?0??getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z@4HA ENDP ; `World::getChunk'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@World@@QEAAPEAVBlock@@HHH@Z
_TEXT	SEGMENT
$T1 = 48
chunk$ = 56
this$ = 96
x$ = 104
y$ = 112
z$ = 120
?getBlock@World@@QEAAPEAVBlock@@HHH@Z PROC		; World::getBlock, COMDAT

; 249  : {

$LN50:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 30
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00014	48 89 6c 24 68	 mov	 QWORD PTR [rsp+104], rbp
  00019	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  0001e	41 8b f9	 mov	 edi, r9d
  00021	41 8b f0	 mov	 esi, r8d
  00024	8b ea		 mov	 ebp, edx

; 250  : 	std::shared_ptr<ChunkBase> chunk = getChunkFromBlockCoordinate(x, y, z);

  00026	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  0002b	45 8b c8	 mov	 r9d, r8d
  0002e	44 8b c2	 mov	 r8d, edx
  00031	48 8d 54 24 38	 lea	 rdx, QWORD PTR chunk$[rsp]
  00036	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  0003b	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  0003c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR chunk$[rsp]
  00041	48 85 db	 test	 rbx, rbx
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 252  : 	if(chunk == nullptr || chunk->isEmpty() || !chunk->isLoaded())

  00044	74 30		 je	 SHORT $LN1@getBlock
  00046	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00049	48 8b cb	 mov	 rcx, rbx
  0004c	ff 50 18	 call	 QWORD PTR [rax+24]
  0004f	84 c0		 test	 al, al
  00051	75 23		 jne	 SHORT $LN1@getBlock
  00053	38 43 09	 cmp	 BYTE PTR [rbx+9], al
  00056	74 1e		 je	 SHORT $LN1@getBlock

; 257  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  00058	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0005b	83 e7 0f	 and	 edi, 15
  0005e	83 e6 0f	 and	 esi, 15
  00061	83 e5 0f	 and	 ebp, 15
  00064	44 8b cf	 mov	 r9d, edi
  00067	44 8b c6	 mov	 r8d, esi
  0006a	8b d5		 mov	 edx, ebp
  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	ff 10		 call	 QWORD PTR [rax]
  00071	48 8b f8	 mov	 rdi, rax
  00074	eb 07		 jmp	 SHORT $LN6@getBlock
$LN1@getBlock:
  00076	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?air@Blocks@@3PEAVBlockAir@@EA ; Blocks::air
$LN6@getBlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR chunk$[rsp+8]
  00082	48 85 c9	 test	 rcx, rcx
  00085	74 24		 je	 SHORT $LN49@getBlock

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00087	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  0008b	75 1e		 jne	 SHORT $LN49@getBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR chunk$[rsp+8]
  00092	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00095	48 8b cb	 mov	 rcx, rbx
  00098	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0009a	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0009e	75 0b		 jne	 SHORT $LN49@getBlock

; 128  : 			_Delete_this();

  000a0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR chunk$[rsp+8]
  000a5	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000a8	ff 50 08	 call	 QWORD PTR [rax+8]
$LN49@getBlock:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 257  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  000ab	48 8b c7	 mov	 rax, rdi

; 258  : }

  000ae	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000b3	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000b8	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000bd	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
?getBlock@World@@QEAAPEAVBlock@@HHH@Z ENDP		; World::getBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
chunk$ = 56
this$ = 96
x$ = 104
y$ = 112
z$ = 120
?dtor$0@?0??getBlock@World@@QEAAPEAVBlock@@HHH@Z@4HA PROC ; `World::getBlock'::`1'::dtor$0
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??getBlock@World@@QEAAPEAVBlock@@HHH@Z@4HA ENDP ; `World::getBlock'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setLoaded@ChunkBase@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?setLoaded@ChunkBase@@QEAAXXZ PROC			; ChunkBase::setLoaded, COMDAT

; 70   : 	loaded = true;

  00000	c6 41 09 01	 mov	 BYTE PTR [rcx+9], 1

; 71   : }

  00004	c3		 ret	 0
?setLoaded@ChunkBase@@QEAAXXZ ENDP			; ChunkBase::setLoaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBoundingBox@ChunkBase@@QEAA?AVAxisAlignedCube@geom@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?getBoundingBox@ChunkBase@@QEAA?AVAxisAlignedCube@geom@@XZ PROC ; ChunkBase::getBoundingBox, COMDAT

; 104  : {

  00000	66 0f 6e 49 18	 movd	 xmm1, DWORD PTR [rcx+24]
  00005	66 0f 6e 51 1c	 movd	 xmm2, DWORD PTR [rcx+28]
  0000a	66 0f 6e 59 20	 movd	 xmm3, DWORD PTR [rcx+32]
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 63   : 	return Vector(x * f, y * f, z * f);

  0000f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41800000

; 10   : {

  00017	c7 42 0c 00 00
	80 3f		 mov	 DWORD PTR [rdx+12], 1065353216 ; 3f800000H
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 105  : 	return geom::AxisAlignedCube(geom::Vector(pos.x, pos.y, pos.z) * 16.0f, geom::Vector(16.0f, 16.0f, 16.0f));

  0001e	48 8b c2	 mov	 rax, rdx
  00021	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00024	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00027	0f 5b db	 cvtdq2ps xmm3, xmm3
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 63   : 	return Vector(x * f, y * f, z * f);

  0002a	f3 0f 59 c8	 mulss	 xmm1, xmm0
  0002e	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00032	f3 0f 59 d8	 mulss	 xmm3, xmm0

; 10   : {

  00036	f3 0f 11 0a	 movss	 DWORD PTR [rdx], xmm1
  0003a	f3 0f 11 52 04	 movss	 DWORD PTR [rdx+4], xmm2
  0003f	f3 0f 11 5a 08	 movss	 DWORD PTR [rdx+8], xmm3
  00044	c7 42 10 00 00
	80 41		 mov	 DWORD PTR [rdx+16], 1098907648 ; 41800000H
  0004b	c7 42 14 00 00
	80 41		 mov	 DWORD PTR [rdx+20], 1098907648 ; 41800000H
  00052	c7 42 18 00 00
	80 41		 mov	 DWORD PTR [rdx+24], 1098907648 ; 41800000H
  00059	c7 42 1c 00 00
	80 3f		 mov	 DWORD PTR [rdx+28], 1065353216 ; 3f800000H
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 106  : }

  00060	c3		 ret	 0
?getBoundingBox@ChunkBase@@QEAA?AVAxisAlignedCube@geom@@XZ ENDP ; ChunkBase::getBoundingBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0ChunkPosition@@QEAA@HHH@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
??0ChunkPosition@@QEAA@HHH@Z PROC			; ChunkPosition::ChunkPosition, COMDAT

; 11   : {

  00000	89 11		 mov	 DWORD PTR [rcx], edx
  00002	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d
  00006	44 89 49 08	 mov	 DWORD PTR [rcx+8], r9d

; 12   : 
; 13   : }

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0ChunkPosition@@QEAA@HHH@Z ENDP			; ChunkPosition::ChunkPosition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??8@YA_NAEBVChunkPosition@@0@Z
_TEXT	SEGMENT
cp1$ = 8
cp2$ = 16
??8@YA_NAEBVChunkPosition@@0@Z PROC			; operator==, COMDAT

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  00000	44 8b 42 08	 mov	 r8d, DWORD PTR [rdx+8]
  00004	45 33 d2	 xor	 r10d, r10d
  00007	44 39 41 08	 cmp	 DWORD PTR [rcx+8], r8d
  0000b	44 8b 42 04	 mov	 r8d, DWORD PTR [rdx+4]
  0000f	8b 12		 mov	 edx, DWORD PTR [rdx]
  00011	41 8b c2	 mov	 eax, r10d
  00014	0f 94 c0	 sete	 al
  00017	44 39 41 04	 cmp	 DWORD PTR [rcx+4], r8d
  0001b	45 8b ca	 mov	 r9d, r10d
  0001e	41 0f 94 c1	 sete	 r9b
  00022	41 23 c1	 and	 eax, r9d
  00025	39 11		 cmp	 DWORD PTR [rcx], edx
  00027	41 0f 94 c2	 sete	 r10b
  0002b	41 23 c2	 and	 eax, r10d

; 331  : }

  0002e	c3		 ret	 0
??8@YA_NAEBVChunkPosition@@0@Z ENDP			; operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getSeed@World@@QEAAIXZ
_TEXT	SEGMENT
this$dead$ = 8
?getSeed@World@@QEAAIXZ PROC				; World::getSeed, COMDAT

; 304  : 	return seed;

  00000	8b 05 40 00 00
	00		 mov	 eax, DWORD PTR ?world@GlobalThread@@3VWorld@@A+64

; 305  : }

  00006	c3		 ret	 0
?getSeed@World@@QEAAIXZ ENDP				; World::getSeed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setUnloaded@ChunkBase@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?setUnloaded@ChunkBase@@QEAAXXZ PROC			; ChunkBase::setUnloaded, COMDAT

; 80   : 	unloaded = true;

  00000	c6 41 0a 01	 mov	 BYTE PTR [rcx+10], 1

; 81   : }

  00004	c3		 ret	 0
?setUnloaded@ChunkBase@@QEAAXXZ ENDP			; ChunkBase::setUnloaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 80
this$ = 80
chunk$ = 88
?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; World::addChunk, COMDAT

; 286  : {

$LN53:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000c	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00015	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  0001a	48 8b fa	 mov	 rdi, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 439  : 		return (_List.end());

  0001d	48 8d 71 50	 lea	 rsi, QWORD PTR [rcx+80]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00021	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00024	48 8b 2a	 mov	 rbp, QWORD PTR [rdx]
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  00027	4c 8d 45 18	 lea	 r8, QWORD PTR [rbp+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 728  : 		return (lower_bound(_Keyval));

  0002b	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00030	48 8b ce	 mov	 rcx, rsi
  00033	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00038	48 39 5c 24 50	 cmp	 QWORD PTR $T2[rsp], rbx
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 287  : 	if(chunkMap.find(chunk->pos) != chunkMap.end())

  0003d	74 30		 je	 SHORT $LN1@addChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0003f	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  00043	48 85 ff	 test	 rdi, rdi
  00046	74 23		 je	 SHORT $LN35@addChunk

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00048	83 c8 ff	 or	 eax, -1
  0004b	f0 0f c1 47 08	 lock xadd DWORD PTR [rdi+8], eax
  00050	ff c8		 dec	 eax
  00052	75 17		 jne	 SHORT $LN35@addChunk

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00054	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00057	48 8b cf	 mov	 rcx, rdi
  0005a	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0005c	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  00060	75 09		 jne	 SHORT $LN35@addChunk

; 128  : 			_Delete_this();

  00062	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00065	48 8b cf	 mov	 rcx, rdi
  00068	ff 50 08	 call	 QWORD PTR [rax+8]
$LN35@addChunk:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 289  : 		return false;

  0006b	32 c0		 xor	 al, al
  0006d	eb 46		 jmp	 SHORT $LN2@addChunk
$LN1@addChunk:

; 290  : 	}
; 291  : 	
; 292  : 	chunkMap[chunk->pos] = chunk;

  0006f	48 8d 55 18	 lea	 rdx, QWORD PTR [rbp+24]
  00073	48 8b ce	 mov	 rcx, rsi
  00076	e8 00 00 00 00	 call	 ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	48 8b d7	 mov	 rdx, rdi
  00081	e8 00 00 00 00	 call	 ??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z ; std::shared_ptr<ChunkBase>::operator=
  00086	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00087	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  0008b	48 85 ff	 test	 rdi, rdi
  0008e	74 23		 je	 SHORT $LN50@addChunk

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00090	83 c8 ff	 or	 eax, -1
  00093	f0 0f c1 47 08	 lock xadd DWORD PTR [rdi+8], eax
  00098	ff c8		 dec	 eax
  0009a	75 17		 jne	 SHORT $LN50@addChunk

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0009c	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0009f	48 8b cf	 mov	 rcx, rdi
  000a2	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000a4	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  000a8	75 09		 jne	 SHORT $LN50@addChunk

; 128  : 			_Delete_this();

  000aa	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000ad	48 8b cf	 mov	 rcx, rdi
  000b0	ff 50 08	 call	 QWORD PTR [rax+8]
$LN50@addChunk:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 294  : 	return true;

  000b3	b0 01		 mov	 al, 1
$LN2@addChunk:

; 295  : }

  000b5	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	5e		 pop	 rsi
  000c0	5d		 pop	 rbp
  000c1	c3		 ret	 0
?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; World::addChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 80
this$ = 80
chunk$ = 88
?dtor$0@?0??addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `World::addChunk'::`1'::dtor$0
  00000	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `World::addChunk'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?removeChunk@World@@QEAAXVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 64
this$ = 64
cp$ = 72
?removeChunk@World@@QEAAXVChunkPosition@@@Z PROC	; World::removeChunk, COMDAT

; 298  : {

$LN34:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 299  : 	chunkMap.erase(cp);

  00006	48 8d 59 50	 lea	 rbx, QWORD PTR [rcx+80]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 713  : 		_Pairii _Where = equal_range(_Keyval);

  0000a	4c 8b c2	 mov	 r8, rdx
  0000d	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00012	48 8b cb	 mov	 rcx, rbx
  00015	e8 00 00 00 00	 call	 ?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0001a	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0001d	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00021	49 8b c0	 mov	 rax, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00024	4d 3b c1	 cmp	 r8, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00027	74 0f		 je	 SHORT $LN15@removeChun
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL22@removeChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00030	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00033	49 3b c1	 cmp	 rax, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00036	75 f8		 jne	 SHORT $LL22@removeChun
$LN15@removeChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 716  : 		erase(_Where.first, _Where.second);

  00038	48 8d 54 24 40	 lea	 rdx, QWORD PTR $T2[rsp]
  0003d	48 8b cb	 mov	 rcx, rbx
  00040	e8 00 00 00 00	 call	 ?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 300  : }

  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
?removeChunk@World@@QEAAXVChunkPosition@@@Z ENDP	; World::removeChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0World@@QEAA@I@Z
_TEXT	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
seed$ = 72
??0World@@QEAA@I@Z PROC					; World::World, COMDAT

; 193  : {

$LN139:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	8b da		 mov	 ebx, edx
  0001a	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00021	48 89 7c 24 40	 mov	 QWORD PTR this$[rsp], rdi
  00026	48 8b cf	 mov	 rcx, rdi
  00029	e8 00 00 00 00	 call	 ??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
  0002e	90		 npad	 1
  0002f	89 1d 40 00 00
	00		 mov	 DWORD PTR ?world@GlobalThread@@3VWorld@@A+64, ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00035	ba 02 00 00 00	 mov	 edx, 2
  0003a	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  00041	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00046	85 c0		 test	 eax, eax
  00048	74 08		 je	 SHORT $LN16@World

; 33   : 		_Throw_C_error(_Res);

  0004a	8b c8		 mov	 ecx, eax
  0004c	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00051	90		 npad	 1
$LN16@World:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 193  : {

  00052	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+80
  00059	e8 00 00 00 00	 call	 ??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
  0005e	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0005f	ba 02 00 00 00	 mov	 edx, 2
  00064	48 8d 0d 90 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+144
  0006b	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00070	85 c0		 test	 eax, eax
  00072	74 08		 je	 SHORT $LN25@World

; 33   : 		_Throw_C_error(_Res);

  00074	8b c8		 mov	 ecx, eax
  00076	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0007b	90		 npad	 1
$LN25@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  0007c	33 db		 xor	 ebx, ebx
  0007e	48 89 1d 98 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+152, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  00085	48 89 1d a0 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+160, rbx

; 779  : 		_Mapsize = 0;

  0008c	48 89 1d a8 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+168, rbx

; 780  : 		_Myoff = 0;

  00093	48 89 1d b0 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+176, rbx

; 781  : 		_Mysize = 0;

  0009a	48 89 1d b8 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+184, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000a1	8d 4b 10	 lea	 ecx, QWORD PTR [rbx+16]
  000a4	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000a9	48 85 c0	 test	 rax, rax
  000ac	75 06		 jne	 SHORT $LN49@World

; 29   : 		_Xbad_alloc();	// report no memory

  000ae	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000b3	cc		 int	 3
$LN49@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  000b4	48 89 05 98 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+152, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000bb	48 89 18	 mov	 QWORD PTR [rax], rbx
  000be	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  000c2	48 8d 0d 98 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+152
  000c9	48 8b 05 98 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+152
  000d0	48 89 08	 mov	 QWORD PTR [rax], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  000d3	ba 02 00 00 00	 mov	 edx, 2
  000d8	48 8d 0d c0 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+192
  000df	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  000e4	85 c0		 test	 eax, eax
  000e6	74 08		 je	 SHORT $LN85@World

; 33   : 		_Throw_C_error(_Res);

  000e8	8b c8		 mov	 ecx, eax
  000ea	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  000ef	90		 npad	 1
$LN85@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 79   : 		{	// construct childless container

  000f0	48 89 1d c8 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+200, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 778  : 		_Map = _Mapptr();

  000f7	48 89 1d d0 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+208, rbx

; 779  : 		_Mapsize = 0;

  000fe	48 89 1d d8 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+216, rbx

; 780  : 		_Myoff = 0;

  00105	48 89 1d e0 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+224, rbx

; 781  : 		_Mysize = 0;

  0010c	48 89 1d e8 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+232, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00113	b9 10 00 00 00	 mov	 ecx, 16
  00118	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0011d	48 85 c0	 test	 rax, rax
  00120	75 06		 jne	 SHORT $LN109@World

; 29   : 		_Xbad_alloc();	// report no memory

  00122	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00127	cc		 int	 3
$LN109@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 900  : 		this->_Myproxy = _Alproxy.allocate(1);

  00128	48 89 05 c8 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+200, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0012f	48 89 18	 mov	 QWORD PTR [rax], rbx
  00132	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 902  : 		this->_Myproxy->_Mycont = this;

  00136	48 8d 15 c8 00
	00 00		 lea	 rdx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+200
  0013d	48 8b 0d c8 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+200
  00144	48 89 11	 mov	 QWORD PTR [rcx], rdx
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 195  : }

  00147	48 8b c7	 mov	 rax, rdi
  0014a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0014f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00153	5f		 pop	 rdi
  00154	c3		 ret	 0
$LN138@World:
??0World@@QEAA@I@Z ENDP					; World::World
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
seed$ = 72
?dtor$0@?0???0World@@QEAA@I@Z@4HA PROC			; `World::World'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
?dtor$0@?0???0World@@QEAA@I@Z@4HA ENDP			; `World::World'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
seed$ = 72
?dtor$1@?0???0World@@QEAA@I@Z@4HA PROC			; `World::World'::`1'::dtor$1
  0000c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00013	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00017	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$1@?0???0World@@QEAA@I@Z@4HA ENDP			; `World::World'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
seed$ = 72
?dtor$2@?0???0World@@QEAA@I@Z@4HA PROC			; `World::World'::`1'::dtor$2
  0001c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00023	48 83 c1 50	 add	 rcx, 80			; 00000050H
  00027	e9 00 00 00 00	 jmp	 ??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
?dtor$2@?0???0World@@QEAA@I@Z@4HA ENDP			; `World::World'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
seed$ = 72
?dtor$3@?0???0World@@QEAA@I@Z@4HA PROC			; `World::World'::`1'::dtor$3
  0002c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00033	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  0003a	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$3@?0???0World@@QEAA@I@Z@4HA ENDP			; `World::World'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
seed$ = 72
?dtor$4@?0???0World@@QEAA@I@Z@4HA PROC			; `World::World'::`1'::dtor$4
  0003f	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00046	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  0004d	e9 00 00 00 00	 jmp	 ??1?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAA@XZ
?dtor$4@?0???0World@@QEAA@I@Z@4HA ENDP			; `World::World'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$dead$ = 64
this$ = 64
seed$ = 72
?dtor$5@?0???0World@@QEAA@I@Z@4HA PROC			; `World::World'::`1'::dtor$5
  00052	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00059	48 81 c1 c0 00
	00 00		 add	 rcx, 192		; 000000c0H
  00060	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$5@?0???0World@@QEAA@I@Z@4HA ENDP			; `World::World'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1World@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 48
??1World@@QEAA@XZ PROC					; World::~World, COMDAT

; 198  : {

$LN138:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00006	48 8d 0d c8 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+200
  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00012	48 8b 0d c8 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+200
  00019	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0001e	48 8d 0d c0 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+192
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00025	33 db		 xor	 ebx, ebx
  00027	48 89 1d c8 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+200, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0002e	e8 00 00 00 00	 call	 _Mtx_destroy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1222 : 		_Tidy();

  00033	48 8d 0d 98 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+152
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0003f	48 8b 0d 98 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+152
  00046	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0004b	48 8d 0d 90 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+144
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 912  : 		this->_Myproxy = 0;

  00052	48 89 1d 98 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+152, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00059	e8 00 00 00 00	 call	 _Mtx_destroy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  0005e	48 8b 0d 60 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+96
  00065	48 85 c9	 test	 rcx, rcx
  00068	74 17		 je	 SHORT $LN45@World
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0006a	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0006f	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1544 : 			this->_Myend = pointer();

  00072	48 89 1d 70 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+112, rbx
  00079	66 0f 7f 05 60
	00 00 00	 movdqa	 XMMWORD PTR ?world@GlobalThread@@3VWorld@@A+96, xmm0
$LN45@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1927 : 		clear();

  00081	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+80
  00088	e8 00 00 00 00	 call	 ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0008d	48 8b 0d 50 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+80
  00094	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00099	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  000a0	e8 00 00 00 00	 call	 _Mtx_destroy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  000a5	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+16
  000ac	48 85 c9	 test	 rcx, rcx
  000af	74 17		 je	 SHORT $LN96@World
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  000b1	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  000b6	0f 57 c0	 xorps	 xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1544 : 			this->_Myend = pointer();

  000b9	48 89 1d 20 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+32, rbx
  000c0	66 0f 7f 05 10
	00 00 00	 movdqa	 XMMWORD PTR ?world@GlobalThread@@3VWorld@@A+16, xmm0
$LN96@World:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1927 : 		clear();

  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  000cf	e8 00 00 00 00	 call	 ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  000d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 200  : }

  000db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000df	5b		 pop	 rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  000e0	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1World@@QEAA@XZ ENDP					; World::~World
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base0@std@@QEBAPEBU_Container_base0@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Getcont@_Iterator_base0@std@@QEBAPEBU_Container_base0@2@XZ PROC ; std::_Iterator_base0::_Getcont, COMDAT

; 55   : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 56   : 		}

  00002	c3		 ret	 0
?_Getcont@_Iterator_base0@std@@QEBAPEBU_Container_base0@2@XZ ENDP ; std::_Iterator_base0::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?toIndex@@YAIAEAI00@Z
_TEXT	SEGMENT
x$ = 8
y$ = 16
z$ = 24
?toIndex@@YAIAEAI00@Z PROC				; toIndex, COMDAT

; 6    : 	return x << 8 | y << 4 | z;

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	c1 e0 04	 shl	 eax, 4
  00005	0b 02		 or	 eax, DWORD PTR [rdx]
  00007	c1 e0 04	 shl	 eax, 4
  0000a	41 0b 00	 or	 eax, DWORD PTR [r8]

; 7    : }

  0000d	c3		 ret	 0
?toIndex@@YAIAEAI00@Z ENDP				; toIndex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z PROC		; ChunkBase::ChunkBase, COMDAT

; 54   : {

$LN35:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkBase@@6B@
  00022	48 89 01	 mov	 QWORD PTR [rcx], rax
  00025	66 c7 41 08 00
	00		 mov	 WORD PTR [rcx+8], 0
  0002b	c6 41 0a 00	 mov	 BYTE PTR [rcx+10], 0
  0002f	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 11   : {

  00033	44 89 41 18	 mov	 DWORD PTR [rcx+24], r8d
  00037	44 89 49 1c	 mov	 DWORD PTR [rcx+28], r9d
  0003b	8b 44 24 60	 mov	 eax, DWORD PTR zPos$[rsp]
  0003f	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 54   : {

  00042	48 83 c1 28	 add	 rcx, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00046	ba 02 00 00 00	 mov	 edx, 2
  0004b	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00050	85 c0		 test	 eax, eax
  00052	74 08		 je	 SHORT $LN15@ChunkBase

; 33   : 		_Throw_C_error(_Res);

  00054	8b c8		 mov	 ecx, eax
  00056	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005b	90		 npad	 1
$LN15@ChunkBase:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0005c	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00060	ba 02 00 00 00	 mov	 edx, 2
  00065	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0006a	85 c0		 test	 eax, eax
  0006c	74 08		 je	 SHORT $LN24@ChunkBase

; 33   : 		_Throw_C_error(_Res);

  0006e	8b c8		 mov	 ecx, eax
  00070	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00075	90		 npad	 1
$LN24@ChunkBase:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00076	48 8d 4b 38	 lea	 rcx, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0007a	33 ff		 xor	 edi, edi
  0007c	48 89 39	 mov	 QWORD PTR [rcx], rdi
  0007f	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);
; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00083	33 d2		 xor	 edx, edx
  00085	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  0008a	90		 npad	 1
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0008b	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0008f	48 89 39	 mov	 QWORD PTR [rcx], rdi
  00092	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)
; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);
; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00096	33 d2		 xor	 edx, edx
  00098	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  0009d	90		 npad	 1
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 56   : }

  0009e	48 8b c3	 mov	 rax, rbx
  000a1	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z ENDP		; ChunkBase::ChunkBase
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
?dtor$0@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA PROC	; `ChunkBase::ChunkBase'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0000b	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$0@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA ENDP	; `ChunkBase::ChunkBase'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
?dtor$1@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA PROC	; `ChunkBase::ChunkBase'::`1'::dtor$1
  00010	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00017	48 83 c1 30	 add	 rcx, 48			; 00000030H
  0001b	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$1@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA ENDP	; `ChunkBase::ChunkBase'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
?dtor$2@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA PROC	; `ChunkBase::ChunkBase'::`1'::dtor$2
  00020	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00027	48 83 c1 38	 add	 rcx, 56			; 00000038H
  0002b	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
?dtor$2@?0???0ChunkBase@@QEAA@AEAVWorld@@HHH@Z@4HA ENDP	; `ChunkBase::ChunkBase'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1ChunkBase@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1ChunkBase@@QEAA@XZ PROC				; ChunkBase::~ChunkBase, COMDAT

; 59   : {

$LN34:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkBase@@6B@
  00016	48 8b f1	 mov	 rsi, rcx
  00019	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0001c	48 8b 59 50	 mov	 rbx, QWORD PTR [rcx+80]
  00020	48 85 db	 test	 rbx, rbx
  00023	74 1d		 je	 SHORT $LN11@ChunkBase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00025	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00029	75 17		 jne	 SHORT $LN11@ChunkBase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002e	48 8b cb	 mov	 rcx, rbx
  00031	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00033	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00037	75 09		 jne	 SHORT $LN11@ChunkBase

; 128  : 			_Delete_this();

  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	48 8b cb	 mov	 rcx, rbx
  0003f	ff 50 08	 call	 QWORD PTR [rax+8]
$LN11@ChunkBase:

; 345  : 		if (_Rep != 0)

  00042	48 8b 5e 40	 mov	 rbx, QWORD PTR [rsi+64]
  00046	48 85 db	 test	 rbx, rbx
  00049	74 1d		 je	 SHORT $LN22@ChunkBase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0004b	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0004f	75 17		 jne	 SHORT $LN22@ChunkBase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00051	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00054	48 8b cb	 mov	 rcx, rbx
  00057	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00059	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0005d	75 09		 jne	 SHORT $LN22@ChunkBase

; 128  : 			_Delete_this();

  0005f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00062	48 8b cb	 mov	 rcx, rbx
  00065	ff 50 08	 call	 QWORD PTR [rax+8]
$LN22@ChunkBase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00068	48 8d 4e 30	 lea	 rcx, QWORD PTR [rsi+48]
  0006c	e8 00 00 00 00	 call	 _Mtx_destroy
  00071	48 8d 4e 28	 lea	 rcx, QWORD PTR [rsi+40]
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 61   : }

  00075	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	5f		 pop	 rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00084	e9 00 00 00 00	 jmp	 _Mtx_destroy
??1ChunkBase@@QEAA@XZ ENDP				; ChunkBase::~ChunkBase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?dataPtr@ChunkBase@@UEAAPEAGXZ
_TEXT	SEGMENT
this$ = 8
?dataPtr@ChunkBase@@UEAAPEAGXZ PROC			; ChunkBase::dataPtr, COMDAT

; 65   : 	return nullptr;

  00000	33 c0		 xor	 eax, eax

; 66   : }

  00002	c3		 ret	 0
?dataPtr@ChunkBase@@UEAAPEAGXZ ENDP			; ChunkBase::dataPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@ChunkBase@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?shouldRender@ChunkBase@@UEAA_NXZ PROC			; ChunkBase::shouldRender, COMDAT

; 90   : 	return false;

  00000	32 c0		 xor	 al, al

; 91   : }

  00002	c3		 ret	 0
?shouldRender@ChunkBase@@UEAA_NXZ ENDP			; ChunkBase::shouldRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z
_TEXT	SEGMENT
this$ = 64
world$dead$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z PROC		; EmptyChunk::EmptyChunk, COMDAT

; 112  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	8b 44 24 60	 mov	 eax, DWORD PTR zPos$[rsp]
  0000a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00011	48 8b d9	 mov	 rbx, rcx
  00014	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00018	e8 00 00 00 00	 call	 ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  00024	48 89 03	 mov	 QWORD PTR [rbx], rax

; 113  : 
; 114  : }

  00027	48 8b c3	 mov	 rax, rbx
  0002a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002e	5b		 pop	 rbx
  0002f	c3		 ret	 0
??0EmptyChunk@@QEAA@AEAVWorld@@HHH@Z ENDP		; EmptyChunk::EmptyChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1EmptyChunk@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1EmptyChunk@@QEAA@XZ PROC				; EmptyChunk::~EmptyChunk, COMDAT

; 117  : {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 118  : 
; 119  : }

  0000a	e9 00 00 00 00	 jmp	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
??1EmptyChunk@@QEAA@XZ ENDP				; EmptyChunk::~EmptyChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z PROC		; EmptyChunk::getBlock, COMDAT

; 123  : 	return Blocks::air;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?air@Blocks@@3PEAVBlockAir@@EA ; Blocks::air

; 124  : }

  00007	c3		 ret	 0
?getBlock@EmptyChunk@@UEAAPEAVBlock@@III@Z ENDP		; EmptyChunk::getBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
block$ = 40
?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z PROC	; EmptyChunk::setBlock, COMDAT

; 128  : 
; 129  : }

  00000	c2 00 00	 ret	 0
?setBlock@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z ENDP	; EmptyChunk::setBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
block$ = 40
?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z PROC	; EmptyChunk::setBlockRaw, COMDAT

; 133  : 
; 134  : }

  00000	c2 00 00	 ret	 0
?setBlockRaw@EmptyChunk@@UEAAXIIIPEAVBlock@@@Z ENDP	; EmptyChunk::setBlockRaw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isEmpty@EmptyChunk@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isEmpty@EmptyChunk@@UEAA_NXZ PROC			; EmptyChunk::isEmpty, COMDAT

; 138  : 	return true;

  00000	b0 01		 mov	 al, 1

; 139  : }

  00002	c3		 ret	 0
?isEmpty@EmptyChunk@@UEAA_NXZ ENDP			; EmptyChunk::isEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@EmptyChunk@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?shouldRender@EmptyChunk@@UEAA_NXZ PROC			; EmptyChunk::shouldRender, COMDAT

; 143  : 	return false;

  00000	32 c0		 xor	 al, al

; 144  : }

  00002	c3		 ret	 0
?shouldRender@EmptyChunk@@UEAA_NXZ ENDP			; EmptyChunk::shouldRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??0Chunk@@QEAA@AEAVWorld@@HHH@Z
_TEXT	SEGMENT
this$ = 64
world$ = 72
xPos$ = 80
yPos$ = 88
zPos$ = 96
??0Chunk@@QEAA@AEAVWorld@@HHH@Z PROC			; Chunk::Chunk, COMDAT

; 150  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	8b 44 24 60	 mov	 eax, DWORD PTR zPos$[rsp]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00011	e8 00 00 00 00	 call	 ??0ChunkBase@@QEAA@AEAVWorld@@HHH@Z ; ChunkBase::ChunkBase
  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  0001d	48 89 03	 mov	 QWORD PTR [rbx], rax
  00020	33 c0		 xor	 eax, eax
  00022	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax

; 151  : 
; 152  : }

  00026	48 8b c3	 mov	 rax, rbx
  00029	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
??0Chunk@@QEAA@AEAVWorld@@HHH@Z ENDP			; Chunk::Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??1Chunk@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1Chunk@@QEAA@XZ PROC					; Chunk::~Chunk, COMDAT

; 155  : {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 156  : 
; 157  : }

  0000a	e9 00 00 00 00	 jmp	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
??1Chunk@@QEAA@XZ ENDP					; Chunk::~Chunk
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getBlock@Chunk@@UEAAPEAVBlock@@III@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
?getBlock@Chunk@@UEAAPEAVBlock@@III@Z PROC		; Chunk::getBlock, COMDAT

; 161  : 	return Blocks::blockArray[data[toIndex(x, y, z)]];

  00000	c1 e2 04	 shl	 edx, 4
  00003	41 8b c1	 mov	 eax, r9d
  00006	41 0b d0	 or	 edx, r8d

; 6    : 	return x << 8 | y << 4 | z;

  00009	c1 e2 04	 shl	 edx, 4
  0000c	48 0b d0	 or	 rdx, rax

; 161  : 	return Blocks::blockArray[data[toIndex(x, y, z)]];

  0000f	0f b7 44 51 60	 movzx	 eax, WORD PTR [rcx+rdx*2+96]
  00014	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?blockArray@Blocks@@3PAPEAVBlock@@A ; Blocks::blockArray
  0001b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 162  : }

  0001f	c3		 ret	 0
?getBlock@Chunk@@UEAAPEAVBlock@@III@Z ENDP		; Chunk::getBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
block$ = 40
?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z PROC		; Chunk::setBlock, COMDAT

; 166  : 	data[toIndex(x, y, z)] = block->id;

  00000	c1 e2 04	 shl	 edx, 4
  00003	41 8b c1	 mov	 eax, r9d
  00006	44 0b c2	 or	 r8d, edx

; 6    : 	return x << 8 | y << 4 | z;

  00009	41 c1 e0 04	 shl	 r8d, 4
  0000d	4c 0b c0	 or	 r8, rax

; 166  : 	data[toIndex(x, y, z)] = block->id;

  00010	48 8b 44 24 28	 mov	 rax, QWORD PTR block$[rsp]
  00015	0f b7 50 30	 movzx	 edx, WORD PTR [rax+48]
  00019	66 42 89 54 41
	60		 mov	 WORD PTR [rcx+r8*2+96], dx

; 167  : }

  0001f	c3		 ret	 0
?setBlock@Chunk@@UEAAXIIIPEAVBlock@@@Z ENDP		; Chunk::setBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
y$ = 24
z$ = 32
block$ = 40
?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z PROC		; Chunk::setBlockRaw, COMDAT

; 171  : 	data[toIndex(x, y, z)] = block->id;

  00000	c1 e2 04	 shl	 edx, 4
  00003	41 8b c1	 mov	 eax, r9d
  00006	44 0b c2	 or	 r8d, edx

; 6    : 	return x << 8 | y << 4 | z;

  00009	41 c1 e0 04	 shl	 r8d, 4
  0000d	4c 0b c0	 or	 r8, rax

; 171  : 	data[toIndex(x, y, z)] = block->id;

  00010	48 8b 44 24 28	 mov	 rax, QWORD PTR block$[rsp]
  00015	0f b7 50 30	 movzx	 edx, WORD PTR [rax+48]
  00019	66 42 89 54 41
	60		 mov	 WORD PTR [rcx+r8*2+96], dx

; 172  : }

  0001f	c3		 ret	 0
?setBlockRaw@Chunk@@UEAAXIIIPEAVBlock@@@Z ENDP		; Chunk::setBlockRaw
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?isEmpty@Chunk@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?isEmpty@Chunk@@UEAA_NXZ PROC				; Chunk::isEmpty, COMDAT

; 176  : 	return false;

  00000	32 c0		 xor	 al, al

; 177  : }

  00002	c3		 ret	 0
?isEmpty@Chunk@@UEAA_NXZ ENDP				; Chunk::isEmpty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?dataPtr@Chunk@@UEAAPEAGXZ
_TEXT	SEGMENT
this$ = 8
?dataPtr@Chunk@@UEAAPEAGXZ PROC				; Chunk::dataPtr, COMDAT

; 181  : 	return data;

  00000	48 8d 41 60	 lea	 rax, QWORD PTR [rcx+96]

; 182  : }

  00004	c3		 ret	 0
?dataPtr@Chunk@@UEAAPEAGXZ ENDP				; Chunk::dataPtr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?shouldRender@Chunk@@UEAA_NXZ
_TEXT	SEGMENT
this$ = 8
?shouldRender@Chunk@@UEAA_NXZ PROC			; Chunk::shouldRender, COMDAT

; 186  : 	return true;

  00000	b0 01		 mov	 al, 1

; 187  : }

  00002	c3		 ret	 0
?shouldRender@Chunk@@UEAA_NXZ ENDP			; Chunk::shouldRender
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ PROC ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT
$LN49:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  00009	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 13		 je	 SHORT $LN7@unordered_
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00017	33 c0		 xor	 eax, eax
  00019	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1543 : 			this->_Mylast = pointer();

  0001d	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 1544 : 			this->_Myend = pointer();

  00021	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
$LN7@unordered_:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1927 : 		clear();

  00025	48 8b cb	 mov	 rcx, rbx
  00028	e8 00 00 00 00	 call	 ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0002d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ENDP ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?tick@World@@QEAAXXZ
_TEXT	SEGMENT
$T1 = 48
$T2 = 56
c$3 = 72
_Tmp$4 = 144
this$ = 144
$T5 = 152
?tick@World@@QEAAXXZ PROC				; World::tick, COMDAT

; 203  : {

$LN249:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000c	48 c7 44 24 30
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00015	48 89 9c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rbx
  0001d	4c 8b f9	 mov	 r15, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00020	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 44   : 		{	// construct with node pointer _Pnode

  00023	48 8b 18	 mov	 rbx, QWORD PTR [rax]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00026	48 3b d8	 cmp	 rbx, rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 204  : 	for(auto iter = redrawQuicklyAfterTick.begin(); iter != redrawQuicklyAfterTick.end(); ++iter)

  00029	0f 84 ac 00 00
	00		 je	 $LN2@tick
  0002f	33 ed		 xor	 ebp, ebp
$LL25@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00031	48 8b 7b 28	 mov	 rdi, QWORD PTR [rbx+40]
  00035	4c 8b 73 20	 mov	 r14, QWORD PTR [rbx+32]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00039	48 85 ff	 test	 rdi, rdi
  0003c	74 04		 je	 SHORT $LN74@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0003e	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]
$LN74@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00042	48 89 7c 24 50	 mov	 QWORD PTR c$3[rsp+8], rdi

; 427  : 		_Ptr = _Other_ptr;

  00047	4c 89 74 24 48	 mov	 QWORD PTR c$3[rsp], r14
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 207  : 		if(!c->isEmpty())

  0004c	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0004f	49 8b ce	 mov	 rcx, r14
  00052	ff 50 18	 call	 QWORD PTR [rax+24]
  00055	84 c0		 test	 al, al
  00057	75 54		 jne	 SHORT $LN1@tick

; 95   : 	renderUpdateNeeded = flag;

  00059	41 c6 46 08 01	 mov	 BYTE PTR [r14+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0005e	48 89 6c 24 38	 mov	 QWORD PTR $T2[rsp], rbp
  00063	48 89 6c 24 40	 mov	 QWORD PTR $T2[rsp+8], rbp

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00068	48 85 ff	 test	 rdi, rdi
  0006b	74 2b		 je	 SHORT $LN104@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0006d	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00071	48 8b 74 24 40	 mov	 rsi, QWORD PTR $T2[rsp+8]
  00076	48 85 f6	 test	 rsi, rsi
  00079	74 1d		 je	 SHORT $LN104@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0007b	f0 ff 4e 08	 lock dec DWORD PTR [rsi+8]
  0007f	75 17		 jne	 SHORT $LN104@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00081	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00084	48 8b ce	 mov	 rcx, rsi
  00087	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00089	f0 ff 4e 0c	 lock dec DWORD PTR [rsi+12]
  0008d	75 09		 jne	 SHORT $LN104@tick

; 128  : 			_Delete_this();

  0008f	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00092	48 8b ce	 mov	 rcx, rsi
  00095	ff 50 08	 call	 QWORD PTR [rax+8]
$LN104@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00098	48 89 7c 24 40	 mov	 QWORD PTR $T2[rsp+8], rdi

; 427  : 		_Ptr = _Other_ptr;

  0009d	4c 89 74 24 38	 mov	 QWORD PTR $T2[rsp], r14
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 210  : 			requestQuickChunkDraw(c);

  000a2	48 8d 4c 24 38	 lea	 rcx, QWORD PTR $T2[rsp]
  000a7	e8 00 00 00 00	 call	 ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestQuickChunkDraw
  000ac	90		 npad	 1
$LN1@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000ad	48 85 ff	 test	 rdi, rdi
  000b0	74 1d		 je	 SHORT $LN3@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000b2	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  000b6	75 17		 jne	 SHORT $LN3@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000b8	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000bb	48 8b cf	 mov	 rcx, rdi
  000be	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000c0	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  000c4	75 09		 jne	 SHORT $LN3@tick

; 128  : 			_Delete_this();

  000c6	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000c9	48 8b cf	 mov	 rcx, rdi
  000cc	ff 50 08	 call	 QWORD PTR [rax+8]
$LN3@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  000cf	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  000d2	49 3b 1f	 cmp	 rbx, QWORD PTR [r15]
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 204  : 	for(auto iter = redrawQuicklyAfterTick.begin(); iter != redrawQuicklyAfterTick.end(); ++iter)

  000d5	0f 85 56 ff ff
	ff		 jne	 $LL25@tick
$LN2@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 722  : 		_List.clear();

  000db	49 8b cf	 mov	 rcx, r15
  000de	e8 00 00 00 00	 call	 ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear

; 723  : 		_Init();
; 724  : 		}
; 725  : 
; 726  : 	iterator find(const key_type& _Keyval)
; 727  : 		{	// find an element in mutable hash table that matches _Keyval
; 728  : 		return (lower_bound(_Keyval));
; 729  : 		}
; 730  : 
; 731  : 	const_iterator find(const key_type& _Keyval) const
; 732  : 		{	// find an element in nonmutable hash table that matches _Keyval
; 733  : 		return (lower_bound(_Keyval));
; 734  : 		}
; 735  : 
; 736  : 	size_type count(const key_type& _Keyval) const
; 737  : 		{	// count all elements that match _Keyval
; 738  : 		_Paircc _Ans = equal_range(_Keyval);
; 739  : 		size_type _Num = 0;
; 740  : 		_Distance(_Ans.first, _Ans.second, _Num);
; 741  : 		return (_Num);
; 742  : 		}
; 743  : 
; 744  : 	iterator lower_bound(const key_type& _Keyval)
; 745  : 		{	// find leftmost not less than _Keyval in mutable hash table
; 746  : 		size_type _Bucket = _Hashval(_Keyval);
; 747  : 		for (_Unchecked_iterator _Where = _Begin(_Bucket);
; 748  : 			_Where != _End(_Bucket); ++_Where)
; 749  : 			if (!((_Traits&)*this)(this->_Kfn(*_Where), _Keyval))
; 750  : 				return (((_Traits&)*this)(_Keyval,
; 751  : 					this->_Kfn(*_Where)) ? end() : _Make_iter(_Where));
; 752  : 		return (end());
; 753  : 		}
; 754  : 
; 755  : 	const_iterator lower_bound(const key_type& _Keyval) const
; 756  : 		{	// find leftmost not less than _Keyval in nonmutable hash table
; 757  : 		size_type _Bucket = _Hashval(_Keyval);
; 758  : 		for (_Unchecked_const_iterator _Where = _Begin(_Bucket);
; 759  : 			_Where != _End(_Bucket); ++_Where)
; 760  : 			if (!((_Traits&)*this)(this->_Kfn(*_Where), _Keyval))
; 761  : 				return (((_Traits&)*this)(_Keyval,
; 762  : 					this->_Kfn(*_Where)) ? end() : _Make_iter(_Where));
; 763  : 		return (end());
; 764  : 		}
; 765  : 
; 766  : 	iterator upper_bound(const key_type& _Keyval)
; 767  : 		{	// find leftmost not greater than _Keyval in mutable hash table
; 768  : 		size_type _Bucket = _Hashval(_Keyval);
; 769  : 		for (_Unchecked_iterator _Where = _End(_Bucket);
; 770  : 			_Where != _Begin(_Bucket); )
; 771  : 			if (!((_Traits&)*this)(_Keyval, this->_Kfn(*--_Where)))
; 772  : 				return (((_Traits&)*this)(this->_Kfn(*_Where),
; 773  : 					_Keyval) ? end() : _Make_iter(++_Where));
; 774  : 		return (end());
; 775  : 		}
; 776  : 
; 777  : 	const_iterator upper_bound(const key_type& _Keyval) const
; 778  : 		{	// find leftmost not greater than _Keyval in nonmutable hash table
; 779  : 		size_type _Bucket = _Hashval(_Keyval);
; 780  : 		for (_Unchecked_const_iterator _Where = _End(_Bucket);
; 781  : 			_Where != _Begin(_Bucket); )
; 782  : 			if (!((_Traits&)*this)(_Keyval, this->_Kfn(*--_Where)))
; 783  : 				return (((_Traits&)*this)(this->_Kfn(*_Where),
; 784  : 					_Keyval) ? end() : _Make_iter(++_Where));
; 785  : 		return (end());
; 786  : 		}
; 787  : 
; 788  : 	_Pairii equal_range(const key_type& _Keyval)
; 789  : 		{	// find range equivalent to _Keyval in mutable hash table
; 790  : 		size_type _Bucket = _Hashval(_Keyval);
; 791  : 		for (_Unchecked_iterator _Where = _Begin(_Bucket);
; 792  : 			_Where != _End(_Bucket); ++_Where)
; 793  : 			if (!((_Traits&)*this)(this->_Kfn(*_Where), _Keyval))
; 794  : 				{	// found _First, look for end of range
; 795  : 				_Unchecked_iterator _First = _Where;
; 796  : 				for (; _Where != _End(_Bucket); ++_Where)
; 797  : 					if (((_Traits&)*this)(_Keyval, this->_Kfn(*_Where)))
; 798  : 						break;
; 799  : 				if (_First == _Where)
; 800  : 					break;
; 801  : 				return (_Pairii(_Make_iter(_First),
; 802  : 					_Make_iter(_Where)));
; 803  : 				}
; 804  : 		return (_Pairii(end(), end()));
; 805  : 		}
; 806  : 
; 807  : 	_Paircc equal_range(const key_type& _Keyval) const
; 808  : 		{	// find range equivalent to _Keyval in nonmutable hash table
; 809  : 		size_type _Bucket = _Hashval(_Keyval);
; 810  : 		for (_Unchecked_const_iterator _Where = _Begin(_Bucket);
; 811  : 			_Where != _End(_Bucket); ++_Where)
; 812  : 			if (!((_Traits&)*this)(this->_Kfn(*_Where), _Keyval))
; 813  : 				{	// found _First, look for end of range
; 814  : 				_Unchecked_const_iterator _First = _Where;
; 815  : 				for (; _Where != _End(_Bucket); ++_Where)
; 816  : 					if (((_Traits&)*this)(_Keyval, this->_Kfn(*_Where)))
; 817  : 						break;
; 818  : 				if (_First == _Where)
; 819  : 					break;
; 820  : 				return (_Paircc(_Make_iter(_First),
; 821  : 					_Make_iter(_Where)));
; 822  : 				}
; 823  : 		return (_Paircc(end(), end()));
; 824  : 		}
; 825  : 
; 826  : 	void swap(_Myt& _Right)
; 827  : 		{	// exchange contents with _Right
; 828  : 		if (this != &_Right)
; 829  : 			{	// different, worth swapping
; 830  : 			_Swap_adl((_Traits&)*this, (_Traits&)_Right);
; 831  : 			this->_List.swap(_Right._List);
; 832  : 			this->_Vec.swap(_Right._Vec);
; 833  : 			_STD swap(this->_Mask, _Right._Mask);
; 834  : 			_STD swap(this->_Maxidx, _Right._Maxidx);
; 835  : 			_STD swap(this->_Max_bucket_size, _Right._Max_bucket_size);
; 836  : 			}
; 837  : 		}
; 838  : 
; 839  : protected:
; 840  : 	template<class _Valty>
; 841  : 		_Unchecked_iterator _Buynode_if_nil(_Valty&&,
; 842  : 			_Unchecked_iterator _Plist)
; 843  : 		{	// node exists, just return it
; 844  : 		return (_Plist);
; 845  : 		}
; 846  : 
; 847  : 	template<class _Valty>
; 848  : 		_Unchecked_iterator _Buynode_if_nil(_Valty&& _Val, _Nil)
; 849  : 		{	// node doesn't exist, make it
; 850  : 		_List.push_front(_STD forward<_Valty>(_Val));
; 851  : 		return (_Unchecked_begin());
; 852  : 		}
; 853  : 
; 854  : 	void _Destroy_if_not_nil(_Unchecked_iterator _Plist)
; 855  : 		{	// node exists, destroy it
; 856  : 		_List.erase(_Make_iter(_Plist));
; 857  : 		}
; 858  : 
; 859  : 	void _Destroy_if_not_nil(_Nil)
; 860  : 		{	// node doesn't exist, do nothing
; 861  : 		}
; 862  : 
; 863  : 	template<class _Valty,
; 864  : 		class _Nodety>
; 865  : 		_Pairib _Insert(_Valty&& _Val, _Nodety _Pnode)
; 866  : 		{	// try to insert existing node with value _Val
; 867  : 		size_type _Bucket;
; 868  : 		_Unchecked_iterator _Where;
; 869  : 
; 870  : 		_TRY_BEGIN
; 871  : 		_Bucket = _Hashval(this->_Kfn(_Val));
; 872  : 		_Where = _End(_Bucket);
; 873  : 		for (; _Where != _Begin(_Bucket); )
; 874  : 			if (((_Traits&)*this)(this->_Kfn(_Val), this->_Kfn(*--_Where)))
; 875  : 				;	// still too high in bucket list
; 876  : 			else if (_Multi
; 877  : 				|| ((_Traits&)*this)(this->_Kfn(*_Where), this->_Kfn(_Val)))
; 878  : 				{	// found insertion point, back up to it
; 879  : 				++_Where;
; 880  : 				break;
; 881  : 				}
; 882  : 			else
; 883  : 				{	// discard new list element and return existing
; 884  : 				_Destroy_if_not_nil(_Pnode);
; 885  : 				return (_Pairib(_Make_iter(_Where), false));
; 886  : 				}
; 887  : 		_CATCH_ALL
; 888  : 		_Destroy_if_not_nil(_Pnode);
; 889  : 		_RERAISE;
; 890  : 		_CATCH_END
; 891  : 
; 892  : 		_Unchecked_iterator _Plist =
; 893  : 			_Buynode_if_nil(_STD forward<_Valty>(_Val), _Pnode);
; 894  : 		_Unchecked_iterator _Next = _Plist;
; 895  : 
; 896  : 		if (_Where != ++_Next)	// move element into place
; 897  : 			_List._Unchecked_splice(_Where, _Plist, _Next);
; 898  : 
; 899  : 		_Insert_bucket(_Plist, _Where, _Bucket);
; 900  : 		_Check_size();
; 901  : 		return (_Pairib(_Make_iter(_Plist), true));
; 902  : 		}
; 903  : 
; 904  : 	_Unchecked_iterator& _Vec_lo(size_type _Bucket)
; 905  : 		{	// return reference to begin() for _Bucket
; 906  : 		return (_Vec[2 * _Bucket]);
; 907  : 		}
; 908  : 
; 909  : 	_Unchecked_const_iterator& _Vec_lo(size_type _Bucket) const
; 910  : 		{	// return reference to begin() for _Bucket
; 911  : 		return ((_Unchecked_const_iterator&)_Vec[2 * _Bucket]);
; 912  : 		}
; 913  : 
; 914  : 	_Unchecked_iterator& _Vec_hi(size_type _Bucket)
; 915  : 		{	// return reference to end()-1 for _Bucket
; 916  : 		return (_Vec[2 * _Bucket + 1]);
; 917  : 		}
; 918  : 
; 919  : 	_Unchecked_const_iterator& _Vec_hi(size_type _Bucket) const
; 920  : 		{	// return reference to end()-1 for _Bucket
; 921  : 		return ((_Unchecked_const_iterator&)_Vec[2 * _Bucket + 1]);
; 922  : 		}
; 923  : 
; 924  : 	_Unchecked_iterator _Begin(size_type _Bucket)
; 925  : 		{	// return begin iterator for bucket _Bucket
; 926  : 		return (_Vec_lo(_Bucket));
; 927  : 		}
; 928  : 
; 929  : 	_Unchecked_const_iterator _Begin(size_type _Bucket) const
; 930  : 		{	// return begin iterator for bucket _Bucket
; 931  : 		return (_Vec_lo(_Bucket));
; 932  : 		}
; 933  : 
; 934  : 	_Unchecked_iterator _End(size_type _Bucket)
; 935  : 		{	// return end iterator for bucket _Bucket
; 936  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 937  : 			return (_Unchecked_end());
; 938  : 		else
; 939  : 			{	// point past last element
; 940  : 			_Unchecked_iterator _Ans = _Vec_hi(_Bucket);
; 941  : 			return (++_Ans);
; 942  : 			}
; 943  : 		}
; 944  : 	_Unchecked_const_iterator _End(size_type _Bucket) const
; 945  : 		{	// return end iterator for bucket _Bucket
; 946  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 947  : 			return (_Unchecked_end());
; 948  : 		else
; 949  : 			{	// point past last element
; 950  : 			_Unchecked_const_iterator _Ans = _Vec_hi(_Bucket);
; 951  : 			return (++_Ans);
; 952  : 			}
; 953  : 		}
; 954  : 
; 955  : 	void _Erase_bucket(iterator _Plist_arg, size_type _Bucket)
; 956  : 		{	// fix iterators before erasing _Plist before _Where
; 957  : 		_Unchecked_iterator _Plist = _Plist_arg._Unchecked();
; 958  : 		if (_Vec_hi(_Bucket) == _Plist)
; 959  : 			if (_Vec_lo(_Bucket) == _Plist)
; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();
; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();
; 963  : 				}
; 964  : 			else
; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element
; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)
; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element
; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;
; 1004 : 		if (_Maxidx <= _Num)
; 1005 : 			_Num -= (_Mask >> 1) + 1;
; 1006 : 		return (_Num);
; 1007 : 		}
; 1008 : 
; 1009 : 	void _Init(size_type _Buckets = _Min_buckets)
; 1010 : 		{	// initialize hash table with _Buckets buckets, leave list alone
; 1011 : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

  000e3	49 8d 4f 10	 lea	 rcx, QWORD PTR [r15+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  000e7	49 8b 07	 mov	 rax, QWORD PTR [r15]
  000ea	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR _Tmp$4[rsp], rax

; 1454 : 		erase(begin(), end());

  000f2	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;

  000f5	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  000f9	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR _Tmp$4[rsp]
  00101	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00106	41 b9 10 00 00
	00		 mov	 r9d, 16
  0010c	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR $T5[rsp]
  00114	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1012 : 		_Mask = _Buckets - 1;

  00119	49 c7 47 28 07
	00 00 00	 mov	 QWORD PTR [r15+40], 7

; 1013 : 		_Maxidx = _Buckets;

  00121	49 c7 47 30 08
	00 00 00	 mov	 QWORD PTR [r15+48], 8
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 215  : }

  00129	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+160]
  00131	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00135	41 5f		 pop	 r15
  00137	41 5e		 pop	 r14
  00139	5f		 pop	 rdi
  0013a	5e		 pop	 rsi
  0013b	5d		 pop	 rbp
  0013c	c3		 ret	 0
?tick@World@@QEAAXXZ ENDP				; World::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T2 = 56
c$3 = 72
_Tmp$4 = 144
this$ = 144
$T5 = 152
?dtor$0@?0??tick@World@@QEAAXXZ@4HA PROC		; `World::tick'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR c$3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??tick@World@@QEAAXXZ@4HA ENDP		; `World::tick'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
__$ReturnUdt$ = 88
x$ = 96
y$ = 104
z$ = 112
?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z PROC ; World::getChunkFromBlockCoordinate, COMDAT

; 232  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 233  : 	return getChunk(x >> 4, y >> 4, z >> 4);

  00006	8b 44 24 70	 mov	 eax, DWORD PTR z$[rsp]
  0000a	41 c1 f9 04	 sar	 r9d, 4
  0000e	41 c1 f8 04	 sar	 r8d, 4
  00012	c1 f8 04	 sar	 eax, 4
  00015	48 8b da	 mov	 rbx, rdx
  00018	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00020	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00024	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  00029	48 8b c3	 mov	 rax, rbx

; 234  : }

  0002c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ENDP ; World::getChunkFromBlockCoordinate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z
_TEXT	SEGMENT
i$1$ = 48
tv605 = 52
tv604 = 56
c$1 = 72
chunk$ = 88
$T2 = 104
this$ = 192
x$ = 200
y$ = 208
z$ = 216
block$ = 224
?setBlock@World@@QEAAXHHHPEAVBlock@@@Z PROC		; World::setBlock, COMDAT

; 261  : {

$LN123:
  00000	48 8b c4	 mov	 rax, rsp
  00003	44 89 48 20	 mov	 DWORD PTR [rax+32], r9d
  00007	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	57		 push	 rdi
  0000e	41 54		 push	 r12
  00010	41 55		 push	 r13
  00012	41 56		 push	 r14
  00014	41 57		 push	 r15
  00016	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0001d	48 c7 40 88 fe
	ff ff ff	 mov	 QWORD PTR [rax-120], -2
  00025	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00029	41 8b e9	 mov	 ebp, r9d
  0002c	45 8b e0	 mov	 r12d, r8d
  0002f	44 8b ea	 mov	 r13d, edx

; 262  : 	std::shared_ptr<ChunkBase> chunk = getChunkFromBlockCoordinate(x, y, z);

  00032	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00037	45 8b c8	 mov	 r9d, r8d
  0003a	44 8b c2	 mov	 r8d, edx
  0003d	48 8d 50 a0	 lea	 rdx, QWORD PTR [rax-96]
  00041	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  00046	90		 npad	 1

; 263  : 
; 264  : 	if(!chunk->isEmpty() && chunk->isLoaded())

  00047	4c 8b 7c 24 58	 mov	 r15, QWORD PTR chunk$[rsp]
  0004c	49 8b 07	 mov	 rax, QWORD PTR [r15]
  0004f	49 8b cf	 mov	 rcx, r15
  00052	ff 50 18	 call	 QWORD PTR [rax+24]
  00055	84 c0		 test	 al, al
  00057	0f 85 9a 01 00
	00		 jne	 $LN7@setBlock
  0005d	41 38 47 09	 cmp	 BYTE PTR [r15+9], al
  00061	0f 84 90 01 00
	00		 je	 $LN7@setBlock

; 265  : 	{
; 266  : 		bool sameBlock = chunk->getBlock(x & 0xf, y & 0xf, z & 0xf) == block;

  00067	83 e5 0f	 and	 ebp, 15
  0006a	41 8b f4	 mov	 esi, r12d
  0006d	83 e6 0f	 and	 esi, 15
  00070	41 8b fd	 mov	 edi, r13d
  00073	83 e7 0f	 and	 edi, 15
  00076	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00079	44 8b cd	 mov	 r9d, ebp
  0007c	44 8b c6	 mov	 r8d, esi
  0007f	8b d7		 mov	 edx, edi
  00081	49 8b cf	 mov	 rcx, r15
  00084	ff 10		 call	 QWORD PTR [rax]
  00086	4c 8b 94 24 e0
	00 00 00	 mov	 r10, QWORD PTR block$[rsp]
  0008e	49 3b c2	 cmp	 rax, r10
  00091	0f 94 c3	 sete	 bl

; 267  : 		chunk->setBlock(x & 0xf, y & 0xf, z & 0xf, block);

  00094	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00097	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  0009c	44 8b cd	 mov	 r9d, ebp
  0009f	44 8b c6	 mov	 r8d, esi
  000a2	8b d7		 mov	 edx, edi
  000a4	49 8b cf	 mov	 rcx, r15
  000a7	ff 50 08	 call	 QWORD PTR [rax+8]

; 268  : 		if(!sameBlock)

  000aa	84 db		 test	 bl, bl
  000ac	0f 85 45 01 00
	00		 jne	 $LN7@setBlock

; 269  : 		{
; 270  : 			for(int i = x - 1; i <= x + 1; i++)

  000b2	41 8d 45 ff	 lea	 eax, DWORD PTR [r13-1]
  000b6	89 44 24 30	 mov	 DWORD PTR i$1$[rsp], eax
  000ba	41 8d 4d 01	 lea	 ecx, DWORD PTR [r13+1]
  000be	89 4c 24 34	 mov	 DWORD PTR tv605[rsp], ecx
  000c2	3b c1		 cmp	 eax, ecx
  000c4	0f 8f 2d 01 00
	00		 jg	 $LN7@setBlock
  000ca	41 8d 54 24 ff	 lea	 edx, DWORD PTR [r12-1]
  000cf	89 54 24 38	 mov	 DWORD PTR tv604[rsp], edx
  000d3	41 ff c4	 inc	 r12d
  000d6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL9@setBlock:

; 271  : 			{
; 272  : 				for(int j = y - 1; j <= y + 1; j++)

  000e0	8b f2		 mov	 esi, edx
  000e2	41 3b d4	 cmp	 edx, r12d
  000e5	0f 8f fe 00 00
	00		 jg	 $LN8@setBlock
  000eb	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR z$[rsp]
  000f2	44 8d 69 ff	 lea	 r13d, DWORD PTR [rcx-1]
  000f6	8d 69 01	 lea	 ebp, DWORD PTR [rcx+1]
  000f9	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@setBlock:

; 274  : 					for(int k = z - 1; k <= z + 1; k++)

  00100	41 8b dd	 mov	 ebx, r13d
  00103	44 3b ed	 cmp	 r13d, ebp
  00106	0f 8f ca 00 00
	00		 jg	 $LN5@setBlock
  0010c	4c 8b bc 24 c0
	00 00 00	 mov	 r15, QWORD PTR this$[rsp]
  00114	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL3@setBlock:

; 275  : 					{
; 276  : 						std::shared_ptr<ChunkBase> c = getChunkFromBlockCoordinate(i, j, k);

  00120	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00124	44 8b ce	 mov	 r9d, esi
  00127	44 8b c0	 mov	 r8d, eax
  0012a	48 8d 54 24 48	 lea	 rdx, QWORD PTR c$1[rsp]
  0012f	49 8b cf	 mov	 rcx, r15
  00132	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  00137	90		 npad	 1

; 277  : 						redrawQuicklyAfterTick[c->pos] = c;

  00138	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp]
  0013d	48 8d 57 18	 lea	 rdx, QWORD PTR [rdi+24]
  00141	49 8b cf	 mov	 rcx, r15
  00144	e8 00 00 00 00	 call	 ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 407  : 		if (_Other_rep)

  00149	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$1[rsp+8]
  0014e	48 85 c9	 test	 rcx, rcx
  00151	74 0e		 je	 SHORT $LN57@setBlock

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00153	f0 ff 41 08	 lock inc DWORD PTR [rcx+8]
  00157	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$1[rsp+8]
  0015c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp]
$LN57@setBlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00161	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00165	48 89 54 24 70	 mov	 QWORD PTR $T2[rsp+8], rdx

; 49   : 	_Right = _Move(_Tmp);

  0016a	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  0016e	48 89 38	 mov	 QWORD PTR [rax], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00171	48 85 d2	 test	 rdx, rdx
  00174	74 29		 je	 SHORT $LN88@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00176	f0 ff 4a 08	 lock dec DWORD PTR [rdx+8]
  0017a	75 1e		 jne	 SHORT $LN122@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0017c	48 8b 7c 24 70	 mov	 rdi, QWORD PTR $T2[rsp+8]
  00181	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00184	48 8b cf	 mov	 rcx, rdi
  00187	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00189	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0018d	75 0b		 jne	 SHORT $LN122@setBlock

; 128  : 			_Delete_this();

  0018f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR $T2[rsp+8]
  00194	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00197	ff 50 08	 call	 QWORD PTR [rax+8]
$LN122@setBlock:
  0019a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$1[rsp+8]
$LN88@setBlock:

; 345  : 		if (_Rep != 0)

  0019f	48 85 c9	 test	 rcx, rcx
  001a2	74 24		 je	 SHORT $LN2@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  001a4	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  001a8	75 1e		 jne	 SHORT $LN2@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  001aa	48 8b 7c 24 50	 mov	 rdi, QWORD PTR c$1[rsp+8]
  001af	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  001b2	48 8b cf	 mov	 rcx, rdi
  001b5	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  001b7	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  001bb	75 0b		 jne	 SHORT $LN2@setBlock

; 128  : 			_Delete_this();

  001bd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR c$1[rsp+8]
  001c2	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001c5	ff 50 08	 call	 QWORD PTR [rax+8]
$LN2@setBlock:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 274  : 					for(int k = z - 1; k <= z + 1; k++)

  001c8	ff c3		 inc	 ebx
  001ca	3b dd		 cmp	 ebx, ebp
  001cc	8b 44 24 30	 mov	 eax, DWORD PTR i$1$[rsp]
  001d0	0f 8e 4a ff ff
	ff		 jle	 $LL3@setBlock
$LN5@setBlock:

; 271  : 			{
; 272  : 				for(int j = y - 1; j <= y + 1; j++)

  001d6	ff c6		 inc	 esi
  001d8	41 3b f4	 cmp	 esi, r12d
  001db	0f 8e 1f ff ff
	ff		 jle	 $LL6@setBlock
  001e1	8b 4c 24 34	 mov	 ecx, DWORD PTR tv605[rsp]
  001e5	8b 54 24 38	 mov	 edx, DWORD PTR tv604[rsp]
$LN8@setBlock:

; 269  : 		{
; 270  : 			for(int i = x - 1; i <= x + 1; i++)

  001e9	ff c0		 inc	 eax
  001eb	89 44 24 30	 mov	 DWORD PTR i$1$[rsp], eax
  001ef	3b c1		 cmp	 eax, ecx
  001f1	0f 8e e9 fe ff
	ff		 jle	 $LL9@setBlock
$LN7@setBlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001f7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR chunk$[rsp+8]
  001fc	48 85 c9	 test	 rcx, rcx
  001ff	74 24		 je	 SHORT $LN110@setBlock

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00201	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00205	75 1e		 jne	 SHORT $LN110@setBlock

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00207	48 8b 5c 24 60	 mov	 rbx, QWORD PTR chunk$[rsp+8]
  0020c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0020f	48 8b cb	 mov	 rcx, rbx
  00212	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00214	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00218	75 0b		 jne	 SHORT $LN110@setBlock

; 128  : 			_Delete_this();

  0021a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR chunk$[rsp+8]
  0021f	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00222	ff 50 08	 call	 QWORD PTR [rax+8]
$LN110@setBlock:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 283  : }

  00225	48 8b 9c 24 c8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+200]
  0022d	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00234	41 5f		 pop	 r15
  00236	41 5e		 pop	 r14
  00238	41 5d		 pop	 r13
  0023a	41 5c		 pop	 r12
  0023c	5f		 pop	 rdi
  0023d	5e		 pop	 rsi
  0023e	5d		 pop	 rbp
  0023f	c3		 ret	 0
?setBlock@World@@QEAAXHHHPEAVBlock@@@Z ENDP		; World::setBlock
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 48
tv605 = 52
tv604 = 56
c$1 = 72
chunk$ = 88
$T2 = 104
this$ = 192
x$ = 200
y$ = 208
z$ = 216
block$ = 224
?dtor$0@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA PROC ; `World::setBlock'::`1'::dtor$0
  00000	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA ENDP ; `World::setBlock'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
i$1$ = 48
tv605 = 52
tv604 = 56
c$1 = 72
chunk$ = 88
$T2 = 104
this$ = 192
x$ = 200
y$ = 208
z$ = 216
block$ = 224
?dtor$1@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA PROC ; `World::setBlock'::`1'::dtor$1
  0000c	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR c$1[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$1@?0??setBlock@World@@QEAAXHHHPEAVBlock@@@Z@4HA ENDP ; `World::setBlock'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>, COMDAT

; 499  : 	shared_ptr(nullptr_t)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00008	33 d2		 xor	 edx, edx
  0000a	48 8b d9	 mov	 rbx, rcx

; 282  : 		{	// construct

  0000d	48 89 01	 mov	 QWORD PTR [rcx], rax
  00010	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00014	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>

; 502  : 		}

  00019	48 8b c3	 mov	 rax, rbx
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@$$T@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
;	COMDAT ??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 48
this$ = 80
_Tmp$2 = 88
$T3 = 96
??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ PROC ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 113  : 		{	// construct empty map from defaults

$LN158:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000a	48 c7 44 24 30
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00018	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 531  : 		this->_Myhead = 0;

  0001b	33 ff		 xor	 edi, edi
  0001d	48 89 39	 mov	 QWORD PTR [rcx], rdi

; 532  : 		this->_Mysize = 0;

  00020	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00024	45 33 c0	 xor	 r8d, r8d
  00027	33 d2		 xor	 edx, edx
  00029	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0

; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);
; 548  : 		}
; 549  : 
; 550  : 	_Nodeptr _Myhead;	// pointer to head node
; 551  : 	size_type _Mysize;	// number of elements
; 552  : 	};
; 553  : 
; 554  : 		// TEMPLATE CLASS _List_alloc
; 555  : template<bool _Al_has_storage,
; 556  : 	class _Alloc_types>
; 557  : 	class _List_alloc
; 558  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 559  : 	{	// base class for list to hold allocator with storage
; 560  : public:
; 561  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 562  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 563  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 564  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 565  : 	typedef typename _Alloc_types::_Node _Node;
; 566  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 567  : 
; 568  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 569  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 570  : 		: _Alnod(_Al)
; 571  : 		{	// construct head node, allocator from _Al
; 572  : 		this->_Myhead = _Buyheadnode();
; 573  : 		}
; 574  : 
; 575  : 	~_List_alloc() _NOEXCEPT
; 576  : 		{	// destroy head node
; 577  : 		_Freeheadnode(this->_Myhead);
; 578  : 		}
; 579  : 
; 580  : 	void _Change_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Alnod = _Al;
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 588  : 		}
; 589  : 
; 590  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 591  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 592  : 		: _Alnod(_Al)
; 593  : 		{	// construct head node, allocator from _Al
; 594  : 		this->_Myhead = _Buyheadnode();
; 595  : 		_TRY_BEGIN
; 596  : 		_Alloc_proxy();
; 597  : 		_CATCH_ALL
; 598  : 		_Freeheadnode(this->_Myhead);
; 599  : 		_RERAISE;
; 600  : 		_CATCH_END
; 601  : 		}
; 602  : 
; 603  : 	~_List_alloc() _NOEXCEPT
; 604  : 		{	// destroy proxy
; 605  : 		_Freeheadnode(this->_Myhead);
; 606  : 		_Free_proxy();
; 607  : 		}
; 608  : 
; 609  : 	void _Change_alloc(const _Alty& _Al)
; 610  : 		{	// replace old allocator
; 611  : 		_Free_proxy();
; 612  : 		_Alnod = _Al;
; 613  : 		_Alloc_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Swap_alloc(_Myt& _Right)
; 617  : 		{	// swap allocators
; 618  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 619  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 620  : 		}
; 621  : 
; 622  : 	void _Alloc_proxy()
; 623  : 		{	// construct proxy from _Alnod
; 624  : 		typename _Alty::template rebind<_Container_proxy>::other
; 625  : 			_Alproxy(_Alnod);
; 626  : 		this->_Myproxy = _Alproxy.allocate(1);
; 627  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 628  : 		this->_Myproxy->_Mycont = this;
; 629  : 		}
; 630  : 
; 631  : 	void _Free_proxy()
; 632  : 		{	// destroy proxy
; 633  : 		typename _Alty::template rebind<_Container_proxy>::other
; 634  : 			_Alproxy(_Alnod);
; 635  : 		this->_Orphan_all();
; 636  : 		_Alproxy.destroy(this->_Myproxy);
; 637  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 638  : 		this->_Myproxy = 0;
; 639  : 		}
; 640  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 641  : 
; 642  : 	_Nodeptr _Buyheadnode()
; 643  : 		{	// get head node using current allocator
; 644  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 645  : 		}
; 646  : 
; 647  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 648  : 		{	// free head node using current allocator
; 649  : 		_Alnod.destroy(
; 650  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 651  : 		_Alnod.destroy(
; 652  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 653  : 		_Alnod.deallocate(_Pnode, 1);
; 654  : 		}
; 655  : 
; 656  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 657  : 		_Nodeptr _Prev)
; 658  : 		{	// allocate a node and set links
; 659  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 660  : 
; 661  : 		if (_Next == _Nodeptr())
; 662  : 			{	// point at self
; 663  : 			_Next = _Pnode;
; 664  : 			_Prev = _Pnode;
; 665  : 			}
; 666  : 		_TRY_BEGIN
; 667  : 		_Alnod.construct(
; 668  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 669  : 		_Alnod.construct(
; 670  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 671  : 		_CATCH_ALL
; 672  : 		_Alnod.deallocate(_Pnode, 1);
; 673  : 		_RERAISE;
; 674  : 		_CATCH_END
; 675  : 
; 676  : 		return (_Pnode);
; 677  : 		}
; 678  : 
; 679  : 	_Alty& _Getal()
; 680  : 		{	// get reference to allocator
; 681  : 		return (_Alnod);
; 682  : 		}
; 683  : 
; 684  : 	const _Alty& _Getal() const
; 685  : 		{	// get reference to allocator
; 686  : 		return (_Alnod);
; 687  : 		}
; 688  : 
; 689  : 	_Alty _Alnod;	// allocator object for stored elements
; 690  : 	};
; 691  : 
; 692  : 		// TEMPLATE CLASS _List_alloc
; 693  : template<class _Alloc_types>
; 694  : 	class _List_alloc<false, _Alloc_types>
; 695  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 696  : 	{	// base class for list to hold allocator with no storage
; 697  : public:
; 698  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 699  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 700  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 701  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 702  : 	typedef typename _Alloc_types::_Node _Node;
; 703  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 704  : 
; 705  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 706  : 	_List_alloc(const _Alloc& = _Alloc())
; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();

  0002e	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  00031	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 487  : 		_Mylast = pointer();

  00035	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi

; 488  : 		_Myend = pointer();

  00039	48 89 7b 20	 mov	 QWORD PTR [rbx+32], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 317  : 		{	// construct empty hash table

  0003d	c7 43 38 00 00
	80 3f		 mov	 DWORD PTR [rbx+56], 1065353216 ; 3f800000H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00044	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  00047	48 89 44 24 58	 mov	 QWORD PTR _Tmp$2[rsp], rax

; 47   : 		{	// construct with pointer _Parg

  0004c	8b cf		 mov	 ecx, edi

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  0004e	48 85 ff	 test	 rdi, rdi

; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())

  00051	74 1d		 je	 SHORT $LN130@unordered_

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00053	48 85 c9	 test	 rcx, rcx

; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)

  00056	74 1c		 je	 SHORT $LN64@unordered_
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2487 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00058	8b d7		 mov	 edx, edi

; 2465 : 	for (; _First != _Last; ++_Dest, ++_First)

  0005a	48 85 ff	 test	 rdi, rdi
  0005d	74 11		 je	 SHORT $LN130@unordered_
  0005f	90		 npad	 1
$LL132@unordered_:

; 2466 : 		*_Dest = _STD move(*_First);

  00060	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00063	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2465 : 	for (; _First != _Last; ++_Dest, ++_First)

  00066	48 83 c1 08	 add	 rcx, 8
  0006a	48 83 c2 08	 add	 rdx, 8
  0006e	75 f0		 jne	 SHORT $LL132@unordered_
$LN130@unordered_:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1406 : 				this->_Mylast = _Ptr;

  00070	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx
$LN64@unordered_:

; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)
; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else
; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)
; 850  : 				_Reserve(1);
; 851  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 852  : 			this->_Getal().construct(this->_Mylast,
; 853  : 				_STD forward<value_type>(_Val));
; 854  : 			++this->_Mylast;
; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);
; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);
; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);
; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00074	48 8d 44 24 58	 lea	 rax, QWORD PTR _Tmp$2[rsp]
  00079	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007e	41 b9 10 00 00
	00		 mov	 r9d, 16
  00084	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  00088	48 8d 54 24 60	 lea	 rdx, QWORD PTR $T3[rsp]
  0008d	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00091	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1012 : 		_Mask = _Buckets - 1;

  00096	48 c7 43 28 07
	00 00 00	 mov	 QWORD PTR [rbx+40], 7

; 1013 : 		_Maxidx = _Buckets;

  0009e	48 c7 43 30 08
	00 00 00	 mov	 QWORD PTR [rbx+48], 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map

; 114  : 		}

  000a6	48 8b c3	 mov	 rax, rbx
  000a9	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000ae	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
??0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ ENDP ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Tmp$2 = 88
$T3 = 96
?dtor$1@?0???0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >'::`1'::dtor$1
  00000	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
?dtor$1@?0???0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
_Tmp$2 = 88
$T3 = 96
?dtor$2@?0???0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ@4HA PROC ; `std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >'::`1'::dtor$2
  0000c	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00013	48 83 c1 10	 add	 rcx, 16
  00017	e9 00 00 00 00	 jmp	 ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
?dtor$2@?0???0?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAA@XZ@4HA ENDP ; `std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
;	COMDAT ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = 40
$T2 = 56
$T3 = 72
_Where$ = 128
this$ = 128
_Keyval$ = 136
??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z PROC ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[], COMDAT

; 259  : 		{	// find element matching _Keyval or insert with default mapped

$LN184:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00008	48 c7 40 a8 fe
	ff ff ff	 mov	 QWORD PTR [rax-88], -2
  00010	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00014	48 8b fa	 mov	 rdi, rdx
  00017	48 8b d9	 mov	 rbx, rcx

; 260  : 		iterator _Where = this->lower_bound(_Keyval);

  0001a	4c 8b c2	 mov	 r8, rdx
  0001d	48 8d 50 08	 lea	 rdx, QWORD PTR [rax+8]
  00021	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00026	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00029	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR _Where$[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map

; 261  : 		if (_Where == this->end())

  00031	0f 85 c8 00 00
	00		 jne	 $LN167@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 138  : 		{	// construct from moved values

  00037	8b 0f		 mov	 ecx, DWORD PTR [rdi]
  00039	89 4c 24 48	 mov	 DWORD PTR $T3[rsp], ecx
  0003d	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  00040	89 4c 24 4c	 mov	 DWORD PTR $T3[rsp+4], ecx
  00044	8b 4f 08	 mov	 ecx, DWORD PTR [rdi+8]
  00047	89 4c 24 50	 mov	 DWORD PTR $T3[rsp+8], ecx

; 48   : 	_Left = _Move(_Right);

  0004b	33 c9		 xor	 ecx, ecx
  0004d	48 89 4c 24 60	 mov	 QWORD PTR $T3[rsp+24], rcx

; 49   : 	_Right = _Move(_Tmp);

  00052	48 89 4c 24 30	 mov	 QWORD PTR $T1[rsp+8], rcx

; 48   : 	_Left = _Move(_Right);

  00057	48 89 4c 24 58	 mov	 QWORD PTR $T3[rsp+16], rcx

; 49   : 	_Right = _Move(_Tmp);

  0005c	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 96   : 		return (_Ptr);

  00061	48 8b 38	 mov	 rdi, QWORD PTR [rax]

; 548  : 		}
; 549  : 
; 550  : 	_Nodeptr _Myhead;	// pointer to head node
; 551  : 	size_type _Mysize;	// number of elements
; 552  : 	};
; 553  : 
; 554  : 		// TEMPLATE CLASS _List_alloc
; 555  : template<bool _Al_has_storage,
; 556  : 	class _Alloc_types>
; 557  : 	class _List_alloc
; 558  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 559  : 	{	// base class for list to hold allocator with storage
; 560  : public:
; 561  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 562  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 563  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 564  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 565  : 	typedef typename _Alloc_types::_Node _Node;
; 566  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 567  : 
; 568  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 569  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 570  : 		: _Alnod(_Al)
; 571  : 		{	// construct head node, allocator from _Al
; 572  : 		this->_Myhead = _Buyheadnode();
; 573  : 		}
; 574  : 
; 575  : 	~_List_alloc() _NOEXCEPT
; 576  : 		{	// destroy head node
; 577  : 		_Freeheadnode(this->_Myhead);
; 578  : 		}
; 579  : 
; 580  : 	void _Change_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Alnod = _Al;
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 588  : 		}
; 589  : 
; 590  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 591  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 592  : 		: _Alnod(_Al)
; 593  : 		{	// construct head node, allocator from _Al
; 594  : 		this->_Myhead = _Buyheadnode();
; 595  : 		_TRY_BEGIN
; 596  : 		_Alloc_proxy();
; 597  : 		_CATCH_ALL
; 598  : 		_Freeheadnode(this->_Myhead);
; 599  : 		_RERAISE;
; 600  : 		_CATCH_END
; 601  : 		}
; 602  : 
; 603  : 	~_List_alloc() _NOEXCEPT
; 604  : 		{	// destroy proxy
; 605  : 		_Freeheadnode(this->_Myhead);
; 606  : 		_Free_proxy();
; 607  : 		}
; 608  : 
; 609  : 	void _Change_alloc(const _Alty& _Al)
; 610  : 		{	// replace old allocator
; 611  : 		_Free_proxy();
; 612  : 		_Alnod = _Al;
; 613  : 		_Alloc_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Swap_alloc(_Myt& _Right)
; 617  : 		{	// swap allocators
; 618  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 619  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 620  : 		}
; 621  : 
; 622  : 	void _Alloc_proxy()
; 623  : 		{	// construct proxy from _Alnod
; 624  : 		typename _Alty::template rebind<_Container_proxy>::other
; 625  : 			_Alproxy(_Alnod);
; 626  : 		this->_Myproxy = _Alproxy.allocate(1);
; 627  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 628  : 		this->_Myproxy->_Mycont = this;
; 629  : 		}
; 630  : 
; 631  : 	void _Free_proxy()
; 632  : 		{	// destroy proxy
; 633  : 		typename _Alty::template rebind<_Container_proxy>::other
; 634  : 			_Alproxy(_Alnod);
; 635  : 		this->_Orphan_all();
; 636  : 		_Alproxy.destroy(this->_Myproxy);
; 637  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 638  : 		this->_Myproxy = 0;
; 639  : 		}
; 640  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 641  : 
; 642  : 	_Nodeptr _Buyheadnode()
; 643  : 		{	// get head node using current allocator
; 644  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 645  : 		}
; 646  : 
; 647  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 648  : 		{	// free head node using current allocator
; 649  : 		_Alnod.destroy(
; 650  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 651  : 		_Alnod.destroy(
; 652  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 653  : 		_Alnod.deallocate(_Pnode, 1);
; 654  : 		}
; 655  : 
; 656  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 657  : 		_Nodeptr _Prev)
; 658  : 		{	// allocate a node and set links
; 659  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 660  : 
; 661  : 		if (_Next == _Nodeptr())
; 662  : 			{	// point at self
; 663  : 			_Next = _Pnode;
; 664  : 			_Prev = _Pnode;
; 665  : 			}
; 666  : 		_TRY_BEGIN
; 667  : 		_Alnod.construct(
; 668  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 669  : 		_Alnod.construct(
; 670  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 671  : 		_CATCH_ALL
; 672  : 		_Alnod.deallocate(_Pnode, 1);
; 673  : 		_RERAISE;
; 674  : 		_CATCH_END
; 675  : 
; 676  : 		return (_Pnode);
; 677  : 		}
; 678  : 
; 679  : 	_Alty& _Getal()
; 680  : 		{	// get reference to allocator
; 681  : 		return (_Alnod);
; 682  : 		}
; 683  : 
; 684  : 	const _Alty& _Getal() const
; 685  : 		{	// get reference to allocator
; 686  : 		return (_Alnod);
; 687  : 		}
; 688  : 
; 689  : 	_Alty _Alnod;	// allocator object for stored elements
; 690  : 	};
; 691  : 
; 692  : 		// TEMPLATE CLASS _List_alloc
; 693  : template<class _Alloc_types>
; 694  : 	class _List_alloc<false, _Alloc_types>
; 695  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 696  : 	{	// base class for list to hold allocator with no storage
; 697  : public:
; 698  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 699  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 700  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 701  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 702  : 	typedef typename _Alloc_types::_Node _Node;
; 703  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 704  : 
; 705  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 706  : 	_List_alloc(const _Alloc& = _Alloc())
; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();
; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 774  : 		}
; 775  : 
; 776  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 777  : 		{	// free head node using current allocator
; 778  : 		this->_Getal().destroy(
; 779  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 780  : 		this->_Getal().destroy(
; 781  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 782  : 		this->_Getal().deallocate(_Pnode, 1);
; 783  : 		}
; 784  : 
; 785  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 786  : 		_Nodeptr _Prev)
; 787  : 		{	// allocate a node and set links
; 788  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 789  : 
; 790  : 		if (_Next == _Nodeptr())
; 791  : 			{	// point at self
; 792  : 			_Next = _Pnode;
; 793  : 			_Prev = _Pnode;
; 794  : 			}
; 795  : 		_TRY_BEGIN
; 796  : 		this->_Getal().construct(
; 797  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 798  : 		this->_Getal().construct(
; 799  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 800  : 		_CATCH_ALL
; 801  : 		this->_Getal().deallocate(_Pnode, 1);
; 802  : 		_RERAISE;
; 803  : 		_CATCH_END
; 804  : 
; 805  : 		return (_Pnode);
; 806  : 		}
; 807  : 
; 808  : 	_Alty _Getal() const
; 809  : 		{	// get reference to allocator
; 810  : 		return (_Alty());
; 811  : 		}
; 812  : 	};
; 813  : 
; 814  : 		// TEMPLATE CLASS _List_buy
; 815  : template<class _Ty,
; 816  : 	class _Alloc>
; 817  : 	class _List_buy
; 818  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 819  : 			_List_base_types<_Ty, _Alloc> >
; 820  : 	{	// base class for list to hold buynode/freenode functions
; 821  : public:
; 822  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 823  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 824  : 	typedef typename _Mybase::_Alty _Alty;
; 825  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 826  : 
; 827  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 828  : 		: _Mybase(_Al)
; 829  : 		{	// construct from allocator
; 830  : 		}
; 831  : 
; 832  : #define _LIST_BUYNODE( \
; 833  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 834  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 835  : 		_Nodeptr _Buynode(_Nodeptr _Next, \
; 836  : 			_Nodeptr _Prev COMMA LIST(_TYPE_REFREF_ARG)) \
; 837  : 		{	/* allocate a node and set links and value */ \
; 838  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev); \
; 839  : 		_TRY_BEGIN \
; 840  : 		this->_Getal().construct( \
; 841  : 			_STD addressof(this->_Myval(_Pnode)) \
; 842  : 				COMMA LIST(_FORWARD_ARG)); \
; 843  : 		_CATCH_ALL \
; 844  : 		this->_Getal().deallocate(_Pnode, 1); \
; 845  : 		_RERAISE; \
; 846  : 		_CATCH_END \
; 847  : 		return (_Pnode); \
; 848  : 		}
; 849  : 
; 850  : _VARIADIC_EXPAND_0X(_LIST_BUYNODE, , , , )
; 851  : #undef _LIST_BUYNODE
; 852  : 
; 853  : 	void _Freenode(_Nodeptr _Pnode)
; 854  : 		{	// give node back
; 855  : 		this->_Getal().destroy(
; 856  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 857  : 		this->_Getal().destroy(
; 858  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 859  : 		this->_Getal().destroy(
; 860  : 			_STD addressof(this->_Myval(_Pnode)));
; 861  : 		this->_Getal().deallocate(_Pnode, 1);
; 862  : 		}
; 863  : 	};
; 864  : 
; 865  : 		// TEMPLATE CLASS list
; 866  : template<class _Ty,
; 867  : 	class _Alloc = allocator<_Ty> >
; 868  : 	class list
; 869  : 		: public _List_buy<_Ty, _Alloc>
; 870  : 	{	// bidirectional linked list
; 871  : public:
; 872  : 	typedef list<_Ty, _Alloc> _Myt;
; 873  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 874  : 	typedef typename _Mybase::_Node _Node;
; 875  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 876  : 	typedef typename _Mybase::_Alty _Alty;
; 877  : 
; 878  : 	typedef _Alloc allocator_type;
; 879  : 	typedef typename _Mybase::size_type size_type;
; 880  : 	typedef typename _Mybase::difference_type difference_type;
; 881  : 	typedef typename _Mybase::pointer pointer;
; 882  : 	typedef typename _Mybase::const_pointer const_pointer;
; 883  : 	typedef typename _Mybase::reference reference;
; 884  : 	typedef typename _Mybase::const_reference const_reference;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	typedef typename _Mybase::const_iterator const_iterator;
; 888  : 	typedef typename _Mybase::iterator iterator;
; 889  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 890  : 		_Unchecked_const_iterator;
; 891  : 	typedef typename _Mybase::_Unchecked_iterator
; 892  : 		_Unchecked_iterator;
; 893  : 
; 894  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 895  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 896  : 
; 897  : 	list()
; 898  : 		: _Mybase()
; 899  : 		{	// construct empty list
; 900  : 		}
; 901  : 
; 902  : 	explicit list(const _Alloc& _Al)
; 903  : 		: _Mybase(_Al)
; 904  : 		{	// construct empty list, allocator
; 905  : 		}
; 906  : 
; 907  : 	explicit list(size_type _Count)
; 908  : 		: _Mybase()
; 909  : 		{	// construct list from _Count * _Ty()
; 910  : 		resize(_Count);
; 911  : 		}
; 912  : 
; 913  : 	list(size_type _Count, const _Ty& _Val)
; 914  : 		: _Mybase()
; 915  : 		{	// construct list from _Count * _Val
; 916  : 		_Construct_n(_Count, _Val);
; 917  : 		}
; 918  : 
; 919  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 920  : 		: _Mybase(_Al)
; 921  : 		{	// construct list from _Count * _Val, allocator
; 922  : 		_Construct_n(_Count, _Val);
; 923  : 		}
; 924  : 
; 925  : 	list(const _Myt& _Right)
; 926  : 
; 927  :  #if _HAS_CPP0X
; 928  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 929  : 
; 930  :  #else /* _HAS_CPP0X */
; 931  : 		: _Mybase(_Right._Getal())
; 932  :  #endif /* _HAS_CPP0X */
; 933  : 
; 934  : 		{	// construct list by copying _Right
; 935  : 		_TRY_BEGIN
; 936  : 		insert(begin(), _Right.begin(), _Right.end());
; 937  : 		_CATCH_ALL
; 938  : 		_Tidy();
; 939  : 		_RERAISE;
; 940  : 		_CATCH_END
; 941  : 		}
; 942  : 
; 943  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 944  : 		: _Mybase(_Al)
; 945  : 		{	// construct list by copying _Right, allocator
; 946  : 		_TRY_BEGIN
; 947  : 		insert(begin(), _Right.begin(), _Right.end());
; 948  : 		_CATCH_ALL
; 949  : 		_Tidy();
; 950  : 		_RERAISE;
; 951  : 		_CATCH_END
; 952  : 		}
; 953  : 
; 954  : 	template<class _Iter>
; 955  : 		list(_Iter _First, _Iter _Last,
; 956  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 957  : 				void>::type ** = 0)
; 958  : 		: _Mybase()
; 959  : 		{	// construct list from [_First, _Last,
; 960  : 		_Construct(_First, _Last);
; 961  : 		}
; 962  : 
; 963  : 	template<class _Iter>
; 964  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 965  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 966  : 				void>::type ** = 0)
; 967  : 		: _Mybase(_Al)
; 968  : 		{	// construct list, allocator from [_First, _Last)
; 969  : 		_Construct(_First, _Last);
; 970  : 		}
; 971  : 
; 972  : 	template<class _Iter>
; 973  : 		void _Construct(_Iter _First, _Iter _Last)
; 974  : 		{	// construct list from [_First, _Last), input iterators
; 975  : 		_TRY_BEGIN
; 976  : 		insert(begin(), _First, _Last);
; 977  : 		_CATCH_ALL
; 978  : 		_Tidy();
; 979  : 		_RERAISE;
; 980  : 		_CATCH_END
; 981  : 		}
; 982  : 
; 983  : 	void _Construct_n(size_type _Count,
; 984  : 		const _Ty& _Val)
; 985  : 		{	// construct from _Count * _Val
; 986  : 		_TRY_BEGIN
; 987  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 988  : 		_CATCH_ALL
; 989  : 		_Tidy();
; 990  : 		_RERAISE;
; 991  : 		_CATCH_END
; 992  : 		}
; 993  : 
; 994  : 	list(_Myt&& _Right)
; 995  : 		: _Mybase(_Right._Getal())
; 996  : 		{	// construct list by moving _Right
; 997  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 998  : 		}
; 999  : 
; 1000 : 	list(_Myt&& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct list by moving _Right, allocator
; 1003 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1004 : 		}
; 1005 : 
; 1006 : 	_Myt& operator=(_Myt&& _Right)
; 1007 : 		{	// assign by moving _Right
; 1008 : 		if (this != &_Right)
; 1009 : 			{	// different, assign it
; 1010 : 			clear();
; 1011 : 
; 1012 :  #if _HAS_CPP0X
; 1013 : 			if (this->_Getal() != _Right._Getal()
; 1014 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1015 : 				this->_Change_alloc(_Right._Getal());
; 1016 :  #endif /* _HAS_CPP0X */
; 1017 : 
; 1018 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1019 : 			}
; 1020 : 		return (*this);
; 1021 : 		}
; 1022 : 
; 1023 : 	void _Assign_rv(_Myt&& _Right)
; 1024 : 		{	// swap with empty *this, same allocator
; 1025 : 		this->_Swap_all(_Right);
; 1026 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1027 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1028 : 		}
; 1029 : 
; 1030 : 	void push_front(_Ty&& _Val)
; 1031 : 		{	// insert element at beginning
; 1032 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1033 : 		}
; 1034 : 
; 1035 : 	void push_back(_Ty&& _Val)
; 1036 : 		{	// insert element at end
; 1037 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1038 : 		}
; 1039 : 
; 1040 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1041 : 		{	// insert _Val at _Where
; 1042 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1043 : 		}
; 1044 : 
; 1045 : #define _LIST_EMPLACE_INSERT( \
; 1046 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1047 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1048 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1049 : 		{	/* insert element at beginning */ \
; 1050 : 		_Insert(_Unchecked_begin() COMMA LIST(_FORWARD_ARG)); \
; 1051 : 		} \
; 1052 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1053 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1054 : 		{	/* insert element at end */ \
; 1055 : 		_Insert(_Unchecked_end() COMMA LIST(_FORWARD_ARG)); \
; 1056 : 		} \
; 1057 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1058 : 		iterator emplace(const_iterator _Where \
; 1059 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1060 : 		{	/* insert element at _Where */ \
; 1061 : 		_LIST_EMPLACE_CHECK \
; 1062 : 		_Insert(_Where._Unchecked() COMMA LIST(_FORWARD_ARG)); \
; 1063 : 		return (_Make_iter(--_Where)); \
; 1064 : 		} \
; 1065 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1066 : 		void _Insert(_Unchecked_const_iterator _Where \
; 1067 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1068 : 		{	/* insert element at _Where */ \
; 1069 : 		_Nodeptr _Pnode = _Where._Mynode(); \
; 1070 : 		_Nodeptr _Newnode = this->_Buynode(_Pnode, \
; 1071 : 			this->_Prevnode(_Pnode) COMMA LIST(_FORWARD_ARG)); \
; 1072 : 		_Incsize(1); \
; 1073 : 		this->_Prevnode(_Pnode) = _Newnode; \
; 1074 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode; \
; 1075 : 		}
; 1076 : 
; 1077 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1078 : #define _LIST_EMPLACE_CHECK \
; 1079 : 		if (_Where._Getcont() != this) \
; 1080 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1081 : 
; 1082 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1083 : #define _LIST_EMPLACE_CHECK
; 1084 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1085 : 
; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00064	4c 8d 4c 24 48	 lea	 r9, QWORD PTR $T3[rsp]
  00069	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  0006d	48 8b d7	 mov	 rdx, rdi
  00070	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
  00075	48 8b d0	 mov	 rdx, rax

; 1087 : #undef _LIST_EMPLACE_CHECK
; 1088 : #undef _LIST_EMPLACE_INSERT
; 1089 : 
; 1090 : 	~list() _NOEXCEPT
; 1091 : 		{	// destroy the object
; 1092 : 		_Tidy();
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();
; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();
; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();
; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());
; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());
; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1916 : 		}
; 1917 : 
; 1918 : 	void _Assign_n(size_type _Count, const _Ty& _Val)
; 1919 : 		{	// assign _Count * _Val
; 1920 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1921 : 		clear();
; 1922 : 		_Insert_n(_Unchecked_begin(), _Count, _Tmp);
; 1923 : 		}
; 1924 : 
; 1925 : 	void _Tidy()
; 1926 : 		{	// free all storage
; 1927 : 		clear();
; 1928 : 		}
; 1929 : 
; 1930 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1931 : 		size_type _Count, const _Ty& _Val)
; 1932 : 		{	// insert _Count * _Val at _Where
; 1933 : 		size_type _Countsave = _Count;
; 1934 : 
; 1935 : 		_TRY_BEGIN
; 1936 : 		for (; 0 < _Count; --_Count)
; 1937 : 			_Insert(_Where, _Val);
; 1938 : 		_CATCH_ALL
; 1939 : 		for (; _Count < _Countsave; ++_Count)
; 1940 : 			{	// undo inserts
; 1941 : 			_Unchecked_const_iterator _Before = _Where;
; 1942 : 			_Unchecked_erase(--_Before);
; 1943 : 			}
; 1944 : 		_RERAISE;
; 1945 : 		_CATCH_END
; 1946 : 		}
; 1947 : 
; 1948 : 	void _Incsize(size_type _Count)
; 1949 : 		{	// alter element count, with checking
; 1950 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00078	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0007c	48 b9 54 55 55
	55 55 55 55 05	 mov	 rcx, 384307168202282324	; 0555555555555554H
  00086	48 2b c8	 sub	 rcx, rax
  00089	48 83 f9 01	 cmp	 rcx, 1
  0008d	73 0d		 jae	 SHORT $LN85@operator

; 1951 : 			_Xlength_error("list<T> too long");

  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00096	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0009b	cc		 int	 3
$LN85@operator:

; 1952 : 		this->_Mysize += _Count;

  0009c	48 ff c0	 inc	 rax
  0009f	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 548  : 		}
; 549  : 
; 550  : 	_Nodeptr _Myhead;	// pointer to head node
; 551  : 	size_type _Mysize;	// number of elements
; 552  : 	};
; 553  : 
; 554  : 		// TEMPLATE CLASS _List_alloc
; 555  : template<bool _Al_has_storage,
; 556  : 	class _Alloc_types>
; 557  : 	class _List_alloc
; 558  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 559  : 	{	// base class for list to hold allocator with storage
; 560  : public:
; 561  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 562  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 563  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 564  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 565  : 	typedef typename _Alloc_types::_Node _Node;
; 566  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 567  : 
; 568  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 569  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 570  : 		: _Alnod(_Al)
; 571  : 		{	// construct head node, allocator from _Al
; 572  : 		this->_Myhead = _Buyheadnode();
; 573  : 		}
; 574  : 
; 575  : 	~_List_alloc() _NOEXCEPT
; 576  : 		{	// destroy head node
; 577  : 		_Freeheadnode(this->_Myhead);
; 578  : 		}
; 579  : 
; 580  : 	void _Change_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Alnod = _Al;
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 588  : 		}
; 589  : 
; 590  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 591  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 592  : 		: _Alnod(_Al)
; 593  : 		{	// construct head node, allocator from _Al
; 594  : 		this->_Myhead = _Buyheadnode();
; 595  : 		_TRY_BEGIN
; 596  : 		_Alloc_proxy();
; 597  : 		_CATCH_ALL
; 598  : 		_Freeheadnode(this->_Myhead);
; 599  : 		_RERAISE;
; 600  : 		_CATCH_END
; 601  : 		}
; 602  : 
; 603  : 	~_List_alloc() _NOEXCEPT
; 604  : 		{	// destroy proxy
; 605  : 		_Freeheadnode(this->_Myhead);
; 606  : 		_Free_proxy();
; 607  : 		}
; 608  : 
; 609  : 	void _Change_alloc(const _Alty& _Al)
; 610  : 		{	// replace old allocator
; 611  : 		_Free_proxy();
; 612  : 		_Alnod = _Al;
; 613  : 		_Alloc_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Swap_alloc(_Myt& _Right)
; 617  : 		{	// swap allocators
; 618  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 619  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 620  : 		}
; 621  : 
; 622  : 	void _Alloc_proxy()
; 623  : 		{	// construct proxy from _Alnod
; 624  : 		typename _Alty::template rebind<_Container_proxy>::other
; 625  : 			_Alproxy(_Alnod);
; 626  : 		this->_Myproxy = _Alproxy.allocate(1);
; 627  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 628  : 		this->_Myproxy->_Mycont = this;
; 629  : 		}
; 630  : 
; 631  : 	void _Free_proxy()
; 632  : 		{	// destroy proxy
; 633  : 		typename _Alty::template rebind<_Container_proxy>::other
; 634  : 			_Alproxy(_Alnod);
; 635  : 		this->_Orphan_all();
; 636  : 		_Alproxy.destroy(this->_Myproxy);
; 637  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 638  : 		this->_Myproxy = 0;
; 639  : 		}
; 640  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 641  : 
; 642  : 	_Nodeptr _Buyheadnode()
; 643  : 		{	// get head node using current allocator
; 644  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 645  : 		}
; 646  : 
; 647  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 648  : 		{	// free head node using current allocator
; 649  : 		_Alnod.destroy(
; 650  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 651  : 		_Alnod.destroy(
; 652  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 653  : 		_Alnod.deallocate(_Pnode, 1);
; 654  : 		}
; 655  : 
; 656  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 657  : 		_Nodeptr _Prev)
; 658  : 		{	// allocate a node and set links
; 659  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 660  : 
; 661  : 		if (_Next == _Nodeptr())
; 662  : 			{	// point at self
; 663  : 			_Next = _Pnode;
; 664  : 			_Prev = _Pnode;
; 665  : 			}
; 666  : 		_TRY_BEGIN
; 667  : 		_Alnod.construct(
; 668  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 669  : 		_Alnod.construct(
; 670  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 671  : 		_CATCH_ALL
; 672  : 		_Alnod.deallocate(_Pnode, 1);
; 673  : 		_RERAISE;
; 674  : 		_CATCH_END
; 675  : 
; 676  : 		return (_Pnode);
; 677  : 		}
; 678  : 
; 679  : 	_Alty& _Getal()
; 680  : 		{	// get reference to allocator
; 681  : 		return (_Alnod);
; 682  : 		}
; 683  : 
; 684  : 	const _Alty& _Getal() const
; 685  : 		{	// get reference to allocator
; 686  : 		return (_Alnod);
; 687  : 		}
; 688  : 
; 689  : 	_Alty _Alnod;	// allocator object for stored elements
; 690  : 	};
; 691  : 
; 692  : 		// TEMPLATE CLASS _List_alloc
; 693  : template<class _Alloc_types>
; 694  : 	class _List_alloc<false, _Alloc_types>
; 695  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 696  : 	{	// base class for list to hold allocator with no storage
; 697  : public:
; 698  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 699  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 700  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 701  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 702  : 	typedef typename _Alloc_types::_Node _Node;
; 703  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 704  : 
; 705  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 706  : 	_List_alloc(const _Alloc& = _Alloc())
; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();
; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 774  : 		}
; 775  : 
; 776  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 777  : 		{	// free head node using current allocator
; 778  : 		this->_Getal().destroy(
; 779  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 780  : 		this->_Getal().destroy(
; 781  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 782  : 		this->_Getal().deallocate(_Pnode, 1);
; 783  : 		}
; 784  : 
; 785  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 786  : 		_Nodeptr _Prev)
; 787  : 		{	// allocate a node and set links
; 788  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 789  : 
; 790  : 		if (_Next == _Nodeptr())
; 791  : 			{	// point at self
; 792  : 			_Next = _Pnode;
; 793  : 			_Prev = _Pnode;
; 794  : 			}
; 795  : 		_TRY_BEGIN
; 796  : 		this->_Getal().construct(
; 797  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 798  : 		this->_Getal().construct(
; 799  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 800  : 		_CATCH_ALL
; 801  : 		this->_Getal().deallocate(_Pnode, 1);
; 802  : 		_RERAISE;
; 803  : 		_CATCH_END
; 804  : 
; 805  : 		return (_Pnode);
; 806  : 		}
; 807  : 
; 808  : 	_Alty _Getal() const
; 809  : 		{	// get reference to allocator
; 810  : 		return (_Alty());
; 811  : 		}
; 812  : 	};
; 813  : 
; 814  : 		// TEMPLATE CLASS _List_buy
; 815  : template<class _Ty,
; 816  : 	class _Alloc>
; 817  : 	class _List_buy
; 818  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 819  : 			_List_base_types<_Ty, _Alloc> >
; 820  : 	{	// base class for list to hold buynode/freenode functions
; 821  : public:
; 822  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 823  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 824  : 	typedef typename _Mybase::_Alty _Alty;
; 825  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 826  : 
; 827  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 828  : 		: _Mybase(_Al)
; 829  : 		{	// construct from allocator
; 830  : 		}
; 831  : 
; 832  : #define _LIST_BUYNODE( \
; 833  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 834  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 835  : 		_Nodeptr _Buynode(_Nodeptr _Next, \
; 836  : 			_Nodeptr _Prev COMMA LIST(_TYPE_REFREF_ARG)) \
; 837  : 		{	/* allocate a node and set links and value */ \
; 838  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev); \
; 839  : 		_TRY_BEGIN \
; 840  : 		this->_Getal().construct( \
; 841  : 			_STD addressof(this->_Myval(_Pnode)) \
; 842  : 				COMMA LIST(_FORWARD_ARG)); \
; 843  : 		_CATCH_ALL \
; 844  : 		this->_Getal().deallocate(_Pnode, 1); \
; 845  : 		_RERAISE; \
; 846  : 		_CATCH_END \
; 847  : 		return (_Pnode); \
; 848  : 		}
; 849  : 
; 850  : _VARIADIC_EXPAND_0X(_LIST_BUYNODE, , , , )
; 851  : #undef _LIST_BUYNODE
; 852  : 
; 853  : 	void _Freenode(_Nodeptr _Pnode)
; 854  : 		{	// give node back
; 855  : 		this->_Getal().destroy(
; 856  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 857  : 		this->_Getal().destroy(
; 858  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 859  : 		this->_Getal().destroy(
; 860  : 			_STD addressof(this->_Myval(_Pnode)));
; 861  : 		this->_Getal().deallocate(_Pnode, 1);
; 862  : 		}
; 863  : 	};
; 864  : 
; 865  : 		// TEMPLATE CLASS list
; 866  : template<class _Ty,
; 867  : 	class _Alloc = allocator<_Ty> >
; 868  : 	class list
; 869  : 		: public _List_buy<_Ty, _Alloc>
; 870  : 	{	// bidirectional linked list
; 871  : public:
; 872  : 	typedef list<_Ty, _Alloc> _Myt;
; 873  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 874  : 	typedef typename _Mybase::_Node _Node;
; 875  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 876  : 	typedef typename _Mybase::_Alty _Alty;
; 877  : 
; 878  : 	typedef _Alloc allocator_type;
; 879  : 	typedef typename _Mybase::size_type size_type;
; 880  : 	typedef typename _Mybase::difference_type difference_type;
; 881  : 	typedef typename _Mybase::pointer pointer;
; 882  : 	typedef typename _Mybase::const_pointer const_pointer;
; 883  : 	typedef typename _Mybase::reference reference;
; 884  : 	typedef typename _Mybase::const_reference const_reference;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	typedef typename _Mybase::const_iterator const_iterator;
; 888  : 	typedef typename _Mybase::iterator iterator;
; 889  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 890  : 		_Unchecked_const_iterator;
; 891  : 	typedef typename _Mybase::_Unchecked_iterator
; 892  : 		_Unchecked_iterator;
; 893  : 
; 894  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 895  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 896  : 
; 897  : 	list()
; 898  : 		: _Mybase()
; 899  : 		{	// construct empty list
; 900  : 		}
; 901  : 
; 902  : 	explicit list(const _Alloc& _Al)
; 903  : 		: _Mybase(_Al)
; 904  : 		{	// construct empty list, allocator
; 905  : 		}
; 906  : 
; 907  : 	explicit list(size_type _Count)
; 908  : 		: _Mybase()
; 909  : 		{	// construct list from _Count * _Ty()
; 910  : 		resize(_Count);
; 911  : 		}
; 912  : 
; 913  : 	list(size_type _Count, const _Ty& _Val)
; 914  : 		: _Mybase()
; 915  : 		{	// construct list from _Count * _Val
; 916  : 		_Construct_n(_Count, _Val);
; 917  : 		}
; 918  : 
; 919  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 920  : 		: _Mybase(_Al)
; 921  : 		{	// construct list from _Count * _Val, allocator
; 922  : 		_Construct_n(_Count, _Val);
; 923  : 		}
; 924  : 
; 925  : 	list(const _Myt& _Right)
; 926  : 
; 927  :  #if _HAS_CPP0X
; 928  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 929  : 
; 930  :  #else /* _HAS_CPP0X */
; 931  : 		: _Mybase(_Right._Getal())
; 932  :  #endif /* _HAS_CPP0X */
; 933  : 
; 934  : 		{	// construct list by copying _Right
; 935  : 		_TRY_BEGIN
; 936  : 		insert(begin(), _Right.begin(), _Right.end());
; 937  : 		_CATCH_ALL
; 938  : 		_Tidy();
; 939  : 		_RERAISE;
; 940  : 		_CATCH_END
; 941  : 		}
; 942  : 
; 943  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 944  : 		: _Mybase(_Al)
; 945  : 		{	// construct list by copying _Right, allocator
; 946  : 		_TRY_BEGIN
; 947  : 		insert(begin(), _Right.begin(), _Right.end());
; 948  : 		_CATCH_ALL
; 949  : 		_Tidy();
; 950  : 		_RERAISE;
; 951  : 		_CATCH_END
; 952  : 		}
; 953  : 
; 954  : 	template<class _Iter>
; 955  : 		list(_Iter _First, _Iter _Last,
; 956  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 957  : 				void>::type ** = 0)
; 958  : 		: _Mybase()
; 959  : 		{	// construct list from [_First, _Last,
; 960  : 		_Construct(_First, _Last);
; 961  : 		}
; 962  : 
; 963  : 	template<class _Iter>
; 964  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 965  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 966  : 				void>::type ** = 0)
; 967  : 		: _Mybase(_Al)
; 968  : 		{	// construct list, allocator from [_First, _Last)
; 969  : 		_Construct(_First, _Last);
; 970  : 		}
; 971  : 
; 972  : 	template<class _Iter>
; 973  : 		void _Construct(_Iter _First, _Iter _Last)
; 974  : 		{	// construct list from [_First, _Last), input iterators
; 975  : 		_TRY_BEGIN
; 976  : 		insert(begin(), _First, _Last);
; 977  : 		_CATCH_ALL
; 978  : 		_Tidy();
; 979  : 		_RERAISE;
; 980  : 		_CATCH_END
; 981  : 		}
; 982  : 
; 983  : 	void _Construct_n(size_type _Count,
; 984  : 		const _Ty& _Val)
; 985  : 		{	// construct from _Count * _Val
; 986  : 		_TRY_BEGIN
; 987  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 988  : 		_CATCH_ALL
; 989  : 		_Tidy();
; 990  : 		_RERAISE;
; 991  : 		_CATCH_END
; 992  : 		}
; 993  : 
; 994  : 	list(_Myt&& _Right)
; 995  : 		: _Mybase(_Right._Getal())
; 996  : 		{	// construct list by moving _Right
; 997  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 998  : 		}
; 999  : 
; 1000 : 	list(_Myt&& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct list by moving _Right, allocator
; 1003 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1004 : 		}
; 1005 : 
; 1006 : 	_Myt& operator=(_Myt&& _Right)
; 1007 : 		{	// assign by moving _Right
; 1008 : 		if (this != &_Right)
; 1009 : 			{	// different, assign it
; 1010 : 			clear();
; 1011 : 
; 1012 :  #if _HAS_CPP0X
; 1013 : 			if (this->_Getal() != _Right._Getal()
; 1014 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1015 : 				this->_Change_alloc(_Right._Getal());
; 1016 :  #endif /* _HAS_CPP0X */
; 1017 : 
; 1018 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1019 : 			}
; 1020 : 		return (*this);
; 1021 : 		}
; 1022 : 
; 1023 : 	void _Assign_rv(_Myt&& _Right)
; 1024 : 		{	// swap with empty *this, same allocator
; 1025 : 		this->_Swap_all(_Right);
; 1026 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1027 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1028 : 		}
; 1029 : 
; 1030 : 	void push_front(_Ty&& _Val)
; 1031 : 		{	// insert element at beginning
; 1032 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1033 : 		}
; 1034 : 
; 1035 : 	void push_back(_Ty&& _Val)
; 1036 : 		{	// insert element at end
; 1037 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1038 : 		}
; 1039 : 
; 1040 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1041 : 		{	// insert _Val at _Where
; 1042 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1043 : 		}
; 1044 : 
; 1045 : #define _LIST_EMPLACE_INSERT( \
; 1046 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1047 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1048 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1049 : 		{	/* insert element at beginning */ \
; 1050 : 		_Insert(_Unchecked_begin() COMMA LIST(_FORWARD_ARG)); \
; 1051 : 		} \
; 1052 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1053 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1054 : 		{	/* insert element at end */ \
; 1055 : 		_Insert(_Unchecked_end() COMMA LIST(_FORWARD_ARG)); \
; 1056 : 		} \
; 1057 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1058 : 		iterator emplace(const_iterator _Where \
; 1059 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1060 : 		{	/* insert element at _Where */ \
; 1061 : 		_LIST_EMPLACE_CHECK \
; 1062 : 		_Insert(_Where._Unchecked() COMMA LIST(_FORWARD_ARG)); \
; 1063 : 		return (_Make_iter(--_Where)); \
; 1064 : 		} \
; 1065 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1066 : 		void _Insert(_Unchecked_const_iterator _Where \
; 1067 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1068 : 		{	/* insert element at _Where */ \
; 1069 : 		_Nodeptr _Pnode = _Where._Mynode(); \
; 1070 : 		_Nodeptr _Newnode = this->_Buynode(_Pnode, \
; 1071 : 			this->_Prevnode(_Pnode) COMMA LIST(_FORWARD_ARG)); \
; 1072 : 		_Incsize(1); \
; 1073 : 		this->_Prevnode(_Pnode) = _Newnode; \
; 1074 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode; \
; 1075 : 		}
; 1076 : 
; 1077 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1078 : #define _LIST_EMPLACE_CHECK \
; 1079 : 		if (_Where._Getcont() != this) \
; 1080 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1081 : 
; 1082 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1083 : #define _LIST_EMPLACE_CHECK
; 1084 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1085 : 
; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  000a3	48 89 57 08	 mov	 QWORD PTR [rdi+8], rdx

; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  000a7	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]

; 548  : 		}
; 549  : 
; 550  : 	_Nodeptr _Myhead;	// pointer to head node
; 551  : 	size_type _Mysize;	// number of elements
; 552  : 	};
; 553  : 
; 554  : 		// TEMPLATE CLASS _List_alloc
; 555  : template<bool _Al_has_storage,
; 556  : 	class _Alloc_types>
; 557  : 	class _List_alloc
; 558  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 559  : 	{	// base class for list to hold allocator with storage
; 560  : public:
; 561  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 562  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 563  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 564  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 565  : 	typedef typename _Alloc_types::_Node _Node;
; 566  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 567  : 
; 568  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 569  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 570  : 		: _Alnod(_Al)
; 571  : 		{	// construct head node, allocator from _Al
; 572  : 		this->_Myhead = _Buyheadnode();
; 573  : 		}
; 574  : 
; 575  : 	~_List_alloc() _NOEXCEPT
; 576  : 		{	// destroy head node
; 577  : 		_Freeheadnode(this->_Myhead);
; 578  : 		}
; 579  : 
; 580  : 	void _Change_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Alnod = _Al;
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 588  : 		}
; 589  : 
; 590  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 591  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 592  : 		: _Alnod(_Al)
; 593  : 		{	// construct head node, allocator from _Al
; 594  : 		this->_Myhead = _Buyheadnode();
; 595  : 		_TRY_BEGIN
; 596  : 		_Alloc_proxy();
; 597  : 		_CATCH_ALL
; 598  : 		_Freeheadnode(this->_Myhead);
; 599  : 		_RERAISE;
; 600  : 		_CATCH_END
; 601  : 		}
; 602  : 
; 603  : 	~_List_alloc() _NOEXCEPT
; 604  : 		{	// destroy proxy
; 605  : 		_Freeheadnode(this->_Myhead);
; 606  : 		_Free_proxy();
; 607  : 		}
; 608  : 
; 609  : 	void _Change_alloc(const _Alty& _Al)
; 610  : 		{	// replace old allocator
; 611  : 		_Free_proxy();
; 612  : 		_Alnod = _Al;
; 613  : 		_Alloc_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Swap_alloc(_Myt& _Right)
; 617  : 		{	// swap allocators
; 618  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 619  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 620  : 		}
; 621  : 
; 622  : 	void _Alloc_proxy()
; 623  : 		{	// construct proxy from _Alnod
; 624  : 		typename _Alty::template rebind<_Container_proxy>::other
; 625  : 			_Alproxy(_Alnod);
; 626  : 		this->_Myproxy = _Alproxy.allocate(1);
; 627  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 628  : 		this->_Myproxy->_Mycont = this;
; 629  : 		}
; 630  : 
; 631  : 	void _Free_proxy()
; 632  : 		{	// destroy proxy
; 633  : 		typename _Alty::template rebind<_Container_proxy>::other
; 634  : 			_Alproxy(_Alnod);
; 635  : 		this->_Orphan_all();
; 636  : 		_Alproxy.destroy(this->_Myproxy);
; 637  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 638  : 		this->_Myproxy = 0;
; 639  : 		}
; 640  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 641  : 
; 642  : 	_Nodeptr _Buyheadnode()
; 643  : 		{	// get head node using current allocator
; 644  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 645  : 		}
; 646  : 
; 647  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 648  : 		{	// free head node using current allocator
; 649  : 		_Alnod.destroy(
; 650  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 651  : 		_Alnod.destroy(
; 652  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 653  : 		_Alnod.deallocate(_Pnode, 1);
; 654  : 		}
; 655  : 
; 656  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 657  : 		_Nodeptr _Prev)
; 658  : 		{	// allocate a node and set links
; 659  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 660  : 
; 661  : 		if (_Next == _Nodeptr())
; 662  : 			{	// point at self
; 663  : 			_Next = _Pnode;
; 664  : 			_Prev = _Pnode;
; 665  : 			}
; 666  : 		_TRY_BEGIN
; 667  : 		_Alnod.construct(
; 668  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 669  : 		_Alnod.construct(
; 670  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 671  : 		_CATCH_ALL
; 672  : 		_Alnod.deallocate(_Pnode, 1);
; 673  : 		_RERAISE;
; 674  : 		_CATCH_END
; 675  : 
; 676  : 		return (_Pnode);
; 677  : 		}
; 678  : 
; 679  : 	_Alty& _Getal()
; 680  : 		{	// get reference to allocator
; 681  : 		return (_Alnod);
; 682  : 		}
; 683  : 
; 684  : 	const _Alty& _Getal() const
; 685  : 		{	// get reference to allocator
; 686  : 		return (_Alnod);
; 687  : 		}
; 688  : 
; 689  : 	_Alty _Alnod;	// allocator object for stored elements
; 690  : 	};
; 691  : 
; 692  : 		// TEMPLATE CLASS _List_alloc
; 693  : template<class _Alloc_types>
; 694  : 	class _List_alloc<false, _Alloc_types>
; 695  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 696  : 	{	// base class for list to hold allocator with no storage
; 697  : public:
; 698  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 699  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 700  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 701  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 702  : 	typedef typename _Alloc_types::_Node _Node;
; 703  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 704  : 
; 705  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 706  : 	_List_alloc(const _Alloc& = _Alloc())
; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();
; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 774  : 		}
; 775  : 
; 776  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 777  : 		{	// free head node using current allocator
; 778  : 		this->_Getal().destroy(
; 779  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 780  : 		this->_Getal().destroy(
; 781  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 782  : 		this->_Getal().deallocate(_Pnode, 1);
; 783  : 		}
; 784  : 
; 785  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 786  : 		_Nodeptr _Prev)
; 787  : 		{	// allocate a node and set links
; 788  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 789  : 
; 790  : 		if (_Next == _Nodeptr())
; 791  : 			{	// point at self
; 792  : 			_Next = _Pnode;
; 793  : 			_Prev = _Pnode;
; 794  : 			}
; 795  : 		_TRY_BEGIN
; 796  : 		this->_Getal().construct(
; 797  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 798  : 		this->_Getal().construct(
; 799  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 800  : 		_CATCH_ALL
; 801  : 		this->_Getal().deallocate(_Pnode, 1);
; 802  : 		_RERAISE;
; 803  : 		_CATCH_END
; 804  : 
; 805  : 		return (_Pnode);
; 806  : 		}
; 807  : 
; 808  : 	_Alty _Getal() const
; 809  : 		{	// get reference to allocator
; 810  : 		return (_Alty());
; 811  : 		}
; 812  : 	};
; 813  : 
; 814  : 		// TEMPLATE CLASS _List_buy
; 815  : template<class _Ty,
; 816  : 	class _Alloc>
; 817  : 	class _List_buy
; 818  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 819  : 			_List_base_types<_Ty, _Alloc> >
; 820  : 	{	// base class for list to hold buynode/freenode functions
; 821  : public:
; 822  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 823  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 824  : 	typedef typename _Mybase::_Alty _Alty;
; 825  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 826  : 
; 827  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 828  : 		: _Mybase(_Al)
; 829  : 		{	// construct from allocator
; 830  : 		}
; 831  : 
; 832  : #define _LIST_BUYNODE( \
; 833  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 834  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 835  : 		_Nodeptr _Buynode(_Nodeptr _Next, \
; 836  : 			_Nodeptr _Prev COMMA LIST(_TYPE_REFREF_ARG)) \
; 837  : 		{	/* allocate a node and set links and value */ \
; 838  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev); \
; 839  : 		_TRY_BEGIN \
; 840  : 		this->_Getal().construct( \
; 841  : 			_STD addressof(this->_Myval(_Pnode)) \
; 842  : 				COMMA LIST(_FORWARD_ARG)); \
; 843  : 		_CATCH_ALL \
; 844  : 		this->_Getal().deallocate(_Pnode, 1); \
; 845  : 		_RERAISE; \
; 846  : 		_CATCH_END \
; 847  : 		return (_Pnode); \
; 848  : 		}
; 849  : 
; 850  : _VARIADIC_EXPAND_0X(_LIST_BUYNODE, , , , )
; 851  : #undef _LIST_BUYNODE
; 852  : 
; 853  : 	void _Freenode(_Nodeptr _Pnode)
; 854  : 		{	// give node back
; 855  : 		this->_Getal().destroy(
; 856  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 857  : 		this->_Getal().destroy(
; 858  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 859  : 		this->_Getal().destroy(
; 860  : 			_STD addressof(this->_Myval(_Pnode)));
; 861  : 		this->_Getal().deallocate(_Pnode, 1);
; 862  : 		}
; 863  : 	};
; 864  : 
; 865  : 		// TEMPLATE CLASS list
; 866  : template<class _Ty,
; 867  : 	class _Alloc = allocator<_Ty> >
; 868  : 	class list
; 869  : 		: public _List_buy<_Ty, _Alloc>
; 870  : 	{	// bidirectional linked list
; 871  : public:
; 872  : 	typedef list<_Ty, _Alloc> _Myt;
; 873  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 874  : 	typedef typename _Mybase::_Node _Node;
; 875  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 876  : 	typedef typename _Mybase::_Alty _Alty;
; 877  : 
; 878  : 	typedef _Alloc allocator_type;
; 879  : 	typedef typename _Mybase::size_type size_type;
; 880  : 	typedef typename _Mybase::difference_type difference_type;
; 881  : 	typedef typename _Mybase::pointer pointer;
; 882  : 	typedef typename _Mybase::const_pointer const_pointer;
; 883  : 	typedef typename _Mybase::reference reference;
; 884  : 	typedef typename _Mybase::const_reference const_reference;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	typedef typename _Mybase::const_iterator const_iterator;
; 888  : 	typedef typename _Mybase::iterator iterator;
; 889  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 890  : 		_Unchecked_const_iterator;
; 891  : 	typedef typename _Mybase::_Unchecked_iterator
; 892  : 		_Unchecked_iterator;
; 893  : 
; 894  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 895  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 896  : 
; 897  : 	list()
; 898  : 		: _Mybase()
; 899  : 		{	// construct empty list
; 900  : 		}
; 901  : 
; 902  : 	explicit list(const _Alloc& _Al)
; 903  : 		: _Mybase(_Al)
; 904  : 		{	// construct empty list, allocator
; 905  : 		}
; 906  : 
; 907  : 	explicit list(size_type _Count)
; 908  : 		: _Mybase()
; 909  : 		{	// construct list from _Count * _Ty()
; 910  : 		resize(_Count);
; 911  : 		}
; 912  : 
; 913  : 	list(size_type _Count, const _Ty& _Val)
; 914  : 		: _Mybase()
; 915  : 		{	// construct list from _Count * _Val
; 916  : 		_Construct_n(_Count, _Val);
; 917  : 		}
; 918  : 
; 919  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 920  : 		: _Mybase(_Al)
; 921  : 		{	// construct list from _Count * _Val, allocator
; 922  : 		_Construct_n(_Count, _Val);
; 923  : 		}
; 924  : 
; 925  : 	list(const _Myt& _Right)
; 926  : 
; 927  :  #if _HAS_CPP0X
; 928  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 929  : 
; 930  :  #else /* _HAS_CPP0X */
; 931  : 		: _Mybase(_Right._Getal())
; 932  :  #endif /* _HAS_CPP0X */
; 933  : 
; 934  : 		{	// construct list by copying _Right
; 935  : 		_TRY_BEGIN
; 936  : 		insert(begin(), _Right.begin(), _Right.end());
; 937  : 		_CATCH_ALL
; 938  : 		_Tidy();
; 939  : 		_RERAISE;
; 940  : 		_CATCH_END
; 941  : 		}
; 942  : 
; 943  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 944  : 		: _Mybase(_Al)
; 945  : 		{	// construct list by copying _Right, allocator
; 946  : 		_TRY_BEGIN
; 947  : 		insert(begin(), _Right.begin(), _Right.end());
; 948  : 		_CATCH_ALL
; 949  : 		_Tidy();
; 950  : 		_RERAISE;
; 951  : 		_CATCH_END
; 952  : 		}
; 953  : 
; 954  : 	template<class _Iter>
; 955  : 		list(_Iter _First, _Iter _Last,
; 956  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 957  : 				void>::type ** = 0)
; 958  : 		: _Mybase()
; 959  : 		{	// construct list from [_First, _Last,
; 960  : 		_Construct(_First, _Last);
; 961  : 		}
; 962  : 
; 963  : 	template<class _Iter>
; 964  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 965  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 966  : 				void>::type ** = 0)
; 967  : 		: _Mybase(_Al)
; 968  : 		{	// construct list, allocator from [_First, _Last)
; 969  : 		_Construct(_First, _Last);
; 970  : 		}
; 971  : 
; 972  : 	template<class _Iter>
; 973  : 		void _Construct(_Iter _First, _Iter _Last)
; 974  : 		{	// construct list from [_First, _Last), input iterators
; 975  : 		_TRY_BEGIN
; 976  : 		insert(begin(), _First, _Last);
; 977  : 		_CATCH_ALL
; 978  : 		_Tidy();
; 979  : 		_RERAISE;
; 980  : 		_CATCH_END
; 981  : 		}
; 982  : 
; 983  : 	void _Construct_n(size_type _Count,
; 984  : 		const _Ty& _Val)
; 985  : 		{	// construct from _Count * _Val
; 986  : 		_TRY_BEGIN
; 987  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 988  : 		_CATCH_ALL
; 989  : 		_Tidy();
; 990  : 		_RERAISE;
; 991  : 		_CATCH_END
; 992  : 		}
; 993  : 
; 994  : 	list(_Myt&& _Right)
; 995  : 		: _Mybase(_Right._Getal())
; 996  : 		{	// construct list by moving _Right
; 997  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 998  : 		}
; 999  : 
; 1000 : 	list(_Myt&& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct list by moving _Right, allocator
; 1003 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1004 : 		}
; 1005 : 
; 1006 : 	_Myt& operator=(_Myt&& _Right)
; 1007 : 		{	// assign by moving _Right
; 1008 : 		if (this != &_Right)
; 1009 : 			{	// different, assign it
; 1010 : 			clear();
; 1011 : 
; 1012 :  #if _HAS_CPP0X
; 1013 : 			if (this->_Getal() != _Right._Getal()
; 1014 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1015 : 				this->_Change_alloc(_Right._Getal());
; 1016 :  #endif /* _HAS_CPP0X */
; 1017 : 
; 1018 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1019 : 			}
; 1020 : 		return (*this);
; 1021 : 		}
; 1022 : 
; 1023 : 	void _Assign_rv(_Myt&& _Right)
; 1024 : 		{	// swap with empty *this, same allocator
; 1025 : 		this->_Swap_all(_Right);
; 1026 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1027 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1028 : 		}
; 1029 : 
; 1030 : 	void push_front(_Ty&& _Val)
; 1031 : 		{	// insert element at beginning
; 1032 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1033 : 		}
; 1034 : 
; 1035 : 	void push_back(_Ty&& _Val)
; 1036 : 		{	// insert element at end
; 1037 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1038 : 		}
; 1039 : 
; 1040 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1041 : 		{	// insert _Val at _Where
; 1042 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1043 : 		}
; 1044 : 
; 1045 : #define _LIST_EMPLACE_INSERT( \
; 1046 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1047 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1048 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1049 : 		{	/* insert element at beginning */ \
; 1050 : 		_Insert(_Unchecked_begin() COMMA LIST(_FORWARD_ARG)); \
; 1051 : 		} \
; 1052 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1053 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1054 : 		{	/* insert element at end */ \
; 1055 : 		_Insert(_Unchecked_end() COMMA LIST(_FORWARD_ARG)); \
; 1056 : 		} \
; 1057 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1058 : 		iterator emplace(const_iterator _Where \
; 1059 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1060 : 		{	/* insert element at _Where */ \
; 1061 : 		_LIST_EMPLACE_CHECK \
; 1062 : 		_Insert(_Where._Unchecked() COMMA LIST(_FORWARD_ARG)); \
; 1063 : 		return (_Make_iter(--_Where)); \
; 1064 : 		} \
; 1065 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1066 : 		void _Insert(_Unchecked_const_iterator _Where \
; 1067 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1068 : 		{	/* insert element at _Where */ \
; 1069 : 		_Nodeptr _Pnode = _Where._Mynode(); \
; 1070 : 		_Nodeptr _Newnode = this->_Buynode(_Pnode, \
; 1071 : 			this->_Prevnode(_Pnode) COMMA LIST(_FORWARD_ARG)); \
; 1072 : 		_Incsize(1); \
; 1073 : 		this->_Prevnode(_Pnode) = _Newnode; \
; 1074 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode; \
; 1075 : 		}
; 1076 : 
; 1077 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1078 : #define _LIST_EMPLACE_CHECK \
; 1079 : 		if (_Where._Getcont() != this) \
; 1080 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1081 : 
; 1082 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1083 : #define _LIST_EMPLACE_CHECK
; 1084 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1085 : 
; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  000ab	48 89 10	 mov	 QWORD PTR [rax], rdx

; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  000ae	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]

; 44   : 		{	// construct with node pointer _Pnode

  000b1	4d 8b 09	 mov	 r9, QWORD PTR [r9]

; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  000b4	4d 8d 41 10	 lea	 r8, QWORD PTR [r9+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 385  : 		return (_Insert(_List.front(), _Unchecked_begin()));

  000b8	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T2[rsp]
  000bd	48 8b cb	 mov	 rcx, rbx
  000c0	e8 00 00 00 00	 call	 ??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map

; 265  : 					mapped_type())).first;

  000c5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000c8	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR _Where$[rsp], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T3[rsp+24]
  000d5	48 85 c9	 test	 rcx, rcx
  000d8	74 25		 je	 SHORT $LN182@operator

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000da	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  000de	75 1f		 jne	 SHORT $LN182@operator

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000e0	48 8b 5c 24 60	 mov	 rbx, QWORD PTR $T3[rsp+24]
  000e5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000e8	48 8b cb	 mov	 rcx, rbx
  000eb	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000ed	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  000f1	75 0c		 jne	 SHORT $LN182@operator

; 128  : 			_Delete_this();

  000f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T3[rsp+24]
  000f8	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000fb	ff 50 08	 call	 QWORD PTR [rax+8]
  000fe	90		 npad	 1
$LN182@operator:
$LN167@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map

; 266  : 		return (_Where->second);

  000ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _Where$[rsp]
  00107	48 83 c0 20	 add	 rax, 32			; 00000020H

; 267  : 		}

  0010b	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR [rsp+136]
  00113	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00117	5f		 pop	 rdi
  00118	c3		 ret	 0
$LN183@operator:
??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ENDP ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 56
$T3 = 72
_Where$ = 128
this$ = 128
_Keyval$ = 136
?dtor$0@?0???A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA PROC ; `std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0???A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA ENDP ; `std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
$T2 = 56
$T3 = 72
_Where$ = 128
this$ = 128
_Keyval$ = 136
?dtor$1@?0???A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA PROC ; `std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]'::`1'::dtor$1
  0000c	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR $T3[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
?dtor$1@?0???A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z@4HA ENDP ; `std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ??1?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT

; 416  : 		{	// destroy hash table

$LN47:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  00009	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 13		 je	 SHORT $LN5@Hash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00012	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00017	33 c0		 xor	 eax, eax
  00019	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1543 : 			this->_Mylast = pointer();

  0001d	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 1544 : 			this->_Myend = pointer();

  00021	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
$LN5@Hash:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1927 : 		clear();

  00025	48 8b cb	 mov	 rcx, rbx
  00028	e8 00 00 00 00	 call	 ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0002d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 418  : 		}

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00035	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@XZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::~_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Keyval$ = 72
$T2 = 80
?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT

; 712  : 		{	// erase and count all that match _Keyval

$LN32:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 713  : 		_Pairii _Where = equal_range(_Keyval);

  0000a	4c 8b c2	 mov	 r8, rdx
  0000d	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00012	48 8b f9	 mov	 rdi, rcx
  00015	e8 00 00 00 00	 call	 ?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range

; 714  : 		size_type _Num = 0;

  0001a	33 db		 xor	 ebx, ebx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0001c	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0001f	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00023	49 8b d0	 mov	 rdx, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00026	4d 3b c1	 cmp	 r8, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00029	74 10		 je	 SHORT $LN13@erase
  0002b	0f 1f 44 00 00	 npad	 5
$LL20@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00030	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 799  : 		++_Off;

  00033	48 ff c3	 inc	 rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00036	49 3b d1	 cmp	 rdx, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00039	75 f5		 jne	 SHORT $LL20@erase
$LN13@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 716  : 		erase(_Where.first, _Where.second);

  0003b	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00040	48 8b cf	 mov	 rcx, rdi
  00043	e8 00 00 00 00	 call	 ?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase

; 717  : 		return (_Num);

  00048	48 8b c3	 mov	 rax, rbx

; 718  : 		}

  0004b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00050	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00054	5f		 pop	 rdi
  00055	c3		 ret	 0
?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA_KAEBVChunkPosition@@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?clear@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Tmp$1 = 64
this$ = 64
$T2 = 72
?clear@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear, COMDAT

; 721  : 		{	// erase all

$LN130:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b d9	 mov	 rbx, rcx

; 722  : 		_List.clear();

  00009	e8 00 00 00 00	 call	 ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  0000e	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1454 : 		erase(begin(), end());

  00011	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1011 : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

  00015	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  00019	48 89 44 24 40	 mov	 QWORD PTR _Tmp$1[rsp], rax

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  0001e	48 8d 44 24 40	 lea	 rax, QWORD PTR _Tmp$1[rsp]
  00023	48 8d 54 24 48	 lea	 rdx, QWORD PTR $T2[rsp]
  00028	41 b9 10 00 00
	00		 mov	 r9d, 16

; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;

  0002e	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00037	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1012 : 		_Mask = _Buckets - 1;

  0003c	48 c7 43 28 07
	00 00 00	 mov	 QWORD PTR [rbx+40], 7

; 1013 : 		_Maxidx = _Buckets;

  00044	48 c7 43 30 08
	00 00 00	 mov	 QWORD PTR [rbx+48], 8

; 723  : 		_Init();
; 724  : 		}

  0004c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
?clear@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?find@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Keyval$ = 64
?find@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find, COMDAT

; 727  : 		{	// find an element in mutable hash table that matches _Keyval

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 728  : 		return (lower_bound(_Keyval));

  00009	e8 00 00 00 00	 call	 ?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
  0000e	48 8b c3	 mov	 rax, rbx

; 729  : 		}

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	c3		 ret	 0
?find@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::shared_ptr<ChunkBase>::operator=, COMDAT

; 627  : 		{	// assign shared ownership of resource owned by _Right

$LN59:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 627  : 		{	// assign shared ownership of resource owned by _Right

  0000d	48 8b f9	 mov	 rdi, rcx

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00010	48 85 c0	 test	 rax, rax
  00013	74 04		 je	 SHORT $LN20@operator

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00015	f0 ff 40 08	 lock inc DWORD PTR [rax+8]
$LN20@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00019	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]

; 49   : 	_Right = _Move(_Tmp);

  0001d	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  00021	4c 89 07	 mov	 QWORD PTR [rdi], r8

; 48   : 	_Left = _Move(_Right);

  00024	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp+8], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00029	48 85 c9	 test	 rcx, rcx
  0002c	74 41		 je	 SHORT $LN56@operator

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0002e	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00032	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00037	75 28		 jne	 SHORT $LN55@operator
  00039	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003e	48 8b 5c 24 28	 mov	 rbx, QWORD PTR $T1[rsp+8]
  00043	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0004b	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00054	75 0b		 jne	 SHORT $LN55@operator

; 128  : 			_Delete_this();

  00056	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp+8]
  0005b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0005e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN55@operator:

; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);

  00061	48 8b c7	 mov	 rax, rdi
  00064	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 630  : 		}

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN56@operator:

; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);

  0006f	48 8b c7	 mov	 rax, rdi

; 630  : 		}

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::shared_ptr<ChunkBase>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ PROC ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >, COMDAT
$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 18	 mov	 rbx, QWORD PTR [rcx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN11@pair

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN14@pair

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN14@pair

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN14@pair:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN11@pair:
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ENDP ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 80
$T2 = 88
_Parg$dead$ = 88
_Tmp$3 = 96
_Al$dead$ = 96
??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >, COMDAT

; 317  : 		{	// construct empty hash table

$LN151:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00014	48 c7 44 24 30
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0001d	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00022	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 531  : 		this->_Myhead = 0;

  00025	33 ff		 xor	 edi, edi
  00027	48 89 39	 mov	 QWORD PTR [rcx], rdi

; 532  : 		this->_Mysize = 0;

  0002a	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  0002e	45 33 c0	 xor	 r8d, r8d
  00031	33 d2		 xor	 edx, edx
  00033	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0

; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);
; 548  : 		}
; 549  : 
; 550  : 	_Nodeptr _Myhead;	// pointer to head node
; 551  : 	size_type _Mysize;	// number of elements
; 552  : 	};
; 553  : 
; 554  : 		// TEMPLATE CLASS _List_alloc
; 555  : template<bool _Al_has_storage,
; 556  : 	class _Alloc_types>
; 557  : 	class _List_alloc
; 558  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 559  : 	{	// base class for list to hold allocator with storage
; 560  : public:
; 561  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 562  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 563  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 564  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 565  : 	typedef typename _Alloc_types::_Node _Node;
; 566  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 567  : 
; 568  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 569  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 570  : 		: _Alnod(_Al)
; 571  : 		{	// construct head node, allocator from _Al
; 572  : 		this->_Myhead = _Buyheadnode();
; 573  : 		}
; 574  : 
; 575  : 	~_List_alloc() _NOEXCEPT
; 576  : 		{	// destroy head node
; 577  : 		_Freeheadnode(this->_Myhead);
; 578  : 		}
; 579  : 
; 580  : 	void _Change_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Alnod = _Al;
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 588  : 		}
; 589  : 
; 590  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 591  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 592  : 		: _Alnod(_Al)
; 593  : 		{	// construct head node, allocator from _Al
; 594  : 		this->_Myhead = _Buyheadnode();
; 595  : 		_TRY_BEGIN
; 596  : 		_Alloc_proxy();
; 597  : 		_CATCH_ALL
; 598  : 		_Freeheadnode(this->_Myhead);
; 599  : 		_RERAISE;
; 600  : 		_CATCH_END
; 601  : 		}
; 602  : 
; 603  : 	~_List_alloc() _NOEXCEPT
; 604  : 		{	// destroy proxy
; 605  : 		_Freeheadnode(this->_Myhead);
; 606  : 		_Free_proxy();
; 607  : 		}
; 608  : 
; 609  : 	void _Change_alloc(const _Alty& _Al)
; 610  : 		{	// replace old allocator
; 611  : 		_Free_proxy();
; 612  : 		_Alnod = _Al;
; 613  : 		_Alloc_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Swap_alloc(_Myt& _Right)
; 617  : 		{	// swap allocators
; 618  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 619  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 620  : 		}
; 621  : 
; 622  : 	void _Alloc_proxy()
; 623  : 		{	// construct proxy from _Alnod
; 624  : 		typename _Alty::template rebind<_Container_proxy>::other
; 625  : 			_Alproxy(_Alnod);
; 626  : 		this->_Myproxy = _Alproxy.allocate(1);
; 627  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 628  : 		this->_Myproxy->_Mycont = this;
; 629  : 		}
; 630  : 
; 631  : 	void _Free_proxy()
; 632  : 		{	// destroy proxy
; 633  : 		typename _Alty::template rebind<_Container_proxy>::other
; 634  : 			_Alproxy(_Alnod);
; 635  : 		this->_Orphan_all();
; 636  : 		_Alproxy.destroy(this->_Myproxy);
; 637  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 638  : 		this->_Myproxy = 0;
; 639  : 		}
; 640  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 641  : 
; 642  : 	_Nodeptr _Buyheadnode()
; 643  : 		{	// get head node using current allocator
; 644  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 645  : 		}
; 646  : 
; 647  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 648  : 		{	// free head node using current allocator
; 649  : 		_Alnod.destroy(
; 650  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 651  : 		_Alnod.destroy(
; 652  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 653  : 		_Alnod.deallocate(_Pnode, 1);
; 654  : 		}
; 655  : 
; 656  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 657  : 		_Nodeptr _Prev)
; 658  : 		{	// allocate a node and set links
; 659  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 660  : 
; 661  : 		if (_Next == _Nodeptr())
; 662  : 			{	// point at self
; 663  : 			_Next = _Pnode;
; 664  : 			_Prev = _Pnode;
; 665  : 			}
; 666  : 		_TRY_BEGIN
; 667  : 		_Alnod.construct(
; 668  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 669  : 		_Alnod.construct(
; 670  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 671  : 		_CATCH_ALL
; 672  : 		_Alnod.deallocate(_Pnode, 1);
; 673  : 		_RERAISE;
; 674  : 		_CATCH_END
; 675  : 
; 676  : 		return (_Pnode);
; 677  : 		}
; 678  : 
; 679  : 	_Alty& _Getal()
; 680  : 		{	// get reference to allocator
; 681  : 		return (_Alnod);
; 682  : 		}
; 683  : 
; 684  : 	const _Alty& _Getal() const
; 685  : 		{	// get reference to allocator
; 686  : 		return (_Alnod);
; 687  : 		}
; 688  : 
; 689  : 	_Alty _Alnod;	// allocator object for stored elements
; 690  : 	};
; 691  : 
; 692  : 		// TEMPLATE CLASS _List_alloc
; 693  : template<class _Alloc_types>
; 694  : 	class _List_alloc<false, _Alloc_types>
; 695  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 696  : 	{	// base class for list to hold allocator with no storage
; 697  : public:
; 698  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 699  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 700  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 701  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 702  : 	typedef typename _Alloc_types::_Node _Node;
; 703  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 704  : 
; 705  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 706  : 	_List_alloc(const _Alloc& = _Alloc())
; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();

  00038	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  0003b	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 487  : 		_Mylast = pointer();

  0003f	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi

; 488  : 		_Myend = pointer();

  00043	48 89 7b 20	 mov	 QWORD PTR [rbx+32], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 317  : 		{	// construct empty hash table

  00047	c7 43 38 00 00
	80 3f		 mov	 DWORD PTR [rbx+56], 1065353216 ; 3f800000H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  0004e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  00051	48 89 44 24 60	 mov	 QWORD PTR _Tmp$3[rsp], rax

; 47   : 		{	// construct with pointer _Parg

  00056	8b cf		 mov	 ecx, edi

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00058	48 85 ff	 test	 rdi, rdi

; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())

  0005b	74 23		 je	 SHORT $LN123@Hash

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  0005d	48 85 c9	 test	 rcx, rcx

; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)

  00060	74 22		 je	 SHORT $LN57@Hash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2487 : 		_Dest, _Ptr_cat(_First, _Dest)));

  00062	8b d7		 mov	 edx, edi

; 2465 : 	for (; _First != _Last; ++_Dest, ++_First)

  00064	48 85 ff	 test	 rdi, rdi
  00067	74 17		 je	 SHORT $LN123@Hash
  00069	0f 1f 80 00 00
	00 00		 npad	 7
$LL125@Hash:

; 2466 : 		*_Dest = _STD move(*_First);

  00070	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00073	48 89 01	 mov	 QWORD PTR [rcx], rax

; 2465 : 	for (; _First != _Last; ++_Dest, ++_First)

  00076	48 83 c1 08	 add	 rcx, 8
  0007a	48 83 c2 08	 add	 rdx, 8
  0007e	75 f0		 jne	 SHORT $LL125@Hash
$LN123@Hash:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1406 : 				this->_Mylast = _Ptr;

  00080	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx
$LN57@Hash:

; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)
; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else
; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)
; 850  : 				_Reserve(1);
; 851  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 852  : 			this->_Getal().construct(this->_Mylast,
; 853  : 				_STD forward<value_type>(_Val));
; 854  : 			++this->_Mylast;
; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);
; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);
; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);
; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00084	48 8d 44 24 60	 lea	 rax, QWORD PTR _Tmp$3[rsp]
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	41 b9 10 00 00
	00		 mov	 r9d, 16
  00094	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  00098	48 8d 54 24 58	 lea	 rdx, QWORD PTR $T2[rsp]
  0009d	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  000a1	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1012 : 		_Mask = _Buckets - 1;

  000a6	48 c7 43 28 07
	00 00 00	 mov	 QWORD PTR [rbx+40], 7

; 1013 : 		_Maxidx = _Buckets;

  000ae	48 c7 43 30 08
	00 00 00	 mov	 QWORD PTR [rbx+48], 8

; 318  : 		_Init();
; 319  : 		}

  000b6	48 8b c3	 mov	 rax, rbx
  000b9	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000be	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c2	5f		 pop	 rdi
  000c3	c3		 ret	 0
??0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
$T2 = 88
_Parg$dead$ = 88
_Tmp$3 = 96
_Al$dead$ = 96
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >'::`1'::dtor$0
  00000	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
?dtor$0@?0???0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
this$ = 80
$T2 = 88
_Parg$dead$ = 88
_Tmp$3 = 96
_Al$dead$ = 96
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z@4HA PROC ; `std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >'::`1'::dtor$1
  0000c	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00013	48 83 c1 10	 add	 rcx, 16
  00017	e9 00 00 00 00	 jmp	 ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
?dtor$1@?0???0?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z@4HA ENDP ; `std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
this$ = 80
__$ReturnUdt$ = 88
_First$ = 96
_Last$ = 104
?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT

; 696  : 		{	// erase [_First, _Last)

$LN266:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 57		 push	 r15
  0000e	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00012	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 696  : 		{	// erase [_First, _Last)

  00015	49 8b f8	 mov	 rdi, r8
  00018	4c 8b fa	 mov	 r15, rdx
  0001b	48 8b f1	 mov	 rsi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0001e	4c 3b 00	 cmp	 r8, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 698  : 		if (_First == begin() && _Last == end())

  00021	75 1f		 jne	 SHORT $LN260@erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00023	4c 3b c8	 cmp	 r9, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 698  : 		if (_First == begin() && _Last == end())

  00026	75 1a		 jne	 SHORT $LN260@erase

; 699  : 			{	// erase all
; 700  : 			clear();

  00028	e8 00 00 00 00	 call	 ?clear@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAAXXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::clear
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  0002d	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 44   : 		{	// construct with node pointer _Pnode

  00030	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 707  : 			return (_Make_iter(_First));

  00033	49 8b c7	 mov	 rax, r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00036	49 89 0f	 mov	 QWORD PTR [r15], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 709  : 		}

  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	41 5f		 pop	 r15
  0003f	5f		 pop	 rdi
  00040	5e		 pop	 rsi
  00041	c3		 ret	 0
$LN260@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00042	4c 3b 44 24 68	 cmp	 r8, QWORD PTR _Last$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 705  : 			while (_First != _Last)

  00047	0f 84 f3 00 00
	00		 je	 $LN1@erase
  0004d	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00052	48 89 6c 24 28	 mov	 QWORD PTR [rsp+40], rbp
  00057	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0005c	0f 1f 40 00	 npad	 4
$LL2@erase:

; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00060	48 8b 6e 28	 mov	 rbp, QWORD PTR [rsi+40]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 246  : 		_Myiter _Tmp = *this;

  00064	48 8b df	 mov	 rbx, rdi

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00067	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  0006a	48 8d 53 10	 lea	 rdx, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0006e	48 89 7c 24 60	 mov	 QWORD PTR _First$[rsp], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00073	e8 00 00 00 00	 call	 ??R?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@std@@QEBA_KAEBVChunkPosition@@@Z ; std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >::operator()
  00078	48 8b d0	 mov	 rdx, rax
  0007b	48 23 d5	 and	 rdx, rbp

; 1004 : 		if (_Maxidx <= _Num)

  0007e	48 39 56 30	 cmp	 QWORD PTR [rsi+48], rdx
  00082	77 0d		 ja	 SHORT $LN69@erase

; 1005 : 			_Num -= (_Mask >> 1) + 1;

  00084	48 d1 ed	 shr	 rbp, 1
  00087	48 83 c9 ff	 or	 rcx, -1
  0008b	48 2b cd	 sub	 rcx, rbp
  0008e	48 03 d1	 add	 rdx, rcx
$LN69@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00091	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 958  : 		if (_Vec_hi(_Bucket) == _Plist)

  00095	48 c1 e2 04	 shl	 rdx, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00099	48 03 ca	 add	 rcx, rdx
  0009c	48 39 59 08	 cmp	 QWORD PTR [rcx+8], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 958  : 		if (_Vec_hi(_Bucket) == _Plist)

  000a0	75 23		 jne	 SHORT $LN88@erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  000a2	48 39 19	 cmp	 QWORD PTR [rcx], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 959  : 			if (_Vec_lo(_Bucket) == _Plist)

  000a5	75 14		 jne	 SHORT $LN87@erase

; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();

  000a7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000aa	48 89 01	 mov	 QWORD PTR [rcx], rax

; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();

  000ad	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  000b1	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000b4	48 89 44 0a 08	 mov	 QWORD PTR [rdx+rcx+8], rax

; 963  : 				}
; 964  : 			else

  000b9	eb 15		 jmp	 SHORT $LN264@erase
$LN87@erase:

; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

  000bb	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000bf	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)

  000c3	eb 0b		 jmp	 SHORT $LN264@erase
$LN88@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  000c5	48 39 19	 cmp	 QWORD PTR [rcx], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)

  000c8	75 0b		 jne	 SHORT $LN84@erase

; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

  000ca	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000cd	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN264@erase:
  000d0	48 8b 7c 24 60	 mov	 rdi, QWORD PTR _First$[rsp]
$LN84@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1427 : 		if (_Pnode != this->_Myhead)

  000d5	48 3b 1e	 cmp	 rbx, QWORD PTR [rsi]
  000d8	74 4c		 je	 SHORT $LN167@erase

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  000da	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]

; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);

  000de	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000e1	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);

  000e4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000e7	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000eb	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000ef	48 8b 7b 28	 mov	 rdi, QWORD PTR [rbx+40]
  000f3	48 85 ff	 test	 rdi, rdi
  000f6	74 1d		 je	 SHORT $LN229@erase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000f8	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  000fc	75 17		 jne	 SHORT $LN229@erase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000fe	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00101	48 8b cf	 mov	 rcx, rdi
  00104	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00106	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0010a	75 09		 jne	 SHORT $LN229@erase

; 128  : 			_Delete_this();

  0010c	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0010f	48 8b cf	 mov	 rcx, rdi
  00112	ff 50 08	 call	 QWORD PTR [rax+8]
$LN229@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00115	48 8b cb	 mov	 rcx, rbx
  00118	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1434 : 			--this->_Mysize;

  0011d	48 ff 4e 08	 dec	 QWORD PTR [rsi+8]
  00121	48 8b 7c 24 60	 mov	 rdi, QWORD PTR _First$[rsp]
$LN167@erase:

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00126	48 3b 7c 24 68	 cmp	 rdi, QWORD PTR _Last$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 705  : 			while (_First != _Last)

  0012b	0f 85 2f ff ff
	ff		 jne	 $LL2@erase
  00131	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
  00136	48 8b 6c 24 28	 mov	 rbp, QWORD PTR [rsp+40]
  0013b	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN1@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00140	49 89 3f	 mov	 QWORD PTR [r15], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 707  : 			return (_Make_iter(_First));

  00143	49 8b c7	 mov	 rax, r15

; 709  : 		}

  00146	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0014a	41 5f		 pop	 r15
  0014c	5f		 pop	 rdi
  0014d	5e		 pop	 rsi
  0014e	c3		 ret	 0
?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
$T1 = 48
$T2 = 48
this$ = 48
__$ReturnUdt$ = 56
_Keyval$ = 64
?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound, COMDAT

; 745  : 		{	// find leftmost not less than _Keyval in mutable hash table

$LN142:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 942  : 			}
; 943  : 		}
; 944  : 	_Unchecked_const_iterator _End(size_type _Bucket) const
; 945  : 		{	// return end iterator for bucket _Bucket
; 946  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 947  : 			return (_Unchecked_end());
; 948  : 		else
; 949  : 			{	// point past last element
; 950  : 			_Unchecked_const_iterator _Ans = _Vec_hi(_Bucket);
; 951  : 			return (++_Ans);
; 952  : 			}
; 953  : 		}
; 954  : 
; 955  : 	void _Erase_bucket(iterator _Plist_arg, size_type _Bucket)
; 956  : 		{	// fix iterators before erasing _Plist before _Where
; 957  : 		_Unchecked_iterator _Plist = _Plist_arg._Unchecked();
; 958  : 		if (_Vec_hi(_Bucket) == _Plist)
; 959  : 			if (_Vec_lo(_Bucket) == _Plist)
; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();
; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();
; 963  : 				}
; 964  : 			else
; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element
; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)
; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element
; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00015	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]

; 745  : 		{	// find leftmost not less than _Keyval in mutable hash table

  00019	48 8b f2	 mov	 rsi, rdx

; 942  : 			}
; 943  : 		}
; 944  : 	_Unchecked_const_iterator _End(size_type _Bucket) const
; 945  : 		{	// return end iterator for bucket _Bucket
; 946  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 947  : 			return (_Unchecked_end());
; 948  : 		else
; 949  : 			{	// point past last element
; 950  : 			_Unchecked_const_iterator _Ans = _Vec_hi(_Bucket);
; 951  : 			return (++_Ans);
; 952  : 			}
; 953  : 		}
; 954  : 
; 955  : 	void _Erase_bucket(iterator _Plist_arg, size_type _Bucket)
; 956  : 		{	// fix iterators before erasing _Plist before _Where
; 957  : 		_Unchecked_iterator _Plist = _Plist_arg._Unchecked();
; 958  : 		if (_Vec_hi(_Bucket) == _Plist)
; 959  : 			if (_Vec_lo(_Bucket) == _Plist)
; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();
; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();
; 963  : 				}
; 964  : 			else
; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element
; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)
; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element
; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  0001c	49 8b d0	 mov	 rdx, r8

; 745  : 		{	// find leftmost not less than _Keyval in mutable hash table

  0001f	49 8b d8	 mov	 rbx, r8
  00022	4c 8b f1	 mov	 r14, rcx

; 942  : 			}
; 943  : 		}
; 944  : 	_Unchecked_const_iterator _End(size_type _Bucket) const
; 945  : 		{	// return end iterator for bucket _Bucket
; 946  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 947  : 			return (_Unchecked_end());
; 948  : 		else
; 949  : 			{	// point past last element
; 950  : 			_Unchecked_const_iterator _Ans = _Vec_hi(_Bucket);
; 951  : 			return (++_Ans);
; 952  : 			}
; 953  : 		}
; 954  : 
; 955  : 	void _Erase_bucket(iterator _Plist_arg, size_type _Bucket)
; 956  : 		{	// fix iterators before erasing _Plist before _Where
; 957  : 		_Unchecked_iterator _Plist = _Plist_arg._Unchecked();
; 958  : 		if (_Vec_hi(_Bucket) == _Plist)
; 959  : 			if (_Vec_lo(_Bucket) == _Plist)
; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();
; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();
; 963  : 				}
; 964  : 			else
; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element
; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)
; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element
; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00025	e8 00 00 00 00	 call	 ??R?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@std@@QEBA_KAEBVChunkPosition@@@Z ; std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >::operator()
  0002a	4c 8b c8	 mov	 r9, rax
  0002d	4c 23 cf	 and	 r9, rdi

; 1004 : 		if (_Maxidx <= _Num)

  00030	4d 39 4e 30	 cmp	 QWORD PTR [r14+48], r9
  00034	77 0d		 ja	 SHORT $LN9@lower_boun

; 1005 : 			_Num -= (_Mask >> 1) + 1;

  00036	48 d1 ef	 shr	 rdi, 1
  00039	49 83 c8 ff	 or	 r8, -1
  0003d	4c 2b c7	 sub	 r8, rdi
  00040	4d 03 c8	 add	 r9, r8
$LN9@lower_boun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00043	4d 8b 56 10	 mov	 r10, QWORD PTR [r14+16]
  00047	4d 8b 06	 mov	 r8, QWORD PTR [r14]
  0004a	49 c1 e1 04	 shl	 r9, 4
  0004e	4d 03 d1	 add	 r10, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 926  : 		return (_Vec_lo(_Bucket));

  00051	4d 8b 0a	 mov	 r9, QWORD PTR [r10]
  00054	49 8b c1	 mov	 rax, r9
$LL20@lower_boun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00057	4d 3b c8	 cmp	 r9, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 936  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

  0005a	75 05		 jne	 SHORT $LN25@lower_boun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  0005c	49 8b c8	 mov	 rcx, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 937  : 			return (_Unchecked_end());

  0005f	eb 07		 jmp	 SHORT $LN24@lower_boun
$LN25@lower_boun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00061	49 8b 4a 08	 mov	 rcx, QWORD PTR [r10+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 941  : 			return (++_Ans);

  00065	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN24@lower_boun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00068	48 3b c1	 cmp	 rax, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 748  : 			_Where != _End(_Bucket); ++_Where)

  0006b	74 5c		 je	 SHORT $LN2@lower_boun
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  0006d	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]
  00070	39 48 18	 cmp	 DWORD PTR [rax+24], ecx
  00073	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  00076	0f 94 c2	 sete	 dl
  00079	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  0007c	0f 94 c1	 sete	 cl
  0007f	22 d1		 and	 dl, cl
  00081	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00083	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00086	0f 94 c1	 sete	 cl
  00089	84 d1		 test	 dl, cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 749  : 			if (!((_Traits&)*this)(this->_Kfn(*_Where), _Keyval))

  0008b	75 05		 jne	 SHORT $LN137@lower_boun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  0008d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00090	eb c5		 jmp	 SHORT $LL20@lower_boun
$LN137@lower_boun:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  00092	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00095	4c 89 44 24 30	 mov	 QWORD PTR $T2[rsp], r8
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  0009a	39 4b 08	 cmp	 DWORD PTR [rbx+8], ecx
  0009d	8b 48 14	 mov	 ecx, DWORD PTR [rax+20]
  000a0	0f 94 c2	 sete	 dl
  000a3	39 4b 04	 cmp	 DWORD PTR [rbx+4], ecx
  000a6	0f 94 c1	 sete	 cl
  000a9	22 d1		 and	 dl, cl
  000ab	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  000ae	39 0b		 cmp	 DWORD PTR [rbx], ecx
  000b0	0f 94 c1	 sete	 cl
  000b3	84 d1		 test	 dl, cl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 751  : 					this->_Kfn(*_Where)) ? end() : _Make_iter(_Where));

  000b5	74 05		 je	 SHORT $LN139@lower_boun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  000b7	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
$LN139@lower_boun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 751  : 					this->_Kfn(*_Where)) ? end() : _Make_iter(_Where));

  000bc	48 8d 44 24 30	 lea	 rax, QWORD PTR $T1[rsp]
  000c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c4	48 89 06	 mov	 QWORD PTR [rsi], rax
  000c7	eb 03		 jmp	 SHORT $LN140@lower_boun
$LN2@lower_boun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  000c9	4c 89 06	 mov	 QWORD PTR [rsi], r8
$LN140@lower_boun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 753  : 		}

  000cc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d1	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000d6	48 8b c6	 mov	 rax, rsi
  000d9	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000de	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e2	41 5e		 pop	 r14
  000e4	c3		 ret	 0
?lower_bound@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBVChunkPosition@@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Keyval$ = 64
?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range, COMDAT

; 789  : 		{	// find range equivalent to _Keyval in mutable hash table

$LN235:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 942  : 			}
; 943  : 		}
; 944  : 	_Unchecked_const_iterator _End(size_type _Bucket) const
; 945  : 		{	// return end iterator for bucket _Bucket
; 946  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 947  : 			return (_Unchecked_end());
; 948  : 		else
; 949  : 			{	// point past last element
; 950  : 			_Unchecked_const_iterator _Ans = _Vec_hi(_Bucket);
; 951  : 			return (++_Ans);
; 952  : 			}
; 953  : 		}
; 954  : 
; 955  : 	void _Erase_bucket(iterator _Plist_arg, size_type _Bucket)
; 956  : 		{	// fix iterators before erasing _Plist before _Where
; 957  : 		_Unchecked_iterator _Plist = _Plist_arg._Unchecked();
; 958  : 		if (_Vec_hi(_Bucket) == _Plist)
; 959  : 			if (_Vec_lo(_Bucket) == _Plist)
; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();
; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();
; 963  : 				}
; 964  : 			else
; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element
; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)
; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element
; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00015	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]

; 789  : 		{	// find range equivalent to _Keyval in mutable hash table

  00019	4c 8b f2	 mov	 r14, rdx

; 942  : 			}
; 943  : 		}
; 944  : 	_Unchecked_const_iterator _End(size_type _Bucket) const
; 945  : 		{	// return end iterator for bucket _Bucket
; 946  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 947  : 			return (_Unchecked_end());
; 948  : 		else
; 949  : 			{	// point past last element
; 950  : 			_Unchecked_const_iterator _Ans = _Vec_hi(_Bucket);
; 951  : 			return (++_Ans);
; 952  : 			}
; 953  : 		}
; 954  : 
; 955  : 	void _Erase_bucket(iterator _Plist_arg, size_type _Bucket)
; 956  : 		{	// fix iterators before erasing _Plist before _Where
; 957  : 		_Unchecked_iterator _Plist = _Plist_arg._Unchecked();
; 958  : 		if (_Vec_hi(_Bucket) == _Plist)
; 959  : 			if (_Vec_lo(_Bucket) == _Plist)
; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();
; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();
; 963  : 				}
; 964  : 			else
; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element
; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)
; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element
; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  0001c	49 8b d0	 mov	 rdx, r8

; 789  : 		{	// find range equivalent to _Keyval in mutable hash table

  0001f	49 8b d8	 mov	 rbx, r8
  00022	48 8b f1	 mov	 rsi, rcx

; 942  : 			}
; 943  : 		}
; 944  : 	_Unchecked_const_iterator _End(size_type _Bucket) const
; 945  : 		{	// return end iterator for bucket _Bucket
; 946  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 947  : 			return (_Unchecked_end());
; 948  : 		else
; 949  : 			{	// point past last element
; 950  : 			_Unchecked_const_iterator _Ans = _Vec_hi(_Bucket);
; 951  : 			return (++_Ans);
; 952  : 			}
; 953  : 		}
; 954  : 
; 955  : 	void _Erase_bucket(iterator _Plist_arg, size_type _Bucket)
; 956  : 		{	// fix iterators before erasing _Plist before _Where
; 957  : 		_Unchecked_iterator _Plist = _Plist_arg._Unchecked();
; 958  : 		if (_Vec_hi(_Bucket) == _Plist)
; 959  : 			if (_Vec_lo(_Bucket) == _Plist)
; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();
; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();
; 963  : 				}
; 964  : 			else
; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element
; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)
; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element
; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00025	e8 00 00 00 00	 call	 ??R?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@std@@QEBA_KAEBVChunkPosition@@@Z ; std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >::operator()
  0002a	4c 8b c8	 mov	 r9, rax
  0002d	4c 23 cf	 and	 r9, rdi

; 1004 : 		if (_Maxidx <= _Num)

  00030	4c 39 4e 30	 cmp	 QWORD PTR [rsi+48], r9
  00034	77 0d		 ja	 SHORT $LN12@equal_rang

; 1005 : 			_Num -= (_Mask >> 1) + 1;

  00036	48 d1 ef	 shr	 rdi, 1
  00039	49 83 c8 ff	 or	 r8, -1
  0003d	4c 2b c7	 sub	 r8, rdi
  00040	4d 03 c8	 add	 r9, r8
$LN12@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00043	4c 8b 5e 10	 mov	 r11, QWORD PTR [rsi+16]
  00047	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0004a	49 c1 e1 04	 shl	 r9, 4
  0004e	4d 03 d9	 add	 r11, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 926  : 		return (_Vec_lo(_Bucket));

  00051	4d 8b 13	 mov	 r10, QWORD PTR [r11]
  00054	49 8b c2	 mov	 rax, r10
$LL23@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00057	4c 3b d1	 cmp	 r10, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 936  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

  0005a	75 05		 jne	 SHORT $LN28@equal_rang
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  0005c	48 8b d1	 mov	 rdx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 937  : 			return (_Unchecked_end());

  0005f	eb 07		 jmp	 SHORT $LN27@equal_rang
$LN28@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00061	49 8b 53 08	 mov	 rdx, QWORD PTR [r11+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 941  : 			return (++_Ans);

  00065	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN27@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00068	48 3b c2	 cmp	 rax, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 792  : 			_Where != _End(_Bucket); ++_Where)

  0006b	74 77		 je	 SHORT $LN7@equal_rang
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  0006d	8b 53 08	 mov	 edx, DWORD PTR [rbx+8]
  00070	39 50 18	 cmp	 DWORD PTR [rax+24], edx
  00073	8b 53 04	 mov	 edx, DWORD PTR [rbx+4]
  00076	41 0f 94 c0	 sete	 r8b
  0007a	39 50 14	 cmp	 DWORD PTR [rax+20], edx
  0007d	0f 94 c2	 sete	 dl
  00080	44 22 c2	 and	 r8b, dl
  00083	8b 13		 mov	 edx, DWORD PTR [rbx]
  00085	39 50 10	 cmp	 DWORD PTR [rax+16], edx
  00088	0f 94 c2	 sete	 dl
  0008b	44 84 c2	 test	 r8b, dl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 793  : 			if (!((_Traits&)*this)(this->_Kfn(*_Where), _Keyval))

  0008e	75 05		 jne	 SHORT $LN229@equal_rang
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  00090	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00093	eb c2		 jmp	 SHORT $LL23@equal_rang
$LN229@equal_rang:
  00095	8b 7b 08	 mov	 edi, DWORD PTR [rbx+8]
  00098	8b 73 04	 mov	 esi, DWORD PTR [rbx+4]
  0009b	8b 1b		 mov	 ebx, DWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 795  : 				_Unchecked_iterator _First = _Where;

  0009d	4c 8b c0	 mov	 r8, rax
$LL89@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  000a0	4c 3b d1	 cmp	 r10, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 936  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

  000a3	75 05		 jne	 SHORT $LN94@equal_rang
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  000a5	48 8b d1	 mov	 rdx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 937  : 			return (_Unchecked_end());

  000a8	eb 07		 jmp	 SHORT $LN93@equal_rang
$LN94@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  000aa	49 8b 53 08	 mov	 rdx, QWORD PTR [r11+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 941  : 			return (++_Ans);

  000ae	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN93@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  000b1	48 3b c2	 cmp	 rax, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 796  : 				for (; _Where != _End(_Bucket); ++_Where)

  000b4	74 20		 je	 SHORT $LN230@equal_rang
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  000b6	3b 70 14	 cmp	 esi, DWORD PTR [rax+20]
  000b9	41 0f 94 c1	 sete	 r9b
  000bd	3b 78 18	 cmp	 edi, DWORD PTR [rax+24]
  000c0	0f 94 c2	 sete	 dl
  000c3	44 22 ca	 and	 r9b, dl
  000c6	3b 58 10	 cmp	 ebx, DWORD PTR [rax+16]
  000c9	0f 94 c2	 sete	 dl
  000cc	44 84 ca	 test	 r9b, dl
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 797  : 					if (((_Traits&)*this)(_Keyval, this->_Kfn(*_Where)))

  000cf	74 05		 je	 SHORT $LN230@equal_rang
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  000d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d4	eb ca		 jmp	 SHORT $LL89@equal_rang
$LN230@equal_rang:

; 86   : 		return (_Ptr == _Right._Ptr);

  000d6	4c 3b c0	 cmp	 r8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 799  : 				if (_First == _Where)

  000d9	74 09		 je	 SHORT $LN7@equal_rang
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000db	4d 89 06	 mov	 QWORD PTR [r14], r8
  000de	49 89 46 08	 mov	 QWORD PTR [r14+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 801  : 				return (_Pairii(_Make_iter(_First),

  000e2	eb 07		 jmp	 SHORT $LN233@equal_rang
$LN7@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000e4	49 89 0e	 mov	 QWORD PTR [r14], rcx
  000e7	49 89 4e 08	 mov	 QWORD PTR [r14+8], rcx
$LN233@equal_rang:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 805  : 		}

  000eb	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f0	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000f5	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000fa	49 8b c6	 mov	 rax, r14
  000fd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00101	41 5e		 pop	 r14
  00103	c3		 ret	 0
?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Init@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
_Tmp$1 = 64
this$ = 64
$T2 = 72
_Buckets$ = 72
?_Init@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Init, COMDAT

; 1010 : 		{	// initialize hash table with _Buckets buckets, leave list alone

$LN128:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1454 : 		erase(begin(), end());

  0000a	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1010 : 		{	// initialize hash table with _Buckets buckets, leave list alone

  0000e	48 8b d9	 mov	 rbx, rcx

; 1011 : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

  00011	48 83 c1 10	 add	 rcx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  00015	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1010 : 		{	// initialize hash table with _Buckets buckets, leave list alone

  00018	48 8b fa	 mov	 rdi, rdx

; 1011 : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

  0001b	4c 8d 0c 12	 lea	 r9, QWORD PTR [rdx+rdx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  0001f	48 89 44 24 40	 mov	 QWORD PTR _Tmp$1[rsp], rax

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00024	48 8d 44 24 40	 lea	 rax, QWORD PTR _Tmp$1[rsp]
  00029	48 8d 54 24 48	 lea	 rdx, QWORD PTR $T2[rsp]
  0002e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax

; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;

  00033	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00037	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1012 : 		_Mask = _Buckets - 1;

  0003c	48 8d 47 ff	 lea	 rax, QWORD PTR [rdi-1]

; 1013 : 		_Maxidx = _Buckets;

  00040	48 89 7b 30	 mov	 QWORD PTR [rbx+48], rdi
  00044	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 1014 : 		}

  00048	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
?_Init@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAX_K@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 1091 : 		{	// destroy the object

$LN30:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();
; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();
; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();
; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());
; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());
; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1916 : 		}
; 1917 : 
; 1918 : 	void _Assign_n(size_type _Count, const _Ty& _Val)
; 1919 : 		{	// assign _Count * _Val
; 1920 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1921 : 		clear();
; 1922 : 		_Insert_n(_Unchecked_begin(), _Count, _Tmp);
; 1923 : 		}
; 1924 : 
; 1925 : 	void _Tidy()
; 1926 : 		{	// free all storage
; 1927 : 		clear();

  00009	e8 00 00 00 00	 call	 ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0000e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1093 : 		}

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00016	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear, COMDAT

; 1470 : 		{	// erase all

$LN66:
  00000	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  00005	41 56		 push	 r14
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  0000b	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1470 : 		{	// erase all

  0000e	4c 8b f1	 mov	 r14, rcx

; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);

  00011	48 8b 38	 mov	 rdi, QWORD PTR [rax]

; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;

  00014	48 89 00	 mov	 QWORD PTR [rax], rax

; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);

  00017	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;

  0001a	48 89 40 08	 mov	 QWORD PTR [rax+8], rax

; 1478 : 		this->_Mysize = 0;

  0001e	48 c7 41 08 00
	00 00 00	 mov	 QWORD PTR [rcx+8], 0

; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00026	48 3b 39	 cmp	 rdi, QWORD PTR [rcx]
  00029	74 58		 je	 SHORT $LN1@clear
  0002b	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00030	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00035	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@clear:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00040	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1482 : 			_Pnext = this->_Nextnode(_Pnode);

  00044	48 8b 37	 mov	 rsi, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00047	48 85 db	 test	 rbx, rbx
  0004a	74 1d		 je	 SHORT $LN53@clear

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0004c	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00050	75 17		 jne	 SHORT $LN53@clear

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00052	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00055	48 8b cb	 mov	 rcx, rbx
  00058	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0005a	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0005e	75 09		 jne	 SHORT $LN53@clear

; 128  : 			_Delete_this();

  00060	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00063	48 8b cb	 mov	 rcx, rbx
  00066	ff 50 08	 call	 QWORD PTR [rax+8]
$LN53@clear:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00069	48 8b cf	 mov	 rcx, rdi
  0006c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)

  00071	48 8b fe	 mov	 rdi, rsi
  00074	49 3b 36	 cmp	 rsi, QWORD PTR [r14]
  00077	75 c7		 jne	 SHORT $LL3@clear
  00079	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0007e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN1@clear:

; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}

  00083	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	41 5e		 pop	 r14
  0008e	c3		 ret	 0
?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >, COMDAT

; 899  : 		{	// destroy the object

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);
; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);
; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);
; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)
; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)
; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));
; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 12		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00011	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00016	33 c0		 xor	 eax, eax
  00018	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1543 : 			this->_Mylast = pointer();

  0001b	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1544 : 			this->_Myend = pointer();

  0001f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN3@vector:

; 900  : 		_Tidy();
; 901  : 		}

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??1?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::~vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$shared_ptr@VChunkBase@@@std@@QEAA@XZ PROC		; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT

; 282  : 		{	// construct

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ENDP		; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?swap@?$shared_ptr@VChunkBase@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
?swap@?$shared_ptr@VChunkBase@@@std@@QEAAXAEAV12@@Z PROC ; std::shared_ptr<ChunkBase>::swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 677  : 		}

  0001c	c3		 ret	 0
?swap@?$shared_ptr@VChunkBase@@@std@@QEAAXAEAV12@@Z ENDP ; std::shared_ptr<ChunkBase>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??1?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ PROC ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@XZ ENDP ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::~_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Unchecked_end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Unchecked_end, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 459  : 		return (_List._Unchecked_end());

  00006	48 8b c2	 mov	 rax, rdx

; 460  : 		}

  00009	c3		 ret	 0
?_Unchecked_end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Make_iter@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Make_iter, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00000	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 469  : 		return (_List._Make_iter(_Where));

  00003	48 8b c2	 mov	 rax, rdx

; 470  : 		}

  00006	c3		 ret	 0
?_Make_iter@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Make_iter@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Make_iter, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00000	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 474  : 		return (_List._Make_iter(_Where));

  00003	48 8b c2	 mov	 rax, rdx

; 475  : 		}

  00006	c3		 ret	 0
?_Make_iter@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Plist$ = 64
?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase, COMDAT

; 688  : 		{	// erase element at _Plist

$LN109:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00014	57		 push	 rdi
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00019	48 8b 71 28	 mov	 rsi, QWORD PTR [rcx+40]

; 688  : 		{	// erase element at _Plist

  0001d	48 8b ea	 mov	 rbp, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map

; 60   : 		return (_Val.first);

  00020	49 8d 50 10	 lea	 rdx, QWORD PTR [r8+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 688  : 		{	// erase element at _Plist

  00024	49 8b d8	 mov	 rbx, r8
  00027	48 8b f9	 mov	 rdi, rcx

; 968  : 		}
; 969  : 
; 970  : 	void _Insert_bucket(_Unchecked_iterator _Plist,
; 971  : 		_Unchecked_iterator _Where, size_type _Bucket)
; 972  : 		{	// fix iterators after inserting _Plist before _Where
; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())
; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;
; 976  : 			_Vec_hi(_Bucket) = _Plist;
; 977  : 			}
; 978  : 		else if (_Vec_lo(_Bucket) == _Where)
; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element
; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element
; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  0002a	e8 00 00 00 00	 call	 ??R?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@std@@QEBA_KAEBVChunkPosition@@@Z ; std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >::operator()
  0002f	4c 8b c8	 mov	 r9, rax
  00032	4c 23 ce	 and	 r9, rsi

; 1004 : 		if (_Maxidx <= _Num)

  00035	4c 39 4f 30	 cmp	 QWORD PTR [rdi+48], r9
  00039	77 0d		 ja	 SHORT $LN9@erase

; 1005 : 			_Num -= (_Mask >> 1) + 1;

  0003b	48 d1 ee	 shr	 rsi, 1
  0003e	49 83 c8 ff	 or	 r8, -1
  00042	4c 2b c6	 sub	 r8, rsi
  00045	4d 03 c8	 add	 r9, r8
$LN9@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00048	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 958  : 		if (_Vec_hi(_Bucket) == _Plist)

  0004c	49 c1 e1 04	 shl	 r9, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00050	49 03 c9	 add	 rcx, r9
  00053	48 39 59 08	 cmp	 QWORD PTR [rcx+8], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 958  : 		if (_Vec_hi(_Bucket) == _Plist)

  00057	75 23		 jne	 SHORT $LN28@erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00059	48 39 19	 cmp	 QWORD PTR [rcx], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 959  : 			if (_Vec_lo(_Bucket) == _Plist)

  0005c	75 14		 jne	 SHORT $LN27@erase

; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();

  0005e	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00061	48 89 01	 mov	 QWORD PTR [rcx], rax

; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();

  00064	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00068	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0006b	49 89 44 09 08	 mov	 QWORD PTR [r9+rcx+8], rax

; 963  : 				}
; 964  : 			else

  00070	eb 15		 jmp	 SHORT $LN107@erase
$LN27@erase:

; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

  00072	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00076	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)

  0007a	eb 0b		 jmp	 SHORT $LN107@erase
$LN28@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0007c	48 39 19	 cmp	 QWORD PTR [rcx], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)

  0007f	75 0b		 jne	 SHORT $LN24@erase

; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

  00081	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00084	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN107@erase:
  00087	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Plist$[rsp]
$LN24@erase:

; 689  : 		size_type _Bucket = _Hashval(this->_Kfn(*_Plist));
; 690  : 
; 691  : 		_Erase_bucket(_Make_iter(_Plist), _Bucket);
; 692  : 		return (_List.erase(_Plist));

  0008c	4c 8b c3	 mov	 r8, rbx
  0008f	48 8b d5	 mov	 rdx, rbp
  00092	48 8b cf	 mov	 rcx, rdi
  00095	e8 00 00 00 00	 call	 ?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::erase

; 693  : 		}

  0009a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000a4	48 8b c5	 mov	 rax, rbp
  000a7	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b0	5f		 pop	 rdi
  000b1	c3		 ret	 0
?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Bucket$ = 24
?_Begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Begin, COMDAT

; 926  : 		return (_Vec_lo(_Bucket));

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00004	4d 03 c0	 add	 r8, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 926  : 		return (_Vec_lo(_Bucket));

  00007	4a 8b 0c c0	 mov	 rcx, QWORD PTR [rax+r8*8]
  0000b	48 8b c2	 mov	 rax, rdx
  0000e	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 927  : 		}

  00011	c3		 ret	 0
?_Begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_End@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Bucket$ = 24
?_End@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_End, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00000	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00004	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00007	4d 03 c0	 add	 r8, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0000a	4b 39 04 c1	 cmp	 QWORD PTR [r9+r8*8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 936  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

  0000e	75 07		 jne	 SHORT $LN2@End
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00010	48 89 02	 mov	 QWORD PTR [rdx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 941  : 			return (++_Ans);

  00013	48 8b c2	 mov	 rax, rdx

; 942  : 			}
; 943  : 		}

  00016	c3		 ret	 0
$LN2@End:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00017	4b 8b 44 c1 08	 mov	 rax, QWORD PTR [r9+r8*8+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 941  : 			return (++_Ans);

  0001c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0001f	48 8b c2	 mov	 rax, rdx
  00022	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 942  : 			}
; 943  : 		}

  00025	c3		 ret	 0
?_End@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_End
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Hashval@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBA_KAEBVChunkPosition@@@Z
_TEXT	SEGMENT
this$ = 48
_Keyval$ = 56
?_Hashval@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBA_KAEBVChunkPosition@@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hashval, COMDAT

; 1002 : 		{	// return hash value, masked and wrapped to current table size

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  0000a	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	e8 00 00 00 00	 call	 ??R?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@std@@QEBA_KAEBVChunkPosition@@@Z ; std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >::operator()
  00016	48 23 c7	 and	 rax, rdi

; 1004 : 		if (_Maxidx <= _Num)

  00019	48 39 43 30	 cmp	 QWORD PTR [rbx+48], rax
  0001d	77 0d		 ja	 SHORT $LN4@Hashval

; 1005 : 			_Num -= (_Mask >> 1) + 1;

  0001f	48 d1 ef	 shr	 rdi, 1
  00022	48 83 c9 ff	 or	 rcx, -1
  00026	48 2b cf	 sub	 rcx, rdi
  00029	48 03 c1	 add	 rax, rcx
$LN4@Hashval:

; 1006 : 		return (_Num);
; 1007 : 		}

  0002c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
?_Hashval@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEBA_KAEBVChunkPosition@@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Hashval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
;	COMDAT ??0?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Traits$dead$ = 16
??0?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@@Z PROC ; std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>, COMDAT

; 36   : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@QEAA@AEBV?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@1@@Z ENDP ; std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??0?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 904  : 		{	// construct empty list, allocator

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 531  : 		this->_Myhead = 0;

  00006	33 c0		 xor	 eax, eax

; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00008	45 33 c0	 xor	 r8d, r8d
  0000b	33 d2		 xor	 edx, edx

; 531  : 		this->_Myhead = 0;

  0000d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 532  : 		this->_Mysize = 0;

  00010	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 904  : 		{	// construct empty list, allocator

  00014	48 8b d9	 mov	 rbx, rcx

; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00017	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0

; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);
; 548  : 		}
; 549  : 
; 550  : 	_Nodeptr _Myhead;	// pointer to head node
; 551  : 	size_type _Mysize;	// number of elements
; 552  : 	};
; 553  : 
; 554  : 		// TEMPLATE CLASS _List_alloc
; 555  : template<bool _Al_has_storage,
; 556  : 	class _Alloc_types>
; 557  : 	class _List_alloc
; 558  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 559  : 	{	// base class for list to hold allocator with storage
; 560  : public:
; 561  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 562  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 563  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 564  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 565  : 	typedef typename _Alloc_types::_Node _Node;
; 566  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 567  : 
; 568  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 569  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 570  : 		: _Alnod(_Al)
; 571  : 		{	// construct head node, allocator from _Al
; 572  : 		this->_Myhead = _Buyheadnode();
; 573  : 		}
; 574  : 
; 575  : 	~_List_alloc() _NOEXCEPT
; 576  : 		{	// destroy head node
; 577  : 		_Freeheadnode(this->_Myhead);
; 578  : 		}
; 579  : 
; 580  : 	void _Change_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Alnod = _Al;
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 588  : 		}
; 589  : 
; 590  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 591  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 592  : 		: _Alnod(_Al)
; 593  : 		{	// construct head node, allocator from _Al
; 594  : 		this->_Myhead = _Buyheadnode();
; 595  : 		_TRY_BEGIN
; 596  : 		_Alloc_proxy();
; 597  : 		_CATCH_ALL
; 598  : 		_Freeheadnode(this->_Myhead);
; 599  : 		_RERAISE;
; 600  : 		_CATCH_END
; 601  : 		}
; 602  : 
; 603  : 	~_List_alloc() _NOEXCEPT
; 604  : 		{	// destroy proxy
; 605  : 		_Freeheadnode(this->_Myhead);
; 606  : 		_Free_proxy();
; 607  : 		}
; 608  : 
; 609  : 	void _Change_alloc(const _Alty& _Al)
; 610  : 		{	// replace old allocator
; 611  : 		_Free_proxy();
; 612  : 		_Alnod = _Al;
; 613  : 		_Alloc_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Swap_alloc(_Myt& _Right)
; 617  : 		{	// swap allocators
; 618  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 619  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 620  : 		}
; 621  : 
; 622  : 	void _Alloc_proxy()
; 623  : 		{	// construct proxy from _Alnod
; 624  : 		typename _Alty::template rebind<_Container_proxy>::other
; 625  : 			_Alproxy(_Alnod);
; 626  : 		this->_Myproxy = _Alproxy.allocate(1);
; 627  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 628  : 		this->_Myproxy->_Mycont = this;
; 629  : 		}
; 630  : 
; 631  : 	void _Free_proxy()
; 632  : 		{	// destroy proxy
; 633  : 		typename _Alty::template rebind<_Container_proxy>::other
; 634  : 			_Alproxy(_Alnod);
; 635  : 		this->_Orphan_all();
; 636  : 		_Alproxy.destroy(this->_Myproxy);
; 637  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 638  : 		this->_Myproxy = 0;
; 639  : 		}
; 640  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 641  : 
; 642  : 	_Nodeptr _Buyheadnode()
; 643  : 		{	// get head node using current allocator
; 644  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 645  : 		}
; 646  : 
; 647  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 648  : 		{	// free head node using current allocator
; 649  : 		_Alnod.destroy(
; 650  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 651  : 		_Alnod.destroy(
; 652  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 653  : 		_Alnod.deallocate(_Pnode, 1);
; 654  : 		}
; 655  : 
; 656  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 657  : 		_Nodeptr _Prev)
; 658  : 		{	// allocate a node and set links
; 659  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 660  : 
; 661  : 		if (_Next == _Nodeptr())
; 662  : 			{	// point at self
; 663  : 			_Next = _Pnode;
; 664  : 			_Prev = _Pnode;
; 665  : 			}
; 666  : 		_TRY_BEGIN
; 667  : 		_Alnod.construct(
; 668  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 669  : 		_Alnod.construct(
; 670  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 671  : 		_CATCH_ALL
; 672  : 		_Alnod.deallocate(_Pnode, 1);
; 673  : 		_RERAISE;
; 674  : 		_CATCH_END
; 675  : 
; 676  : 		return (_Pnode);
; 677  : 		}
; 678  : 
; 679  : 	_Alty& _Getal()
; 680  : 		{	// get reference to allocator
; 681  : 		return (_Alnod);
; 682  : 		}
; 683  : 
; 684  : 	const _Alty& _Getal() const
; 685  : 		{	// get reference to allocator
; 686  : 		return (_Alnod);
; 687  : 		}
; 688  : 
; 689  : 	_Alty _Alnod;	// allocator object for stored elements
; 690  : 	};
; 691  : 
; 692  : 		// TEMPLATE CLASS _List_alloc
; 693  : template<class _Alloc_types>
; 694  : 	class _List_alloc<false, _Alloc_types>
; 695  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 696  : 	{	// base class for list to hold allocator with no storage
; 697  : public:
; 698  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 699  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 700  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 701  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 702  : 	typedef typename _Alloc_types::_Node _Node;
; 703  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 704  : 
; 705  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 706  : 	_List_alloc(const _Alloc& = _Alloc())
; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();

  0001c	48 89 03	 mov	 QWORD PTR [rbx], rax

; 905  : 		}

  0001f	48 8b c3	 mov	 rax, rbx
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
??0?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Tidy@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Tidy@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tidy, COMDAT

; 1927 : 		clear();

  00000	e9 00 00 00 00	 jmp	 ?clear@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::clear
?_Tidy@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXXZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Pnode$ = 56
?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode, COMDAT

; 854  : 		{	// give node back

$LN51:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0000a	48 8b 5a 28	 mov	 rbx, QWORD PTR [rdx+40]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 854  : 		{	// give node back

  0000e	48 8b f2	 mov	 rsi, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00011	48 85 db	 test	 rbx, rbx
  00014	74 27		 je	 SHORT $LN40@Freenode

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00016	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0001a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0001f	75 17		 jne	 SHORT $LN49@Freenode

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00021	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00024	48 8b cb	 mov	 rcx, rbx
  00027	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00029	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0002d	75 09		 jne	 SHORT $LN49@Freenode

; 128  : 			_Delete_this();

  0002f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00032	48 8b cb	 mov	 rcx, rbx
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
$LN49@Freenode:
  00038	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN40@Freenode:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0003d	48 8b ce	 mov	 rcx, rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 862  : 		}

  00040	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5e		 pop	 rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0004a	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?_Freenode@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Freenode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00000	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??1?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::~_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Prevnode, COMDAT

; 542  : 		return ((_Nodepref)_Pnode->_Prev);

  00000	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]

; 543  : 		}

  00004	c3		 ret	 0
?_Prevnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Prevnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 691  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Tmp$1 = 64
this$ = 64
_Count$ = 72
$T2 = 80
_Val$ = 80
?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::assign, COMDAT

; 1240 : 		{	// assign _Count * _Val

$LN116:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  00004	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 1454 : 		erase(begin(), end());

  00007	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  0000a	4c 8b ca	 mov	 r9, rdx

; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  0000d	48 89 44 24 40	 mov	 QWORD PTR _Tmp$1[rsp], rax

; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00012	48 8d 44 24 40	 lea	 rax, QWORD PTR _Tmp$1[rsp]
  00017	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  0001c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax

; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;

  00021	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00025	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n

; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
?assign@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Tidy, COMDAT

; 1535 : 		{	// free all storage

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1536 : 		if (this->_Myfirst != pointer())

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 12		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00011	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00016	33 c0		 xor	 eax, eax
  00018	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1543 : 			this->_Mylast = pointer();

  0001b	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1544 : 			this->_Myend = pointer();

  0001f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN1@Tidy:

; 1545 : 			}
; 1546 : 		}

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
?_Tidy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA?AV01@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA?AV01@H@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 246  : 		_Myiter _Tmp = *this;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00006	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00009	48 89 01	 mov	 QWORD PTR [rcx], rax

; 247  : 		++*this;
; 248  : 		return (_Tmp);

  0000c	48 8b c2	 mov	 rax, rdx

; 249  : 		}

  0000f	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA?AV01@H@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator==, COMDAT

; 86   : 		return (_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00006	0f 94 c0	 sete	 al

; 87   : 		}

  00009	c3		 ret	 0
??8?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator!=, COMDAT

; 86   : 		return (_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx

; 91   : 		return (!(*this == _Right));

  00006	0f 95 c0	 setne	 al

; 92   : 		}

  00009	c3		 ret	 0
??9?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*, COMDAT

; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}

  00007	c3		 ret	 0
??D?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  00003	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);

  00006	48 8b c1	 mov	 rax, rcx

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  00009	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 141  : 		}

  0000c	c3		 ret	 0
??E?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Vec_lo@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Bucket$ = 16
?_Vec_lo@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Vec_lo, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00000	48 c1 e2 04	 shl	 rdx, 4
  00004	48 03 51 10	 add	 rdx, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 906  : 		return (_Vec[2 * _Bucket]);

  00008	48 8b c2	 mov	 rax, rdx

; 907  : 		}

  0000b	c3		 ret	 0
?_Vec_lo@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Vec_lo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Vec_hi@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Bucket$ = 16
?_Vec_hi@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Vec_hi, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 916  : 		return (_Vec[2 * _Bucket + 1]);

  00004	48 c1 e2 04	 shl	 rdx, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00008	48 83 c0 08	 add	 rax, 8
  0000c	48 03 c2	 add	 rax, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 917  : 		}

  0000f	c3		 ret	 0
?_Vec_hi@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Vec_hi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Erase_bucket@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Plist_arg$ = 16
_Bucket$ = 24
?_Erase_bucket@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase_bucket, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00000	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 958  : 		if (_Vec_hi(_Bucket) == _Plist)

  00004	49 c1 e0 04	 shl	 r8, 4
  00008	4c 8b d1	 mov	 r10, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0000b	4d 03 c8	 add	 r9, r8
  0000e	49 39 51 08	 cmp	 QWORD PTR [r9+8], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 958  : 		if (_Vec_hi(_Bucket) == _Plist)

  00012	75 21		 jne	 SHORT $LN5@Erase_buck
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00014	49 39 11	 cmp	 QWORD PTR [r9], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 959  : 			if (_Vec_lo(_Bucket) == _Plist)

  00017	75 13		 jne	 SHORT $LN4@Erase_buck

; 960  : 				{	// make bucket empty
; 961  : 				_Vec_lo(_Bucket) = _Unchecked_end();

  00019	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0001c	49 89 01	 mov	 QWORD PTR [r9], rax

; 962  : 				_Vec_hi(_Bucket) = _Unchecked_end();

  0001f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00023	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00026	49 89 44 08 08	 mov	 QWORD PTR [r8+rcx+8], rax

; 968  : 		}

  0002b	c3		 ret	 0
$LN4@Erase_buck:

; 963  : 				}
; 964  : 			else
; 965  : 				_Vec_hi(_Bucket) = --_Plist;	// move end back one element

  0002c	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00030	49 89 41 08	 mov	 QWORD PTR [r9+8], rax

; 968  : 		}

  00034	c3		 ret	 0
$LN5@Erase_buck:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00035	49 39 11	 cmp	 QWORD PTR [r9], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 966  : 		else if (_Vec_lo(_Bucket) == _Plist)

  00038	75 06		 jne	 SHORT $LN1@Erase_buck

; 967  : 			_Vec_lo(_Bucket) = ++_Plist;	// move beginning up one element

  0003a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0003d	49 89 01	 mov	 QWORD PTR [r9], rax
$LN1@Erase_buck:

; 968  : 		}

  00040	f3 c3		 fatret	 0
?_Erase_bucket@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Erase_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Unchecked_end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_end, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));

  00006	48 8b c2	 mov	 rax, rdx

; 1148 : 		}

  00009	c3		 ret	 0
?_Unchecked_end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Make_iter, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1157 : 		return (iterator(_Where._Ptr, this));

  00003	48 8b c2	 mov	 rax, rdx

; 1158 : 		}

  00006	c3		 ret	 0
?_Make_iter@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Make_iter@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Make_iter, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1162 : 		return (iterator(_Where._Ptr, this));

  00003	48 8b c2	 mov	 rax, rdx

; 1163 : 		}

  00006	c3		 ret	 0
?_Make_iter@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Where$ = 80
?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::erase, COMDAT

; 1416 : 		{	// erase element at _Where

$LN86:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	41 56		 push	 r14
  00009	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  0000d	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 1416 : 		{	// erase element at _Where

  00010	49 8b d8	 mov	 rbx, r8
  00013	48 8b f2	 mov	 rsi, rdx
  00016	4c 8b f1	 mov	 r14, rcx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00019	48 89 44 24 50	 mov	 QWORD PTR _Where$[rsp], rax

; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)

  0001e	4c 3b 01	 cmp	 r8, QWORD PTR [rcx]
  00021	74 6f		 je	 SHORT $LN82@erase

; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00023	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]

; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);

  00027	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002a	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0002f	49 89 00	 mov	 QWORD PTR [r8], rax

; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);

  00032	4c 8b 03	 mov	 r8, QWORD PTR [rbx]
  00035	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00039	49 89 40 08	 mov	 QWORD PTR [r8+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0003d	48 8b 7b 28	 mov	 rdi, QWORD PTR [rbx+40]
  00041	48 85 ff	 test	 rdi, rdi
  00044	74 27		 je	 SHORT $LN63@erase

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00046	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  0004a	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0004f	75 17		 jne	 SHORT $LN83@erase

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00051	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00054	48 8b cf	 mov	 rcx, rdi
  00057	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00059	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0005d	75 09		 jne	 SHORT $LN83@erase

; 128  : 			_Delete_this();

  0005f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00062	48 8b cf	 mov	 rcx, rdi
  00065	ff 50 08	 call	 QWORD PTR [rax+8]
$LN83@erase:
  00068	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN63@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0006d	48 8b cb	 mov	 rcx, rbx
  00070	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR _Where$[rsp]

; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;

  0007a	49 ff 4e 08	 dec	 QWORD PTR [r14+8]
  0007e	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 44   : 		{	// construct with node pointer _Pnode

  00083	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));

  00086	48 8b c6	 mov	 rax, rsi

; 1437 : 		}

  00089	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008d	41 5e		 pop	 r14
  0008f	5e		 pop	 rsi
  00090	5b		 pop	 rbx
  00091	c3		 ret	 0
$LN82@erase:

; 44   : 		{	// construct with node pointer _Pnode

  00092	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));

  00095	48 8b c6	 mov	 rax, rsi

; 1437 : 		}

  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	41 5e		 pop	 r14
  0009e	5e		 pop	 rsi
  0009f	5b		 pop	 rbx
  000a0	c3		 ret	 0
?erase@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Al$dead$ = 56
??0?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 829  : 		{	// construct from allocator

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 531  : 		this->_Myhead = 0;

  00006	33 c0		 xor	 eax, eax

; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00008	45 33 c0	 xor	 r8d, r8d
  0000b	33 d2		 xor	 edx, edx

; 531  : 		this->_Myhead = 0;

  0000d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 532  : 		this->_Mysize = 0;

  00010	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 829  : 		{	// construct from allocator

  00014	48 8b d9	 mov	 rbx, rcx

; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00017	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0

; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);
; 548  : 		}
; 549  : 
; 550  : 	_Nodeptr _Myhead;	// pointer to head node
; 551  : 	size_type _Mysize;	// number of elements
; 552  : 	};
; 553  : 
; 554  : 		// TEMPLATE CLASS _List_alloc
; 555  : template<bool _Al_has_storage,
; 556  : 	class _Alloc_types>
; 557  : 	class _List_alloc
; 558  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 559  : 	{	// base class for list to hold allocator with storage
; 560  : public:
; 561  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 562  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 563  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 564  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 565  : 	typedef typename _Alloc_types::_Node _Node;
; 566  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 567  : 
; 568  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 569  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 570  : 		: _Alnod(_Al)
; 571  : 		{	// construct head node, allocator from _Al
; 572  : 		this->_Myhead = _Buyheadnode();
; 573  : 		}
; 574  : 
; 575  : 	~_List_alloc() _NOEXCEPT
; 576  : 		{	// destroy head node
; 577  : 		_Freeheadnode(this->_Myhead);
; 578  : 		}
; 579  : 
; 580  : 	void _Change_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Alnod = _Al;
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 588  : 		}
; 589  : 
; 590  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 591  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 592  : 		: _Alnod(_Al)
; 593  : 		{	// construct head node, allocator from _Al
; 594  : 		this->_Myhead = _Buyheadnode();
; 595  : 		_TRY_BEGIN
; 596  : 		_Alloc_proxy();
; 597  : 		_CATCH_ALL
; 598  : 		_Freeheadnode(this->_Myhead);
; 599  : 		_RERAISE;
; 600  : 		_CATCH_END
; 601  : 		}
; 602  : 
; 603  : 	~_List_alloc() _NOEXCEPT
; 604  : 		{	// destroy proxy
; 605  : 		_Freeheadnode(this->_Myhead);
; 606  : 		_Free_proxy();
; 607  : 		}
; 608  : 
; 609  : 	void _Change_alloc(const _Alty& _Al)
; 610  : 		{	// replace old allocator
; 611  : 		_Free_proxy();
; 612  : 		_Alnod = _Al;
; 613  : 		_Alloc_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Swap_alloc(_Myt& _Right)
; 617  : 		{	// swap allocators
; 618  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 619  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 620  : 		}
; 621  : 
; 622  : 	void _Alloc_proxy()
; 623  : 		{	// construct proxy from _Alnod
; 624  : 		typename _Alty::template rebind<_Container_proxy>::other
; 625  : 			_Alproxy(_Alnod);
; 626  : 		this->_Myproxy = _Alproxy.allocate(1);
; 627  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 628  : 		this->_Myproxy->_Mycont = this;
; 629  : 		}
; 630  : 
; 631  : 	void _Free_proxy()
; 632  : 		{	// destroy proxy
; 633  : 		typename _Alty::template rebind<_Container_proxy>::other
; 634  : 			_Alproxy(_Alnod);
; 635  : 		this->_Orphan_all();
; 636  : 		_Alproxy.destroy(this->_Myproxy);
; 637  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 638  : 		this->_Myproxy = 0;
; 639  : 		}
; 640  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 641  : 
; 642  : 	_Nodeptr _Buyheadnode()
; 643  : 		{	// get head node using current allocator
; 644  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 645  : 		}
; 646  : 
; 647  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 648  : 		{	// free head node using current allocator
; 649  : 		_Alnod.destroy(
; 650  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 651  : 		_Alnod.destroy(
; 652  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 653  : 		_Alnod.deallocate(_Pnode, 1);
; 654  : 		}
; 655  : 
; 656  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 657  : 		_Nodeptr _Prev)
; 658  : 		{	// allocate a node and set links
; 659  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 660  : 
; 661  : 		if (_Next == _Nodeptr())
; 662  : 			{	// point at self
; 663  : 			_Next = _Pnode;
; 664  : 			_Prev = _Pnode;
; 665  : 			}
; 666  : 		_TRY_BEGIN
; 667  : 		_Alnod.construct(
; 668  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 669  : 		_Alnod.construct(
; 670  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 671  : 		_CATCH_ALL
; 672  : 		_Alnod.deallocate(_Pnode, 1);
; 673  : 		_RERAISE;
; 674  : 		_CATCH_END
; 675  : 
; 676  : 		return (_Pnode);
; 677  : 		}
; 678  : 
; 679  : 	_Alty& _Getal()
; 680  : 		{	// get reference to allocator
; 681  : 		return (_Alnod);
; 682  : 		}
; 683  : 
; 684  : 	const _Alty& _Getal() const
; 685  : 		{	// get reference to allocator
; 686  : 		return (_Alnod);
; 687  : 		}
; 688  : 
; 689  : 	_Alty _Alnod;	// allocator object for stored elements
; 690  : 	};
; 691  : 
; 692  : 		// TEMPLATE CLASS _List_alloc
; 693  : template<class _Alloc_types>
; 694  : 	class _List_alloc<false, _Alloc_types>
; 695  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 696  : 	{	// base class for list to hold allocator with no storage
; 697  : public:
; 698  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 699  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 700  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 701  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 702  : 	typedef typename _Alloc_types::_Node _Node;
; 703  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 704  : 
; 705  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 706  : 	_List_alloc(const _Alloc& = _Alloc())
; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();

  0001c	48 89 03	 mov	 QWORD PTR [rbx], rax

; 830  : 		}

  0001f	48 8b c3	 mov	 rax, rbx
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
??0?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Pnode$ = 16
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?_Freeheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal, COMDAT

; 810  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 811  : 		}

  00003	c3		 ret	 0
?_Getal@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Assign_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Tmp$ = 64
this$ = 64
_Count$ = 72
$T1 = 80
_Val$ = 80
?_Assign_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Assign_n, COMDAT

; 1452 : 		{	// assign _Count * _Val

$LN114:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  00004	49 8b 00	 mov	 rax, QWORD PTR [r8]

; 1454 : 		erase(begin(), end());

  00007	4c 8b 01	 mov	 r8, QWORD PTR [rcx]

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  0000a	4c 8b ca	 mov	 r9, rdx

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  0000d	48 89 44 24 40	 mov	 QWORD PTR _Tmp$[rsp], rax

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00012	48 8d 44 24 40	 lea	 rax, QWORD PTR _Tmp$[rsp]
  00017	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T1[rsp]
  0001c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax

; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;

  00021	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00025	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n

; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}

  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	c3		 ret	 0
?_Assign_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAX_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Assign_n
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Destroy, COMDAT

; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}

  00000	c2 00 00	 ret	 0
?_Destroy@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 594  : 		{	// construct allocator from _Al
; 595  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >::_Getal, COMDAT

; 647  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 648  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator*, COMDAT

; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}

  00007	c3		 ret	 0
??D?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++, COMDAT

; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  00003	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 61   : 		return (*this);

  00006	48 8b c1	 mov	 rax, rcx
  00009	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 62   : 		}

  0000c	c3		 ret	 0
??E?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 706  : 	_List_alloc(const _Alloc& = _Alloc())

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 531  : 		this->_Myhead = 0;

  00006	33 c0		 xor	 eax, eax

; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00008	45 33 c0	 xor	 r8d, r8d
  0000b	33 d2		 xor	 edx, edx

; 531  : 		this->_Myhead = 0;

  0000d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 532  : 		this->_Mysize = 0;

  00010	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 706  : 	_List_alloc(const _Alloc& = _Alloc())

  00014	48 8b d9	 mov	 rbx, rcx

; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00017	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0

; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();

  0001c	48 89 03	 mov	 QWORD PTR [rbx], rax

; 709  : 		}

  0001f	48 8b c3	 mov	 rax, rbx
  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
??0?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::begin, COMDAT

; 47   : 		{	// construct with pointer _Parg

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 982  : 		return (iterator(this->_Myfirst, this));

  00006	48 8b c2	 mov	 rax, rdx

; 983  : 		}

  00009	c3		 ret	 0
?begin@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?end@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::end, COMDAT

; 47   : 		{	// construct with pointer _Parg

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 89 02	 mov	 QWORD PTR [rdx], rax

; 992  : 		return (iterator(this->_Mylast, this));

  00007	48 8b c2	 mov	 rax, rdx

; 993  : 		}

  0000a	c3		 ret	 0
?end@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_K@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator[], COMDAT

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 8d 04 d0	 lea	 rax, QWORD PTR [rax+rdx*8]

; 1149 : 		}

  00007	c3		 ret	 0
??A?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAAEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@_K@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 64
__$ReturnUdt$ = 72
_Where$ = 80
_Count$ = 88
_Val$ = 96
?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::insert, COMDAT

; 1251 : 		{	// insert _Count * _Val at _Where

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00006	48 8b 44 24 60	 mov	 rax, QWORD PTR _Val$[rsp]
  0000b	48 8b da	 mov	 rbx, rdx
  0000e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00013	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
  00018	48 8b c3	 mov	 rax, rbx

; 1253 : 		}

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
?insert@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?erase@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_First_arg$ = 24
_Last_arg$ = 32
?erase@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@0@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::erase, COMDAT

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1381 : 		{	// erase [_First, _Last)

  00003	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00008	4c 8b d9	 mov	 r11, rcx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  0000b	4c 3b c0	 cmp	 r8, rax

; 1382 : 		if (_First_arg == begin() && _Last_arg == end())

  0000e	75 11		 jne	 SHORT $LN4@erase

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00010	4c 3b 49 08	 cmp	 r9, QWORD PTR [rcx+8]

; 1382 : 		if (_First_arg == begin() && _Last_arg == end())

  00014	75 0b		 jne	 SHORT $LN4@erase

; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;

  00016	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 47   : 		{	// construct with pointer _Parg

  0001a	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));

  0001d	48 8b c2	 mov	 rax, rdx

; 1410 : 		}

  00020	c3		 ret	 0
$LN4@erase:

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}
; 50   : 
; 51   : 	typedef pointer _Unchecked_type;
; 52   : 
; 53   : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 54   : 		{	// reset from unchecked iterator
; 55   : 		this->_Ptr = (_Tptr)_Right;
; 56   : 		return (*this);
; 57   : 		}
; 58   : 
; 59   : 	_Unchecked_type _Unchecked() const
; 60   : 		{	// make an unchecked iterator
; 61   : 		return (_Unchecked_type(this->_Ptr));
; 62   : 		}
; 63   : 
; 64   : 	reference operator*() const
; 65   : 		{	// return designated object
; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		if (this->_Getcont() == 0
; 68   : 			|| this->_Ptr == 0
; 69   : 			|| this->_Ptr < ((_Myvec *)this->_Getcont())->_Myfirst
; 70   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 71   : 			{	// report error
; 72   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 73   : 			_SCL_SECURE_OUT_OF_RANGE;
; 74   : 			}
; 75   : 
; 76   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 77   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 78   : 		_SCL_SECURE_VALIDATE_RANGE(
; 79   : 			this->_Ptr != _Tptr()
; 80   : 			&& ((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr
; 81   : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(this->_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*this->_Ptr);
; 87   : 		}
; 88   : 
; 89   : 	pointer operator->() const
; 90   : 		{	// return pointer to class object
; 91   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 92   : 		}
; 93   : 
; 94   : 	_Myiter& operator++()
; 95   : 		{	// preincrement
; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		if (this->_Getcont() == 0
; 98   : 			|| this->_Ptr == 0
; 99   : 			|| ((_Myvec *)this->_Getcont())->_Mylast <= this->_Ptr)
; 100  : 			{	// report error
; 101  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 102  : 			_SCL_SECURE_OUT_OF_RANGE;
; 103  : 			}
; 104  : 
; 105  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 106  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 107  : 		_SCL_SECURE_VALIDATE_RANGE(
; 108  : 			this->_Ptr != _Tptr()
; 109  : 			&& this->_Ptr < ((_Myvec *)this->_Getcont())->_Mylast);
; 110  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 111  : 
; 112  : 		++this->_Ptr;
; 113  : 		return (*this);
; 114  : 		}
; 115  : 
; 116  : 	_Myiter operator++(int)
; 117  : 		{	// postincrement
; 118  : 		_Myiter _Tmp = *this;
; 119  : 		++*this;
; 120  : 		return (_Tmp);
; 121  : 		}
; 122  : 
; 123  : 	_Myiter& operator--()
; 124  : 		{	// predecrement
; 125  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 126  : 		if (this->_Getcont() == 0
; 127  : 			|| this->_Ptr == 0
; 128  : 			|| this->_Ptr <= ((_Myvec *)this->_Getcont())->_Myfirst)
; 129  : 			{	// report error
; 130  : 			_DEBUG_ERROR("vector iterator not decrementable");
; 131  : 			_SCL_SECURE_OUT_OF_RANGE;
; 132  : 			}
; 133  : 
; 134  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 135  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 136  : 		_SCL_SECURE_VALIDATE_RANGE(
; 137  : 			this->_Ptr != _Tptr()
; 138  : 			&& ((_Myvec *)this->_Getcont())->_Myfirst < this->_Ptr);
; 139  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 140  : 
; 141  : 		--this->_Ptr;
; 142  : 		return (*this);
; 143  : 		}
; 144  : 
; 145  : 	_Myiter operator--(int)
; 146  : 		{	// postdecrement
; 147  : 		_Myiter _Tmp = *this;
; 148  : 		--*this;
; 149  : 		return (_Tmp);
; 150  : 		}
; 151  : 
; 152  : 	_Myiter& operator+=(difference_type _Off)
; 153  : 		{	// increment by integer
; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;
; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00021	4d 3b c1	 cmp	 r8, r9

; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)

  00024	74 37		 je	 SHORT $LN85@erase

; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));

  00026	4c 8b 51 08	 mov	 r10, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2487 : 		_Dest, _Ptr_cat(_First, _Dest)));

  0002a	49 8b c8	 mov	 rcx, r8

; 2465 : 	for (; _First != _Last; ++_Dest, ++_First)

  0002d	4d 3b ca	 cmp	 r9, r10
  00030	74 27		 je	 SHORT $LN67@erase
  00032	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL69@erase:

; 2466 : 		*_Dest = _STD move(*_First);

  00040	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00043	49 83 c1 08	 add	 r9, 8
  00047	48 83 c1 08	 add	 rcx, 8
  0004b	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax
  0004f	4d 3b ca	 cmp	 r9, r10
  00052	75 ec		 jne	 SHORT $LL69@erase

; 2465 : 	for (; _First != _Last; ++_Dest, ++_First)

  00054	4c 8b 44 24 18	 mov	 r8, QWORD PTR _First_arg$[rsp]
$LN67@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1406 : 				this->_Mylast = _Ptr;

  00059	49 89 4b 08	 mov	 QWORD PTR [r11+8], rcx
$LN85@erase:

; 47   : 		{	// construct with pointer _Parg

  0005d	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));

  00060	48 8b c2	 mov	 rax, rdx

; 1410 : 		}

  00063	c3		 ret	 0
?erase@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@0@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >, COMDAT

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 489  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Unchecked@?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked@?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Unchecked, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));

  00006	48 8b c2	 mov	 rax, rdx

; 359  : 		}

  00009	c3		 ret	 0
?_Unchecked@?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode, COMDAT

; 96   : 		return (_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 97   : 		}

  00003	c3		 ret	 0
?_Mynode@?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEBAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 125  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--, COMDAT

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]

; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);

  00007	48 8b c1	 mov	 rax, rcx

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  0000a	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 154  : 		}

  0000d	c3		 ret	 0
??F?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ PROC ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode, COMDAT

; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));

  00000	45 33 c0	 xor	 r8d, r8d
  00003	33 d2		 xor	 edx, edx
  00005	e9 00 00 00 00	 jmp	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0
?_Buyheadnode@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@XZ ENDP ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 532  : 		this->_Mysize = 0;

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 533  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
_Where$ = 24
?_Make_iter@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Make_iter, COMDAT

; 47   : 		{	// construct with pointer _Parg

  00000	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 1002 : 		return (iterator(_Where._Ptr, this));

  00003	48 8b c2	 mov	 rax, rdx

; 1003 : 		}

  00006	c3		 ret	 0
?_Make_iter@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?clear@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAXXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::clear, COMDAT

; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1417 : 		}

  00007	c3		 ret	 0
?clear@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEAAXXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Tmp$1 = 96
this$ = 96
__$ReturnUdt$ = 104
_Where$ = 112
_Count$ = 120
_Val$ = 128
?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n, COMDAT

; 1566 : 		{	// insert _Count * _Val at _Where

$LN220:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	41 54		 push	 r12
  00013	41 56		 push	 r14
  00015	41 57		 push	 r15
  00017	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001b	48 8b f1	 mov	 rsi, rcx

; 1567 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1568 : 		if (_VICONT(_Where) != this
; 1569 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1570 : 			|| this->_Mylast < _VIPTR(_Where))
; 1571 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1572 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 
; 1574 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;

  0001e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00021	49 8b e8	 mov	 rbp, r8
  00024	48 2b e9	 sub	 rbp, rcx
  00027	4d 8b f1	 mov	 r14, r9
  0002a	4d 8b f8	 mov	 r15, r8
  0002d	48 c1 fd 03	 sar	 rbp, 3
  00031	4c 8b e2	 mov	 r12, rdx

; 1575 : 		if (_Count == 0)

  00034	4d 85 c9	 test	 r9, r9
  00037	0f 84 e7 01 00
	00		 je	 $LN189@Insert_n

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  0003d	48 8b 5e 10	 mov	 rbx, QWORD PTR [rsi+16]
  00041	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00045	48 8b c3	 mov	 rax, rbx
  00048	48 2b c2	 sub	 rax, rdx
  0004b	48 c1 f8 03	 sar	 rax, 3

; 1576 : 			;
; 1577 : 		else if (_Unused_capacity() < _Count)

  0004f	49 3b c1	 cmp	 rax, r9
  00052	0f 83 ec 00 00
	00		 jae	 $LN10@Insert_n

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00058	48 2b d1	 sub	 rdx, rcx

; 1578 : 			{	// not enough room, reallocate
; 1579 : 			if (max_size() - size() < _Count)

  0005b	49 b9 ff ff ff
	ff ff ff ff 1f	 mov	 r9, 2305843009213693951	; 1fffffffffffffffH

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00065	48 c1 fa 03	 sar	 rdx, 3

; 1578 : 			{	// not enough room, reallocate
; 1579 : 			if (max_size() - size() < _Count)

  00069	49 8b c1	 mov	 rax, r9
  0006c	48 2b c2	 sub	 rax, rdx
  0006f	49 3b c6	 cmp	 rax, r14
  00072	0f 82 d1 01 00
	00		 jb	 $LN218@Insert_n

; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  :  #if _HAS_CPP0X
; 443  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 444  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 445  : 
; 446  :  #else /* _HAS_CPP0X */
; 447  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 448  :  #endif /* _HAS_CPP0X */
; 449  : 
; 450  : 	typedef typename _Alty::pointer _Tptr;
; 451  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 452  : 
; 453  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 454  : 		_Simple_types<typename _Alty::value_type>,
; 455  : 		_Vec_iter_types<typename _Alty::value_type,
; 456  : 			typename _Alty::size_type,
; 457  : 			typename _Alty::difference_type,
; 458  : 			typename _Alty::pointer,
; 459  : 			typename _Alty::const_pointer,
; 460  : 			typename _Alty::reference,
; 461  : 			typename _Alty::const_reference> >::type
; 462  : 		_Val_types;
; 463  : 	};
; 464  : 
; 465  : 		// TEMPLATE CLASS _Vector_val
; 466  : template<class _Val_types>
; 467  : 	class _Vector_val
; 468  : 		: public _Container_base
; 469  : 	{	// base class for vector to hold data
; 470  : public:
; 471  : 	typedef _Vector_val<_Val_types> _Myt;
; 472  : 
; 473  : 	typedef typename _Val_types::value_type value_type;
; 474  : 	typedef typename _Val_types::size_type size_type;
; 475  : 	typedef typename _Val_types::difference_type difference_type;
; 476  : 	typedef typename _Val_types::pointer pointer;
; 477  : 	typedef typename _Val_types::const_pointer const_pointer;
; 478  : 	typedef typename _Val_types::reference reference;
; 479  : 	typedef typename _Val_types::const_reference const_reference;
; 480  : 
; 481  : 	typedef _Vector_iterator<_Myt> iterator;
; 482  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 483  : 
; 484  : 	_Vector_val()
; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();
; 487  : 		_Mylast = pointer();
; 488  : 		_Myend = pointer();
; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)
; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else
; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)
; 850  : 				_Reserve(1);
; 851  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 852  : 			this->_Getal().construct(this->_Mylast,
; 853  : 				_STD forward<value_type>(_Val));
; 854  : 			++this->_Mylast;
; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);

  00078	48 2b d9	 sub	 rbx, rcx

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  0007b	49 8b c1	 mov	 rax, r9
  0007e	33 ff		 xor	 edi, edi

; 368  : 		}
; 369  : 
; 370  : 	_Myiter& operator-=(difference_type _Off)
; 371  : 		{	// decrement by integer
; 372  : 		return (*this += -_Off);
; 373  : 		}
; 374  : 
; 375  : 	_Myiter operator-(difference_type _Off) const
; 376  : 		{	// return this - integer
; 377  : 		_Myiter _Tmp = *this;
; 378  : 		return (_Tmp -= _Off);
; 379  : 		}
; 380  : 
; 381  : 	difference_type operator-(const _Mybase& _Right) const
; 382  : 		{	// return difference of iterators
; 383  : 		return (*(_Mybase *)this - _Right);
; 384  : 		}
; 385  : 
; 386  : 	reference operator[](difference_type _Off) const
; 387  : 		{	// subscript
; 388  : 		return (*(*this + _Off));
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : template<class _Myvec> inline
; 393  : 	typename _Vector_iterator<_Myvec>::_Unchecked_type
; 394  : 		_Unchecked(_Vector_iterator<_Myvec> _Iter)
; 395  : 	{	// convert to unchecked
; 396  : 	return (_Iter._Unchecked());
; 397  : 	}
; 398  : 
; 399  : template<class _Myvec> inline
; 400  : 	_Vector_iterator<_Myvec>&
; 401  : 		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
; 402  : 			typename _Vector_iterator<_Myvec>
; 403  : 				::_Unchecked_type _Right)
; 404  : 	{	// convert to checked
; 405  : 	return (_Iter._Rechecked(_Right));
; 406  : 	}
; 407  : 
; 408  : template<class _Myvec> inline
; 409  : 	_Vector_iterator<_Myvec> operator+(
; 410  : 		typename _Vector_iterator<_Myvec>::difference_type _Off,
; 411  : 		_Vector_iterator<_Myvec> _Next)
; 412  : 	{	// add offset to iterator
; 413  : 	return (_Next += _Off);
; 414  : 	}
; 415  : 
; 416  : 		// vector TYPE WRAPPERS
; 417  : template<class _Value_type,
; 418  : 	class _Size_type,
; 419  : 	class _Difference_type,
; 420  : 	class _Pointer,
; 421  : 	class _Const_pointer,
; 422  : 	class _Reference,
; 423  : 	class _Const_reference>
; 424  : 	struct _Vec_iter_types
; 425  : 	{	// wraps types needed by iterators
; 426  : 	typedef _Value_type value_type;
; 427  : 	typedef _Size_type size_type;
; 428  : 	typedef _Difference_type difference_type;
; 429  : 	typedef _Pointer pointer;
; 430  : 	typedef _Const_pointer const_pointer;
; 431  : 	typedef _Reference reference;
; 432  : 	typedef _Const_reference const_reference;
; 433  : 	};
; 434  : 
; 435  : template<class _Ty,
; 436  : 	class _Alloc0>
; 437  : 	struct _Vec_base_types
; 438  : 	{	// types needed for a container base
; 439  : 	typedef _Alloc0 _Alloc;
; 440  : 	typedef _Vec_base_types<_Ty, _Alloc> _Myt;
; 441  : 
; 442  :  #if _HAS_CPP0X
; 443  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 444  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 445  : 
; 446  :  #else /* _HAS_CPP0X */
; 447  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 448  :  #endif /* _HAS_CPP0X */
; 449  : 
; 450  : 	typedef typename _Alty::pointer _Tptr;
; 451  : 	typedef typename _Alty::template rebind<_Tptr>::other _Alpty;
; 452  : 
; 453  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 454  : 		_Simple_types<typename _Alty::value_type>,
; 455  : 		_Vec_iter_types<typename _Alty::value_type,
; 456  : 			typename _Alty::size_type,
; 457  : 			typename _Alty::difference_type,
; 458  : 			typename _Alty::pointer,
; 459  : 			typename _Alty::const_pointer,
; 460  : 			typename _Alty::reference,
; 461  : 			typename _Alty::const_reference> >::type
; 462  : 		_Val_types;
; 463  : 	};
; 464  : 
; 465  : 		// TEMPLATE CLASS _Vector_val
; 466  : template<class _Val_types>
; 467  : 	class _Vector_val
; 468  : 		: public _Container_base
; 469  : 	{	// base class for vector to hold data
; 470  : public:
; 471  : 	typedef _Vector_val<_Val_types> _Myt;
; 472  : 
; 473  : 	typedef typename _Val_types::value_type value_type;
; 474  : 	typedef typename _Val_types::size_type size_type;
; 475  : 	typedef typename _Val_types::difference_type difference_type;
; 476  : 	typedef typename _Val_types::pointer pointer;
; 477  : 	typedef typename _Val_types::const_pointer const_pointer;
; 478  : 	typedef typename _Val_types::reference reference;
; 479  : 	typedef typename _Val_types::const_reference const_reference;
; 480  : 
; 481  : 	typedef _Vector_iterator<_Myt> iterator;
; 482  : 	typedef _Vector_const_iterator<_Myt> const_iterator;
; 483  : 
; 484  : 	_Vector_val()
; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();
; 487  : 		_Mylast = pointer();
; 488  : 		_Myend = pointer();
; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)
; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else
; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)
; 850  : 				_Reserve(1);
; 851  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 852  : 			this->_Getal().construct(this->_Mylast,
; 853  : 				_STD forward<value_type>(_Val));
; 854  : 			++this->_Mylast;
; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);

  00080	48 c1 fb 03	 sar	 rbx, 3

; 1580 : 				_Xlen();	// result too long
; 1581 : 
; 1582 : 			size_type _Capacity = _Grow_to(size() + _Count);

  00084	4e 8d 04 32	 lea	 r8, QWORD PTR [rdx+r14]

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00088	48 8b cb	 mov	 rcx, rbx
  0008b	48 d1 e9	 shr	 rcx, 1
  0008e	48 2b c1	 sub	 rax, rcx
  00091	48 3b c3	 cmp	 rax, rbx
  00094	73 04		 jae	 SHORT $LN51@Insert_n
  00096	8b df		 mov	 ebx, edi
  00098	eb 03		 jmp	 SHORT $LN52@Insert_n
$LN51@Insert_n:
  0009a	48 03 d9	 add	 rbx, rcx
$LN52@Insert_n:

; 1489 : 		if (_Capacity < _Count)

  0009d	49 3b d8	 cmp	 rbx, r8
  000a0	49 0f 42 d8	 cmovb	 rbx, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  000a4	48 85 db	 test	 rbx, rbx
  000a7	74 27		 je	 SHORT $LN80@Insert_n

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  000a9	49 3b d9	 cmp	 rbx, r9
  000ac	0f 87 a4 01 00
	00		 ja	 $LN79@Insert_n
  000b2	48 8d 0c dd 00
	00 00 00	 lea	 rcx, QWORD PTR [rbx*8]
  000ba	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000bf	48 8b f8	 mov	 rdi, rax
  000c2	48 85 c0	 test	 rax, rax
  000c5	0f 84 8b 01 00
	00		 je	 $LN79@Insert_n
  000cb	4c 8b 7c 24 70	 mov	 r15, QWORD PTR _Where$[rsp]
$LN80@Insert_n:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1584 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

  000d0	4c 2b 3e	 sub	 r15, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 613  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  000d3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR _Val$[rsp]
  000db	49 8b d6	 mov	 rdx, r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1584 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;

  000de	49 c1 ff 03	 sar	 r15, 3

; 1585 : 			int _Ncopied = 0;
; 1586 : 
; 1587 : 			_TRY_BEGIN
; 1588 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1589 : 				_STD addressof(_Val));	// add new stuff

  000e2	4a 8d 0c ff	 lea	 rcx, QWORD PTR [rdi+r15*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 613  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  000e6	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  000eb	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Where$[rsp]
  000f0	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000f3	4c 8b c7	 mov	 r8, rdi
  000f6	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
  000fb	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  000ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _Where$[rsp]
  00104	4b 8d 04 37	 lea	 rax, QWORD PTR [r15+r14]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1595 : 				_Newvec + (_Whereoff + _Count));	// copy suffix

  00108	4c 8d 04 c7	 lea	 r8, QWORD PTR [rdi+rax*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0010c	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00111	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00114	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00118	48 2b c1	 sub	 rax, rcx
  0011b	48 c1 f8 03	 sar	 rax, 3

; 1596 : 			_CATCH_ALL
; 1597 : 			if (1 < _Ncopied)
; 1598 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1599 : 			if (0 < _Ncopied)
; 1600 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1601 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1602 : 			_RERAISE;
; 1603 : 			_CATCH_END
; 1604 : 
; 1605 : 			_Count += size();

  0011f	4c 03 f0	 add	 r14, rax

; 1606 : 			if (this->_Myfirst != pointer())

  00122	48 85 c9	 test	 rcx, rcx
  00125	74 05		 je	 SHORT $LN130@Insert_n
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00127	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN130@Insert_n:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1614 : 			this->_Myend = _Newvec + _Capacity;

  0012c	48 8d 04 df	 lea	 rax, QWORD PTR [rdi+rbx*8]

; 1615 : 			this->_Mylast = _Newvec + _Count;
; 1616 : 			this->_Myfirst = _Newvec;

  00130	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  00133	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
  00137	4a 8d 04 f7	 lea	 rax, QWORD PTR [rdi+r14*8]
  0013b	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 1617 : 			}
; 1618 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))

  0013f	e9 e0 00 00 00	 jmp	 $LN189@Insert_n
$LN10@Insert_n:

; 1621 : 			value_type _Tmp = _Val;	// in case _Val is in sequence

  00144	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR _Val$[rsp]
  0014c	48 8b c2	 mov	 rax, rdx
  0014f	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  00152	49 2b c0	 sub	 rax, r8
  00155	48 c1 f8 03	 sar	 rax, 3
  00159	49 3b c1	 cmp	 rax, r9
  0015c	73 60		 jae	 SHORT $LN3@Insert_n

; 1622 : 
; 1623 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1624 : 				_VIPTR(_Where) + _Count);	// copy suffix

  0015e	4a 8d 3c cd 00
	00 00 00	 lea	 rdi, QWORD PTR [r9*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00166	49 8b cf	 mov	 rcx, r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1621 : 			value_type _Tmp = _Val;	// in case _Val is in sequence

  00169	48 89 5c 24 60	 mov	 QWORD PTR _Tmp$1[rsp], rbx

; 1622 : 
; 1623 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1624 : 				_VIPTR(_Where) + _Count);	// copy suffix

  0016e	4c 03 c7	 add	 r8, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00171	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1629 : 				_STD addressof(_Tmp));	// insert new stuff off end

  00176	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 613  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  0017a	4c 8d 44 24 60	 lea	 r8, QWORD PTR _Tmp$1[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1629 : 				_STD addressof(_Tmp));	// insert new stuff off end

  0017f	48 8b c1	 mov	 rax, rcx
  00182	48 2b 44 24 70	 sub	 rax, QWORD PTR _Where$[rsp]
  00187	48 c1 f8 03	 sar	 rax, 3
  0018b	4c 2b f0	 sub	 r14, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 613  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  0018e	49 8b d6	 mov	 rdx, r14
  00191	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1636 : 			this->_Mylast += _Count;

  00196	48 01 7e 08	 add	 QWORD PTR [rsi+8], rdi
  0019a	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2669 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);

  0019e	48 8b 44 24 70	 mov	 rax, QWORD PTR _Where$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1639 : 				_Tmp);	// insert up to old end

  001a3	48 2b cf	 sub	 rcx, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2645 : 	for (; _First != _Last; ++_First)

  001a6	48 3b c1	 cmp	 rax, rcx
  001a9	74 79		 je	 SHORT $LN189@Insert_n
  001ab	0f 1f 44 00 00	 npad	 5
$LL162@Insert_n:

; 2646 : 		*_First = _Val;

  001b0	48 89 18	 mov	 QWORD PTR [rax], rbx
  001b3	48 83 c0 08	 add	 rax, 8
  001b7	48 3b c1	 cmp	 rax, rcx
  001ba	75 f4		 jne	 SHORT $LL162@Insert_n
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1641 : 		else

  001bc	eb 66		 jmp	 SHORT $LN189@Insert_n
$LN3@Insert_n:

; 1647 : 				this->_Mylast);	// copy suffix

  001be	4e 8d 34 cd 00
	00 00 00	 lea	 r14, QWORD PTR [r9*8]
  001c6	48 8b fa	 mov	 rdi, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  001c9	4c 8b c2	 mov	 r8, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1647 : 				this->_Mylast);	// copy suffix

  001cc	49 2b fe	 sub	 rdi, r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  001cf	48 8b cf	 mov	 rcx, rdi
  001d2	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2391 : 	while (_First != _Last)

  001d7	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Where$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1647 : 				this->_Mylast);	// copy suffix

  001dc	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2391 : 	while (_First != _Last)

  001e0	48 3b d7	 cmp	 rdx, rdi
  001e3	74 21		 je	 SHORT $LN179@Insert_n
  001e5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL180@Insert_n:

; 2392 : 		*--_Dest = *--_Last;

  001f0	48 8b 47 f8	 mov	 rax, QWORD PTR [rdi-8]
  001f4	48 83 ef 08	 sub	 rdi, 8
  001f8	49 89 04 3e	 mov	 QWORD PTR [r14+rdi], rax
  001fc	48 8b 54 24 70	 mov	 rdx, QWORD PTR _Where$[rsp]
  00201	48 3b d7	 cmp	 rdx, rdi
  00204	75 ea		 jne	 SHORT $LL180@Insert_n
$LN179@Insert_n:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1653 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

  00206	49 8d 04 16	 lea	 rax, QWORD PTR [r14+rdx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2645 : 	for (; _First != _Last; ++_First)

  0020a	48 3b d0	 cmp	 rdx, rax
  0020d	74 15		 je	 SHORT $LN189@Insert_n
  0020f	90		 npad	 1
$LL191@Insert_n:

; 2646 : 		*_First = _Val;

  00210	48 89 1a	 mov	 QWORD PTR [rdx], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1653 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

  00213	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _Where$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2645 : 	for (; _First != _Last; ++_First)

  00218	48 83 c2 08	 add	 rdx, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1653 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole

  0021c	49 03 ce	 add	 rcx, r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2645 : 	for (; _First != _Last; ++_First)

  0021f	48 3b d1	 cmp	 rdx, rcx
  00222	75 ec		 jne	 SHORT $LL191@Insert_n
$LN189@Insert_n:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 170  : 		_Ptr += _Off;

  00224	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 1656 : 		}

  00227	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]

; 170  : 		_Ptr += _Off;

  0022c	48 8d 0c e8	 lea	 rcx, QWORD PTR [rax+rbp*8]

; 1656 : 		}

  00230	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  00235	49 8b c4	 mov	 rax, r12

; 171  : 		return (*this);
; 172  : 		}
; 173  : 
; 174  : 	_Myiter operator+(difference_type _Off) const
; 175  : 		{	// return this + integer
; 176  : 		_Myiter _Tmp = *this;
; 177  : 		return (_Tmp += _Off);
; 178  : 		}
; 179  : 
; 180  : 	_Myiter& operator-=(difference_type _Off)
; 181  : 		{	// decrement by integer
; 182  : 		return (*this += -_Off);
; 183  : 		}
; 184  : 
; 185  : 	_Myiter operator-(difference_type _Off) const
; 186  : 		{	// return this - integer
; 187  : 		_Myiter _Tmp = *this;
; 188  : 		return (_Tmp -= _Off);
; 189  : 		}
; 190  : 
; 191  : 	difference_type operator-(const _Myiter& _Right) const
; 192  : 		{	// return difference of iterators
; 193  : 		_Compat(_Right);
; 194  : 		return (this->_Ptr - _Right._Ptr);
; 195  : 		}
; 196  : 
; 197  : 	reference operator[](difference_type _Off) const
; 198  : 		{	// subscript
; 199  : 		return (*(*this + _Off));
; 200  : 		}
; 201  : 
; 202  : 	bool operator==(const _Myiter& _Right) const
; 203  : 		{	// test for iterator equality
; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);
; 206  : 		}
; 207  : 
; 208  : 	bool operator!=(const _Myiter& _Right) const
; 209  : 		{	// test for iterator inequality
; 210  : 		return (!(*this == _Right));
; 211  : 		}
; 212  : 
; 213  : 	bool operator<(const _Myiter& _Right) const
; 214  : 		{	// test if this < _Right
; 215  : 		_Compat(_Right);
; 216  : 		return (this->_Ptr < _Right._Ptr);
; 217  : 		}
; 218  : 
; 219  : 	bool operator>(const _Myiter& _Right) const
; 220  : 		{	// test if this > _Right
; 221  : 		return (_Right < *this);
; 222  : 		}
; 223  : 
; 224  : 	bool operator<=(const _Myiter& _Right) const
; 225  : 		{	// test if this <= _Right
; 226  : 		return (!(_Right < *this));
; 227  : 		}
; 228  : 
; 229  : 	bool operator>=(const _Myiter& _Right) const
; 230  : 		{	// test if this >= _Right
; 231  : 		return (!(*this < _Right));
; 232  : 		}
; 233  : 
; 234  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 235  : 	void _Compat(const _Myiter& _Right) const
; 236  : 		{	// test for compatible iterator pair
; 237  : 		if (this->_Getcont() == 0
; 238  : 			|| this->_Getcont() != _Right._Getcont())
; 239  : 			{	// report error
; 240  : 			_DEBUG_ERROR("vector iterators incompatible");
; 241  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 242  : 			}
; 243  : 		}
; 244  : 
; 245  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 246  : 	void _Compat(const _Myiter& _Right) const
; 247  : 		{	// test for compatible iterator pair
; 248  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 249  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Getcont() == _Right._Getcont());
; 250  : 		}
; 251  : 
; 252  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 253  : 	void _Compat(const _Myiter&) const
; 254  : 		{	// test for compatible iterator pair
; 255  : 		}
; 256  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 257  : 
; 258  : 	_Tptr _Ptr;	// pointer to element in vector
; 259  : 	};
; 260  : 
; 261  : template<class _Myvec> inline
; 262  : 	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
; 263  : 		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
; 264  : 	{	// convert to unchecked
; 265  : 	return (_Iter._Unchecked());
; 266  : 	}
; 267  : 
; 268  : template<class _Myvec> inline
; 269  : 	_Vector_const_iterator<_Myvec>&
; 270  : 		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
; 271  : 			typename _Vector_const_iterator<_Myvec>
; 272  : 				::_Unchecked_type _Right)
; 273  : 	{	// convert to checked
; 274  : 	return (_Iter._Rechecked(_Right));
; 275  : 	}
; 276  : 
; 277  : template<class _Myvec> inline
; 278  : 	_Vector_const_iterator<_Myvec> operator+(
; 279  : 		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
; 280  : 		_Vector_const_iterator<_Myvec> _Next)
; 281  : 	{	// add offset to iterator
; 282  : 	return (_Next += _Off);
; 283  : 	}
; 284  : 
; 285  : 		// TEMPLATE CLASS _Vector_iterator
; 286  : template<class _Myvec>
; 287  : 	class _Vector_iterator
; 288  : 		: public _Vector_const_iterator<_Myvec>
; 289  : 	{	// iterator for mutable vector
; 290  : public:
; 291  : 	typedef _Vector_iterator<_Myvec> _Myiter;
; 292  : 	typedef _Vector_const_iterator<_Myvec> _Mybase;
; 293  : 	typedef random_access_iterator_tag iterator_category;
; 294  : 
; 295  : 	typedef typename _Myvec::value_type value_type;
; 296  : 	typedef typename _Myvec::difference_type difference_type;
; 297  : 	typedef typename _Myvec::pointer pointer;
; 298  : 	typedef typename _Myvec::reference reference;
; 299  : 
; 300  : 	_Vector_iterator()
; 301  : 		{	// construct with null vector pointer
; 302  : 		}
; 303  : 
; 304  : 	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
; 305  : 		: _Mybase(_Parg, _Pvector)
; 306  : 		{	// construct with pointer _Parg
; 307  : 		}
; 308  : 
; 309  : 	typedef pointer _Unchecked_type;
; 310  : 
; 311  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 312  : 		{	// reset from unchecked iterator
; 313  : 		this->_Ptr = _Right;
; 314  : 		return (*this);
; 315  : 		}
; 316  : 
; 317  : 	_Unchecked_type _Unchecked() const
; 318  : 		{	// make an unchecked iterator
; 319  : 		return (_Unchecked_type(this->_Ptr));
; 320  : 		}
; 321  : 
; 322  : 	reference operator*() const
; 323  : 		{	// return designated object
; 324  : 		return ((reference)**(_Mybase *)this);
; 325  : 		}
; 326  : 
; 327  : 	pointer operator->() const
; 328  : 		{	// return pointer to class object
; 329  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 330  : 		}
; 331  : 
; 332  : 	_Myiter& operator++()
; 333  : 		{	// preincrement
; 334  : 		++*(_Mybase *)this;
; 335  : 		return (*this);
; 336  : 		}
; 337  : 
; 338  : 	_Myiter operator++(int)
; 339  : 		{	// postincrement
; 340  : 		_Myiter _Tmp = *this;
; 341  : 		++*this;
; 342  : 		return (_Tmp);
; 343  : 		}
; 344  : 
; 345  : 	_Myiter& operator--()
; 346  : 		{	// predecrement
; 347  : 		--*(_Mybase *)this;
; 348  : 		return (*this);
; 349  : 		}
; 350  : 
; 351  : 	_Myiter operator--(int)
; 352  : 		{	// postdecrement
; 353  : 		_Myiter _Tmp = *this;
; 354  : 		--*this;
; 355  : 		return (_Tmp);
; 356  : 		}
; 357  : 
; 358  : 	_Myiter& operator+=(difference_type _Off)
; 359  : 		{	// increment by integer
; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);
; 362  : 		}
; 363  : 
; 364  : 	_Myiter operator+(difference_type _Off) const
; 365  : 		{	// return this + integer
; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

  00238	49 89 0c 24	 mov	 QWORD PTR [r12], rcx

; 1656 : 		}

  0023c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00240	41 5f		 pop	 r15
  00242	41 5e		 pop	 r14
  00244	41 5c		 pop	 r12
  00246	5f		 pop	 rdi
  00247	5e		 pop	 rsi
  00248	c3		 ret	 0
$LN218@Insert_n:

; 1657 : 
; 1658 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1659 : 		{	// copy initializing _Count * _Val, using allocator
; 1660 : 		_Alty _Alval(this->_Getal());
; 1661 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1662 : 		return (_Ptr + _Count);
; 1663 : 		}
; 1664 : 
; 1665 : 	__declspec(noreturn) void _Xlen() const
; 1666 : 		{	// report a length_error
; 1667 : 		_Xlength_error("vector<T> too long");

  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00250	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00255	cc		 int	 3
$LN79@Insert_n:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00256	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0025b	cc		 int	 3
$LN217@Insert_n:
?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--, COMDAT

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]

; 74   : 		return (*this);

  00007	48 8b c1	 mov	 rax, rcx
  0000a	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 75   : 		}

  0000d	c3		 ret	 0
??F?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAAAEAV01@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 307  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator==, COMDAT

; 204  : 		_Compat(_Right);
; 205  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00006	0f 94 c0	 sete	 al

; 206  : 		}

  00009	c3		 ret	 0
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator!=, COMDAT

; 205  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx

; 210  : 		return (!(*this == _Right));

  00006	0f 95 c0	 setne	 al

; 211  : 		}

  00009	c3		 ret	 0
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_Next$ = 56
_Prev$ = 64
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z PROC ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0, COMDAT

; 787  : 		{	// allocate a node and set links

$LN77:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000a	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 787  : 		{	// allocate a node and set links

  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b da	 mov	 rbx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00015	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001a	48 85 c0	 test	 rax, rax
  0001d	74 25		 je	 SHORT $LN75@Buynode0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 790  : 		if (_Next == _Nodeptr())

  0001f	48 85 db	 test	 rbx, rbx
  00022	75 06		 jne	 SHORT $LN2@Buynode0

; 791  : 			{	// point at self
; 792  : 			_Next = _Pnode;

  00024	48 8b d8	 mov	 rbx, rax

; 793  : 			_Prev = _Pnode;

  00027	48 8b f8	 mov	 rdi, rax
$LN2@Buynode0:

; 542  : 		return ((_Nodepref)_Pnode->_Prev);

  0002a	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0002e	48 89 18	 mov	 QWORD PTR [rax], rbx
  00031	48 85 c9	 test	 rcx, rcx
  00034	74 03		 je	 SHORT $LN62@Buynode0
  00036	48 89 39	 mov	 QWORD PTR [rcx], rdi
$LN62@Buynode0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 806  : 		}

  00039	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
$LN75@Buynode0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00044	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00049	cc		 int	 3
$LN74@Buynode0:
?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ENDP ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Unused_capacity, COMDAT

; 972  : 		return (this->_Myend - this->_Mylast);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 41 08	 sub	 rax, QWORD PTR [rcx+8]
  00008	48 c1 f8 03	 sar	 rax, 3

; 973  : 		}

  0000c	c3		 ret	 0
?_Unused_capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::size, COMDAT

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 03	 sar	 rax, 3

; 1088 : 		}

  0000b	c3		 ret	 0
?size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size, COMDAT

; 1092 : 		return (this->_Getal().max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 1093 : 		}

  0000a	c3		 ret	 0
?max_size@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBA_K_K@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Grow_to, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00004	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 967  : 		return (this->_Myend - this->_Myfirst);

  0000e	4c 2b 01	 sub	 r8, QWORD PTR [rcx]
  00011	49 c1 f8 03	 sar	 r8, 3

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00015	49 8b c8	 mov	 rcx, r8
  00018	48 d1 e9	 shr	 rcx, 1
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	49 3b c0	 cmp	 rax, r8
  00021	73 0e		 jae	 SHORT $LN4@Grow_to
  00023	45 33 c0	 xor	 r8d, r8d

; 1489 : 		if (_Capacity < _Count)

  00026	4c 3b c2	 cmp	 r8, rdx
  00029	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0002d	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  00030	c3		 ret	 0
$LN4@Grow_to:

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00031	4c 03 c1	 add	 r8, rcx

; 1489 : 		if (_Capacity < _Count)

  00034	4c 3b c2	 cmp	 r8, rdx
  00037	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0003b	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  0003e	c3		 ret	 0
?_Grow_to@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBA_K_K@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@PEAV32@_KPEBV32@@Z
_TEXT	SEGMENT
this$dead$ = 64
_Ptr$ = 72
_Count$ = 80
_Pval$ = 88
?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@PEAV32@_KPEBV32@@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Ufill, COMDAT

; 1659 : 		{	// copy initializing _Count * _Val, using allocator

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b da	 mov	 rbx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 613  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00010	4d 8b c1	 mov	 r8, r9
  00013	48 8b d7	 mov	 rdx, rdi
  00016	48 8b cb	 mov	 rcx, rbx
  00019	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1662 : 		return (_Ptr + _Count);

  0001e	48 8d 04 fb	 lea	 rax, QWORD PTR [rbx+rdi*8]

; 1663 : 		}

  00022	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00027	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002b	5f		 pop	 rdi
  0002c	c3		 ret	 0
?_Ufill@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@PEAV32@_KPEBV32@@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Xlen, COMDAT

; 1666 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1667 : 		_Xlength_error("vector<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Orphan_range, COMDAT

; 1694 : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_range@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEBAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN19:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 21		 je	 SHORT $LN8@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 17		 ja	 SHORT $LN17@allocate
  0001a	48 8d 0c d5 00
	00 00 00	 lea	 rcx, QWORD PTR [rdx*8]
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00027	48 85 c0	 test	 rax, rax
  0002a	74 05		 je	 SHORT $LN17@allocate
$LN8@allocate:

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN17@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00036	cc		 int	 3
$LN16@allocate:
?allocate@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA?AV01@_J@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Off$ = 24
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA?AV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+, COMDAT

; 170  : 		_Ptr += _Off;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	4a 8d 0c c0	 lea	 rcx, QWORD PTR [rax+r8*8]

; 366  : 		_Myiter _Tmp = *this;
; 367  : 		return (_Tmp += _Off);

  00007	48 8b c2	 mov	 rax, rdx
  0000a	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 368  : 		}

  0000d	c3		 ret	 0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA?AV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pvector$dead$ = 24
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >, COMDAT

; 47   : 		{	// construct with pointer _Parg

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 48   : 		this->_Adopt(_Pvector);
; 49   : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Compat, COMDAT

; 255  : 		}

  00000	c2 00 00	 ret	 0
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBAXAEBV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00009	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0000e	48 85 c0	 test	 rax, rax
  00011	74 05		 je	 SHORT $LN15@allocate

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
$LN15@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00018	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0001d	cc		 int	 3
$LN14@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::capacity, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 03	 sar	 rax, 3

; 968  : 		}

  0000b	c3		 ret	 0
?capacity@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 21		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 17		 ja	 SHORT $LN14@allocate
  0001a	48 8d 0c d5 00
	00 00 00	 lea	 rcx, QWORD PTR [rdx*8]
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00027	48 85 c0	 test	 rax, rax
  0002a	74 05		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00036	cc		 int	 3
$LN13@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size, COMDAT

; 914  : 		return (_Mytraits::max_size(*this));

  00000	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 915  : 		}

  0000a	c3		 ret	 0
?max_size@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+=, COMDAT

; 170  : 		_Ptr += _Off;

  00000	48 8d 04 d5 00
	00 00 00	 lea	 rax, QWORD PTR [rdx*8]
  00008	48 01 01	 add	 QWORD PTR [rcx], rax

; 360  : 		*(_Mybase *)this += _Off;
; 361  : 		return (*this);

  0000b	48 8b c1	 mov	 rax, rcx

; 362  : 		}

  0000e	c3		 ret	 0
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$dead$ = 56
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z PROC ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00009	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0000e	48 85 c0	 test	 rax, rax
  00011	74 05		 je	 SHORT $LN12@allocate

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
$LN12@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00018	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0001d	cc		 int	 3
$LN11@allocate:
?allocate@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@_K@Z ENDP ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 21		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 17		 ja	 SHORT $LN11@allocate
  0001a	48 8d 0c d5 00
	00 00 00	 lea	 rcx, QWORD PTR [rdx*8]
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00027	48 85 c0	 test	 rax, rax
  0002a	74 05		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00036	cc		 int	 3
$LN10@allocate:
?allocate@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@_K@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size, COMDAT

; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));

  00000	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 492  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+=, COMDAT

; 154  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 155  : 		if (this->_Getcont() == 0
; 156  : 			|| this->_Ptr + _Off < ((_Myvec *)this->_Getcont())->_Myfirst
; 157  : 			|| ((_Myvec *)this->_Getcont())->_Mylast < this->_Ptr + _Off)
; 158  : 			{	// report error
; 159  : 			_DEBUG_ERROR("vector iterator + offset out of range");
; 160  : 			_SCL_SECURE_OUT_OF_RANGE;
; 161  : 			}
; 162  : 
; 163  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 164  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0);
; 165  : 		_SCL_SECURE_VALIDATE_RANGE(
; 166  : 			((_Myvec *)this->_Getcont())->_Myfirst <= this->_Ptr + _Off
; 167  : 			&& this->_Ptr + _Off <= ((_Myvec *)this->_Getcont())->_Mylast);
; 168  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 169  : 
; 170  : 		_Ptr += _Off;

  00000	48 8d 04 d5 00
	00 00 00	 lea	 rax, QWORD PTR [rdx*8]
  00008	48 01 01	 add	 QWORD PTR [rcx], rax

; 171  : 		return (*this);

  0000b	48 8b c1	 mov	 rax, rcx

; 172  : 		}

  0000e	c3		 ret	 0
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@_J@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z
_TEXT	SEGMENT
this$ = 48
_Px$ = 56
??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>, COMDAT

; 485  : 		explicit shared_ptr(_Ux *_Px)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00008	48 8b d9	 mov	 rbx, rcx

; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00012	e8 00 00 00 00	 call	 ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>

; 488  : 		}

  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
??$?0VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVEmptyChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0AEBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBVChunkPosition@@$$QEAV?$shared_ptr@VChunkBase@@@1@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
__formal$dead$ = 32
??$?0AEBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBVChunkPosition@@$$QEAV?$shared_ptr@VChunkBase@@@1@PEAPEAX@Z PROC ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const & __ptr64,std::shared_ptr<ChunkBase> >, COMDAT

; 138  : 		{	// construct from moved values

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	4c 8b c9	 mov	 r9, rcx
  00005	89 01		 mov	 DWORD PTR [rcx], eax
  00007	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  0000a	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0000d	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  00010	48 8d 51 10	 lea	 rdx, QWORD PTR [rcx+16]
  00014	89 41 08	 mov	 DWORD PTR [rcx+8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00017	33 c9		 xor	 ecx, ecx
  00019	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0001c	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00020	49 3b d0	 cmp	 rdx, r8
  00023	74 18		 je	 SHORT $LN36@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00025	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00029	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0002d	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  00031	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00034	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00037	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  0003a	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN36@shared_ptr:

; 139  : 		}

  0003d	49 8b c1	 mov	 rax, r9
  00040	c3		 ret	 0
??$?0AEBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBVChunkPosition@@$$QEAV?$shared_ptr@VChunkBase@@@1@PEAPEAX@Z ENDP ; std::pair<ChunkPosition,std::shared_ptr<ChunkBase> >::pair<ChunkPosition,std::shared_ptr<ChunkBase> ><ChunkPosition const & __ptr64,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
_Val$ = 80
??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 380  : 		typename enable_if<is_convertible<_Valty, value_type>::value,

$LN90:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  0000f	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00012	4d 8b c8	 mov	 r9, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 380  : 		typename enable_if<is_convertible<_Valty, value_type>::value,

  00015	48 8b f2	 mov	 rsi, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 96   : 		return (_Ptr);

  00018	48 8b 38	 mov	 rdi, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 380  : 		typename enable_if<is_convertible<_Valty, value_type>::value,

  0001b	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  0001e	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  00022	48 8b d7	 mov	 rdx, rdi
  00025	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >

; 1087 : #undef _LIST_EMPLACE_CHECK
; 1088 : #undef _LIST_EMPLACE_INSERT
; 1089 : 
; 1090 : 	~list() _NOEXCEPT
; 1091 : 		{	// destroy the object
; 1092 : 		_Tidy();
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();
; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();
; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();
; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());
; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());
; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1916 : 		}
; 1917 : 
; 1918 : 	void _Assign_n(size_type _Count, const _Ty& _Val)
; 1919 : 		{	// assign _Count * _Val
; 1920 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1921 : 		clear();
; 1922 : 		_Insert_n(_Unchecked_begin(), _Count, _Tmp);
; 1923 : 		}
; 1924 : 
; 1925 : 	void _Tidy()
; 1926 : 		{	// free all storage
; 1927 : 		clear();
; 1928 : 		}
; 1929 : 
; 1930 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1931 : 		size_type _Count, const _Ty& _Val)
; 1932 : 		{	// insert _Count * _Val at _Where
; 1933 : 		size_type _Countsave = _Count;
; 1934 : 
; 1935 : 		_TRY_BEGIN
; 1936 : 		for (; 0 < _Count; --_Count)
; 1937 : 			_Insert(_Where, _Val);
; 1938 : 		_CATCH_ALL
; 1939 : 		for (; _Count < _Countsave; ++_Count)
; 1940 : 			{	// undo inserts
; 1941 : 			_Unchecked_const_iterator _Before = _Where;
; 1942 : 			_Unchecked_erase(--_Before);
; 1943 : 			}
; 1944 : 		_RERAISE;
; 1945 : 		_CATCH_END
; 1946 : 		}
; 1947 : 
; 1948 : 	void _Incsize(size_type _Count)
; 1949 : 		{	// alter element count, with checking
; 1950 : 		if (max_size() - this->_Mysize - 1 < _Count)

  0002a	49 b8 54 55 55
	55 55 55 55 05	 mov	 r8, 384307168202282324	; 0555555555555554H

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00034	48 8b c8	 mov	 rcx, rax

; 1087 : #undef _LIST_EMPLACE_CHECK
; 1088 : #undef _LIST_EMPLACE_INSERT
; 1089 : 
; 1090 : 	~list() _NOEXCEPT
; 1091 : 		{	// destroy the object
; 1092 : 		_Tidy();
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();
; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();
; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();
; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());
; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());
; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1916 : 		}
; 1917 : 
; 1918 : 	void _Assign_n(size_type _Count, const _Ty& _Val)
; 1919 : 		{	// assign _Count * _Val
; 1920 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1921 : 		clear();
; 1922 : 		_Insert_n(_Unchecked_begin(), _Count, _Tmp);
; 1923 : 		}
; 1924 : 
; 1925 : 	void _Tidy()
; 1926 : 		{	// free all storage
; 1927 : 		clear();
; 1928 : 		}
; 1929 : 
; 1930 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1931 : 		size_type _Count, const _Ty& _Val)
; 1932 : 		{	// insert _Count * _Val at _Where
; 1933 : 		size_type _Countsave = _Count;
; 1934 : 
; 1935 : 		_TRY_BEGIN
; 1936 : 		for (; 0 < _Count; --_Count)
; 1937 : 			_Insert(_Where, _Val);
; 1938 : 		_CATCH_ALL
; 1939 : 		for (; _Count < _Countsave; ++_Count)
; 1940 : 			{	// undo inserts
; 1941 : 			_Unchecked_const_iterator _Before = _Where;
; 1942 : 			_Unchecked_erase(--_Before);
; 1943 : 			}
; 1944 : 		_RERAISE;
; 1945 : 		_CATCH_END
; 1946 : 		}
; 1947 : 
; 1948 : 	void _Incsize(size_type _Count)
; 1949 : 		{	// alter element count, with checking
; 1950 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00037	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0003b	4c 2b c0	 sub	 r8, rax
  0003e	49 83 f8 01	 cmp	 r8, 1
  00042	72 49		 jb	 SHORT $LN88@insert

; 1952 : 		this->_Mysize += _Count;

  00044	48 ff c0	 inc	 rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 385  : 		return (_Insert(_List.front(), _Unchecked_begin()));

  00047	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1952 : 		this->_Mysize += _Count;

  0004c	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00050	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00054	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00058	48 89 08	 mov	 QWORD PTR [rax], rcx

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  0005b	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 385  : 		return (_Insert(_List.front(), _Unchecked_begin()));

  0005e	48 8b cb	 mov	 rcx, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00061	4d 8b 09	 mov	 r9, QWORD PTR [r9]

; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00064	4d 8d 41 10	 lea	 r8, QWORD PTR [r9+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 385  : 		return (_Insert(_List.front(), _Unchecked_begin()));

  00068	e8 00 00 00 00	 call	 ??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >

; 386  : 		}

  0006d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00072	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00075	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00079	88 46 08	 mov	 BYTE PTR [rsi+8], al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 385  : 		return (_Insert(_List.front(), _Unchecked_begin()));

  0007c	48 8b c6	 mov	 rax, rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0007f	48 89 0e	 mov	 QWORD PTR [rsi], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 386  : 		}

  00082	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00087	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008b	5f		 pop	 rdi
  0008c	c3		 ret	 0
$LN88@insert:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1951 : 			_Xlength_error("list<T> too long");

  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00094	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00099	cc		 int	 3
$LN87@insert:
??$insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAU01@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAU01@PEAPEAX@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 182  : 		{	// construct from moved compatible pair

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 183  : 		}

  0000e	48 8b c1	 mov	 rax, rcx
  00011	c3		 ret	 0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAU01@PEAPEAX@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Distance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_K@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
??$_Distance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_K@Z PROC ; std::_Distance<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 3b ca	 cmp	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00003	74 0b		 je	 SHORT $LN5@Distance
$LL12@Distance:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00005	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 799  : 		++_Off;

  00008	49 ff 00	 inc	 QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0000b	48 3b ca	 cmp	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  0000e	75 f5		 jne	 SHORT $LL12@Distance
$LN5@Distance:

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));
; 832  : 	}

  00010	f3 c3		 fatret	 0
??$_Distance@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_K@Z ENDP ; std::_Distance<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$dead$ = 16
??$?0V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > ><std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >, COMDAT

; 847  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$?0V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > ><std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\unordered_map
;	COMDAT ??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
_Val$ = 8
??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >, COMDAT

; 59   : 		{	// extract key from element value
; 60   : 		return (_Val.first);

  00000	48 8b c1	 mov	 rax, rcx

; 61   : 		}

  00003	c3		 ret	 0
??$_Kfn@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@SAAEBVChunkPosition@@AEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0>::_Kfn<ChunkPosition const ,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
__formal$dead$ = 32
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PEAPEAX@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 138  : 		{	// construct from moved values

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00009	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 139  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V01@@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@0PEAPEAX@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::addressof<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::addressof<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 907  : 		void destroy(_Ty *_Ptr)

$LN25:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN20@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN23@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN23@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN23@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN20@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 910  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >, COMDAT

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 81   : 	}

  00000	c2 00 00	 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00@Z PROC ; std::_Move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>, COMDAT

; 2485 : 	{	// move [_First, _Last) to [_Dest, ...), unchecked

  00000	49 8b c0	 mov	 rax, r8

; 2465 : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	48 3b ca	 cmp	 rcx, rdx
  00006	74 1c		 je	 SHORT $LN15@Move
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL7@Move:

; 2466 : 		*_Dest = _STD move(*_First);

  00010	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00013	48 83 c1 08	 add	 rcx, 8
  00017	48 83 c0 08	 add	 rax, 8
  0001b	4c 89 40 f8	 mov	 QWORD PTR [rax-8], r8
  0001f	48 3b ca	 cmp	 rcx, rdx
  00022	75 ec		 jne	 SHORT $LL7@Move
$LN15@Move:

; 2486 : 	return (_Move(_First, _Last,
; 2487 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2488 : 	}

  00024	f3 c3		 fatret	 0
??$_Move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00@Z ENDP ; std::_Move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@$$CBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEAV21@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEAV21@00@Z PROC ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>, COMDAT

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	49 8b c0	 mov	 rax, r8
  00007	48 8b ca	 mov	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0000a	4d 8b c1	 mov	 r8, r9
  0000d	48 8b d0	 mov	 rdx, rax
  00010	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1562 : 		}

  00015	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00019	c3		 ret	 0
??$_Umove@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@PEAV21@00@Z ENDP ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Umove<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 2645 : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 1b		 je	 SHORT $LN7@fill
  00005	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL9@fill:

; 2646 : 		*_First = _Val;

  00010	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00013	48 83 c1 08	 add	 rcx, 8
  00017	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	75 f0		 jne	 SHORT $LL9@fill
$LN7@fill:

; 2668 : 	_DEBUG_RANGE(_First, _Last);
; 2669 : 	_Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
; 2670 : 	}

  00020	f3 c3		 fatret	 0
??$fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
??$_Copy_backward@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00@Z PROC ; std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>, COMDAT

; 2411 : 	{	// copy [_First, _Last) backwards to [..., _Dest), unchecked

  00000	49 8b c0	 mov	 rax, r8

; 2391 : 	while (_First != _Last)

  00003	48 3b ca	 cmp	 rcx, rdx
  00006	74 1c		 je	 SHORT $LN12@Copy_backw
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL6@Copy_backw:

; 2392 : 		*--_Dest = *--_Last;

  00010	4c 8b 42 f8	 mov	 r8, QWORD PTR [rdx-8]
  00014	48 83 ea 08	 sub	 rdx, 8
  00018	48 83 e8 08	 sub	 rax, 8
  0001c	4c 89 00	 mov	 QWORD PTR [rax], r8
  0001f	48 3b d1	 cmp	 rdx, rcx
  00022	75 ec		 jne	 SHORT $LL6@Copy_backw
$LN12@Copy_backw:

; 2412 : 	return (_Copy_backward(_First, _Last,
; 2413 : 		_Dest, _Ptr_cat(_First, _Dest)));
; 2414 : 	}

  00024	f3 c3		 fatret	 0
??$_Copy_backward@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00@Z ENDP ; std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN11@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN11@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Count$ = 72
_Pval$ = 80
_Al$dead$ = 88
??$_Uninitialized_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >, COMDAT

; 611  : 	{	// copy _Count * *_Pval to raw _First, using _Al

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 612  : 	_Uninit_fill_n(_First, _Count, _Pval, _Al,
; 613  : 		_Val_type(_First), _Ptr_cat(_First, _First));

  00004	e8 00 00 00 00	 call	 ??$_Uninit_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >

; 614  : 	}

  00009	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000d	c3		 ret	 0
??$_Uninitialized_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z PROC ; std::_Allocate<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 55 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282325	; 0555555555555555H
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 17		 ja	 SHORT $LN12@Allocate
  00013	48 8d 0c 49	 lea	 rcx, QWORD PTR [rcx+rcx*2]
  00017	48 c1 e1 04	 shl	 rcx, 4
  0001b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00020	48 85 c0	 test	 rax, rax
  00023	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002a	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002f	cc		 int	 3
$LN11@Allocate:
??$_Allocate@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@_KPEAU10@@Z ENDP ; std::_Allocate<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEAV10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEAV10@@Z PROC ; std::_Allocate<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 17		 ja	 SHORT $LN12@Allocate
  00013	48 8d 0c cd 00
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8]
  0001b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00020	48 85 c0	 test	 rax, rax
  00023	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002a	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002f	cc		 int	 3
$LN11@Allocate:
??$_Allocate@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEAV10@@Z ENDP ; std::_Allocate<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SA_KHAEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SA_KHAEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >, COMDAT

; 381  : 		return (_Al.max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 382  : 		}

  0000a	c3		 ret	 0
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@_Alloc_max_size@std@@SA_KHAEBU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Alloc_max_size::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Unchecked_begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Unchecked_begin, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 44   : 		{	// construct with node pointer _Pnode

  00003	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 449  : 		return (_List._Unchecked_begin());

  00006	48 8b c2	 mov	 rax, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00009	48 89 0a	 mov	 QWORD PTR [rdx], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 450  : 		}

  0000c	c3		 ret	 0
?_Unchecked_begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?front@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?front@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@XZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::front, COMDAT

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00003	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00006	48 83 c0 10	 add	 rax, 16

; 1257 : 		return (*begin());
; 1258 : 		}

  0000a	c3		 ret	 0
?front@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@XZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::max_size, COMDAT

; 914  : 		return (_Mytraits::max_size(*this));

  00000	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 915  : 		}

  0000a	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Unchecked_begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Unchecked_begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_begin, COMDAT

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 44   : 		{	// construct with node pointer _Pnode

  00003	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),

  00006	48 8b c2	 mov	 rax, rdx

; 44   : 		{	// construct with node pointer _Pnode

  00009	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 1136 : 			this));
; 1137 : 		}

  0000c	c3		 ret	 0
?_Unchecked_begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::max_size, COMDAT

; 762  : 		return (_Al.max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 763  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::max_size, COMDAT

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH

; 629  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>, COMDAT

; 708  : 		void _Resetp(_Ux *_Px)

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  0001e	b9 18 00 00 00	 mov	 ecx, 24
  00023	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00028	48 85 c0	 test	 rax, rax
  0002b	74 1c		 je	 SHORT $LN5@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0002d	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1
  00034	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$_Ref_count@VEmptyChunk@@@std@@6B@
  00042	48 89 08	 mov	 QWORD PTR [rax], rcx
  00045	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
$LN5@Resetp:

; 717  : 
; 718  : 	template<class _Ux,
; 719  : 		class _Dx>
; 720  : 		void _Resetp(_Ux *_Px, _Dx _Dt)
; 721  : 		{	// release, take ownership of _Px, deleter _Dt
; 722  : 		_TRY_BEGIN	// allocate control block and reset
; 723  : 		_Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
; 724  : 		_CATCH_ALL	// allocation failed, delete resource
; 725  : 		_Dt(_Px);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : //#if _HAS_CPP0X
; 731  : 	template<class _Ux,
; 732  : 		class _Dx,
; 733  : 		class _Alloc>
; 734  : 		void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 735  : 		{	// release, take ownership of _Px, deleter _Dt, allocator _Ax
; 736  : 		typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
; 737  : 		typename _Alloc::template rebind<_Refd>::other _Al = _Ax;
; 738  : 
; 739  : 		_TRY_BEGIN	// allocate control block and reset
; 740  : 		_Refd *_Ptr = _Al.allocate(1);
; 741  : 		::new (_Ptr) _Refd(_Px, _Dt, _Al);
; 742  : 		_Resetp0(_Px, _Ptr);
; 743  : 		_CATCH_ALL	// allocation failed, delete resource
; 744  : 		_Dt(_Px);
; 745  : 		_RERAISE;
; 746  : 		_CATCH_END
; 747  : 		}
; 748  : //#endif /* _HAS_CPP0X */
; 749  : 
; 750  : public:
; 751  : 	template<class _Ux>
; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00049	4c 8b c0	 mov	 r8, rax
  0004c	48 8b d3	 mov	 rdx, rbx
  0004f	48 8b cf	 mov	 rcx, rdi
  00052	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
  00057	90		 npad	 1

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;
; 714  : 		_RERAISE;
; 715  : 		_CATCH_END
; 716  : 		}

  00058	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN30@Resetp:
??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA PROC ; `std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>'::`1'::catch$0

; 712  : 		_CATCH_ALL	// allocation failed, delete resource

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000b	48 8b ea	 mov	 rbp, rdx
__catch$??$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z$0:

; 713  : 		delete _Px;

  0000e	48 8b 5d 48	 mov	 rbx, QWORD PTR _Px$[rbp]
  00012	48 85 db	 test	 rbx, rbx
  00015	74 1a		 je	 SHORT $LN25@catch$0
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 117  : {

  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  0001e	48 89 03	 mov	 QWORD PTR [rbx], rax

; 118  : 
; 119  : }

  00021	48 8b cb	 mov	 rcx, rbx
  00024	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN25@catch$0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 714  : 		_RERAISE;

  00031	33 d2		 xor	 edx, edx
  00033	33 c9		 xor	 ecx, ecx
  00035	e8 00 00 00 00	 call	 _CxxThrowException
  0003a	90		 npad	 1
?catch$0@?0???$_Resetp@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVEmptyChunk@@@Z@4HA ENDP ; `std::shared_ptr<ChunkBase>::_Resetp<EmptyChunk>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z PROC ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YA$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??$emplace_front@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_V0$ = 56
??$emplace_front@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::emplace_front<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

$LN47:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  0000a	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  0000d	4c 8b ca	 mov	 r9, rdx
  00010	48 8b d9	 mov	 rbx, rcx

; 96   : 		return (_Ptr);

  00013	48 8b 38	 mov	 rdi, QWORD PTR [rax]

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00016	48 8b d7	 mov	 rdx, rdi
  00019	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  0001d	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >

; 1087 : #undef _LIST_EMPLACE_CHECK
; 1088 : #undef _LIST_EMPLACE_INSERT
; 1089 : 
; 1090 : 	~list() _NOEXCEPT
; 1091 : 		{	// destroy the object
; 1092 : 		_Tidy();
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();
; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();
; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();
; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());
; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());
; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1916 : 		}
; 1917 : 
; 1918 : 	void _Assign_n(size_type _Count, const _Ty& _Val)
; 1919 : 		{	// assign _Count * _Val
; 1920 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1921 : 		clear();
; 1922 : 		_Insert_n(_Unchecked_begin(), _Count, _Tmp);
; 1923 : 		}
; 1924 : 
; 1925 : 	void _Tidy()
; 1926 : 		{	// free all storage
; 1927 : 		clear();
; 1928 : 		}
; 1929 : 
; 1930 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1931 : 		size_type _Count, const _Ty& _Val)
; 1932 : 		{	// insert _Count * _Val at _Where
; 1933 : 		size_type _Countsave = _Count;
; 1934 : 
; 1935 : 		_TRY_BEGIN
; 1936 : 		for (; 0 < _Count; --_Count)
; 1937 : 			_Insert(_Where, _Val);
; 1938 : 		_CATCH_ALL
; 1939 : 		for (; _Count < _Countsave; ++_Count)
; 1940 : 			{	// undo inserts
; 1941 : 			_Unchecked_const_iterator _Before = _Where;
; 1942 : 			_Unchecked_erase(--_Before);
; 1943 : 			}
; 1944 : 		_RERAISE;
; 1945 : 		_CATCH_END
; 1946 : 		}
; 1947 : 
; 1948 : 	void _Incsize(size_type _Count)
; 1949 : 		{	// alter element count, with checking
; 1950 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00022	48 ba 54 55 55
	55 55 55 55 05	 mov	 rdx, 384307168202282324	; 0555555555555554H

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  0002c	4c 8b c0	 mov	 r8, rax

; 1087 : #undef _LIST_EMPLACE_CHECK
; 1088 : #undef _LIST_EMPLACE_INSERT
; 1089 : 
; 1090 : 	~list() _NOEXCEPT
; 1091 : 		{	// destroy the object
; 1092 : 		_Tidy();
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();
; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();
; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();
; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());
; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());
; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1916 : 		}
; 1917 : 
; 1918 : 	void _Assign_n(size_type _Count, const _Ty& _Val)
; 1919 : 		{	// assign _Count * _Val
; 1920 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1921 : 		clear();
; 1922 : 		_Insert_n(_Unchecked_begin(), _Count, _Tmp);
; 1923 : 		}
; 1924 : 
; 1925 : 	void _Tidy()
; 1926 : 		{	// free all storage
; 1927 : 		clear();
; 1928 : 		}
; 1929 : 
; 1930 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1931 : 		size_type _Count, const _Ty& _Val)
; 1932 : 		{	// insert _Count * _Val at _Where
; 1933 : 		size_type _Countsave = _Count;
; 1934 : 
; 1935 : 		_TRY_BEGIN
; 1936 : 		for (; 0 < _Count; --_Count)
; 1937 : 			_Insert(_Where, _Val);
; 1938 : 		_CATCH_ALL
; 1939 : 		for (; _Count < _Countsave; ++_Count)
; 1940 : 			{	// undo inserts
; 1941 : 			_Unchecked_const_iterator _Before = _Where;
; 1942 : 			_Unchecked_erase(--_Before);
; 1943 : 			}
; 1944 : 		_RERAISE;
; 1945 : 		_CATCH_END
; 1946 : 		}
; 1947 : 
; 1948 : 	void _Incsize(size_type _Count)
; 1949 : 		{	// alter element count, with checking
; 1950 : 		if (max_size() - this->_Mysize - 1 < _Count)

  0002f	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00033	48 2b d0	 sub	 rdx, rax
  00036	48 83 fa 01	 cmp	 rdx, 1
  0003a	72 1d		 jb	 SHORT $LN45@emplace_fr

; 1952 : 		this->_Mysize += _Count;

  0003c	48 ff c0	 inc	 rax
  0003f	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00043	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00048	4c 89 47 08	 mov	 QWORD PTR [rdi+8], r8

; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  0004c	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00050	4c 89 00	 mov	 QWORD PTR [rax], r8
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN45@emplace_fr:

; 1951 : 			_Xlength_error("list<T> too long");

  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  00060	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00065	cc		 int	 3
$LN44@emplace_fr:
??$emplace_front@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::emplace_front<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Val$ = 64
_Pnode$ = 72
??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 865  : 		_Pairib _Insert(_Valty&& _Val, _Nodety _Pnode)

$LN304:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00014	41 57		 push	 r15
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  0001a	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]

; 865  : 		_Pairib _Insert(_Valty&& _Val, _Nodety _Pnode)

  0001e	4c 8b f2	 mov	 r14, rdx

; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  00021	49 8b d0	 mov	 rdx, r8

; 865  : 		_Pairib _Insert(_Valty&& _Val, _Nodety _Pnode)

  00024	49 8b f9	 mov	 rdi, r9
  00027	4d 8b f8	 mov	 r15, r8
  0002a	48 8b f1	 mov	 rsi, rcx

; 981  : 			--_Vec_hi(_Bucket);	// or not
; 982  : 		}
; 983  : 
; 984  : 	void _Copy(const _Myt& _Right)
; 985  : 		{	// copy entire hash table
; 986  : 		_Mask = _Right._Mask;
; 987  : 		_Maxidx = _Right._Maxidx;
; 988  : 		_Max_bucket_size = _Right._Max_bucket_size;
; 989  : 		_List.clear();
; 990  : 
; 991  : 		_TRY_BEGIN
; 992  : 		(_Traits&)*this = (_Traits&)_Right;
; 993  : 		_Vec.assign(_Right._Vec.size(), _Unchecked_end());
; 994  : 		insert(_Right.begin(), _Right.end());
; 995  : 		_CATCH_ALL
; 996  : 		clear();	// list or compare copy failed, bail out
; 997  : 		_RERAISE;
; 998  : 		_CATCH_END
; 999  : 		}
; 1000 : 
; 1001 : 	size_type _Hashval(const key_type& _Keyval) const
; 1002 : 		{	// return hash value, masked and wrapped to current table size
; 1003 : 		size_type _Num = ((_Traits&)*this)(_Keyval) & _Mask;

  0002d	e8 00 00 00 00	 call	 ??R?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@std@@QEBA_KAEBVChunkPosition@@@Z ; std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >::operator()
  00032	4c 8b c8	 mov	 r9, rax
  00035	4c 23 cb	 and	 r9, rbx

; 1004 : 		if (_Maxidx <= _Num)

  00038	4c 39 4e 30	 cmp	 QWORD PTR [rsi+48], r9
  0003c	77 0d		 ja	 SHORT $LN22@Insert

; 1005 : 			_Num -= (_Mask >> 1) + 1;

  0003e	48 d1 eb	 shr	 rbx, 1
  00041	49 83 c8 ff	 or	 r8, -1
  00045	4c 2b c3	 sub	 r8, rbx
  00048	4d 03 c8	 add	 r9, r8
$LN22@Insert:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0004b	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  0004f	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00052	49 c1 e1 04	 shl	 r9, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00056	49 8b 14 01	 mov	 rdx, QWORD PTR [r9+rax]
  0005a	48 3b da	 cmp	 rbx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 936  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

  0005d	0f 84 7e 00 00
	00		 je	 $LN7@Insert
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00063	49 8b 5c 01 08	 mov	 rbx, QWORD PTR [r9+rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 941  : 			return (++_Ans);

  00068	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0006b	48 3b da	 cmp	 rbx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 873  : 		for (; _Where != _Begin(_Bucket); )

  0006e	74 71		 je	 SHORT $LN7@Insert
  00070	45 8b 47 08	 mov	 r8d, DWORD PTR [r15+8]
  00074	45 8b 57 04	 mov	 r10d, DWORD PTR [r15+4]
  00078	45 8b 1f	 mov	 r11d, DWORD PTR [r15]
  0007b	0f 1f 44 00 00	 npad	 5
$LL8@Insert:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  00080	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  00084	44 3b 53 14	 cmp	 r10d, DWORD PTR [rbx+20]
  00088	0f 94 c1	 sete	 cl
  0008b	44 3b 43 18	 cmp	 r8d, DWORD PTR [rbx+24]
  0008f	0f 94 c0	 sete	 al
  00092	22 c8		 and	 cl, al
  00094	44 3b 5b 10	 cmp	 r11d, DWORD PTR [rbx+16]
  00098	0f 94 c0	 sete	 al
  0009b	84 c8		 test	 cl, al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 874  : 			if (((_Traits&)*this)(this->_Kfn(_Val), this->_Kfn(*--_Where)))

  0009d	75 07		 jne	 SHORT $LN6@Insert
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0009f	48 3b da	 cmp	 rbx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 873  : 		for (; _Where != _Begin(_Bucket); )

  000a2	75 dc		 jne	 SHORT $LL8@Insert
  000a4	eb 3b		 jmp	 SHORT $LN7@Insert
$LN6@Insert:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 330  : 	return (cp1.x == cp2.x) & (cp1.y == cp2.y) & (cp1.z == cp2.z);

  000a6	44 39 53 14	 cmp	 DWORD PTR [rbx+20], r10d
  000aa	0f 94 c1	 sete	 cl
  000ad	44 39 43 18	 cmp	 DWORD PTR [rbx+24], r8d
  000b1	0f 94 c0	 sete	 al
  000b4	22 c8		 and	 cl, al
  000b6	44 39 5b 10	 cmp	 DWORD PTR [rbx+16], r11d
  000ba	0f 94 c0	 sete	 al
  000bd	84 c8		 test	 cl, al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 877  : 				|| ((_Traits&)*this)(this->_Kfn(*_Where), this->_Kfn(_Val)))

  000bf	75 05		 jne	 SHORT $LN4@Insert
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  000c1	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 880  : 				break;

  000c4	eb 1b		 jmp	 SHORT $LN7@Insert
$LN4@Insert:

; 881  : 				}
; 882  : 			else
; 883  : 				{	// discard new list element and return existing
; 884  : 				_Destroy_if_not_nil(_Pnode);

  000c6	48 8b d7	 mov	 rdx, rdi
  000c9	48 8b ce	 mov	 rcx, rsi
  000cc	e8 00 00 00 00	 call	 ?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  000d1	49 89 1e	 mov	 QWORD PTR [r14], rbx
  000d4	41 c6 46 08 00	 mov	 BYTE PTR [r14+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 885  : 				return (_Pairib(_Make_iter(_Where), false));

  000d9	49 8b c6	 mov	 rax, r14
  000dc	e9 91 00 00 00	 jmp	 $LN10@Insert
$LN7@Insert:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  000e1	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 86   : 		return (_Ptr == _Right._Ptr);

  000e4	48 3b d8	 cmp	 rbx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 896  : 		if (_Where != ++_Next)	// move element into place

  000e7	74 2d		 je	 SHORT $LN161@Insert
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  000e9	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]

; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);
; 548  : 		}
; 549  : 
; 550  : 	_Nodeptr _Myhead;	// pointer to head node
; 551  : 	size_type _Mysize;	// number of elements
; 552  : 	};
; 553  : 
; 554  : 		// TEMPLATE CLASS _List_alloc
; 555  : template<bool _Al_has_storage,
; 556  : 	class _Alloc_types>
; 557  : 	class _List_alloc
; 558  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 559  : 	{	// base class for list to hold allocator with storage
; 560  : public:
; 561  : 	typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 562  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 563  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 564  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 565  : 	typedef typename _Alloc_types::_Node _Node;
; 566  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 567  : 
; 568  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 569  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 570  : 		: _Alnod(_Al)
; 571  : 		{	// construct head node, allocator from _Al
; 572  : 		this->_Myhead = _Buyheadnode();
; 573  : 		}
; 574  : 
; 575  : 	~_List_alloc() _NOEXCEPT
; 576  : 		{	// destroy head node
; 577  : 		_Freeheadnode(this->_Myhead);
; 578  : 		}
; 579  : 
; 580  : 	void _Change_alloc(const _Alty& _Al)
; 581  : 		{	// replace old allocator
; 582  : 		_Alnod = _Al;
; 583  : 		}
; 584  : 
; 585  : 	void _Swap_alloc(_Myt& _Right)
; 586  : 		{	// swap allocators
; 587  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 588  : 		}
; 589  : 
; 590  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 591  : 	_List_alloc(const _Alloc& _Al = _Alloc())
; 592  : 		: _Alnod(_Al)
; 593  : 		{	// construct head node, allocator from _Al
; 594  : 		this->_Myhead = _Buyheadnode();
; 595  : 		_TRY_BEGIN
; 596  : 		_Alloc_proxy();
; 597  : 		_CATCH_ALL
; 598  : 		_Freeheadnode(this->_Myhead);
; 599  : 		_RERAISE;
; 600  : 		_CATCH_END
; 601  : 		}
; 602  : 
; 603  : 	~_List_alloc() _NOEXCEPT
; 604  : 		{	// destroy proxy
; 605  : 		_Freeheadnode(this->_Myhead);
; 606  : 		_Free_proxy();
; 607  : 		}
; 608  : 
; 609  : 	void _Change_alloc(const _Alty& _Al)
; 610  : 		{	// replace old allocator
; 611  : 		_Free_proxy();
; 612  : 		_Alnod = _Al;
; 613  : 		_Alloc_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Swap_alloc(_Myt& _Right)
; 617  : 		{	// swap allocators
; 618  : 		_Swap_adl(_Alnod, _Right._Alnod);
; 619  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 620  : 		}
; 621  : 
; 622  : 	void _Alloc_proxy()
; 623  : 		{	// construct proxy from _Alnod
; 624  : 		typename _Alty::template rebind<_Container_proxy>::other
; 625  : 			_Alproxy(_Alnod);
; 626  : 		this->_Myproxy = _Alproxy.allocate(1);
; 627  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 628  : 		this->_Myproxy->_Mycont = this;
; 629  : 		}
; 630  : 
; 631  : 	void _Free_proxy()
; 632  : 		{	// destroy proxy
; 633  : 		typename _Alty::template rebind<_Container_proxy>::other
; 634  : 			_Alproxy(_Alnod);
; 635  : 		this->_Orphan_all();
; 636  : 		_Alproxy.destroy(this->_Myproxy);
; 637  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 638  : 		this->_Myproxy = 0;
; 639  : 		}
; 640  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 641  : 
; 642  : 	_Nodeptr _Buyheadnode()
; 643  : 		{	// get head node using current allocator
; 644  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 645  : 		}
; 646  : 
; 647  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 648  : 		{	// free head node using current allocator
; 649  : 		_Alnod.destroy(
; 650  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 651  : 		_Alnod.destroy(
; 652  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 653  : 		_Alnod.deallocate(_Pnode, 1);
; 654  : 		}
; 655  : 
; 656  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 657  : 		_Nodeptr _Prev)
; 658  : 		{	// allocate a node and set links
; 659  : 		_Nodeptr _Pnode = _Alnod.allocate(1);
; 660  : 
; 661  : 		if (_Next == _Nodeptr())
; 662  : 			{	// point at self
; 663  : 			_Next = _Pnode;
; 664  : 			_Prev = _Pnode;
; 665  : 			}
; 666  : 		_TRY_BEGIN
; 667  : 		_Alnod.construct(
; 668  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 669  : 		_Alnod.construct(
; 670  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 671  : 		_CATCH_ALL
; 672  : 		_Alnod.deallocate(_Pnode, 1);
; 673  : 		_RERAISE;
; 674  : 		_CATCH_END
; 675  : 
; 676  : 		return (_Pnode);
; 677  : 		}
; 678  : 
; 679  : 	_Alty& _Getal()
; 680  : 		{	// get reference to allocator
; 681  : 		return (_Alnod);
; 682  : 		}
; 683  : 
; 684  : 	const _Alty& _Getal() const
; 685  : 		{	// get reference to allocator
; 686  : 		return (_Alnod);
; 687  : 		}
; 688  : 
; 689  : 	_Alty _Alnod;	// allocator object for stored elements
; 690  : 	};
; 691  : 
; 692  : 		// TEMPLATE CLASS _List_alloc
; 693  : template<class _Alloc_types>
; 694  : 	class _List_alloc<false, _Alloc_types>
; 695  : 		: public _List_val<typename _Alloc_types::_Val_types>
; 696  : 	{	// base class for list to hold allocator with no storage
; 697  : public:
; 698  : 	typedef _List_alloc<false, _Alloc_types> _Myt;
; 699  : 	typedef _List_val<typename _Alloc_types::_Val_types> _Mybase;
; 700  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 701  : 	typedef typename _Alloc_types::_Alnod_type _Alty;
; 702  : 	typedef typename _Alloc_types::_Node _Node;
; 703  : 	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
; 704  : 
; 705  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 706  : 	_List_alloc(const _Alloc& = _Alloc())
; 707  : 		{	// construct head node, allocator from _Al
; 708  : 		this->_Myhead = _Buyheadnode();
; 709  : 		}
; 710  : 
; 711  : 	~_List_alloc() _NOEXCEPT
; 712  : 		{	// destroy head node
; 713  : 		_Freeheadnode(this->_Myhead);
; 714  : 		}
; 715  : 
; 716  : 	void _Change_alloc(const _Alty&)
; 717  : 		{	// replace old allocator
; 718  : 		}
; 719  : 
; 720  : 	void _Swap_alloc(_Myt&)
; 721  : 		{	// swap allocators
; 722  : 		}
; 723  : 
; 724  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 725  : 	_List_alloc(const _Alloc& = _Alloc())
; 726  : 		{	// construct allocators from _Al
; 727  : 		this->_Myhead = _Buyheadnode();
; 728  : 		_TRY_BEGIN
; 729  : 		_Alloc_proxy();
; 730  : 		_CATCH_ALL
; 731  : 		_Freeheadnode(this->_Myhead);
; 732  : 		_RERAISE;
; 733  : 		_CATCH_END
; 734  : 		}
; 735  : 
; 736  : 	~_List_alloc() _NOEXCEPT
; 737  : 		{	// destroy proxy
; 738  : 		_Freeheadnode(this->_Myhead);
; 739  : 		_Free_proxy();
; 740  : 		}
; 741  : 
; 742  : 	void _Change_alloc(const _Alty&)
; 743  : 		{	// replace old allocator
; 744  : 		}
; 745  : 
; 746  : 	void _Swap_alloc(_Myt& _Right)
; 747  : 		{	// swap allocators
; 748  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 749  : 		}
; 750  : 
; 751  : 	void _Alloc_proxy()
; 752  : 		{	// construct proxy from _Alnod
; 753  : 		typename _Alty::template rebind<_Container_proxy>::other
; 754  : 			_Alproxy;
; 755  : 		this->_Myproxy = _Alproxy.allocate(1);
; 756  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 757  : 		this->_Myproxy->_Mycont = this;
; 758  : 		}
; 759  : 
; 760  : 	void _Free_proxy()
; 761  : 		{	// destroy proxy
; 762  : 		typename _Alty::template rebind<_Container_proxy>::other
; 763  : 			_Alproxy;
; 764  : 		this->_Orphan_all();
; 765  : 		_Alproxy.destroy(this->_Myproxy);
; 766  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 767  : 		this->_Myproxy = 0;
; 768  : 		}
; 769  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 770  : 
; 771  : 	_Nodeptr _Buyheadnode()
; 772  : 		{	// get head node using current allocator
; 773  : 		return (_Buynode0(_Nodeptr(), _Nodeptr()));
; 774  : 		}
; 775  : 
; 776  : 	void _Freeheadnode(_Nodeptr _Pnode)
; 777  : 		{	// free head node using current allocator
; 778  : 		this->_Getal().destroy(
; 779  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 780  : 		this->_Getal().destroy(
; 781  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 782  : 		this->_Getal().deallocate(_Pnode, 1);
; 783  : 		}
; 784  : 
; 785  : 	_Nodeptr _Buynode0(_Nodeptr _Next,
; 786  : 		_Nodeptr _Prev)
; 787  : 		{	// allocate a node and set links
; 788  : 		_Nodeptr _Pnode = this->_Getal().allocate(1);
; 789  : 
; 790  : 		if (_Next == _Nodeptr())
; 791  : 			{	// point at self
; 792  : 			_Next = _Pnode;
; 793  : 			_Prev = _Pnode;
; 794  : 			}
; 795  : 		_TRY_BEGIN
; 796  : 		this->_Getal().construct(
; 797  : 			_STD addressof(this->_Nextnode(_Pnode)), _Next);
; 798  : 		this->_Getal().construct(
; 799  : 			_STD addressof(this->_Prevnode(_Pnode)), _Prev);
; 800  : 		_CATCH_ALL
; 801  : 		this->_Getal().deallocate(_Pnode, 1);
; 802  : 		_RERAISE;
; 803  : 		_CATCH_END
; 804  : 
; 805  : 		return (_Pnode);
; 806  : 		}
; 807  : 
; 808  : 	_Alty _Getal() const
; 809  : 		{	// get reference to allocator
; 810  : 		return (_Alty());
; 811  : 		}
; 812  : 	};
; 813  : 
; 814  : 		// TEMPLATE CLASS _List_buy
; 815  : template<class _Ty,
; 816  : 	class _Alloc>
; 817  : 	class _List_buy
; 818  : 		: public _List_alloc<!is_empty<_Alloc>::value,
; 819  : 			_List_base_types<_Ty, _Alloc> >
; 820  : 	{	// base class for list to hold buynode/freenode functions
; 821  : public:
; 822  : 	typedef _List_alloc<!is_empty<_Alloc>::value,
; 823  : 		_List_base_types<_Ty, _Alloc> > _Mybase;
; 824  : 	typedef typename _Mybase::_Alty _Alty;
; 825  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 826  : 
; 827  : 	_List_buy(const _Alloc& _Al = _Alloc())
; 828  : 		: _Mybase(_Al)
; 829  : 		{	// construct from allocator
; 830  : 		}
; 831  : 
; 832  : #define _LIST_BUYNODE( \
; 833  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 834  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 835  : 		_Nodeptr _Buynode(_Nodeptr _Next, \
; 836  : 			_Nodeptr _Prev COMMA LIST(_TYPE_REFREF_ARG)) \
; 837  : 		{	/* allocate a node and set links and value */ \
; 838  : 		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev); \
; 839  : 		_TRY_BEGIN \
; 840  : 		this->_Getal().construct( \
; 841  : 			_STD addressof(this->_Myval(_Pnode)) \
; 842  : 				COMMA LIST(_FORWARD_ARG)); \
; 843  : 		_CATCH_ALL \
; 844  : 		this->_Getal().deallocate(_Pnode, 1); \
; 845  : 		_RERAISE; \
; 846  : 		_CATCH_END \
; 847  : 		return (_Pnode); \
; 848  : 		}
; 849  : 
; 850  : _VARIADIC_EXPAND_0X(_LIST_BUYNODE, , , , )
; 851  : #undef _LIST_BUYNODE
; 852  : 
; 853  : 	void _Freenode(_Nodeptr _Pnode)
; 854  : 		{	// give node back
; 855  : 		this->_Getal().destroy(
; 856  : 			_STD addressof(this->_Nextnode(_Pnode)));
; 857  : 		this->_Getal().destroy(
; 858  : 			_STD addressof(this->_Prevnode(_Pnode)));
; 859  : 		this->_Getal().destroy(
; 860  : 			_STD addressof(this->_Myval(_Pnode)));
; 861  : 		this->_Getal().deallocate(_Pnode, 1);
; 862  : 		}
; 863  : 	};
; 864  : 
; 865  : 		// TEMPLATE CLASS list
; 866  : template<class _Ty,
; 867  : 	class _Alloc = allocator<_Ty> >
; 868  : 	class list
; 869  : 		: public _List_buy<_Ty, _Alloc>
; 870  : 	{	// bidirectional linked list
; 871  : public:
; 872  : 	typedef list<_Ty, _Alloc> _Myt;
; 873  : 	typedef _List_buy<_Ty, _Alloc> _Mybase;
; 874  : 	typedef typename _Mybase::_Node _Node;
; 875  : 	typedef typename _Mybase::_Nodeptr _Nodeptr;
; 876  : 	typedef typename _Mybase::_Alty _Alty;
; 877  : 
; 878  : 	typedef _Alloc allocator_type;
; 879  : 	typedef typename _Mybase::size_type size_type;
; 880  : 	typedef typename _Mybase::difference_type difference_type;
; 881  : 	typedef typename _Mybase::pointer pointer;
; 882  : 	typedef typename _Mybase::const_pointer const_pointer;
; 883  : 	typedef typename _Mybase::reference reference;
; 884  : 	typedef typename _Mybase::const_reference const_reference;
; 885  : 	typedef typename _Mybase::value_type value_type;
; 886  : 
; 887  : 	typedef typename _Mybase::const_iterator const_iterator;
; 888  : 	typedef typename _Mybase::iterator iterator;
; 889  : 	typedef typename _Mybase::_Unchecked_const_iterator
; 890  : 		_Unchecked_const_iterator;
; 891  : 	typedef typename _Mybase::_Unchecked_iterator
; 892  : 		_Unchecked_iterator;
; 893  : 
; 894  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 895  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 896  : 
; 897  : 	list()
; 898  : 		: _Mybase()
; 899  : 		{	// construct empty list
; 900  : 		}
; 901  : 
; 902  : 	explicit list(const _Alloc& _Al)
; 903  : 		: _Mybase(_Al)
; 904  : 		{	// construct empty list, allocator
; 905  : 		}
; 906  : 
; 907  : 	explicit list(size_type _Count)
; 908  : 		: _Mybase()
; 909  : 		{	// construct list from _Count * _Ty()
; 910  : 		resize(_Count);
; 911  : 		}
; 912  : 
; 913  : 	list(size_type _Count, const _Ty& _Val)
; 914  : 		: _Mybase()
; 915  : 		{	// construct list from _Count * _Val
; 916  : 		_Construct_n(_Count, _Val);
; 917  : 		}
; 918  : 
; 919  : 	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
; 920  : 		: _Mybase(_Al)
; 921  : 		{	// construct list from _Count * _Val, allocator
; 922  : 		_Construct_n(_Count, _Val);
; 923  : 		}
; 924  : 
; 925  : 	list(const _Myt& _Right)
; 926  : 
; 927  :  #if _HAS_CPP0X
; 928  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 929  : 
; 930  :  #else /* _HAS_CPP0X */
; 931  : 		: _Mybase(_Right._Getal())
; 932  :  #endif /* _HAS_CPP0X */
; 933  : 
; 934  : 		{	// construct list by copying _Right
; 935  : 		_TRY_BEGIN
; 936  : 		insert(begin(), _Right.begin(), _Right.end());
; 937  : 		_CATCH_ALL
; 938  : 		_Tidy();
; 939  : 		_RERAISE;
; 940  : 		_CATCH_END
; 941  : 		}
; 942  : 
; 943  : 	list(const _Myt& _Right, const _Alloc& _Al)
; 944  : 		: _Mybase(_Al)
; 945  : 		{	// construct list by copying _Right, allocator
; 946  : 		_TRY_BEGIN
; 947  : 		insert(begin(), _Right.begin(), _Right.end());
; 948  : 		_CATCH_ALL
; 949  : 		_Tidy();
; 950  : 		_RERAISE;
; 951  : 		_CATCH_END
; 952  : 		}
; 953  : 
; 954  : 	template<class _Iter>
; 955  : 		list(_Iter _First, _Iter _Last,
; 956  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 957  : 				void>::type ** = 0)
; 958  : 		: _Mybase()
; 959  : 		{	// construct list from [_First, _Last,
; 960  : 		_Construct(_First, _Last);
; 961  : 		}
; 962  : 
; 963  : 	template<class _Iter>
; 964  : 		list(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 965  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 966  : 				void>::type ** = 0)
; 967  : 		: _Mybase(_Al)
; 968  : 		{	// construct list, allocator from [_First, _Last)
; 969  : 		_Construct(_First, _Last);
; 970  : 		}
; 971  : 
; 972  : 	template<class _Iter>
; 973  : 		void _Construct(_Iter _First, _Iter _Last)
; 974  : 		{	// construct list from [_First, _Last), input iterators
; 975  : 		_TRY_BEGIN
; 976  : 		insert(begin(), _First, _Last);
; 977  : 		_CATCH_ALL
; 978  : 		_Tidy();
; 979  : 		_RERAISE;
; 980  : 		_CATCH_END
; 981  : 		}
; 982  : 
; 983  : 	void _Construct_n(size_type _Count,
; 984  : 		const _Ty& _Val)
; 985  : 		{	// construct from _Count * _Val
; 986  : 		_TRY_BEGIN
; 987  : 		_Insert_n(_Unchecked_begin(), _Count, _Val);
; 988  : 		_CATCH_ALL
; 989  : 		_Tidy();
; 990  : 		_RERAISE;
; 991  : 		_CATCH_END
; 992  : 		}
; 993  : 
; 994  : 	list(_Myt&& _Right)
; 995  : 		: _Mybase(_Right._Getal())
; 996  : 		{	// construct list by moving _Right
; 997  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 998  : 		}
; 999  : 
; 1000 : 	list(_Myt&& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct list by moving _Right, allocator
; 1003 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1004 : 		}
; 1005 : 
; 1006 : 	_Myt& operator=(_Myt&& _Right)
; 1007 : 		{	// assign by moving _Right
; 1008 : 		if (this != &_Right)
; 1009 : 			{	// different, assign it
; 1010 : 			clear();
; 1011 : 
; 1012 :  #if _HAS_CPP0X
; 1013 : 			if (this->_Getal() != _Right._Getal()
; 1014 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1015 : 				this->_Change_alloc(_Right._Getal());
; 1016 :  #endif /* _HAS_CPP0X */
; 1017 : 
; 1018 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1019 : 			}
; 1020 : 		return (*this);
; 1021 : 		}
; 1022 : 
; 1023 : 	void _Assign_rv(_Myt&& _Right)
; 1024 : 		{	// swap with empty *this, same allocator
; 1025 : 		this->_Swap_all(_Right);
; 1026 : 		_Swap_adl(this->_Myhead, _Right._Myhead);
; 1027 : 		_STD swap(this->_Mysize, _Right._Mysize);
; 1028 : 		}
; 1029 : 
; 1030 : 	void push_front(_Ty&& _Val)
; 1031 : 		{	// insert element at beginning
; 1032 : 		_Insert(_Unchecked_begin(), _STD forward<_Ty>(_Val));
; 1033 : 		}
; 1034 : 
; 1035 : 	void push_back(_Ty&& _Val)
; 1036 : 		{	// insert element at end
; 1037 : 		_Insert(_Unchecked_end(), _STD forward<_Ty>(_Val));
; 1038 : 		}
; 1039 : 
; 1040 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1041 : 		{	// insert _Val at _Where
; 1042 : 		return (emplace(_Where, _STD forward<_Ty>(_Val)));
; 1043 : 		}
; 1044 : 
; 1045 : #define _LIST_EMPLACE_INSERT( \
; 1046 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1047 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1048 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1049 : 		{	/* insert element at beginning */ \
; 1050 : 		_Insert(_Unchecked_begin() COMMA LIST(_FORWARD_ARG)); \
; 1051 : 		} \
; 1052 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1053 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1054 : 		{	/* insert element at end */ \
; 1055 : 		_Insert(_Unchecked_end() COMMA LIST(_FORWARD_ARG)); \
; 1056 : 		} \
; 1057 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1058 : 		iterator emplace(const_iterator _Where \
; 1059 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1060 : 		{	/* insert element at _Where */ \
; 1061 : 		_LIST_EMPLACE_CHECK \
; 1062 : 		_Insert(_Where._Unchecked() COMMA LIST(_FORWARD_ARG)); \
; 1063 : 		return (_Make_iter(--_Where)); \
; 1064 : 		} \
; 1065 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1066 : 		void _Insert(_Unchecked_const_iterator _Where \
; 1067 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1068 : 		{	/* insert element at _Where */ \
; 1069 : 		_Nodeptr _Pnode = _Where._Mynode(); \
; 1070 : 		_Nodeptr _Newnode = this->_Buynode(_Pnode, \
; 1071 : 			this->_Prevnode(_Pnode) COMMA LIST(_FORWARD_ARG)); \
; 1072 : 		_Incsize(1); \
; 1073 : 		this->_Prevnode(_Pnode) = _Newnode; \
; 1074 : 		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode; \
; 1075 : 		}
; 1076 : 
; 1077 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1078 : #define _LIST_EMPLACE_CHECK \
; 1079 : 		if (_Where._Getcont() != this) \
; 1080 : 			_DEBUG_ERROR("list emplace iterator outside range");
; 1081 : 
; 1082 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1083 : #define _LIST_EMPLACE_CHECK
; 1084 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1085 : 
; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )
; 1087 : #undef _LIST_EMPLACE_CHECK
; 1088 : #undef _LIST_EMPLACE_INSERT
; 1089 : 
; 1090 : 	~list() _NOEXCEPT
; 1091 : 		{	// destroy the object
; 1092 : 		_Tidy();
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();

  000ed	48 89 01	 mov	 QWORD PTR [rcx], rax

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  000f0	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();

  000f4	48 89 19	 mov	 QWORD PTR [rcx], rbx

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  000f7	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]

; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();

  000fb	48 89 39	 mov	 QWORD PTR [rcx], rdi

; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());

  000fe	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00102	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00106	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx

; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());

  0010a	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0010e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

  00112	48 89 57 08	 mov	 QWORD PTR [rdi+8], rdx
$LN161@Insert:

; 86   : 		return (_Ptr == _Right._Ptr);

  00116	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
  0011a	49 03 d1	 add	 rdx, r9
  0011d	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00120	48 3b 06	 cmp	 rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

  00123	75 0e		 jne	 SHORT $LN215@Insert

; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;

  00125	48 89 3a	 mov	 QWORD PTR [rdx], rdi

; 976  : 			_Vec_hi(_Bucket) = _Plist;

  00128	48 8b 46 10	 mov	 rax, QWORD PTR [rsi+16]
  0012c	49 89 7c 01 08	 mov	 QWORD PTR [r9+rax+8], rdi

; 978  : 		else if (_Vec_lo(_Bucket) == _Where)

  00131	eb 2c		 jmp	 SHORT $LN272@Insert
$LN215@Insert:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00133	48 3b c3	 cmp	 rax, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 978  : 		else if (_Vec_lo(_Bucket) == _Where)

  00136	75 05		 jne	 SHORT $LN213@Insert

; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

  00138	48 89 3a	 mov	 QWORD PTR [rdx], rdi

; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

  0013b	eb 22		 jmp	 SHORT $LN272@Insert
$LN213@Insert:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  0013d	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  00141	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00144	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 86   : 		return (_Ptr == _Right._Ptr);

  00148	48 3b cf	 cmp	 rcx, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

  0014b	74 12		 je	 SHORT $LN272@Insert
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  0014d	48 8b 56 10	 mov	 rdx, QWORD PTR [rsi+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  00151	4a 8b 44 0a 08	 mov	 rax, QWORD PTR [rdx+r9+8]
  00156	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0015a	4a 89 4c 0a 08	 mov	 QWORD PTR [rdx+r9+8], rcx
$LN272@Insert:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 900  : 		_Check_size();

  0015f	48 8b ce	 mov	 rcx, rsi
  00162	e8 00 00 00 00	 call	 ?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Check_size
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00167	49 89 3e	 mov	 QWORD PTR [r14], rdi
  0016a	41 c6 46 08 01	 mov	 BYTE PTR [r14+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 901  : 		return (_Pairib(_Make_iter(_Plist), true));

  0016f	49 8b c6	 mov	 rax, r14
$LN10@Insert:

; 902  : 		}

  00172	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00177	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0017c	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00181	4c 8b 74 24 48	 mov	 r14, QWORD PTR [rsp+72]
  00186	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018a	41 5f		 pop	 r15
  0018c	c3		 ret	 0
??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAU01@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAU01@PEAPEAX@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>, COMDAT

; 182  : 		{	// construct from moved compatible pair

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	0f b6 42 08	 movzx	 eax, BYTE PTR [rdx+8]
  0000a	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 183  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAU01@PEAPEAX@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Iter_cat@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@AEBV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
__formal$dead$ = 16
??$_Iter_cat@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@AEBV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Iter_cat<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 399  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 400  : 	return (_Cat);

  00000	48 8b c1	 mov	 rax, rcx

; 401  : 	}

  00003	c3		 ret	 0
??$_Iter_cat@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@AEBV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Distance2@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_KUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Off$ = 24
__formal$dead$ = 32
??$_Distance2@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_KUbidirectional_iterator_tag@0@@Z PROC ; std::_Distance2<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>, COMDAT

; 797  : 	{	// add to _Off distance between bidirectional iterators (redundant)

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00005	48 3b ca	 cmp	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00008	74 16		 je	 SHORT $LN1@Distance2
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL8@Distance2:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00010	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 799  : 		++_Off;

  00013	49 ff 00	 inc	 QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00016	48 89 4c 24 08	 mov	 QWORD PTR _First$[rsp], rcx

; 298  : 		return (this->_Ptr == _Right._Ptr);

  0001b	48 3b ca	 cmp	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  0001e	75 f0		 jne	 SHORT $LL8@Distance2
$LN1@Distance2:

; 800  : 	}

  00020	f3 c3		 fatret	 0
??$_Distance2@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_K@std@@YAXV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEA_KUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$?0U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAA@AEBV?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > ><std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);
; 758  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

$LN23:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN18@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN21@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN21@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN21@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN18@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 758  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0@Z PROC ; std::_Ptr_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00005	0f b6 44 24 10	 movzx	 eax, BYTE PTR _Cat$[rsp]

; 440  : 	}

  0000a	c3		 ret	 0
??$_Ptr_cat@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >, COMDAT

; 88   : 	for (; _First != _Last; ++_First)
; 89   : 		_Al.destroy(_First);
; 90   : 	}

  00000	c2 00 00	 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>, COMDAT

; 2465 : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 1f		 je	 SHORT $LN11@Move
  00005	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@Move:

; 2466 : 		*_Dest = _STD move(*_First);

  00010	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00013	48 83 c1 08	 add	 rcx, 8
  00017	49 83 c0 08	 add	 r8, 8
  0001b	49 89 40 f8	 mov	 QWORD PTR [r8-8], rax
  0001f	48 3b ca	 cmp	 rcx, rdx
  00022	75 ec		 jne	 SHORT $LL3@Move
$LN11@Move:

; 2467 : 	return (_Dest);

  00024	49 8b c0	 mov	 rax, r8

; 2468 : 	}

  00027	c3		 ret	 0
??$_Move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >

; 474  : 	}

  00009	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000d	c3		 ret	 0
??$_Uninitialized_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
_Src$ = 8
??$_Unchecked@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@@Z PROC ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>, COMDAT

; 276  : 	return (_Src);

  00000	48 8b c1	 mov	 rax, rcx

; 277  : 	}

  00003	c3		 ret	 0
??$_Unchecked@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@@Z ENDP ; std::_Unchecked<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Val$ = 24
??$_Fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z PROC ; std::_Fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 2645 : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 1b		 je	 SHORT $LN1@Fill
  00005	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@Fill:

; 2646 : 		*_First = _Val;

  00010	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00013	48 83 c1 08	 add	 rcx, 8
  00017	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax
  0001b	48 3b ca	 cmp	 rcx, rdx
  0001e	75 f0		 jne	 SHORT $LL3@Fill
$LN1@Fill:

; 2647 : 	}

  00020	f3 c3		 fatret	 0
??$_Fill@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@0AEBV10@@Z ENDP ; std::_Fill<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Copy_backward@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
__formal$dead$ = 32
??$_Copy_backward@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>, COMDAT

; 2391 : 	while (_First != _Last)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 1f		 je	 SHORT $LN8@Copy_backw
  00005	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@Copy_backw:

; 2392 : 		*--_Dest = *--_Last;

  00010	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]
  00014	48 83 ea 08	 sub	 rdx, 8
  00018	49 83 e8 08	 sub	 r8, 8
  0001c	49 89 00	 mov	 QWORD PTR [r8], rax
  0001f	48 3b d1	 cmp	 rdx, rcx
  00022	75 ec		 jne	 SHORT $LL2@Copy_backw
$LN8@Copy_backw:

; 2393 : 	return (_Dest);

  00024	49 8b c0	 mov	 rax, r8

; 2394 : 	}

  00027	c3		 ret	 0
??$_Copy_backward@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z PROC ; std::forward<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@YAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@0@AEAPEAU10@@Z ENDP ; std::forward<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN7@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN7@construct:

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@@Z PROC ; std::_Val_type<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>, COMDAT

; 711  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 712  : 	}

  00002	c3		 ret	 0
??$_Val_type@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@@Z ENDP ; std::_Val_type<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Pval$ = 24
_Al$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 572  : 	for (; 0 < _Count; --_Count, ++_First)

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 14		 je	 SHORT $LN4@Uninit_fil
$LL6@Uninit_fil:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00005	48 85 c9	 test	 rcx, rcx
  00008	74 06		 je	 SHORT $LN5@Uninit_fil
  0000a	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0000d	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN5@Uninit_fil:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 572  : 	for (; 0 < _Count; --_Count, ++_First)

  00010	48 83 c1 08	 add	 rcx, 8
  00014	48 ff ca	 dec	 rdx
  00017	75 ec		 jne	 SHORT $LL6@Uninit_fil
$LN4@Uninit_fil:

; 573  : 		_Al.construct(_First, *_Pval);
; 574  : 	_CATCH_ALL
; 575  : 	for (; _Next != _First; ++_Next)
; 576  : 		_Al.destroy(_Next);
; 577  : 	_RERAISE;
; 578  : 	_CATCH_END
; 579  : 	}

  00019	f3 c3		 fatret	 0
??$_Uninit_fill_n@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_KV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@_KPEBV10@AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,unsigned __int64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??_GEmptyChunk@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GEmptyChunk@@QEAAPEAXI@Z PROC			; EmptyChunk::`scalar deleting destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 117  : {

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax

; 118  : 
; 119  : }

  00013	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00018	48 8b cb	 mov	 rcx, rbx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00020	48 8b c3	 mov	 rax, rbx
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??_GEmptyChunk@@QEAAPEAXI@Z ENDP			; EmptyChunk::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Plist$ = 56
?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil, COMDAT

; 855  : 		{	// node exists, destroy it

$LN98:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b e9	 mov	 rbp, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1427 : 		if (_Pnode != this->_Myhead)

  00010	48 3b 11	 cmp	 rdx, QWORD PTR [rcx]
  00013	74 5b		 je	 SHORT $LN15@Destroy_if

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00015	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]

; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);

  00019	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0001c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00021	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);

  00024	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00027	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0002b	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0002f	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]
  00033	48 85 db	 test	 rbx, rbx
  00036	74 27		 je	 SHORT $LN77@Destroy_if

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00038	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0003c	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00041	75 17		 jne	 SHORT $LN96@Destroy_if

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00043	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0004b	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004f	75 09		 jne	 SHORT $LN96@Destroy_if

; 128  : 			_Delete_this();

  00051	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00054	48 8b cb	 mov	 rcx, rbx
  00057	ff 50 08	 call	 QWORD PTR [rax+8]
$LN96@Destroy_if:
  0005a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
$LN77@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0005f	48 8b cf	 mov	 rcx, rdi
  00062	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 1434 : 			--this->_Mysize;

  00067	48 ff 4d 08	 dec	 QWORD PTR [rbp+8]
  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN15@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 857  : 		}

  00070	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
?_Destroy_if_not_nil@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Insert_bucket@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0_K@Z
_TEXT	SEGMENT
this$ = 8
_Plist$ = 16
_Where$ = 24
_Bucket$ = 32
?_Insert_bucket@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0_K@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_bucket, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00000	4c 8b 51 10	 mov	 r10, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00004	49 c1 e1 04	 shl	 r9, 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 972  : 		{	// fix iterators after inserting _Plist before _Where

  00008	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0000d	4d 03 d1	 add	 r10, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 972  : 		{	// fix iterators after inserting _Plist before _Where

  00010	4c 8b d9	 mov	 r11, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  00013	49 8b 02	 mov	 rax, QWORD PTR [r10]
  00016	48 3b 01	 cmp	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 973  : 		if (_Vec_lo(_Bucket) == _Unchecked_end())

  00019	75 12		 jne	 SHORT $LN5@Insert_buc

; 974  : 			{	// make bucket non-empty
; 975  : 			_Vec_lo(_Bucket) = _Plist;

  0001b	49 89 12	 mov	 QWORD PTR [r10], rdx

; 976  : 			_Vec_hi(_Bucket) = _Plist;

  0001e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00022	48 8b 44 24 10	 mov	 rax, QWORD PTR _Plist$[rsp]
  00027	49 89 44 09 08	 mov	 QWORD PTR [r9+rcx+8], rax

; 982  : 		}

  0002c	c3		 ret	 0
$LN5@Insert_buc:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0002d	49 3b c0	 cmp	 rax, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 978  : 		else if (_Vec_lo(_Bucket) == _Where)

  00030	75 04		 jne	 SHORT $LN3@Insert_buc

; 979  : 			_Vec_lo(_Bucket) = _Plist;	// move beginning back one element

  00032	49 89 12	 mov	 QWORD PTR [r10], rdx

; 982  : 		}

  00035	c3		 ret	 0
$LN3@Insert_buc:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00036	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]

; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);

  0003a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0003d	49 89 4a 08	 mov	 QWORD PTR [r10+8], rcx

; 86   : 		return (_Ptr == _Right._Ptr);

  00041	48 3b 4c 24 10	 cmp	 rcx, QWORD PTR _Plist$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 980  : 		else if (++_Vec_hi(_Bucket) != _Plist)	// move end up one element

  00046	74 12		 je	 SHORT $LN62@Insert_buc
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1148 : 		return (*(this->_Myfirst + _Pos));

  00048	49 8b 53 10	 mov	 rdx, QWORD PTR [r11+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  0004c	4a 8b 44 0a 08	 mov	 rax, QWORD PTR [rdx+r9+8]
  00051	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00055	4a 89 4c 0a 08	 mov	 QWORD PTR [rdx+r9+8], rcx
$LN62@Insert_buc:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 982  : 		}

  0005a	f3 c3		 fatret	 0
?_Insert_bucket@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0_K@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert_bucket
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
$T1 = 48
_Tmp$2 = 80
this$ = 80
$T3 = 88
?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Check_size, COMDAT

; 1017 : 		{	// grow table as needed

$LN226:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 628  : 		return ((float)size() / (float)bucket_count());

  0000a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  0000e	48 8b 59 30	 mov	 rbx, QWORD PTR [rcx+48]
  00012	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@5f800000
  0001a	0f 57 c0	 xorps	 xmm0, xmm0

; 1017 : 		{	// grow table as needed

  0001d	48 8b f1	 mov	 rsi, rcx

; 628  : 		return ((float)size() / (float)bucket_count());

  00020	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00025	48 85 c0	 test	 rax, rax
  00028	79 04		 jns	 SHORT $LN223@Check_size
  0002a	f3 0f 58 c2	 addss	 xmm0, xmm2
$LN223@Check_size:
  0002e	0f 57 c9	 xorps	 xmm1, xmm1
  00031	f3 48 0f 2a cb	 cvtsi2ss xmm1, rbx
  00036	48 85 db	 test	 rbx, rbx
  00039	79 04		 jns	 SHORT $LN222@Check_size
  0003b	f3 0f 58 ca	 addss	 xmm1, xmm2
$LN222@Check_size:
  0003f	f3 0f 5e c1	 divss	 xmm0, xmm1

; 1018 : 		if (max_load_factor() < load_factor())

  00043	0f 2f 41 38	 comiss	 xmm0, DWORD PTR [rcx+56]
  00047	0f 86 97 00 00
	00		 jbe	 $LN218@Check_size

; 1019 : 
; 1020 : 			{	// rehash to bigger table
; 1021 : 			size_type _Newsize = bucket_count();
; 1022 : 
; 1023 : 			if (_Newsize <  512)

  0004d	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00052	48 81 fb 00 02
	00 00		 cmp	 rbx, 512		; 00000200H
  00059	73 0a		 jae	 SHORT $LN3@Check_size

; 1024 : 				_Newsize *= 8;	// multiply by 8

  0005b	48 8d 1c dd 00
	00 00 00	 lea	 rbx, QWORD PTR [rbx*8]

; 1025 : 			else if (_Newsize < _Vec.max_size() / 2)

  00063	eb 12		 jmp	 SHORT $LN1@Check_size
$LN3@Check_size:
  00065	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0006f	48 3b d8	 cmp	 rbx, rax
  00072	73 03		 jae	 SHORT $LN1@Check_size

; 1026 : 				_Newsize *= 2;	// multiply safely by 2

  00074	48 03 db	 add	 rbx, rbx
$LN1@Check_size:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  00077	48 8b 06	 mov	 rax, QWORD PTR [rsi]

; 1454 : 		erase(begin(), end());

  0007a	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1011 : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

  0007e	48 83 c1 10	 add	 rcx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence

  00082	48 89 44 24 50	 mov	 QWORD PTR _Tmp$2[rsp], rax

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00087	48 8d 44 24 50	 lea	 rax, QWORD PTR _Tmp$2[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1011 : 		_Vec.assign(2 * _Buckets, _Unchecked_end());

  0008c	4c 8d 0c 1b	 lea	 r9, QWORD PTR [rbx+rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00090	48 8d 54 24 58	 lea	 rdx, QWORD PTR $T3[rsp]

; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;

  00095	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 1252 : 		return (_Insert_n(_Where, _Count, _Val));

  00099	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009e	e8 00 00 00 00	 call	 ?_Insert_n@?$vector@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@@std@@IEAA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@2@_KAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::_Insert_n
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  000a3	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1012 : 		_Mask = _Buckets - 1;

  000a6	48 8d 43 ff	 lea	 rax, QWORD PTR [rbx-1]
  000aa	48 89 46 28	 mov	 QWORD PTR [rsi+40], rax

; 1013 : 		_Maxidx = _Buckets;

  000ae	48 89 5e 30	 mov	 QWORD PTR [rsi+48], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  000b2	48 39 3f	 cmp	 QWORD PTR [rdi], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1035 : 		if (_Unchecked_begin() != _Last)

  000b5	74 28		 je	 SHORT $LN224@Check_size
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  000b7	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
  000bb	0f 1f 44 00 00	 npad	 5
$LL160@Check_size:

; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  000c0	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1040 : 				_Insert(*_First, _First);

  000c3	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  000c8	48 8b ce	 mov	 rcx, rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  000cb	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1040 : 				_Insert(*_First, _First);

  000ce	4c 8b cb	 mov	 r9, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 547  : 		return ((reference)_Pnode->_Myval);

  000d1	4c 8d 43 10	 lea	 r8, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1040 : 				_Insert(*_First, _First);

  000d5	e8 00 00 00 00	 call	 ??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  000da	48 3b df	 cmp	 rbx, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1041 : 				if (_Done)

  000dd	75 e1		 jne	 SHORT $LL160@Check_size
$LN224@Check_size:
  000df	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
$LN218@Check_size:

; 1027 : 			_Init(_Newsize);
; 1028 : 			_Reinsert();
; 1029 : 			}
; 1030 : 		}

  000e4	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000e9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ed	5e		 pop	 rsi
  000ee	c3		 ret	 0
?_Check_size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Check_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Unchecked_splice@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@00@Z
_TEXT	SEGMENT
this$dead$ = 8
_Where$ = 16
_First$ = 24
_Last$ = 32
?_Unchecked_splice@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@00@Z PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_splice, COMDAT

; 1902 : 		{	// splice [_First, _Last) before _Where

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 8b dc	 mov	 r11, rsp
  00008	4d 89 4b 20	 mov	 QWORD PTR [r11+32], r9
  0000c	4d 89 43 18	 mov	 QWORD PTR [r11+24], r8

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00010	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]

; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();

  00014	4c 89 08	 mov	 QWORD PTR [rax], r9

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00017	49 8b 43 20	 mov	 rax, QWORD PTR [r11+32]
  0001b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();

  0001f	49 8b 43 10	 mov	 rax, QWORD PTR [r11+16]
  00023	48 89 01	 mov	 QWORD PTR [rcx], rax

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00026	49 8b 43 10	 mov	 rax, QWORD PTR [r11+16]
  0002a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]

; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();

  0002e	49 8b 43 18	 mov	 rax, QWORD PTR [r11+24]
  00032	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());

  00035	49 8b 43 20	 mov	 rax, QWORD PTR [r11+32]

; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);

  00039	49 8b 53 10	 mov	 rdx, QWORD PTR [r11+16]

; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());

  0003d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00041	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00045	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());

  00049	49 8b 43 18	 mov	 rax, QWORD PTR [r11+24]
  0004d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00051	49 8b 43 20	 mov	 rax, QWORD PTR [r11+32]
  00055	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;

  00059	49 8b 43 18	 mov	 rax, QWORD PTR [r11+24]
  0005d	4c 89 40 08	 mov	 QWORD PTR [rax+8], r8

; 1916 : 		}

  00061	c3		 ret	 0
?_Unchecked_splice@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@2@00@Z ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Unchecked_splice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 39   : 		{	// construct with null node pointer

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 119  : 		{	// construct with null node
; 120  : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	c3		 ret	 0
??0?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VEmptyChunk@@@std@@QEAA@PEAVEmptyChunk@@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
??0?$_Ref_count@VEmptyChunk@@@std@@QEAA@PEAVEmptyChunk@@@Z PROC ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>, COMDAT

; 155  : 		{	// construct

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_Ref_count@VEmptyChunk@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00007	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [rcx+8], 1
  0000e	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 156  : 		}

  00018	48 8b c1	 mov	 rax, rcx
  0001b	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  0001f	c3		 ret	 0
??0?$_Ref_count@VEmptyChunk@@@std@@QEAA@PEAVEmptyChunk@@@Z ENDP ; std::_Ref_count<EmptyChunk>::_Ref_count<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ PROC	; std::_Ref_count<EmptyChunk>::_Destroy, COMDAT

; 160  : 		{	// destroy managed resource

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 161  : 		delete _Ptr;

  00006	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 1f		 je	 SHORT $LN5@Destroy
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 117  : {

  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7EmptyChunk@@6B@

; 118  : 
; 119  : }

  00016	48 8b cb	 mov	 rcx, rbx
  00019	48 89 03	 mov	 QWORD PTR [rbx], rax
  0001c	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00021	48 8b cb	 mov	 rcx, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 162  : 		}

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
$LN5@Destroy:
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
?_Destroy@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ ENDP	; std::_Ref_count<EmptyChunk>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ PROC ; std::_Ref_count<EmptyChunk>::_Delete_this, COMDAT

; 166  : 		delete this;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 0c		 je	 SHORT $LN3@Delete_thi
  00005	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00008	ba 01 00 00 00	 mov	 edx, 1
  0000d	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
$LN3@Delete_thi:

; 167  : 		}

  00011	f3 c3		 fatret	 0
?_Delete_this@?$_Ref_count@VEmptyChunk@@@std@@EEAAXXZ ENDP ; std::_Ref_count<EmptyChunk>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z PROC	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor', COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN8@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN8@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G?$_Ref_count@VEmptyChunk@@@std@@UEAAPEAXI@Z ENDP	; std::_Ref_count<EmptyChunk>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VEmptyChunk@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Ref_count@VEmptyChunk@@@std@@UEAA@XZ PROC		; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>, COMDAT

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1?$_Ref_count@VEmptyChunk@@@std@@UEAA@XZ ENDP		; std::_Ref_count<EmptyChunk>::~_Ref_count<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?bucket_count@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?bucket_count@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::bucket_count, COMDAT

; 555  : 		return (_Maxidx);

  00000	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]

; 556  : 		}

  00004	c3		 ret	 0
?bucket_count@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::bucket_count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?load_factor@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?load_factor@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::load_factor, COMDAT

; 628  : 		return ((float)size() / (float)bucket_count());

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@5f800000
  0000c	0f 57 c0	 xorps	 xmm0, xmm0
  0000f	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
  00014	48 85 c0	 test	 rax, rax
  00017	79 04		 jns	 SHORT $LN10@load_facto
  00019	f3 0f 58 c2	 addss	 xmm0, xmm2
$LN10@load_facto:
  0001d	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  00021	0f 57 c9	 xorps	 xmm1, xmm1
  00024	f3 48 0f 2a c8	 cvtsi2ss xmm1, rax
  00029	48 85 c0	 test	 rax, rax
  0002c	79 04		 jns	 SHORT $LN9@load_facto
  0002e	f3 0f 58 ca	 addss	 xmm1, xmm2
$LN9@load_facto:
  00032	f3 0f 5e c1	 divss	 xmm0, xmm1

; 629  : 		}

  00036	c3		 ret	 0
?load_factor@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::load_factor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?max_load_factor@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBAMXZ
_TEXT	SEGMENT
this$ = 8
?max_load_factor@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBAMXZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_load_factor, COMDAT

; 633  : 		return (_Max_bucket_size);

  00000	f3 0f 10 41 38	 movss	 xmm0, DWORD PTR [rcx+56]

; 634  : 		}

  00005	c3		 ret	 0
?max_load_factor@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBAMXZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::max_load_factor
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Reinsert, COMDAT

; 1033 : 		{	// insert elements in [begin(), end())

$LN63:
  00000	40 56		 push	 rsi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1033 : 		{	// insert elements in [begin(), end())

  00009	48 8b f1	 mov	 rsi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0000c	48 39 00	 cmp	 QWORD PTR [rax], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1035 : 		if (_Unchecked_begin() != _Last)

  0000f	74 38		 je	 SHORT $LN60@Reinsert
  00011	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00016	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);

  0001b	48 8b 78 08	 mov	 rdi, QWORD PTR [rax+8]
  0001f	90		 npad	 1
$LL3@Reinsert:

; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00020	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1040 : 				_Insert(*_First, _First);

  00023	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00028	48 8b ce	 mov	 rcx, rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  0002b	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1040 : 				_Insert(*_First, _First);

  0002e	4c 8b cb	 mov	 r9, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 547  : 		return ((reference)_Pnode->_Myval);

  00031	4c 8d 43 10	 lea	 r8, QWORD PTR [rbx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1040 : 				_Insert(*_First, _First);

  00035	e8 00 00 00 00	 call	 ??$_Insert@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Insert<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 86   : 		return (_Ptr == _Right._Ptr);

  0003a	48 3b df	 cmp	 rbx, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 1041 : 				if (_Done)

  0003d	75 e1		 jne	 SHORT $LL3@Reinsert
  0003f	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00044	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
$LN60@Reinsert:

; 1042 : 					break;
; 1043 : 				}
; 1044 : 		}

  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5e		 pop	 rsi
  0004e	c3		 ret	 0
?_Reinsert@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAAXXZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Reinsert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@XZ PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>, COMDAT

; 39   : 		{	// construct with null node pointer

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 40   : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@XZ ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size, COMDAT

; 521  : 		return (_List.size());

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 522  : 		}

  00004	c3		 ret	 0
?size@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEBA_KXZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?size@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::size, COMDAT

; 1237 : 		return (this->_Mysize);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1238 : 		}

  00004	c3		 ret	 0
?size@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVEmptyChunk@@PEAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
_Rx$ = 24
??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVEmptyChunk@@PEAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>, COMDAT

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00000	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
??$_Resetp0@VEmptyChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVEmptyChunk@@PEAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp0<EmptyChunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??$_Insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 48
_Where$ = 56
_V0$ = 64
??$_Insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

$LN32:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	4d 8b c8	 mov	 r9, r8
  0000d	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	e8 00 00 00 00	 call	 ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >

; 1087 : #undef _LIST_EMPLACE_CHECK
; 1088 : #undef _LIST_EMPLACE_INSERT
; 1089 : 
; 1090 : 	~list() _NOEXCEPT
; 1091 : 		{	// destroy the object
; 1092 : 		_Tidy();
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();
; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();
; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();
; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());
; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());
; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1916 : 		}
; 1917 : 
; 1918 : 	void _Assign_n(size_type _Count, const _Ty& _Val)
; 1919 : 		{	// assign _Count * _Val
; 1920 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1921 : 		clear();
; 1922 : 		_Insert_n(_Unchecked_begin(), _Count, _Tmp);
; 1923 : 		}
; 1924 : 
; 1925 : 	void _Tidy()
; 1926 : 		{	// free all storage
; 1927 : 		clear();
; 1928 : 		}
; 1929 : 
; 1930 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1931 : 		size_type _Count, const _Ty& _Val)
; 1932 : 		{	// insert _Count * _Val at _Where
; 1933 : 		size_type _Countsave = _Count;
; 1934 : 
; 1935 : 		_TRY_BEGIN
; 1936 : 		for (; 0 < _Count; --_Count)
; 1937 : 			_Insert(_Where, _Val);
; 1938 : 		_CATCH_ALL
; 1939 : 		for (; _Count < _Countsave; ++_Count)
; 1940 : 			{	// undo inserts
; 1941 : 			_Unchecked_const_iterator _Before = _Where;
; 1942 : 			_Unchecked_erase(--_Before);
; 1943 : 			}
; 1944 : 		_RERAISE;
; 1945 : 		_CATCH_END
; 1946 : 		}
; 1947 : 
; 1948 : 	void _Incsize(size_type _Count)
; 1949 : 		{	// alter element count, with checking
; 1950 : 		if (max_size() - this->_Mysize - 1 < _Count)

  0001c	48 ba 54 55 55
	55 55 55 55 05	 mov	 rdx, 384307168202282324	; 0555555555555554H

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00026	4c 8b c0	 mov	 r8, rax

; 1087 : #undef _LIST_EMPLACE_CHECK
; 1088 : #undef _LIST_EMPLACE_INSERT
; 1089 : 
; 1090 : 	~list() _NOEXCEPT
; 1091 : 		{	// destroy the object
; 1092 : 		_Tidy();
; 1093 : 		}
; 1094 : 
; 1095 : 	_Myt& operator=(const _Myt& _Right)
; 1096 : 		{	// assign _Right
; 1097 : 		if (this != &_Right)
; 1098 : 			{	// different, assign it
; 1099 :  #if _HAS_CPP0X
; 1100 : 			if (this->_Getal() != _Right._Getal()
; 1101 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1102 : 				{	// change allocator before copying
; 1103 : 				clear();
; 1104 : 				this->_Change_alloc(_Right._Getal());
; 1105 : 				}
; 1106 :  #endif /* _HAS_CPP0X */
; 1107 : 
; 1108 : 			assign(_Right.begin(), _Right.end());
; 1109 : 			}
; 1110 : 		return (*this);
; 1111 : 		}
; 1112 : 
; 1113 : 	iterator begin() _NOEXCEPT
; 1114 : 		{	// return iterator for beginning of mutable sequence
; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));
; 1116 : 		}
; 1117 : 
; 1118 : 	const_iterator begin() const _NOEXCEPT
; 1119 : 		{	// return iterator for beginning of nonmutable sequence
; 1120 : 		return (const_iterator(this->_Nextnode(this->_Myhead), this));
; 1121 : 		}
; 1122 : 
; 1123 : 	iterator end() _NOEXCEPT
; 1124 : 		{	// return iterator for end of mutable sequence
; 1125 : 		return (iterator(this->_Myhead, this));
; 1126 : 		}
; 1127 : 
; 1128 : 	const_iterator end() const _NOEXCEPT
; 1129 : 		{	// return iterator for end of nonmutable sequence
; 1130 : 		return (const_iterator(this->_Myhead, this));
; 1131 : 		}
; 1132 : 
; 1133 : 	_Unchecked_iterator _Unchecked_begin()
; 1134 : 		{	// return iterator for beginning of mutable sequence
; 1135 : 		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
; 1136 : 			this));
; 1137 : 		}
; 1138 : 
; 1139 : 	_Unchecked_const_iterator _Unchecked_begin() const
; 1140 : 		{	// return iterator for beginning of nonmutable sequence
; 1141 : 		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
; 1142 : 			this));
; 1143 : 		}
; 1144 : 
; 1145 : 	_Unchecked_iterator _Unchecked_end()
; 1146 : 		{	// return unchecked iterator for end of mutable sequence
; 1147 : 		return (_Unchecked_iterator(this->_Myhead, this));
; 1148 : 		}
; 1149 : 
; 1150 : 	_Unchecked_const_iterator _Unchecked_end() const
; 1151 : 		{	// return unchecked iterator for end of nonmutable sequence
; 1152 : 		return (_Unchecked_const_iterator(this->_Myhead, this));
; 1153 : 		}
; 1154 : 
; 1155 : 	iterator _Make_iter(const_iterator _Where) const _NOEXCEPT
; 1156 : 		{	// make iterator from const_iterator
; 1157 : 		return (iterator(_Where._Ptr, this));
; 1158 : 		}
; 1159 : 
; 1160 : 	iterator _Make_iter(_Unchecked_const_iterator _Where) const
; 1161 : 		{	// make iterator from _Unchecked_const_iterator
; 1162 : 		return (iterator(_Where._Ptr, this));
; 1163 : 		}
; 1164 : 
; 1165 : 	reverse_iterator rbegin() _NOEXCEPT
; 1166 : 		{	// return iterator for beginning of reversed mutable sequence
; 1167 : 		return (reverse_iterator(end()));
; 1168 : 		}
; 1169 : 
; 1170 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1171 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1172 : 		return (const_reverse_iterator(end()));
; 1173 : 		}
; 1174 : 
; 1175 : 	reverse_iterator rend() _NOEXCEPT
; 1176 : 		{	// return iterator for end of reversed mutable sequence
; 1177 : 		return (reverse_iterator(begin()));
; 1178 : 		}
; 1179 : 
; 1180 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1181 : 		{	// return iterator for end of reversed nonmutable sequence
; 1182 : 		return (const_reverse_iterator(begin()));
; 1183 : 		}
; 1184 : 
; 1185 :  #if _HAS_CPP0X
; 1186 : 	const_iterator cbegin() const _NOEXCEPT
; 1187 : 		{	// return iterator for beginning of nonmutable sequence
; 1188 : 		return (((const _Myt *)this)->begin());
; 1189 : 		}
; 1190 : 
; 1191 : 	const_iterator cend() const _NOEXCEPT
; 1192 : 		{	// return iterator for end of nonmutable sequence
; 1193 : 		return (((const _Myt *)this)->end());
; 1194 : 		}
; 1195 : 
; 1196 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1197 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1198 : 		return (((const _Myt *)this)->rbegin());
; 1199 : 		}
; 1200 : 
; 1201 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1202 : 		{	// return iterator for end of reversed nonmutable sequence
; 1203 : 		return (((const _Myt *)this)->rend());
; 1204 : 		}
; 1205 :  #endif /* _HAS_CPP0X */
; 1206 : 
; 1207 : 	void resize(size_type _Newsize)
; 1208 : 		{	// determine new length, padding with _Ty() elements as needed
; 1209 : 		if (this->_Mysize < _Newsize)
; 1210 : 			{	// pad to make larger
; 1211 : 			size_type _Count = 0;
; 1212 : 			_TRY_BEGIN
; 1213 : 			for (; this->_Mysize < _Newsize; ++_Count)
; 1214 : 				_Insert(_Unchecked_end());
; 1215 : 			_CATCH_ALL
; 1216 : 			for (; 0 < _Count; --_Count)
; 1217 : 				pop_back();	// undo inserts
; 1218 : 			_RERAISE;
; 1219 : 			_CATCH_END
; 1220 : 			}
; 1221 : 		else
; 1222 : 			while (_Newsize < this->_Mysize)
; 1223 : 				pop_back();
; 1224 : 		}
; 1225 : 
; 1226 : 	void resize(size_type _Newsize, const _Ty& _Val)
; 1227 : 		{	// determine new length, padding with _Val elements as needed
; 1228 : 		if (this->_Mysize < _Newsize)
; 1229 : 			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
; 1230 : 		else
; 1231 : 			while (_Newsize < this->_Mysize)
; 1232 : 				pop_back();
; 1233 : 		}
; 1234 : 
; 1235 : 	size_type size() const _NOEXCEPT
; 1236 : 		{	// return length of sequence
; 1237 : 		return (this->_Mysize);
; 1238 : 		}
; 1239 : 
; 1240 : 	size_type max_size() const _NOEXCEPT
; 1241 : 		{	// return maximum possible length of sequence
; 1242 : 		return (this->_Getal().max_size());
; 1243 : 		}
; 1244 : 
; 1245 : 	bool empty() const _NOEXCEPT
; 1246 : 		{	// test if sequence is empty
; 1247 : 		return (this->_Mysize == 0);
; 1248 : 		}
; 1249 : 
; 1250 : 	allocator_type get_allocator() const _NOEXCEPT
; 1251 : 		{	// return allocator object for values
; 1252 : 		return (this->_Getal());
; 1253 : 		}
; 1254 : 
; 1255 : 	reference front()
; 1256 : 		{	// return first element of mutable sequence
; 1257 : 		return (*begin());
; 1258 : 		}
; 1259 : 
; 1260 : 	const_reference front() const
; 1261 : 		{	// return first element of nonmutable sequence
; 1262 : 		return (*begin());
; 1263 : 		}
; 1264 : 
; 1265 : 	reference back()
; 1266 : 		{	// return last element of mutable sequence
; 1267 : 		return (*(--end()));
; 1268 : 		}
; 1269 : 
; 1270 : 	const_reference back() const
; 1271 : 		{	// return last element of nonmutable sequence
; 1272 : 		return (*(--end()));
; 1273 : 		}
; 1274 : 
; 1275 : 	void push_front(const _Ty& _Val)
; 1276 : 		{	// insert element at beginning
; 1277 : 		_Insert(_Unchecked_begin(), _Val);
; 1278 : 		}
; 1279 : 
; 1280 : 	void pop_front()
; 1281 : 		{	// erase element at beginning
; 1282 : 		erase(begin());
; 1283 : 		}
; 1284 : 
; 1285 : 	void push_back(const _Ty& _Val)
; 1286 : 		{	// insert element at end
; 1287 : 		_Insert(_Unchecked_end(), _Val);
; 1288 : 		}
; 1289 : 
; 1290 : 	void pop_back()
; 1291 : 		{	// erase element at end
; 1292 : 		erase(--end());
; 1293 : 		}
; 1294 : 
; 1295 : 	template<class _Iter>
; 1296 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1297 : 			void>::type
; 1298 : 		assign(_Iter _First, _Iter _Last)
; 1299 : 		{	// assign [_First, _Last), input iterators
; 1300 : 		iterator _Old = begin();
; 1301 : 		_TRY_BEGIN
; 1302 : 		for (; _First != _Last && _Old != end(); ++_First, ++_Old)
; 1303 : 			*_Old = *_First;
; 1304 : 		for (; _First != _Last; ++_First)
; 1305 : 			_Insert(_Unchecked_end(), *_First);
; 1306 : 		_CATCH_ALL
; 1307 : 		clear();
; 1308 : 		_RERAISE;
; 1309 : 		_CATCH_END
; 1310 : 		erase(_Old, end());
; 1311 : 		}
; 1312 : 
; 1313 : 	void assign(size_type _Count, const _Ty& _Val)
; 1314 : 		{	// assign _Count * _Val
; 1315 : 		_Assign_n(_Count, _Val);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1319 : 		{	// insert _Val at _Where
; 1320 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1321 : 		if (_Where._Getcont() != this)
; 1322 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1323 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1324 : 
; 1325 : 		_Insert(_Where._Unchecked(), _Val);
; 1326 : 		return (_Make_iter(--_Where));
; 1327 : 		}
; 1328 : 
; 1329 : 	iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
; 1330 : 		{	// insert _Count * _Val at _Where
; 1331 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1332 : 		if (_Where._Getcont() != this)
; 1333 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1334 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1335 : 
; 1336 : 		iterator _Prev = _Make_iter(_Where);
; 1337 : 		if (_Prev == begin())
; 1338 : 			{	// insert sequence at beginning
; 1339 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1340 : 			return (begin());
; 1341 : 			}
; 1342 : 		else
; 1343 : 			{	// insert sequence not at beginning
; 1344 : 			--_Prev;
; 1345 : 			_Insert_n(_Where._Unchecked(), _Count, _Val);
; 1346 : 			return (++_Prev);
; 1347 : 			}
; 1348 : 		}
; 1349 : 
; 1350 : 	template<class _Iter>
; 1351 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1352 : 			iterator>::type
; 1353 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1354 : 		{	// insert [_First, _Last) at _Where
; 1355 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1356 : 		if (_Where._Getcont() != this)
; 1357 : 			_DEBUG_ERROR("list insert iterator outside range");
; 1358 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1359 : 
; 1360 : 		iterator _Prev = _Make_iter(_Where);
; 1361 : 		if (_Prev == begin())
; 1362 : 			{	// insert sequence at beginning
; 1363 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1364 : 				_Iter_cat(_First));
; 1365 : 			return (begin());
; 1366 : 			}
; 1367 : 		else
; 1368 : 			{	// insert sequence not at beginning
; 1369 : 			--_Prev;
; 1370 : 			_Insert_range(_Where._Unchecked(), _First, _Last,
; 1371 : 				_Iter_cat(_First));
; 1372 : 			return (++_Prev);
; 1373 : 			}
; 1374 : 		}
; 1375 : 
; 1376 : 	template<class _Iter>
; 1377 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1378 : 			_Iter _First, _Iter _Last, input_iterator_tag)
; 1379 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1380 : 		size_type _Num = 0;
; 1381 : 
; 1382 : 		_TRY_BEGIN
; 1383 : 		for (; _First != _Last; ++_First, ++_Num)
; 1384 : 			_Insert(_Where, *_First);
; 1385 : 		_CATCH_ALL
; 1386 : 		for (; 0 < _Num; --_Num)
; 1387 : 			{	// undo inserts
; 1388 : 			_Unchecked_const_iterator _Before = _Where;
; 1389 : 			_Unchecked_erase(--_Before);
; 1390 : 			}
; 1391 : 		_RERAISE;
; 1392 : 		_CATCH_END
; 1393 : 		}
; 1394 : 
; 1395 : 	template<class _Iter>
; 1396 : 		void _Insert_range(_Unchecked_const_iterator _Where,
; 1397 : 			_Iter _First, _Iter _Last, forward_iterator_tag)
; 1398 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1399 : 		_DEBUG_RANGE(_First, _Last);
; 1400 : 		_Iter _Next = _First;
; 1401 : 
; 1402 : 		_TRY_BEGIN
; 1403 : 		for (; _First != _Last; ++_First)
; 1404 : 			_Insert(_Where, *_First);
; 1405 : 		_CATCH_ALL
; 1406 : 		for (; _Next != _First; ++_Next)
; 1407 : 			{	// undo inserts
; 1408 : 			_Unchecked_const_iterator _Before = _Where;
; 1409 : 			_Unchecked_erase(--_Before);
; 1410 : 			}
; 1411 : 		_RERAISE;
; 1412 : 		_CATCH_END
; 1413 : 		}
; 1414 : 
; 1415 : 	iterator erase(const_iterator _Where)
; 1416 : 		{	// erase element at _Where
; 1417 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1418 : 		if (_Where._Getcont() != this || _Where._Ptr == this->_Myhead)
; 1419 : 			_DEBUG_ERROR("list erase iterator outside range");
; 1420 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1421 : 		_Orphan_ptr(*this, _Pnode);
; 1422 : 
; 1423 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1424 : 		_Nodeptr _Pnode = (_Where++)._Mynode();
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Pnode != this->_Myhead)
; 1428 : 			{	// not list head, safe to erase
; 1429 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1430 : 				this->_Nextnode(_Pnode);
; 1431 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1432 : 				this->_Prevnode(_Pnode);
; 1433 : 			this->_Freenode(_Pnode);
; 1434 : 			--this->_Mysize;
; 1435 : 			}
; 1436 : 		return (_Make_iter(_Where));
; 1437 : 		}
; 1438 : 
; 1439 : 	void _Unchecked_erase(_Unchecked_const_iterator _Where)
; 1440 : 		{	// erase element at _Where
; 1441 : 		_Nodeptr _Pnode = _Where._Mynode();
; 1442 : 
; 1443 : 		if (_Pnode != this->_Myhead)
; 1444 : 			{	// not list head, safe to erase
; 1445 : 			this->_Nextnode(this->_Prevnode(_Pnode)) =
; 1446 : 				this->_Nextnode(_Pnode);
; 1447 : 			this->_Prevnode(this->_Nextnode(_Pnode)) =
; 1448 : 				this->_Prevnode(_Pnode);
; 1449 : 			this->_Freenode(_Pnode);
; 1450 : 			--this->_Mysize;
; 1451 : 			}
; 1452 : 		}
; 1453 : 
; 1454 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1455 : 		{	// erase [_First, _Last)
; 1456 : 		if (_First == begin() && _Last == end())
; 1457 : 			{	// erase all and return fresh iterator
; 1458 : 			clear();
; 1459 : 			return (end());
; 1460 : 			}
; 1461 : 		else
; 1462 : 			{	// erase subrange
; 1463 : 			while (_First != _Last)
; 1464 : 				_First = erase(_First);
; 1465 : 			return (_Make_iter(_Last));
; 1466 : 			}
; 1467 : 		}
; 1468 : 
; 1469 : 	void clear() _NOEXCEPT
; 1470 : 		{	// erase all
; 1471 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1472 : 		this->_Orphan_all();
; 1473 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1474 : 
; 1475 : 		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
; 1476 : 		this->_Nextnode(this->_Myhead) = this->_Myhead;
; 1477 : 		this->_Prevnode(this->_Myhead) = this->_Myhead;
; 1478 : 		this->_Mysize = 0;
; 1479 : 
; 1480 : 		for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
; 1481 : 			{	// delete an element
; 1482 : 			_Pnext = this->_Nextnode(_Pnode);
; 1483 : 			this->_Freenode(_Pnode);
; 1484 : 			}
; 1485 : 		}
; 1486 : 
; 1487 : 	void swap(_Myt& _Right)
; 1488 : 		{	// exchange contents with _Right
; 1489 : 		if (this == &_Right)
; 1490 : 			;	// same object, do nothing
; 1491 : 		else if (this->_Getal() == _Right._Getal())
; 1492 : 			{	// same allocator, swap control information
; 1493 : 			this->_Swap_all(_Right);
; 1494 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1495 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1496 : 			}
; 1497 : 
; 1498 :  #if _HAS_CPP0X
; 1499 : 		else if (_Alty::propagate_on_container_swap::value)
; 1500 : 			{	// swap allocators and control information
; 1501 : 			this->_Swap_alloc(_Right);
; 1502 : 			_Swap_adl(this->_Myhead, _Right._Myhead);
; 1503 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1504 : 			}
; 1505 :  #endif /* _HAS_CPP0X */
; 1506 : 
; 1507 : 		else
; 1508 : 			{	// different allocator, do splices
; 1509 : 			iterator _Where = begin();
; 1510 : 			splice(_Where, _Right);
; 1511 : 			_Right.splice(_Right.begin(), *this, _Where, end());
; 1512 : 			}
; 1513 : 		}
; 1514 : 
; 1515 : 	void splice(const_iterator _Where, _Myt& _Right)
; 1516 : 		{	// splice all of _Right at _Where
; 1517 : 		if (this != &_Right && !_Right.empty())
; 1518 : 			{	// worth splicing, do it
; 1519 : 			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
; 1520 : 				_Right._Mysize);
; 1521 : 			}
; 1522 : 		}
; 1523 : 
; 1524 : 	void splice(const_iterator _Where, _Myt&& _Right)
; 1525 : 		{	// splice all of _Right at _Where
; 1526 : 		splice(_Where, (_Myt&)_Right);
; 1527 : 		}
; 1528 : 
; 1529 : 	void splice(const_iterator _Where, _Myt& _Right,
; 1530 : 		const_iterator _First)
; 1531 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1532 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1533 : 		if (_First == _Right.end())
; 1534 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1535 : 		else
; 1536 : 
; 1537 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1538 : 		if (_First != _Right.end())
; 1539 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1540 : 
; 1541 : 			{	// element exists, try splice
; 1542 : 			const_iterator _Last = _First;
; 1543 : 			++_Last;
; 1544 : 			if (this != &_Right
; 1545 : 				|| (_Where != _First && _Where != _Last))
; 1546 : 				_Splice(_Where, _Right, _First, _Last, 1);
; 1547 : 			}
; 1548 : 		}
; 1549 : 
; 1550 : 	void splice(const_iterator _Where, _Myt&& _Right,
; 1551 : 		const_iterator _First)
; 1552 : 		{	// splice _Right [_First, _First + 1) at _Where
; 1553 : 		splice(_Where, (_Myt&)_Right, _First);
; 1554 : 		}
; 1555 : 
; 1556 : 	void splice(const_iterator _Where,
; 1557 : 		_Myt& _Right, const_iterator _First, const_iterator _Last)
; 1558 : 		{	// splice _Right [_First, _Last) at _Where
; 1559 : 		if (_First != _Last && (this != &_Right || _Where != _Last))
; 1560 : 			{	// worth splicing, do it
; 1561 : 			size_type _Count = 0;
; 1562 : 
; 1563 : 			if (this == &_Right)
; 1564 : 				;	// just rearrange this list
; 1565 : 			else if (_First == _Right.begin() && _Last == _Right.end())
; 1566 : 				_Count = _Right._Mysize;	// splice in whole list
; 1567 : 			else
; 1568 : 				{	// count nodes and check for knot
; 1569 : 				const_iterator _Next = _First;
; 1570 : 
; 1571 : 				for (; _Next != _Last; ++_Next, ++_Count)
; 1572 : 					if (_Next == _Right.end())
; 1573 : 						_Xlength_error("list<T> bad splice");
; 1574 : 				}
; 1575 : 			_Splice(_Where, _Right, _First, _Last, _Count);
; 1576 : 			}
; 1577 : 		}
; 1578 : 
; 1579 : 	void splice(const_iterator _Where,
; 1580 : 		_Myt&& _Right, const_iterator _First, const_iterator _Last)
; 1581 : 		{	// splice _Right [_First, _Last) at _Where
; 1582 : 		splice(_Where, (_Myt&)_Right, _First, _Last);
; 1583 : 		}
; 1584 : 
; 1585 : 	void remove(const _Ty& _Val_arg)
; 1586 : 		{	// erase each element matching _Val
; 1587 : 		const _Ty _Val = _Val_arg;	// in case it's removed along the way
; 1588 : 		const _Nodeptr _Phead = this->_Myhead;
; 1589 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1590 : 
; 1591 : 		while (_Pnode != _Phead)
; 1592 : 			if (_Pnode->_Myval == _Val)
; 1593 : 				{	// match, remove it
; 1594 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1595 : 				const _Nodeptr _Perase = _Pnode;
; 1596 : 				_Pnode = this->_Nextnode(_Pnode);
; 1597 : 
; 1598 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1599 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1600 : 				this->_Freenode(_Perase);
; 1601 : 
; 1602 : 				--this->_Mysize;
; 1603 : 				}
; 1604 : 			else
; 1605 : 				_Pnode = this->_Nextnode(_Pnode);
; 1606 : 		}
; 1607 : 
; 1608 : 	template<class _Pr1>
; 1609 : 		void remove_if(_Pr1 _Pred)
; 1610 : 		{	// erase each element satisfying _Pred
; 1611 : 		const _Nodeptr _Phead = this->_Myhead;
; 1612 : 		_Nodeptr _Pnode = this->_Nextnode(_Phead);
; 1613 : 
; 1614 : 		while (_Pnode != _Phead)
; 1615 : 			if (_Pred(_Pnode->_Myval))
; 1616 : 				{	// match, remove it
; 1617 : 				const _Nodeptr _Pprev = this->_Prevnode(_Pnode);
; 1618 : 				const _Nodeptr _Perase = _Pnode;
; 1619 : 				_Pnode = this->_Nextnode(_Pnode);
; 1620 : 
; 1621 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1622 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1623 : 				this->_Freenode(_Perase);
; 1624 : 
; 1625 : 				--this->_Mysize;
; 1626 : 				}
; 1627 : 			else
; 1628 : 				_Pnode = this->_Nextnode(_Pnode);
; 1629 : 		}
; 1630 : 
; 1631 : 	void unique()
; 1632 : 		{	// erase each element matching previous
; 1633 : 		const _Nodeptr _Phead = this->_Myhead;
; 1634 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1635 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1636 : 
; 1637 : 		while (_Pnode != _Phead)
; 1638 : 			if (_Pprev->_Myval == _Pnode->_Myval)
; 1639 : 				{	// match, remove it
; 1640 : 				const _Nodeptr _Perase = _Pnode;
; 1641 : 				_Pnode = this->_Nextnode(_Pnode);
; 1642 : 
; 1643 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1644 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1645 : 				this->_Freenode(_Perase);
; 1646 : 
; 1647 : 				--this->_Mysize;
; 1648 : 				}
; 1649 : 			else
; 1650 : 				{	// no match, advance
; 1651 : 				_Pprev = _Pnode;
; 1652 : 				_Pnode = this->_Nextnode(_Pnode);
; 1653 : 				}
; 1654 : 		}
; 1655 : 
; 1656 : 	template<class _Pr2>
; 1657 : 		void unique(_Pr2 _Pred)
; 1658 : 		{	// erase each element satisfying _Pred with previous
; 1659 : 		const _Nodeptr _Phead = this->_Myhead;
; 1660 : 		_Nodeptr _Pprev = this->_Nextnode(_Phead);
; 1661 : 		_Nodeptr _Pnode = this->_Nextnode(_Pprev);
; 1662 : 
; 1663 : 		while (_Pnode != _Phead)
; 1664 : 			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
; 1665 : 				{	// match, remove it
; 1666 : 				const _Nodeptr _Perase = _Pnode;
; 1667 : 				_Pnode = this->_Nextnode(_Pnode);
; 1668 : 
; 1669 : 				this->_Nextnode(_Pprev) = _Pnode;
; 1670 : 				this->_Prevnode(_Pnode) = _Pprev;
; 1671 : 				this->_Freenode(_Perase);
; 1672 : 
; 1673 : 				--this->_Mysize;
; 1674 : 				}
; 1675 : 			else
; 1676 : 				{	// no match, advance
; 1677 : 				_Pprev = _Pnode;
; 1678 : 				_Pnode = this->_Nextnode(_Pnode);
; 1679 : 				}
; 1680 : 		}
; 1681 : 
; 1682 : 	void merge(_Myt& _Right)
; 1683 : 		{	// merge in elements from _Right, both ordered by operator<
; 1684 : 		if (&_Right != this)
; 1685 : 			{	// safe to merge, do it
; 1686 : 			iterator _First1 = begin(), _Last1 = end();
; 1687 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1688 : 			_DEBUG_ORDER(_First1, _Last1);
; 1689 : 			_DEBUG_ORDER(_First2, _Last2);
; 1690 : 
; 1691 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1692 : 				if (_DEBUG_LT(*_First2, *_First1))
; 1693 : 					{	// splice in an element from _Right
; 1694 : 					iterator _Mid2 = _First2;
; 1695 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1696 : 					_First2 = _Mid2;
; 1697 : 					}
; 1698 : 				else
; 1699 : 					++_First1;
; 1700 : 
; 1701 : 			if (_First2 != _Last2)
; 1702 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1703 : 					_Right._Mysize);	// splice remainder of _Right
; 1704 : 			}
; 1705 : 		}
; 1706 : 
; 1707 : 	void merge(_Myt&& _Right)
; 1708 : 		{	// merge in elements from _Right, both ordered by operator<
; 1709 : 		merge((_Myt&)_Right);
; 1710 : 		}
; 1711 : 
; 1712 : 	template<class _Pr2>
; 1713 : 		void merge(_Myt& _Right, _Pr2 _Pred)
; 1714 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1715 : 		if (&_Right != this)
; 1716 : 			{	// safe to merge, do it
; 1717 : 			iterator _First1 = begin(), _Last1 = end();
; 1718 : 			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
; 1719 : 			_DEBUG_ORDER_PRED(_First1, _Last1, _Pred);
; 1720 : 			_DEBUG_ORDER_PRED(_First2, _Last2, _Pred);
; 1721 : 
; 1722 : 			while (_First1 != _Last1 && _First2 != _Last2)
; 1723 : 				if (_DEBUG_LT_PRED(_Pred, *_First2, *_First1))
; 1724 : 					{	// splice in an element from _Right
; 1725 : 					iterator _Mid2 = _First2;
; 1726 : 					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
; 1727 : 					_First2 = _Mid2;
; 1728 : 					}
; 1729 : 				else
; 1730 : 					++_First1;
; 1731 : 
; 1732 : 			if (_First2 != _Last2)
; 1733 : 				_Splice(_Last1, _Right, _First2, _Last2,
; 1734 : 					_Right._Mysize);	// splice remainder of _Right
; 1735 : 			}
; 1736 : 		}
; 1737 : 
; 1738 : 	template<class _Pr2>
; 1739 : 		void merge(_Myt&& _Right, _Pr2 _Pred)
; 1740 : 		{	// merge in elements from _Right, both ordered by _Pred
; 1741 : 		merge((_Myt&)_Right, _Pred);
; 1742 : 		}
; 1743 : 
; 1744 : 	void sort()
; 1745 : 		{	// order sequence, using operator<
; 1746 : 		if (2 <= this->_Mysize)
; 1747 : 			{	// worth sorting, do it
; 1748 : 			const size_t _MAXBINS = 25;
; 1749 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1750 : 			size_t _Maxbin = 0;
; 1751 : 
; 1752 : 			while (!empty())
; 1753 : 				{	// sort another element, using bins
; 1754 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1755 : 					++begin(), 1);
; 1756 : 
; 1757 : 				size_t _Bin;
; 1758 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1759 : 					++_Bin)
; 1760 : 					{	// merge into ever larger bins
; 1761 : 					_Binlist[_Bin].merge(_Templist);
; 1762 : 					_Binlist[_Bin].swap(_Templist);
; 1763 : 					}
; 1764 : 
; 1765 : 				if (_Bin == _MAXBINS)
; 1766 : 					_Binlist[_Bin - 1].merge(_Templist);
; 1767 : 				else
; 1768 : 					{	// spill to new bin, while they last
; 1769 : 					_Binlist[_Bin].swap(_Templist);
; 1770 : 					if (_Bin == _Maxbin)
; 1771 : 						++_Maxbin;
; 1772 : 					}
; 1773 : 				}
; 1774 : 
; 1775 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1776 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1]);	// merge up
; 1777 : 
; 1778 : 			_Analysis_assume_(0 < _Maxbin);
; 1779 : 
; 1780 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1781 : 			}
; 1782 : 		}
; 1783 : 
; 1784 : 	template<class _Pr2>
; 1785 : 		void sort(_Pr2 _Pred)
; 1786 : 		{	// order sequence, using _Pred
; 1787 : 		if (2 <= this->_Mysize)
; 1788 : 			{	// worth sorting, do it
; 1789 : 			const size_t _MAXBINS = 25;
; 1790 : 			_Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
; 1791 : 			size_t _Maxbin = 0;
; 1792 : 
; 1793 : 			while (!empty())
; 1794 : 				{	// sort another element, using bins
; 1795 : 				_Templist._Splice_same(_Templist.begin(), *this, begin(),
; 1796 : 					++begin(), 1);
; 1797 : 
; 1798 : 				size_t _Bin;
; 1799 : 				for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
; 1800 : 					++_Bin)
; 1801 : 					{	// merge into ever larger bins
; 1802 : 					_Binlist[_Bin].merge(_Templist, _Pred);
; 1803 : 					_Binlist[_Bin].swap(_Templist);
; 1804 : 					}
; 1805 : 
; 1806 : 				if (_Bin == _MAXBINS)
; 1807 : 					_Binlist[_Bin - 1].merge(_Templist, _Pred);
; 1808 : 				else
; 1809 : 					{	// spill to new bin, while they last
; 1810 : 					_Binlist[_Bin].swap(_Templist);
; 1811 : 					if (_Bin == _Maxbin)
; 1812 : 						++_Maxbin;
; 1813 : 					}
; 1814 : 				}
; 1815 : 
; 1816 : 			for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
; 1817 : 				_Binlist[_Bin].merge(_Binlist[_Bin - 1],
; 1818 : 					_Pred);	// merge up
; 1819 : 
; 1820 : 			_Analysis_assume_(0 < _Maxbin);
; 1821 : 
; 1822 : 			splice(begin(), _Binlist[_Maxbin - 1]);	// result in last bin
; 1823 : 			}
; 1824 : 		}
; 1825 : 
; 1826 : 	void reverse() _NOEXCEPT
; 1827 : 		{	// reverse sequence
; 1828 : 		const _Nodeptr _Phead = this->_Myhead;
; 1829 : 		_Nodeptr _Pnode = _Phead;
; 1830 : 
; 1831 : 		for (; ; )
; 1832 : 			{	// flip pointers in a node
; 1833 : 			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
; 1834 : 			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
; 1835 : 			this->_Prevnode(_Pnode) = _Pnext;
; 1836 : 
; 1837 : 			if (_Pnext == _Phead)
; 1838 : 				break;
; 1839 : 			_Pnode = _Pnext;
; 1840 : 			}
; 1841 : 		}
; 1842 : 
; 1843 : 	void _Splice(const_iterator _Where,
; 1844 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1845 : 		size_type _Count)
; 1846 : 		{	// splice _Right [_First, _Last) before _Where
; 1847 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1848 : 		if (_Where._Getcont() != this)
; 1849 : 			_DEBUG_ERROR("list splice iterator outside range");
; 1850 : 		if (this->_Getal() == _Right._Getal())
; 1851 : 			{	// same allocator, just relink
; 1852 : 			if (this != &_Right)
; 1853 : 				for (const_iterator _Next = _First; _Next != _Last; )
; 1854 : 					{	// transfer ownership
; 1855 : 					const_iterator _Iter = _Next++;
; 1856 : 					_Orphan_ptr(_Right, _Iter._Ptr);
; 1857 : 					_Iter._Adopt(this);
; 1858 : 					}
; 1859 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1860 : 			}
; 1861 : 
; 1862 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1863 : 		if (this->_Getal() == _Right._Getal())
; 1864 : 			_Splice_same(_Where, _Right, _First, _Last, _Count);
; 1865 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1866 : 
; 1867 : 		else
; 1868 : 			{	// different allocator, copy nodes then erase source
; 1869 : 			for (const_iterator _Next = _First; _Next != _Last; ++_Next)
; 1870 : 				insert(_Where, (_Ty&&)*_Next);
; 1871 : 			_Right.erase(_First, _Last);
; 1872 : 			}
; 1873 : 		}
; 1874 : 
; 1875 : 	void _Splice_same(const_iterator _Where,
; 1876 : 		_Myt& _Right, const_iterator _First, const_iterator _Last,
; 1877 : 		size_type _Count)
; 1878 : 		{	// splice _Right [_First, _Last) before _Where
; 1879 : 		if (this != &_Right)
; 1880 : 			{	// splicing from another list, adjust counts
; 1881 : 			_Incsize(_Count);
; 1882 : 			_Right._Mysize -= _Count;
; 1883 : 			}
; 1884 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1885 : 			_Last._Mynode();
; 1886 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1887 : 			_Where._Mynode();
; 1888 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1889 : 			_First._Mynode();
; 1890 : 
; 1891 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1892 : 		this->_Prevnode(_Where._Mynode()) =
; 1893 : 			this->_Prevnode(_Last._Mynode());
; 1894 : 		this->_Prevnode(_Last._Mynode()) =
; 1895 : 			this->_Prevnode(_First._Mynode());
; 1896 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1897 : 		}
; 1898 : 
; 1899 : 	void _Unchecked_splice(_Unchecked_const_iterator _Where,
; 1900 : 		_Unchecked_const_iterator _First,
; 1901 : 		_Unchecked_const_iterator _Last)
; 1902 : 		{	// splice [_First, _Last) before _Where
; 1903 : 		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
; 1904 : 			_Last._Mynode();
; 1905 : 		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
; 1906 : 			_Where._Mynode();
; 1907 : 		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
; 1908 : 			_First._Mynode();
; 1909 : 
; 1910 : 		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
; 1911 : 		this->_Prevnode(_Where._Mynode()) =
; 1912 : 			this->_Prevnode(_Last._Mynode());
; 1913 : 		this->_Prevnode(_Last._Mynode()) =
; 1914 : 			this->_Prevnode(_First._Mynode());
; 1915 : 		this->_Prevnode(_First._Mynode()) = _Pnode;
; 1916 : 		}
; 1917 : 
; 1918 : 	void _Assign_n(size_type _Count, const _Ty& _Val)
; 1919 : 		{	// assign _Count * _Val
; 1920 : 		_Ty _Tmp = _Val;	// in case _Val is in sequence
; 1921 : 		clear();
; 1922 : 		_Insert_n(_Unchecked_begin(), _Count, _Tmp);
; 1923 : 		}
; 1924 : 
; 1925 : 	void _Tidy()
; 1926 : 		{	// free all storage
; 1927 : 		clear();
; 1928 : 		}
; 1929 : 
; 1930 : 	void _Insert_n(_Unchecked_const_iterator _Where,
; 1931 : 		size_type _Count, const _Ty& _Val)
; 1932 : 		{	// insert _Count * _Val at _Where
; 1933 : 		size_type _Countsave = _Count;
; 1934 : 
; 1935 : 		_TRY_BEGIN
; 1936 : 		for (; 0 < _Count; --_Count)
; 1937 : 			_Insert(_Where, _Val);
; 1938 : 		_CATCH_ALL
; 1939 : 		for (; _Count < _Countsave; ++_Count)
; 1940 : 			{	// undo inserts
; 1941 : 			_Unchecked_const_iterator _Before = _Where;
; 1942 : 			_Unchecked_erase(--_Before);
; 1943 : 			}
; 1944 : 		_RERAISE;
; 1945 : 		_CATCH_END
; 1946 : 		}
; 1947 : 
; 1948 : 	void _Incsize(size_type _Count)
; 1949 : 		{	// alter element count, with checking
; 1950 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00029	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0002d	48 2b d0	 sub	 rdx, rax
  00030	48 83 fa 01	 cmp	 rdx, 1
  00034	72 1d		 jb	 SHORT $LN30@Insert

; 1952 : 		this->_Mysize += _Count;

  00036	48 ff c0	 inc	 rax
  00039	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  0003d	4c 89 43 08	 mov	 QWORD PTR [rbx+8], r8

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00041	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]

; 1086 : _VARIADIC_EXPAND_0X(_LIST_EMPLACE_INSERT, , , , )

  00045	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004a	4c 89 00	 mov	 QWORD PTR [rax], r8
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN30@Insert:

; 1951 : 			_Xlength_error("list<T> too long");

  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0005a	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0005f	cc		 int	 3
$LN29@Insert:
??$_Insert@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAXV?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Insert<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Val1$ = 16
_Val2$ = 24
__formal$dead$ = 32
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z PROC ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>, COMDAT

; 138  : 		{	// construct from moved values

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 89 01	 mov	 QWORD PTR [rcx], rax
  00006	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  0000a	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 139  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@_N@std@@QEAA@$$QEAV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEA_NPEAPEAX@Z ENDP ; std::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>::pair<std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool><std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z PROC ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ENDP ; std::forward<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ??$_Buynode_if_nil@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V21@@Z
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
__formal$dead$ = 24
_Plist$ = 32
??$_Buynode_if_nil@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V21@@Z PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>, COMDAT

; 842  : 			_Unchecked_iterator _Plist)
; 843  : 		{	// node exists, just return it
; 844  : 		return (_Plist);

  00000	4c 89 0a	 mov	 QWORD PTR [rdx], r9
  00003	48 8b c2	 mov	 rax, rdx

; 845  : 		}

  00006	c3		 ret	 0
??$_Buynode_if_nil@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@IEAA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@V21@@Z ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::_Buynode_if_nil<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z PROC ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>, COMDAT

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 621  : 		void destroy(_Uty *_Ptr)

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN16@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN19@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN19@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN19@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::destroy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$move@AEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>, COMDAT

; 1791 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1792 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 18		 je	 SHORT $LN4@Uninit_mov
$LL6@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00005	4d 85 c0	 test	 r8, r8
  00008	74 06		 je	 SHORT $LN36@Uninit_mov
  0000a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000d	49 89 00	 mov	 QWORD PTR [r8], rax
$LN36@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00010	48 83 c1 08	 add	 rcx, 8
  00014	49 83 c0 08	 add	 r8, 8
  00018	48 3b ca	 cmp	 rcx, rdx
  0001b	75 e8		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 433  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 434  : 	_CATCH_ALL
; 435  : 	for (; _Next != _Dest; ++_Next)
; 436  : 		_Al.destroy(_Next);
; 437  : 	_RERAISE;
; 438  : 	_CATCH_END
; 439  : 	return (_Dest);

  0001d	49 8b c0	 mov	 rax, r8

; 440  : 	}

  00020	c3		 ret	 0
??$_Uninit_move@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@2@V12@@std@@YAPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@PEAV10@00AEAU?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > * __ptr64,std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z PROC ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN3@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN3@construct:
  0000b	f3 c3		 fatret	 0
??$construct@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@AEAPEAU12@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@AEAPEAU21@@Z ENDP ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64,std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV21@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>, COMDAT

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN23@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN23@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV21@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor', COMDAT
$LN22:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  0000a	48 8b 59 18	 mov	 rbx, QWORD PTR [rcx+24]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 35		 je	 SHORT $LN19@scalar

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00016	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0001a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001f	75 17		 jne	 SHORT $LN18@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00021	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00024	48 8b cb	 mov	 rcx, rbx
  00027	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00029	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0002d	75 09		 jne	 SHORT $LN18@scalar

; 128  : 			_Delete_this();

  0002f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00032	48 8b cb	 mov	 rcx, rbx
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
$LN18@scalar:
  00038	48 8b c7	 mov	 rax, rdi
  0003b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00040	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN19@scalar:
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
??_G?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAXI@Z ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >, COMDAT
$LN16:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 18	 mov	 rbx, QWORD PTR [rcx+24]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN11@pair

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN14@pair

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN14@pair

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN14@pair:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN11@pair:
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::~pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Incsize@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Incsize@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX_K@Z PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Incsize, COMDAT

; 1949 : 		{	// alter element count, with checking

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1950 : 		if (max_size() - this->_Mysize - 1 < _Count)

  00004	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00008	48 b8 54 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282324	; 0555555555555554H
  00012	48 2b c2	 sub	 rax, rdx
  00015	48 83 f8 01	 cmp	 rax, 1
  00019	72 0d		 jb	 SHORT $LN15@Incsize

; 1952 : 		this->_Mysize += _Count;

  0001b	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  0001f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1953 : 		}

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
$LN15@Incsize:

; 1951 : 			_Xlength_error("list<T> too long");

  00028	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@MOGOBHAF@list?$DMT?$DO?5too?5long?$AA@
  0002f	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00034	cc		 int	 3
$LN14@Incsize:
?_Incsize@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAX_K@Z ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Incsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?max_size@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA_KXZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::max_size, COMDAT

; 1242 : 		return (this->_Getal().max_size());

  00000	48 b8 55 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282325	; 0555555555555555H

; 1243 : 		}

  0000a	c3		 ret	 0
?max_size@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size, COMDAT

; 914  : 		return (_Mytraits::max_size(*this));

  00000	48 b8 55 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282325	; 0555555555555555H

; 915  : 		}

  0000a	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size, COMDAT

; 762  : 		return (_Al.max_size());

  00000	48 b8 55 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282325	; 0555555555555555H

; 763  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SA_KAEBV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEBA_KXZ PROC ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::max_size, COMDAT

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	48 b8 55 55 55
	55 55 55 55 05	 mov	 rax, 384307168202282325	; 0555555555555555H

; 629  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEBA_KXZ ENDP ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Next$ = 56
_Prev$ = 64
_V0$ = 72
??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 850  : _VARIADIC_EXPAND_0X(_LIST_BUYNODE, , , , )

$LN74:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b d9	 mov	 rbx, r9
  00009	e8 00 00 00 00	 call	 ?_Buynode0@?$_List_alloc@$0A@U?$_List_base_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@0@Z ; std::_List_alloc<0,std::_List_base_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_Buynode0

; 547  : 		return ((reference)_Pnode->_Myval);

  0000e	48 8d 50 10	 lea	 rdx, QWORD PTR [rax+16]

; 850  : _VARIADIC_EXPAND_0X(_LIST_BUYNODE, , , , )

  00012	4c 8b d0	 mov	 r10, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00015	48 85 d2	 test	 rdx, rdx
  00018	74 3f		 je	 SHORT $LN59@Buynode
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0001a	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  0001c	48 83 c2 10	 add	 rdx, 16
  00020	4c 8d 43 10	 lea	 r8, QWORD PTR [rbx+16]
  00024	89 4a f0	 mov	 DWORD PTR [rdx-16], ecx
  00027	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  0002a	89 4a f4	 mov	 DWORD PTR [rdx-12], ecx
  0002d	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]
  00030	89 4a f8	 mov	 DWORD PTR [rdx-8], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00033	33 c9		 xor	 ecx, ecx
  00035	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00038	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0003c	49 3b d0	 cmp	 rdx, r8
  0003f	74 18		 je	 SHORT $LN59@Buynode
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00041	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00045	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00049	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0004d	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00050	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00053	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00056	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN59@Buynode:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 850  : _VARIADIC_EXPAND_0X(_LIST_BUYNODE, , , , )

  00059	49 8b c2	 mov	 rax, r10
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
??$_Buynode@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@?$_List_buy@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEAU21@0$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_List_buy<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Buynode<std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z PROC ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN23@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN23@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z ENDP ; std::_Wrap_alloc<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YAAEBV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEBV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>, COMDAT

; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);
; 587  : 		}
; 588  : 
; 589  : 	pointer allocate(size_type _Count)
; 590  : 		{	// allocate array of _Count elements
; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}
; 593  : 
; 594  : 	pointer allocate(size_type _Count, const void *)
; 595  : 		{	// allocate array of _Count elements, ignore hint
; 596  : 		return (allocate(_Count));
; 597  : 		}
; 598  : 
; 599  : 	void construct(_Ty *_Ptr)
; 600  : 		{	// default construct object at _Ptr
; 601  : 		::new ((void *)_Ptr) _Ty();
; 602  : 		}
; 603  : 
; 604  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 605  : 		{	// construct object at _Ptr with value _Val
; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN19@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN19@construct:

; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 42		 je	 SHORT $LN44@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	48 83 c2 10	 add	 rdx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0000c	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0000e	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  00011	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00015	49 83 c0 10	 add	 r8, 16
  00019	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  0001c	41 8b 40 f8	 mov	 eax, DWORD PTR [r8-8]
  00020	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00023	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00026	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0002a	49 3b d0	 cmp	 rdx, r8
  0002d	74 18		 je	 SHORT $LN44@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0002f	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00033	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00037	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0003b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0003e	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00041	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00044	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN44@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00047	f3 c3		 fatret	 0
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$_Wrap_alloc@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$dead$ = 24
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}

  00000	c2 00 00	 ret	 0
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@@_Alloc_destroy@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Alloc_destroy::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z PROC ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@YA$$QEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@0@AEAV10@@Z ENDP ; std::forward<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z PROC ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);
; 587  : 		}
; 588  : 
; 589  : 	pointer allocate(size_type _Count)
; 590  : 		{	// allocate array of _Count elements
; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}
; 593  : 
; 594  : 	pointer allocate(size_type _Count, const void *)
; 595  : 		{	// allocate array of _Count elements, ignore hint
; 596  : 		return (allocate(_Count));
; 597  : 		}
; 598  : 
; 599  : 	void construct(_Ty *_Ptr)
; 600  : 		{	// default construct object at _Ptr
; 601  : 		::new ((void *)_Ptr) _Ty();
; 602  : 		}
; 603  : 
; 604  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 605  : 		{	// construct object at _Ptr with value _Val
; 606  : 		::new ((void *)_Ptr) _Ty(_Val);
; 607  : 		}
; 608  : 
; 609  : #define _ALLOC_MEMBER_CONSTRUCT( \
; 610  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 611  : 	template<class _Objty COMMA LIST(_CLASS_TYPE)> \
; 612  : 		void construct(_Objty *_Ptr COMMA LIST(_TYPE_REFREF_ARG)) \
; 613  : 		{	/* construct _Objty(_Types...) at _Ptr */ \
; 614  : 		::new ((void *)_Ptr) _Objty(LIST(_FORWARD_ARG)); \
; 615  : 		}
; 616  : 
; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN19@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN19@construct:

; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z ENDP ; std::allocator_traits<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBV32@@_Alloc_construct@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
_V0$ = 32
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBV32@@_Alloc_construct@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z PROC ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>, COMDAT

; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);
; 587  : 		}
; 588  : 
; 589  : 	pointer allocate(size_type _Count)
; 590  : 		{	// allocate array of _Count elements
; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}
; 593  : 
; 594  : 	pointer allocate(size_type _Count, const void *)
; 595  : 		{	// allocate array of _Count elements, ignore hint
; 596  : 		return (allocate(_Count));
; 597  : 		}
; 598  : 
; 599  : 	void construct(_Ty *_Ptr)
; 600  : 		{	// default construct object at _Ptr
; 601  : 		::new ((void *)_Ptr) _Ty();
; 602  : 		}
; 603  : 
; 604  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 605  : 		{	// construct object at _Ptr with value _Val
; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00000	4d 85 c0	 test	 r8, r8
  00003	74 06		 je	 SHORT $LN15@Fn
  00005	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00008	49 89 00	 mov	 QWORD PTR [r8], rax
$LN15@Fn:

; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBV32@@_Alloc_construct@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z ENDP ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 42		 je	 SHORT $LN40@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	48 83 c2 10	 add	 rdx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0000c	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0000e	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  00011	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00015	49 83 c0 10	 add	 r8, 16
  00019	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  0001c	41 8b 40 f8	 mov	 eax, DWORD PTR [r8-8]
  00020	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00023	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00026	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0002a	49 3b d0	 cmp	 rdx, r8
  0002d	74 18		 je	 SHORT $LN40@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0002f	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00033	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00037	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0003b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0003e	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00041	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00044	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN40@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00047	f3 c3		 fatret	 0
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator_traits@V?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@@std@@SAXAEAV?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@1@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> > >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V32@@_Alloc_construct@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Al$dead$ = 16
_Ptr$ = 24
_V0$ = 32
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V32@@_Alloc_construct@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z PROC ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);
; 587  : 		}
; 588  : 
; 589  : 	pointer allocate(size_type _Count)
; 590  : 		{	// allocate array of _Count elements
; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}
; 593  : 
; 594  : 	pointer allocate(size_type _Count, const void *)
; 595  : 		{	// allocate array of _Count elements, ignore hint
; 596  : 		return (allocate(_Count));
; 597  : 		}
; 598  : 
; 599  : 	void construct(_Ty *_Ptr)
; 600  : 		{	// default construct object at _Ptr
; 601  : 		::new ((void *)_Ptr) _Ty();
; 602  : 		}
; 603  : 
; 604  : 	void construct(_Ty *_Ptr, const _Ty& _Val)
; 605  : 		{	// construct object at _Ptr with value _Val
; 606  : 		::new ((void *)_Ptr) _Ty(_Val);
; 607  : 		}
; 608  : 
; 609  : #define _ALLOC_MEMBER_CONSTRUCT( \
; 610  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 611  : 	template<class _Objty COMMA LIST(_CLASS_TYPE)> \
; 612  : 		void construct(_Objty *_Ptr COMMA LIST(_TYPE_REFREF_ARG)) \
; 613  : 		{	/* construct _Objty(_Types...) at _Ptr */ \
; 614  : 		::new ((void *)_Ptr) _Objty(LIST(_FORWARD_ARG)); \
; 615  : 		}
; 616  : 
; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	4d 85 c0	 test	 r8, r8
  00003	74 06		 je	 SHORT $LN15@Fn
  00005	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00008	49 89 00	 mov	 QWORD PTR [r8], rax
$LN15@Fn:

; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$_Fn@U?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V32@@_Alloc_construct@std@@SAXHAEAU?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z ENDP ; std::_Alloc_construct::_Fn<std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>, COMDAT

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN11@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN11@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 42		 je	 SHORT $LN36@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	48 83 c2 10	 add	 rdx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0000c	33 c9		 xor	 ecx, ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  0000e	89 42 f0	 mov	 DWORD PTR [rdx-16], eax
  00011	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00015	49 83 c0 10	 add	 r8, 16
  00019	89 42 f4	 mov	 DWORD PTR [rdx-12], eax
  0001c	41 8b 40 f8	 mov	 eax, DWORD PTR [r8-8]
  00020	89 42 f8	 mov	 DWORD PTR [rdx-8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00023	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00026	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0002a	49 3b d0	 cmp	 rdx, r8
  0002d	74 18		 je	 SHORT $LN36@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0002f	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00033	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00037	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0003b	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0003e	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00041	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00044	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN36@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00047	f3 c3		 fatret	 0
??$construct@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@U?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@@?$allocator@U?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@std@@@std@@QEAAXPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::_List_node<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,void * __ptr64> >::construct<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::pair<ChunkPosition,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);
; 758  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN11@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN11@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>, COMDAT

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN7@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN7@construct:

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@AEBV31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBV32@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Val$ = 24
?construct@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBV32@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::construct, COMDAT

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN3@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN3@construct:

; 607  : 		}

  0000b	f3 c3		 fatret	 0
?construct@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@AEBV32@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAX@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAX@Z PROC ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >, COMDAT

; 182  : 		{	// construct from moved compatible pair

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  00006	4c 8b c1	 mov	 r8, rcx
  00009	89 01		 mov	 DWORD PTR [rcx], eax
  0000b	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  0000e	48 83 c2 10	 add	 rdx, 16
  00012	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  00015	8b 42 f8	 mov	 eax, DWORD PTR [rdx-8]
  00018	89 41 08	 mov	 DWORD PTR [rcx+8], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  0001b	33 c9		 xor	 ecx, ecx
  0001d	49 89 09	 mov	 QWORD PTR [r9], rcx
  00020	49 89 49 08	 mov	 QWORD PTR [r9+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  00024	4c 3b ca	 cmp	 r9, rdx
  00027	74 18		 je	 SHORT $LN36@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00029	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0002d	49 89 41 08	 mov	 QWORD PTR [r9+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00031	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 48   : 	_Left = _Move(_Right);

  00035	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00038	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  0003b	49 89 01	 mov	 QWORD PTR [r9], rax

; 49   : 	_Right = _Move(_Tmp);

  0003e	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN36@shared_ptr:

; 183  : 		}

  00041	49 8b c0	 mov	 rax, r8
  00044	c3		 ret	 0
??$?0VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@$$QEAU?$pair@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@PEAPEAX@Z ENDP ; std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> ><ChunkPosition,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::destroy<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z PROC ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN7@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN7@construct:

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@1@PEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z PROC ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN3@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN3@construct:
  0000b	f3 c3		 fatret	 0
??$construct@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@?$allocator@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@@std@@QEAAXPEAV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@1@$$QEAV21@@Z ENDP ; std::allocator<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >::construct<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >,std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > > >
_TEXT	ENDS
END
