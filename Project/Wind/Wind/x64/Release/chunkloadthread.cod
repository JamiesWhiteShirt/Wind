; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?loaderThread@@3HA				; loaderThread
EXTRN	_time64:PROC
?loaderThread@@3HA DD 01H DUP (?)			; loaderThread
_BSS	ENDS
	ORG $+6
$SG4294957720 DB '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, 's', 00H, '\', 00H, 'g', 00H, 'e', 00H, 'n'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, '.', 00H, 'c', 00H, 'l', 00H, 00H, 00H
$SG4294957719 DB 'generateTerrain_1', 00H
PUBLIC	?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty
PUBLIC	?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkLoad
PUBLIC	?tick@ChunkLoadThread@@MEAA_NXZ			; ChunkLoadThread::tick
PUBLIC	?preStart@ChunkLoadThread@@MEAAXXZ		; ChunkLoadThread::preStart
PUBLIC	?staticInit@ChunkLoadThread@@SAXXZ		; ChunkLoadThread::staticInit
PUBLIC	?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::temperatureNoise
PUBLIC	?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::humidityNoise
PUBLIC	?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::minHeightNoise
PUBLIC	?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::solidNoise
PUBLIC	?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
PUBLIC	?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::stoneNoise
PUBLIC	?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::smoothnessNoise
PUBLIC	?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::maxHeightNoise
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A DB 038H DUP (?) ; ChunkLoadThread::temperatureNoise
?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A DB 038H DUP (?) ; ChunkLoadThread::humidityNoise
?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A DB 038H DUP (?) ; ChunkLoadThread::minHeightNoise
ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A DB 038H DUP (?) ; ChunkLoadThread::solidNoise
?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A DB 038H DUP (?) ; ChunkLoadThread::chunkGenProgram
piecewise_construct DB 01H DUP (?)
	ALIGN	4

?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A DB 038H DUP (?) ; ChunkLoadThread::stoneNoise
?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A DB 038H DUP (?) ; ChunkLoadThread::smoothnessNoise
?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A DB 038H DUP (?) ; ChunkLoadThread::maxHeightNoise
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@ChunkLoadThread@@MEAA_NXZ DD imagerel $LN365
	DD	imagerel $LN365+2875
	DD	imagerel $unwind$?tick@ChunkLoadThread@@MEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?preStart@ChunkLoadThread@@MEAAXXZ DD imagerel $LN31
	DD	imagerel $LN31+809
	DD	imagerel $unwind$?preStart@ChunkLoadThread@@MEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?staticInit@ChunkLoadThread@@SAXXZ DD imagerel $LN40
	DD	imagerel $LN40+755
	DD	imagerel $unwind$?staticInit@ChunkLoadThread@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+76
	DD	imagerel $unwind$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+70
	DD	imagerel $unwind$??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+188
	DD	imagerel $unwind$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+70
	DD	imagerel $unwind$??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+188
	DD	imagerel $unwind$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+70
	DD	imagerel $unwind$??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+54
	DD	imagerel $unwind$??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+70
	DD	imagerel $unwind$??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+49
	DD	imagerel $unwind$??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+70
	DD	imagerel $unwind$??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+54
	DD	imagerel $unwind$??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+70
	DD	imagerel $unwind$??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+188
	DD	imagerel $unwind$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+70
	DD	imagerel $unwind$??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+188
	DD	imagerel $unwind$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+89
	DD	00H
	DD	imagerel ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+166
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 041411H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+89
	DD	00H
	DD	imagerel ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+166
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 041411H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+89
	DD	00H
	DD	imagerel ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+166
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 041411H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+89
	DD	00H
	DD	imagerel ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+166
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 041411H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+25
	DD	00H
	DD	imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+60
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?staticInit@ChunkLoadThread@@SAXXZ DD 020601H
	DD	030029206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?preStart@ChunkLoadThread@@MEAAXXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tick@ChunkLoadThread@@MEAA_NXZ DD imagerel ?tick@ChunkLoadThread@@MEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+181
	DD	00H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+2535
	DD	01H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+2676
	DD	00H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+2764
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tick@ChunkLoadThread@@MEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tick@ChunkLoadThread@@MEAA_NXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	0f0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@ChunkLoadThread@@MEAA_NXZ DD 0154e19H
	DD	0159840H
	DD	016883bH
	DD	0177836H
	DD	0186832H
	DD	03b742eH
	DD	03a642aH
	DD	0393426H
	DD	032011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	0142H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
?minHeightNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; ChunkLoadThread::minHeightNoise$initializer$
?maxHeightNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; ChunkLoadThread::maxHeightNoise$initializer$
?smoothnessNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; ChunkLoadThread::smoothnessNoise$initializer$
?solidNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; ChunkLoadThread::solidNoise$initializer$
?stoneNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; ChunkLoadThread::stoneNoise$initializer$
?temperatureNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; ChunkLoadThread::temperatureNoise$initializer$
?humidityNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; ChunkLoadThread::humidityNoise$initializer$
?chunkGenProgram$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ; ChunkLoadThread::chunkGenProgram$initializer$
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
;	COMDAT time
_TEXT	SEGMENT
_Time$dead$ = 8
time	PROC						; COMDAT

; 133  :     return _time64(_Time);

  00000	33 c9		 xor	 ecx, ecx
  00002	e9 00 00 00 00	 jmp	 _time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::minHeightNoise'', COMDAT

; 8    : Noise::NoiseGenerator2D ChunkLoadThread::minHeightNoise(8, 12, 2.0f, time(0));

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 _time64
  0001b	48 8b d8	 mov	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 143  : {

  0001e	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A, 8
  00028	c7 05 04 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4, 256 ; 00000100H
  00032	c7 05 08 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+8, 12
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00044	f3 0f 11 05 0c
	00 00 00	 movss	 DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+12, xmm0
  0004c	89 05 10 00 00
	00		 mov	 DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16, eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 261  : {

  00052	c6 05 18 00 00
	00 00		 mov	 BYTE PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 143  : {

  00059	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0005e	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00063	48 89 05 30 00
	00 00		 mov	 QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48, rax

; 144  : 	srand(seed);

  0006a	8b cb		 mov	 ecx, ebx
  0006c	e8 00 00 00 00	 call	 srand

; 145  : 	for(int i = 0; i < size * size; i++)

  00071	33 db		 xor	 ebx, ebx
  00073	8b fb		 mov	 edi, ebx
  00075	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0007b	0f af c0	 imul	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	7e 24		 jle	 SHORT $LN5@minHeightN
$LL7@minHeightN:

; 146  : 	{
; 147  : 		noiseMap[i] = rand() & 1;

  00082	e8 00 00 00 00	 call	 rand
  00087	24 01		 and	 al, 1
  00089	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  00090	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 145  : 	for(int i = 0; i < size * size; i++)

  00093	ff c3		 inc	 ebx
  00095	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
  00099	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0009f	0f af c0	 imul	 eax, eax
  000a2	3b d8		 cmp	 ebx, eax
  000a4	7c dc		 jl	 SHORT $LL7@minHeightN
$LN5@minHeightN:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 8    : Noise::NoiseGenerator2D ChunkLoadThread::minHeightNoise(8, 12, 2.0f, time(0));

  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::minHeightNoise''
  000ad	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b6	5f		 pop	 rdi
  000b7	e9 00 00 00 00	 jmp	 atexit
??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::minHeightNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'ChunkLoadThread::minHeightNoise'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::minHeightNoise
  00007	48 83 c1 18	 add	 rcx, 24
  0000b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$0@?0???__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'ChunkLoadThread::minHeightNoise'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::minHeightNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 153  : 	delete[] noiseMap;

  00004	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 267  : 	if(okay)

  00010	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 0
  00017	74 28		 je	 SHORT $LN6@minHeightN

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  00019	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+32
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  00026	85 c0		 test	 eax, eax
  00028	74 17		 je	 SHORT $LN6@minHeightN

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN6@minHeightN:
  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::minHeightNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::maxHeightNoise'', COMDAT

; 9    : Noise::NoiseGenerator2D ChunkLoadThread::maxHeightNoise(8, 12, 2.0f, time(0) + 1);

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 _time64
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 9    : Noise::NoiseGenerator2D ChunkLoadThread::maxHeightNoise(8, 12, 2.0f, time(0) + 1);

  0001b	8d 58 01	 lea	 ebx, DWORD PTR [rax+1]
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 143  : {

  0001e	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A, 8
  00028	c7 05 04 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4, 256 ; 00000100H
  00032	c7 05 08 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+8, 12
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00044	f3 0f 11 05 0c
	00 00 00	 movss	 DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+12, xmm0
  0004c	89 1d 10 00 00
	00		 mov	 DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16, ebx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 261  : {

  00052	c6 05 18 00 00
	00 00		 mov	 BYTE PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 143  : {

  00059	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0005e	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00063	48 89 05 30 00
	00 00		 mov	 QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48, rax

; 144  : 	srand(seed);

  0006a	8b cb		 mov	 ecx, ebx
  0006c	e8 00 00 00 00	 call	 srand

; 145  : 	for(int i = 0; i < size * size; i++)

  00071	33 db		 xor	 ebx, ebx
  00073	8b fb		 mov	 edi, ebx
  00075	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0007b	0f af c0	 imul	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	7e 24		 jle	 SHORT $LN5@maxHeightN
$LL7@maxHeightN:

; 146  : 	{
; 147  : 		noiseMap[i] = rand() & 1;

  00082	e8 00 00 00 00	 call	 rand
  00087	24 01		 and	 al, 1
  00089	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  00090	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 145  : 	for(int i = 0; i < size * size; i++)

  00093	ff c3		 inc	 ebx
  00095	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
  00099	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0009f	0f af c0	 imul	 eax, eax
  000a2	3b d8		 cmp	 ebx, eax
  000a4	7c dc		 jl	 SHORT $LL7@maxHeightN
$LN5@maxHeightN:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 9    : Noise::NoiseGenerator2D ChunkLoadThread::maxHeightNoise(8, 12, 2.0f, time(0) + 1);

  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::maxHeightNoise''
  000ad	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b6	5f		 pop	 rdi
  000b7	e9 00 00 00 00	 jmp	 atexit
??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::maxHeightNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'ChunkLoadThread::maxHeightNoise'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::maxHeightNoise
  00007	48 83 c1 18	 add	 rcx, 24
  0000b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$0@?0???__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'ChunkLoadThread::maxHeightNoise'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::maxHeightNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 153  : 	delete[] noiseMap;

  00004	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 267  : 	if(okay)

  00010	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 0
  00017	74 28		 je	 SHORT $LN6@maxHeightN

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  00019	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+32
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  00026	85 c0		 test	 eax, eax
  00028	74 17		 je	 SHORT $LN6@maxHeightN

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN6@maxHeightN:
  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::maxHeightNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::smoothnessNoise'', COMDAT

; 10   : Noise::NoiseGenerator3D ChunkLoadThread::smoothnessNoise(8, 12, 2.5f, time(0) + 2);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 10   : Noise::NoiseGenerator3D ChunkLoadThread::smoothnessNoise(8, 12, 2.5f, time(0) + 2);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::smoothnessNoise
  00012	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40200000
  0001a	83 c0 02	 add	 eax, 2
  0001d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00021	e8 00 00 00 00	 call	 ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator3D::NoiseGenerator3D
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::smoothnessNoise''
  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	e9 00 00 00 00	 jmp	 atexit
??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::smoothnessNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::smoothnessNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 278  : 	delete[] noiseMap;

  00004	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+48
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 267  : 	if(okay)

  00010	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24, 0
  00017	74 28		 je	 SHORT $LN6@smoothness

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  00019	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+32
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  00026	85 c0		 test	 eax, eax
  00028	74 17		 je	 SHORT $LN6@smoothness

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN6@smoothness:
  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::smoothnessNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::solidNoise'', COMDAT

; 11   : Noise::NoiseGenerator3D ChunkLoadThread::solidNoise(8, 12, 0.0f, time(0) + 3);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 11   : Noise::NoiseGenerator3D ChunkLoadThread::solidNoise(8, 12, 0.0f, time(0) + 3);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::solidNoise
  00012	83 c0 03	 add	 eax, 3
  00015	0f 57 db	 xorps	 xmm3, xmm3
  00018	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0001c	e8 00 00 00 00	 call	 ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator3D::NoiseGenerator3D
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::solidNoise''
  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	e9 00 00 00 00	 jmp	 atexit
??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::solidNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::solidNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 278  : 	delete[] noiseMap;

  00004	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+48
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 267  : 	if(okay)

  00010	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24, 0
  00017	74 28		 je	 SHORT $LN6@solidNoise

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  00019	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+32
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  00026	85 c0		 test	 eax, eax
  00028	74 17		 je	 SHORT $LN6@solidNoise

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN6@solidNoise:
  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::solidNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::stoneNoise'', COMDAT

; 12   : Noise::NoiseGenerator3D ChunkLoadThread::stoneNoise(8, 12, 2.0f, time(0) + 4);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 12   : Noise::NoiseGenerator3D ChunkLoadThread::stoneNoise(8, 12, 2.0f, time(0) + 4);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::stoneNoise
  00012	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40000000
  0001a	83 c0 04	 add	 eax, 4
  0001d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00021	e8 00 00 00 00	 call	 ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator3D::NoiseGenerator3D
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::stoneNoise''
  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	e9 00 00 00 00	 jmp	 atexit
??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::stoneNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::stoneNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 278  : 	delete[] noiseMap;

  00004	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+48
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 267  : 	if(okay)

  00010	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24, 0
  00017	74 28		 je	 SHORT $LN6@stoneNoise

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  00019	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+32
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  00026	85 c0		 test	 eax, eax
  00028	74 17		 je	 SHORT $LN6@stoneNoise

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN6@stoneNoise:
  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::stoneNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::temperatureNoise'', COMDAT

; 13   : Noise::NoiseGenerator2D ChunkLoadThread::temperatureNoise(8, 12, 2.0f, time(0) + 5);

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 _time64
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 13   : Noise::NoiseGenerator2D ChunkLoadThread::temperatureNoise(8, 12, 2.0f, time(0) + 5);

  0001b	8d 58 05	 lea	 ebx, DWORD PTR [rax+5]
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 143  : {

  0001e	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A, 8
  00028	c7 05 04 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4, 256 ; 00000100H
  00032	c7 05 08 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+8, 12
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00044	f3 0f 11 05 0c
	00 00 00	 movss	 DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+12, xmm0
  0004c	89 1d 10 00 00
	00		 mov	 DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16, ebx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 261  : {

  00052	c6 05 18 00 00
	00 00		 mov	 BYTE PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 143  : {

  00059	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0005e	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00063	48 89 05 30 00
	00 00		 mov	 QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48, rax

; 144  : 	srand(seed);

  0006a	8b cb		 mov	 ecx, ebx
  0006c	e8 00 00 00 00	 call	 srand

; 145  : 	for(int i = 0; i < size * size; i++)

  00071	33 db		 xor	 ebx, ebx
  00073	8b fb		 mov	 edi, ebx
  00075	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0007b	0f af c0	 imul	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	7e 24		 jle	 SHORT $LN5@temperatur
$LL7@temperatur:

; 146  : 	{
; 147  : 		noiseMap[i] = rand() & 1;

  00082	e8 00 00 00 00	 call	 rand
  00087	24 01		 and	 al, 1
  00089	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  00090	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 145  : 	for(int i = 0; i < size * size; i++)

  00093	ff c3		 inc	 ebx
  00095	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
  00099	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0009f	0f af c0	 imul	 eax, eax
  000a2	3b d8		 cmp	 ebx, eax
  000a4	7c dc		 jl	 SHORT $LL7@temperatur
$LN5@temperatur:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 13   : Noise::NoiseGenerator2D ChunkLoadThread::temperatureNoise(8, 12, 2.0f, time(0) + 5);

  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::temperatureNoise''
  000ad	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b6	5f		 pop	 rdi
  000b7	e9 00 00 00 00	 jmp	 atexit
??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::temperatureNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'ChunkLoadThread::temperatureNoise'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::temperatureNoise
  00007	48 83 c1 18	 add	 rcx, 24
  0000b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$0@?0???__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'ChunkLoadThread::temperatureNoise'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::temperatureNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 153  : 	delete[] noiseMap;

  00004	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 267  : 	if(okay)

  00010	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 0
  00017	74 28		 je	 SHORT $LN6@temperatur

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  00019	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+32
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  00026	85 c0		 test	 eax, eax
  00028	74 17		 je	 SHORT $LN6@temperatur

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN6@temperatur:
  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::temperatureNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::humidityNoise'', COMDAT

; 14   : Noise::NoiseGenerator2D ChunkLoadThread::humidityNoise(8, 12, 2.0f, time(0) + 6);

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00014	33 c9		 xor	 ecx, ecx
  00016	e8 00 00 00 00	 call	 _time64
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 14   : Noise::NoiseGenerator2D ChunkLoadThread::humidityNoise(8, 12, 2.0f, time(0) + 6);

  0001b	8d 58 06	 lea	 ebx, DWORD PTR [rax+6]
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 143  : {

  0001e	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A, 8
  00028	c7 05 04 00 00
	00 00 01 00 00	 mov	 DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4, 256 ; 00000100H
  00032	c7 05 08 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+8, 12
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00044	f3 0f 11 05 0c
	00 00 00	 movss	 DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+12, xmm0
  0004c	89 1d 10 00 00
	00		 mov	 DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16, ebx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 261  : {

  00052	c6 05 18 00 00
	00 00		 mov	 BYTE PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 143  : {

  00059	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0005e	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00063	48 89 05 30 00
	00 00		 mov	 QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48, rax

; 144  : 	srand(seed);

  0006a	8b cb		 mov	 ecx, ebx
  0006c	e8 00 00 00 00	 call	 srand

; 145  : 	for(int i = 0; i < size * size; i++)

  00071	33 db		 xor	 ebx, ebx
  00073	8b fb		 mov	 edi, ebx
  00075	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0007b	0f af c0	 imul	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	7e 24		 jle	 SHORT $LN5@humidityNo
$LL7@humidityNo:

; 146  : 	{
; 147  : 		noiseMap[i] = rand() & 1;

  00082	e8 00 00 00 00	 call	 rand
  00087	24 01		 and	 al, 1
  00089	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  00090	88 04 0f	 mov	 BYTE PTR [rdi+rcx], al

; 145  : 	for(int i = 0; i < size * size; i++)

  00093	ff c3		 inc	 ebx
  00095	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
  00099	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0009f	0f af c0	 imul	 eax, eax
  000a2	3b d8		 cmp	 ebx, eax
  000a4	7c dc		 jl	 SHORT $LL7@humidityNo
$LN5@humidityNo:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 14   : Noise::NoiseGenerator2D ChunkLoadThread::humidityNoise(8, 12, 2.0f, time(0) + 6);

  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::humidityNoise''
  000ad	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b6	5f		 pop	 rdi
  000b7	e9 00 00 00 00	 jmp	 atexit
??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::humidityNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'ChunkLoadThread::humidityNoise'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::humidityNoise
  00007	48 83 c1 18	 add	 rcx, 24
  0000b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$0@?0???__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'ChunkLoadThread::humidityNoise'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::humidityNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 153  : 	delete[] noiseMap;

  00004	48 8b 0d 30 00
	00 00		 mov	 rcx, QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 267  : 	if(okay)

  00010	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 0
  00017	74 28		 je	 SHORT $LN6@humidityNo

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  00019	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+32
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  00026	85 c0		 test	 eax, eax
  00028	74 17		 je	 SHORT $LN6@humidityNo

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  00038	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003c	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN6@humidityNo:
  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::humidityNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::chunkGenProgram'', COMDAT

; 16   : cl::Program ChunkLoadThread::chunkGenProgram;

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 778  : 		this->_Myhead = _Buyheadnode();

  0000d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64> > > >::_Buyheadnode
  00012	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00019	ba 02 00 00 00	 mov	 edx, 2
  0001e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+24
  00025	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN31@chunkGenPr

; 33   : 		_Throw_C_error(_Res);

  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN31@chunkGenPr:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 97   : {

  00035	c6 05 30 00 00
	00 00		 mov	 BYTE PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+48, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 16   : cl::Program ChunkLoadThread::chunkGenProgram;

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::chunkGenProgram''
  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	e9 00 00 00 00	 jmp	 atexit
??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::chunkGenProgram''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'ChunkLoadThread::chunkGenProgram'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@QEAA@XZ
?dtor$0@?0???__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'ChunkLoadThread::chunkGenProgram'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
text$yd	SEGMENT
??__F?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::chunkGenProgram'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00007	e9 00 00 00 00	 jmp	 ??1Program@cl@@QEAA@XZ	; cl::Program::~Program
??__F?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::chunkGenProgram''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?staticInit@ChunkLoadThread@@SAXXZ
_TEXT	SEGMENT
$T1 = 48
error$2 = 96
error$3 = 96
error$4 = 96
error$5 = 96
error$6 = 104
error$7 = 104
error$8 = 104
?staticInit@ChunkLoadThread@@SAXXZ PROC			; ChunkLoadThread::staticInit, COMDAT

; 19   : {

$LN40:
  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 20   : 	ChunkLoadThread::chunkGenProgram.create(IOUtil::EXE_DIR + L"\\programs\\generation.cl");

  00006	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294957720
  0000d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  00012	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00017	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  0001e	48 8b d0	 mov	 rdx, rax
  00021	e8 00 00 00 00	 call	 ?create@Program@cl@@QEAA_NV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; cl::Program::create
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 205  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00026	48 63 1d 04 00
	00 00		 movsxd	 rbx, DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0002d	4c 8b 0d 30 00
	00 00		 mov	 r9, QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 205  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00034	48 0f af db	 imul	 rbx, rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00038	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  0003f	48 8d 44 24 60	 lea	 rax, QWORD PTR error$5[rsp]
  00044	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  00049	4c 8b c3	 mov	 r8, rbx
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  00057	83 7c 24 60 00	 cmp	 DWORD PTR error$5[rsp], 0
  0005c	48 89 05 20 00
	00 00		 mov	 QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+32, rax
  00063	74 15		 je	 SHORT $LN6@staticInit

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00065	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  00073	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  00078	eb 0e		 jmp	 SHORT $LN7@staticInit
$LN6@staticInit:

; 287  : 	this->size = size;

  0007a	48 89 1d 28 00
	00 00		 mov	 QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40, rbx

; 288  : 	okay = true;

  00081	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 1
$LN7@staticInit:
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 205  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00088	48 63 1d 04 00
	00 00		 movsxd	 rbx, DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0008f	4c 8b 0d 30 00
	00 00		 mov	 r9, QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 205  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  0009d	48 0f af db	 imul	 rbx, rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  000a1	48 8d 44 24 68	 lea	 rax, QWORD PTR error$8[rsp]
  000a6	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  000ab	4c 8b c3	 mov	 r8, rbx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  000b9	83 7c 24 68 00	 cmp	 DWORD PTR error$8[rsp], 0
  000be	48 89 05 20 00
	00 00		 mov	 QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+32, rax
  000c5	74 15		 je	 SHORT $LN11@staticInit

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  000c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  000d5	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  000da	eb 0e		 jmp	 SHORT $LN12@staticInit
$LN11@staticInit:

; 287  : 	this->size = size;

  000dc	48 89 1d 28 00
	00 00		 mov	 QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40, rbx

; 288  : 	okay = true;

  000e3	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 1
$LN12@staticInit:
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  000ea	48 63 05 04 00
	00 00		 movsxd	 rax, DWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  000f1	4c 8b 0d 30 00
	00 00		 mov	 r9, QWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+48
  000f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  000ff	48 8b d8	 mov	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00102	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00107	48 0f af d8	 imul	 rbx, rax
  0010b	48 0f af d8	 imul	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0010f	48 8d 44 24 60	 lea	 rax, QWORD PTR error$4[rsp]
  00114	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00119	4c 8b c3	 mov	 r8, rbx
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  00122	83 7c 24 60 00	 cmp	 DWORD PTR error$4[rsp], 0
  00127	48 89 05 20 00
	00 00		 mov	 QWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+32, rax
  0012e	74 15		 je	 SHORT $LN16@staticInit

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00130	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  0013e	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  00143	eb 0e		 jmp	 SHORT $LN17@staticInit
$LN16@staticInit:

; 287  : 	this->size = size;

  00145	48 89 1d 28 00
	00 00		 mov	 QWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40, rbx

; 288  : 	okay = true;

  0014c	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24, 1
$LN17@staticInit:
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00153	48 63 05 04 00
	00 00		 movsxd	 rax, DWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0015a	4c 8b 0d 30 00
	00 00		 mov	 r9, QWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+48
  00161	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00168	48 8b d8	 mov	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0016b	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00170	48 0f af d8	 imul	 rbx, rax
  00174	48 0f af d8	 imul	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00178	48 8d 44 24 68	 lea	 rax, QWORD PTR error$7[rsp]
  0017d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00182	4c 8b c3	 mov	 r8, rbx
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  0018b	83 7c 24 68 00	 cmp	 DWORD PTR error$7[rsp], 0
  00190	48 89 05 20 00
	00 00		 mov	 QWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+32, rax
  00197	74 15		 je	 SHORT $LN21@staticInit

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00199	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  001a7	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  001ac	eb 0e		 jmp	 SHORT $LN22@staticInit
$LN21@staticInit:

; 287  : 	this->size = size;

  001ae	48 89 1d 28 00
	00 00		 mov	 QWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40, rbx

; 288  : 	okay = true;

  001b5	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24, 1
$LN22@staticInit:
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  001bc	48 63 05 04 00
	00 00		 movsxd	 rax, DWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  001c3	4c 8b 0d 30 00
	00 00		 mov	 r9, QWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+48
  001ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  001d1	48 8b d8	 mov	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  001d4	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 343  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  001d9	48 0f af d8	 imul	 rbx, rax
  001dd	48 0f af d8	 imul	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  001e1	48 8d 44 24 60	 lea	 rax, QWORD PTR error$3[rsp]
  001e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001eb	4c 8b c3	 mov	 r8, rbx
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  001f4	83 7c 24 60 00	 cmp	 DWORD PTR error$3[rsp], 0
  001f9	48 89 05 20 00
	00 00		 mov	 QWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+32, rax
  00200	74 15		 je	 SHORT $LN26@staticInit

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00202	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  00209	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  00210	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  00215	eb 0e		 jmp	 SHORT $LN27@staticInit
$LN26@staticInit:

; 287  : 	this->size = size;

  00217	48 89 1d 28 00
	00 00		 mov	 QWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40, rbx

; 288  : 	okay = true;

  0021e	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24, 1
$LN27@staticInit:
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 205  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00225	48 63 1d 04 00
	00 00		 movsxd	 rbx, DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0022c	4c 8b 0d 30 00
	00 00		 mov	 r9, QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  00233	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 205  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  0023a	48 0f af db	 imul	 rbx, rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0023e	48 8d 44 24 68	 lea	 rax, QWORD PTR error$6[rsp]
  00243	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  00248	4c 8b c3	 mov	 r8, rbx
  0024b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  00256	83 7c 24 68 00	 cmp	 DWORD PTR error$6[rsp], 0
  0025b	48 89 05 20 00
	00 00		 mov	 QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+32, rax
  00262	74 15		 je	 SHORT $LN31@staticInit

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00264	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  0026b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  00272	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  00277	eb 0e		 jmp	 SHORT $LN32@staticInit
$LN31@staticInit:

; 287  : 	this->size = size;

  00279	48 89 1d 28 00
	00 00		 mov	 QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40, rbx

; 288  : 	okay = true;

  00280	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 1
$LN32@staticInit:
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 205  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00287	48 63 1d 04 00
	00 00		 movsxd	 rbx, DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0028e	4c 8b 0d 30 00
	00 00		 mov	 r9, QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+48
  00295	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 205  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  0029c	48 0f af db	 imul	 rbx, rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  002a0	48 8d 44 24 60	 lea	 rax, QWORD PTR error$2[rsp]
  002a5	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  002aa	4c 8b c3	 mov	 r8, rbx
  002ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  002b8	83 7c 24 60 00	 cmp	 DWORD PTR error$2[rsp], 0
  002bd	48 89 05 20 00
	00 00		 mov	 QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+32, rax
  002c4	74 19		 je	 SHORT $LN36@staticInit

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  002c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  002cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  002d4	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 28   : }

  002d9	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002dd	5b		 pop	 rbx
  002de	c3		 ret	 0
$LN36@staticInit:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 287  : 	this->size = size;

  002df	48 89 1d 28 00
	00 00		 mov	 QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40, rbx

; 288  : 	okay = true;

  002e6	c6 05 18 00 00
	00 01		 mov	 BYTE PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+24, 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 28   : }

  002ed	48 83 c4 50	 add	 rsp, 80			; 00000050H
  002f1	5b		 pop	 rbx
  002f2	c3		 ret	 0
?staticInit@ChunkLoadThread@@SAXXZ ENDP			; ChunkLoadThread::staticInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?preStart@ChunkLoadThread@@MEAAXXZ
_TEXT	SEGMENT
error$1 = 64
error$2 = 64
error$3 = 64
error$4 = 64
error$5 = 64
this$ = 64
error$6 = 72
error$7 = 72
error$8 = 72
error$9 = 72
?preStart@ChunkLoadThread@@MEAAXXZ PROC			; ChunkLoadThread::preStart, COMDAT

; 31   : {

$LN31:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00006	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?device@cl@@3PEAU_cl_device_id@@EA ; cl::device
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 31   : {

  0000d	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00017	4c 8d 4c 24 40	 lea	 r9, QWORD PTR error$5[rsp]
  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR error$5[rsp], 0
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateCommandQueue

; 56   : 	if(error != CL_SUCCESS)

  0002d	83 7c 24 40 00	 cmp	 DWORD PTR error$5[rsp], 0
  00032	48 89 83 38 08
	00 00		 mov	 QWORD PTR [rbx+2104], rax
  00039	74 15		 je	 SHORT $LN3@preStart

; 57   : 	{
; 58   : 		GLWindow::instance->postError("Could not create command queue", "Command queue creation error");

  0003b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952818
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952817
  00049	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 59   : 		return false;

  0004e	eb 07		 jmp	 SHORT $LN4@preStart
$LN3@preStart:

; 60   : 	}
; 61   : 
; 62   : 	okay = true;

  00050	c6 83 58 08 00
	00 01		 mov	 BYTE PTR [rbx+2136], 1
$LN4@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  0005e	45 33 c9	 xor	 r9d, r9d
  00061	48 8d 44 24 48	 lea	 rax, QWORD PTR error$9[rsp]
  00066	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0006a	41 b8 00 20 00
	00		 mov	 r8d, 8192		; 00002000H
  00070	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  0007b	83 7c 24 48 00	 cmp	 DWORD PTR error$9[rsp], 0
  00080	48 89 83 68 08
	00 00		 mov	 QWORD PTR [rbx+2152], rax
  00087	74 15		 je	 SHORT $LN6@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00089	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  00097	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  0009c	eb 12		 jmp	 SHORT $LN7@preStart
$LN6@preStart:

; 287  : 	this->size = size;

  0009e	48 c7 83 70 08
	00 00 00 20 00
	00		 mov	 QWORD PTR [rbx+2160], 8192 ; 00002000H

; 288  : 	okay = true;

  000a9	c6 83 60 08 00
	00 01		 mov	 BYTE PTR [rbx+2144], 1
$LN7@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  000b0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  000b7	45 33 c9	 xor	 r9d, r9d
  000ba	48 8d 44 24 40	 lea	 rax, QWORD PTR error$4[rsp]
  000bf	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  000c3	41 b8 10 05 00
	00		 mov	 r8d, 1296		; 00000510H
  000c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  000d4	83 7c 24 40 00	 cmp	 DWORD PTR error$4[rsp], 0
  000d9	48 89 83 80 08
	00 00		 mov	 QWORD PTR [rbx+2176], rax
  000e0	74 15		 je	 SHORT $LN9@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  000e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  000f0	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  000f5	eb 12		 jmp	 SHORT $LN10@preStart
$LN9@preStart:

; 287  : 	this->size = size;

  000f7	48 c7 83 88 08
	00 00 10 05 00
	00		 mov	 QWORD PTR [rbx+2184], 1296 ; 00000510H

; 288  : 	okay = true;

  00102	c6 83 78 08 00
	00 01		 mov	 BYTE PTR [rbx+2168], 1
$LN10@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00109	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00110	45 33 c9	 xor	 r9d, r9d
  00113	48 8d 44 24 48	 lea	 rax, QWORD PTR error$8[rsp]
  00118	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0011c	41 b8 10 05 00
	00		 mov	 r8d, 1296		; 00000510H
  00122	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  0012d	83 7c 24 48 00	 cmp	 DWORD PTR error$8[rsp], 0
  00132	48 89 83 98 08
	00 00		 mov	 QWORD PTR [rbx+2200], rax
  00139	74 15		 je	 SHORT $LN12@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  0013b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  00142	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  00149	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  0014e	eb 12		 jmp	 SHORT $LN13@preStart
$LN12@preStart:

; 287  : 	this->size = size;

  00150	48 c7 83 a0 08
	00 00 10 05 00
	00		 mov	 QWORD PTR [rbx+2208], 1296 ; 00000510H

; 288  : 	okay = true;

  0015b	c6 83 90 08 00
	00 01		 mov	 BYTE PTR [rbx+2192], 1
$LN13@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00162	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00169	45 33 c9	 xor	 r9d, r9d
  0016c	48 8d 44 24 40	 lea	 rax, QWORD PTR error$3[rsp]
  00171	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  00175	41 b8 20 5b 00
	00		 mov	 r8d, 23328		; 00005b20H
  0017b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  00186	83 7c 24 40 00	 cmp	 DWORD PTR error$3[rsp], 0
  0018b	48 89 83 b0 08
	00 00		 mov	 QWORD PTR [rbx+2224], rax
  00192	74 15		 je	 SHORT $LN15@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00194	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  0019b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  001a2	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  001a7	eb 12		 jmp	 SHORT $LN16@preStart
$LN15@preStart:

; 287  : 	this->size = size;

  001a9	48 c7 83 b8 08
	00 00 20 5b 00
	00		 mov	 QWORD PTR [rbx+2232], 23328 ; 00005b20H

; 288  : 	okay = true;

  001b4	c6 83 a8 08 00
	00 01		 mov	 BYTE PTR [rbx+2216], 1
$LN16@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  001bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  001c2	45 33 c9	 xor	 r9d, r9d
  001c5	48 8d 44 24 48	 lea	 rax, QWORD PTR error$7[rsp]
  001ca	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  001ce	41 b8 20 5b 00
	00		 mov	 r8d, 23328		; 00005b20H
  001d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  001df	83 7c 24 48 00	 cmp	 DWORD PTR error$7[rsp], 0
  001e4	48 89 83 c8 08
	00 00		 mov	 QWORD PTR [rbx+2248], rax
  001eb	74 15		 je	 SHORT $LN18@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  001ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  001fb	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  00200	eb 12		 jmp	 SHORT $LN19@preStart
$LN18@preStart:

; 287  : 	this->size = size;

  00202	48 c7 83 d0 08
	00 00 20 5b 00
	00		 mov	 QWORD PTR [rbx+2256], 23328 ; 00005b20H

; 288  : 	okay = true;

  0020d	c6 83 c0 08 00
	00 01		 mov	 BYTE PTR [rbx+2240], 1
$LN19@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00214	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  0021b	45 33 c9	 xor	 r9d, r9d
  0021e	48 8d 44 24 40	 lea	 rax, QWORD PTR error$2[rsp]
  00223	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  00227	41 b8 20 5b 00
	00		 mov	 r8d, 23328		; 00005b20H
  0022d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  00238	83 7c 24 40 00	 cmp	 DWORD PTR error$2[rsp], 0
  0023d	48 89 83 e0 08
	00 00		 mov	 QWORD PTR [rbx+2272], rax
  00244	74 15		 je	 SHORT $LN21@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00246	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  0024d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  00254	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  00259	eb 12		 jmp	 SHORT $LN22@preStart
$LN21@preStart:

; 287  : 	this->size = size;

  0025b	48 c7 83 e8 08
	00 00 20 5b 00
	00		 mov	 QWORD PTR [rbx+2280], 23328 ; 00005b20H

; 288  : 	okay = true;

  00266	c6 83 d8 08 00
	00 01		 mov	 BYTE PTR [rbx+2264], 1
$LN22@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0026d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00274	45 33 c9	 xor	 r9d, r9d
  00277	48 8d 44 24 48	 lea	 rax, QWORD PTR error$6[rsp]
  0027c	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  00280	41 b8 10 05 00
	00		 mov	 r8d, 1296		; 00000510H
  00286	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  00291	83 7c 24 48 00	 cmp	 DWORD PTR error$6[rsp], 0
  00296	48 89 83 f8 08
	00 00		 mov	 QWORD PTR [rbx+2296], rax
  0029d	74 15		 je	 SHORT $LN24@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  0029f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  002a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  002ad	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  002b2	eb 12		 jmp	 SHORT $LN25@preStart
$LN24@preStart:

; 287  : 	this->size = size;

  002b4	48 c7 83 00 09
	00 00 10 05 00
	00		 mov	 QWORD PTR [rbx+2304], 1296 ; 00000510H

; 288  : 	okay = true;

  002bf	c6 83 f0 08 00
	00 01		 mov	 BYTE PTR [rbx+2288], 1
$LN25@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  002c6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  002cd	45 33 c9	 xor	 r9d, r9d
  002d0	48 8d 44 24 40	 lea	 rax, QWORD PTR error$1[rsp]
  002d5	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  002d9	41 b8 10 05 00
	00		 mov	 r8d, 1296		; 00000510H
  002df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 281  : 	if(error != CL_SUCCESS)

  002ea	83 7c 24 40 00	 cmp	 DWORD PTR error$1[rsp], 0
  002ef	48 89 83 10 09
	00 00		 mov	 QWORD PTR [rbx+2320], rax
  002f6	74 19		 je	 SHORT $LN27@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  002f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  002ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  00306	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 41   : }

  0030b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0030f	5b		 pop	 rbx
  00310	c3		 ret	 0
$LN27@preStart:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 287  : 	this->size = size;

  00311	48 c7 83 18 09
	00 00 10 05 00
	00		 mov	 QWORD PTR [rbx+2328], 1296 ; 00000510H

; 288  : 	okay = true;

  0031c	c6 83 08 09 00
	00 01		 mov	 BYTE PTR [rbx+2312], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 41   : }

  00323	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00327	5b		 pop	 rbx
  00328	c3		 ret	 0
?preStart@ChunkLoadThread@@MEAAXXZ ENDP			; ChunkLoadThread::preStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?tick@ChunkLoadThread@@MEAA_NXZ
_TEXT	SEGMENT
chunkZ$ = 112
chunkX$ = 116
chunkY$ = 120
c$1 = 128
$T2 = 144
$T3 = 160
$T4 = 176
event$5 = 184
$T6 = 192
chunk$ = 224
$T7 = 240
$T8 = 248
global_ws$ = 272
local_ws$ = 296
__$ArrayPad$ = 320
this$ = 448
?tick@ChunkLoadThread@@MEAA_NXZ PROC			; ChunkLoadThread::tick, COMDAT

; 44   : {

$LN365:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d a8 48 ff
	ff ff		 lea	 rbp, QWORD PTR [rax-184]
  00013	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H
  0001a	48 c7 45 f0 fe
	ff ff ff	 mov	 QWORD PTR $T7[rbp-256], -2
  00022	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00026	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0002a	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0002e	0f 29 70 c8	 movaps	 XMMWORD PTR [rax-56], xmm6
  00032	0f 29 78 b8	 movaps	 XMMWORD PTR [rax-72], xmm7
  00036	44 0f 29 40 a8	 movaps	 XMMWORD PTR [rax-88], xmm8
  0003b	44 0f 29 48 98	 movaps	 XMMWORD PTR [rax-104], xmm9
  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00047	48 33 c4	 xor	 rax, rsp
  0004a	48 89 45 40	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0004e	48 8b f9	 mov	 rdi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00051	48 83 b9 40 09
	00 00 00	 cmp	 QWORD PTR [rcx+2368], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 45   : 	if(ChunkLoadThread::loadQueue.empty())

  00059	0f 84 99 0a 00
	00		 je	 $LN327@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  0005f	48 8d 55 f8	 lea	 rdx, QWORD PTR $T8[rbp-256]
  00063	48 81 c1 20 09
	00 00		 add	 rcx, 2336		; 00000920H
  0006a	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  0006f	48 8b c8	 mov	 rcx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00072	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00075	45 33 e4	 xor	 r12d, r12d
  00078	48 85 c0	 test	 rax, rax
  0007b	75 05		 jne	 SHORT $LN48@tick
  0007d	41 8b c4	 mov	 eax, r12d
  00080	eb 03		 jmp	 SHORT $LN49@tick
$LN48@tick:
  00082	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN49@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00085	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00089	48 ff ca	 dec	 rdx
  0008c	48 23 51 10	 and	 rdx, QWORD PTR [rcx+16]

; 1426 : 		return (*begin());

  00090	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00094	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00098	4c 8b 72 08	 mov	 r14, QWORD PTR [rdx+8]
  0009c	4c 89 75 b0	 mov	 QWORD PTR $T4[rbp-256], r14
  000a0	4c 8b 3a	 mov	 r15, QWORD PTR [rdx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  000a3	4d 85 f6	 test	 r14, r14
  000a6	74 05		 je	 SHORT $LN69@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  000a8	f0 41 ff 46 08	 lock inc DWORD PTR [r14+8]
$LN69@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  000ad	4c 89 75 e8	 mov	 QWORD PTR chunk$[rbp-248], r14

; 427  : 		_Ptr = _Other_ptr;

  000b1	4c 89 7d e0	 mov	 QWORD PTR chunk$[rbp-256], r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 160  : 		c.pop_front();

  000b5	48 8d 8f 20 09
	00 00		 lea	 rcx, QWORD PTR [rdi+2336]
  000bc	e8 00 00 00 00	 call	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 53   : 	const int chunkX = chunk->pos.x;

  000c1	41 8b 57 18	 mov	 edx, DWORD PTR [r15+24]
  000c5	89 54 24 74	 mov	 DWORD PTR chunkX$[rsp], edx

; 54   : 	const int chunkY = chunk->pos.y;

  000c9	41 8b 4f 1c	 mov	 ecx, DWORD PTR [r15+28]
  000cd	89 4c 24 78	 mov	 DWORD PTR chunkY$[rsp], ecx

; 55   : 	const int chunkZ = chunk->pos.z;

  000d1	41 8b 47 20	 mov	 eax, DWORD PTR [r15+32]
  000d5	89 44 24 70	 mov	 DWORD PTR chunkZ$[rsp], eax
  000d9	66 0f 6e d0	 movd	 xmm2, eax

; 56   : 
; 57   : 	smoothnessNoise.fillNoiseBuffer(queue, smoothnessNoiseBuffer, 18, 18, 18, chunkX * 16.0f - 1.0f, chunkY * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 16.0f, 16.0f, 16.0f);

  000dd	0f 5b d2	 cvtdq2ps xmm2, xmm2
  000e0	f3 44 0f 10 0d
	00 00 00 00	 movss	 xmm9, DWORD PTR __real@41800000
  000e9	f3 41 0f 59 d1	 mulss	 xmm2, xmm9
  000ee	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@3f800000
  000f7	f3 41 0f 5c d0	 subss	 xmm2, xmm8
  000fc	66 0f 6e c9	 movd	 xmm1, ecx
  00100	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00103	f3 41 0f 59 c9	 mulss	 xmm1, xmm9
  00108	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  0010d	66 0f 6e c2	 movd	 xmm0, edx
  00111	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00114	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00119	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  0011e	48 8d 9f a8 08
	00 00		 lea	 rbx, QWORD PTR [rdi+2216]
  00125	48 8d b7 38 08
	00 00		 lea	 rsi, QWORD PTR [rdi+2104]
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 348  : 	fillNoiseBuffer(queue, buffer, xs, ys, zs, smoothness, x, y, z, xd, yd, zd);

  0012c	f3 44 0f 11 4c
	24 60		 movss	 DWORD PTR [rsp+96], xmm9
  00133	f3 44 0f 11 4c
	24 58		 movss	 DWORD PTR [rsp+88], xmm9
  0013a	f3 44 0f 11 4c
	24 50		 movss	 DWORD PTR [rsp+80], xmm9
  00141	f3 0f 11 54 24
	48		 movss	 DWORD PTR [rsp+72], xmm2
  00147	f3 0f 11 4c 24
	40		 movss	 DWORD PTR [rsp+64], xmm1
  0014d	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  00153	f3 0f 10 05 0c
	00 00 00	 movss	 xmm0, DWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+12
  0015b	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00161	4c 8b c3	 mov	 r8, rbx
  00164	48 8b d6	 mov	 rdx, rsi
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::smoothnessNoise
  0016e	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBuffer
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 58   : 	queue.sync();

  00173	48 8b ce	 mov	 rcx, rsi
  00176	e8 00 00 00 00	 call	 ?sync@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::sync
  0017b	66 0f 6e 4c 24
	70		 movd	 xmm1, DWORD PTR chunkZ$[rsp]

; 59   : 	minHeightNoise.fillNoiseBuffer(queue, minHeightNoiseBuffer, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 20.0f, 20.0f);

  00181	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00184	f3 41 0f 59 c9	 mulss	 xmm1, xmm9
  00189	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  0018e	66 0f 6e 44 24
	74		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  00194	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00197	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  0019c	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  001a1	4c 8d 87 78 08
	00 00		 lea	 r8, QWORD PTR [rdi+2168]
  001a8	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@41a00000
  001b0	f3 0f 11 74 24
	48		 movss	 DWORD PTR [rsp+72], xmm6
  001b6	f3 0f 11 74 24
	40		 movss	 DWORD PTR [rsp+64], xmm6
  001bc	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  001c2	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  001c8	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@40000000
  001d0	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  001d6	48 8b d6	 mov	 rdx, rsi
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::minHeightNoise
  001e0	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer
  001e5	66 0f 6e 4c 24
	70		 movd	 xmm1, DWORD PTR chunkZ$[rsp]

; 60   : 	maxHeightNoise.fillNoiseBuffer(queue, maxHeightNoiseBuffer, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 20.0f, 20.0f);

  001eb	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001ee	f3 41 0f 59 c9	 mulss	 xmm1, xmm9
  001f3	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  001f8	66 0f 6e 44 24
	74		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  001fe	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00201	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00206	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  0020b	4c 8d 87 90 08
	00 00		 lea	 r8, QWORD PTR [rdi+2192]
  00212	f3 0f 11 74 24
	48		 movss	 DWORD PTR [rsp+72], xmm6
  00218	f3 0f 11 74 24
	40		 movss	 DWORD PTR [rsp+64], xmm6
  0021e	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  00224	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0022a	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  00230	48 8b d6	 mov	 rdx, rsi
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::maxHeightNoise
  0023a	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer
  0023f	66 0f 6e 5c 24
	70		 movd	 xmm3, DWORD PTR chunkZ$[rsp]

; 61   : 	solidNoise.fillNoiseBufferWithSmoothness(queue, solidNoiseBuffer, 18, 18, 18, smoothnessNoiseBuffer, chunkX * 16.0f - 1.0f, chunkY * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 20.0f, 25.0f, 20.0f);

  00245	0f 5b db	 cvtdq2ps xmm3, xmm3
  00248	f3 41 0f 59 d9	 mulss	 xmm3, xmm9
  0024d	f3 41 0f 5c d8	 subss	 xmm3, xmm8
  00252	66 0f 6e 54 24
	78		 movd	 xmm2, DWORD PTR chunkY$[rsp]
  00258	0f 5b d2	 cvtdq2ps xmm2, xmm2
  0025b	f3 41 0f 59 d1	 mulss	 xmm2, xmm9
  00260	f3 41 0f 5c d0	 subss	 xmm2, xmm8
  00265	66 0f 6e 4c 24
	74		 movd	 xmm1, DWORD PTR chunkX$[rsp]
  0026b	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0026e	f3 41 0f 59 c9	 mulss	 xmm1, xmm9
  00273	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  00278	4c 8d 87 c0 08
	00 00		 lea	 r8, QWORD PTR [rdi+2240]
  0027f	f3 0f 11 74 24
	60		 movss	 DWORD PTR [rsp+96], xmm6
  00285	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41c80000
  0028d	f3 0f 11 44 24
	58		 movss	 DWORD PTR [rsp+88], xmm0
  00293	f3 0f 11 74 24
	50		 movss	 DWORD PTR [rsp+80], xmm6
  00299	f3 0f 11 5c 24
	48		 movss	 DWORD PTR [rsp+72], xmm3
  0029f	f3 0f 11 54 24
	40		 movss	 DWORD PTR [rsp+64], xmm2
  002a5	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  002ab	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  002b0	48 8b d6	 mov	 rdx, rsi
  002b3	e8 00 00 00 00	 call	 ?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBufferWithSmoothness
  002b8	66 0f 6e 54 24
	70		 movd	 xmm2, DWORD PTR chunkZ$[rsp]

; 62   : 	stoneNoise.fillNoiseBuffer(queue, stoneNoiseBuffer, 18, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkY * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 20.0f, 20.0f, 20.0f);

  002be	0f 5b d2	 cvtdq2ps xmm2, xmm2
  002c1	f3 41 0f 59 d1	 mulss	 xmm2, xmm9
  002c6	f3 41 0f 5c d0	 subss	 xmm2, xmm8
  002cb	66 0f 6e 4c 24
	78		 movd	 xmm1, DWORD PTR chunkY$[rsp]
  002d1	0f 5b c9	 cvtdq2ps xmm1, xmm1
  002d4	f3 41 0f 59 c9	 mulss	 xmm1, xmm9
  002d9	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  002de	66 0f 6e 44 24
	74		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  002e4	0f 5b c0	 cvtdq2ps xmm0, xmm0
  002e7	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  002ec	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  002f1	4c 8d 87 d8 08
	00 00		 lea	 r8, QWORD PTR [rdi+2264]
  002f8	f3 0f 11 74 24
	60		 movss	 DWORD PTR [rsp+96], xmm6
  002fe	f3 0f 11 74 24
	58		 movss	 DWORD PTR [rsp+88], xmm6
  00304	f3 0f 11 74 24
	50		 movss	 DWORD PTR [rsp+80], xmm6
  0030a	f3 0f 11 54 24
	48		 movss	 DWORD PTR [rsp+72], xmm2
  00310	f3 0f 11 4c 24
	40		 movss	 DWORD PTR [rsp+64], xmm1
  00316	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  0031c	f3 0f 11 7c 24
	30		 movss	 DWORD PTR [rsp+48], xmm7
  00322	48 8b d6	 mov	 rdx, rsi
  00325	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::stoneNoise
  0032c	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBuffer
  00331	66 0f 6e 4c 24
	70		 movd	 xmm1, DWORD PTR chunkZ$[rsp]

; 63   : 	temperatureNoise.fillNoiseBuffer(queue, temperatureNoiseBuffer, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 4.0f, 4.0f);

  00337	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0033a	f3 41 0f 59 c9	 mulss	 xmm1, xmm9
  0033f	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  00344	66 0f 6e 44 24
	74		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  0034a	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0034d	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  00352	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  00357	4c 8d 87 f0 08
	00 00		 lea	 r8, QWORD PTR [rdi+2288]
  0035e	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@40800000
  00366	f3 0f 11 74 24
	48		 movss	 DWORD PTR [rsp+72], xmm6
  0036c	f3 0f 11 74 24
	40		 movss	 DWORD PTR [rsp+64], xmm6
  00372	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  00378	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0037e	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  00384	48 8b d6	 mov	 rdx, rsi
  00387	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::temperatureNoise
  0038e	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer
  00393	66 0f 6e 4c 24
	70		 movd	 xmm1, DWORD PTR chunkZ$[rsp]

; 64   : 	humidityNoise.fillNoiseBuffer(queue, humidityNoiseBuffer, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 4.0f, 4.0f);

  00399	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0039c	f3 41 0f 59 c9	 mulss	 xmm1, xmm9
  003a1	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  003a6	66 0f 6e 44 24
	74		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  003ac	0f 5b c0	 cvtdq2ps xmm0, xmm0
  003af	f3 41 0f 59 c1	 mulss	 xmm0, xmm9
  003b4	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  003b9	4c 8d 87 08 09
	00 00		 lea	 r8, QWORD PTR [rdi+2312]
  003c0	f3 0f 11 74 24
	48		 movss	 DWORD PTR [rsp+72], xmm6
  003c6	f3 0f 11 74 24
	40		 movss	 DWORD PTR [rsp+64], xmm6
  003cc	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  003d2	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  003d8	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  003de	48 8b d6	 mov	 rdx, rsi
  003e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::humidityNoise
  003e8	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer

; 65   : 	queue.sync();

  003ed	48 8b ce	 mov	 rcx, rsi
  003f0	e8 00 00 00 00	 call	 ?sync@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::sync

; 66   : 
; 67   : 	const size_t local_ws[] = {1, 1, 1};

  003f5	bb 01 00 00 00	 mov	 ebx, 1
  003fa	48 89 5d 28	 mov	 QWORD PTR local_ws$[rbp-256], rbx
  003fe	48 89 5d 30	 mov	 QWORD PTR local_ws$[rbp-248], rbx
  00402	48 89 5d 38	 mov	 QWORD PTR local_ws$[rbp-240], rbx

; 68   : 	const size_t global_ws[] = {16, 16, 16};

  00406	48 c7 45 10 10
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-256], 16
  0040e	48 c7 45 18 10
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-248], 16
  00416	48 c7 45 20 10
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-240], 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0041e	48 c7 45 d8 0f
	00 00 00	 mov	 QWORD PTR $T6[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00426	4c 89 65 d0	 mov	 QWORD PTR $T6[rbp-240], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0042a	c6 45 c0 00	 mov	 BYTE PTR $T6[rbp-256], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0042e	44 8d 43 10	 lea	 r8d, QWORD PTR [rbx+16]
  00432	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294957719
  00439	48 8d 4d c0	 lea	 rcx, QWORD PTR $T6[rbp-256]
  0043d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 70   : 	if(!chunkGenProgram.prepare("generateTerrain_1")) GlobalThread::stop = true;

  00442	48 8d 55 c0	 lea	 rdx, QWORD PTR $T6[rbp-256]
  00446	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  0044d	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  00452	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00459	84 c0		 test	 al, al
  0045b	0f 44 cb	 cmove	 ecx, ebx
  0045e	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  00464	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  0046b	48 85 c9	 test	 rcx, rcx
  0046e	75 10		 jne	 SHORT $LN135@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00470	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  00477	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  0047e	eb 35		 jmp	 SHORT $LN353@tick
$LN135@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00480	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  00486	8b d0		 mov	 edx, eax
  00488	ff c0		 inc	 eax
  0048a	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);

  00490	4c 8d 8f 68 08
	00 00		 lea	 r9, QWORD PTR [rdi+2152]

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00497	41 b8 08 00 00
	00		 mov	 r8d, 8
  0049d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  004a3	85 c0		 test	 eax, eax
  004a5	74 19		 je	 SHORT $LN24@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  004a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  004ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN353@tick:
  004b5	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 71   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &blockBuffer)) GlobalThread::stop = true;

  004ba	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN24@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  004c0	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  004c7	48 85 c9	 test	 rcx, rcx
  004ca	75 10		 jne	 SHORT $LN139@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  004cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  004d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  004da	eb 33		 jmp	 SHORT $LN354@tick
$LN139@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  004dc	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  004e2	8b d0		 mov	 edx, eax
  004e4	ff c0		 inc	 eax
  004e6	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax
  004ec	4c 8d 4c 24 74	 lea	 r9, QWORD PTR chunkX$[rsp]
  004f1	41 b8 04 00 00
	00		 mov	 r8d, 4
  004f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  004fd	85 c0		 test	 eax, eax
  004ff	74 19		 je	 SHORT $LN23@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00501	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  00508	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN354@tick:
  0050f	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 72   : 	if(!chunkGenProgram.setArgument(sizeof(const int), &chunkX)) GlobalThread::stop = true;

  00514	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN23@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  0051a	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  00521	48 85 c9	 test	 rcx, rcx
  00524	75 10		 jne	 SHORT $LN143@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00526	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  0052d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  00534	eb 33		 jmp	 SHORT $LN355@tick
$LN143@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00536	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  0053c	8b d0		 mov	 edx, eax
  0053e	ff c0		 inc	 eax
  00540	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax
  00546	4c 8d 4c 24 78	 lea	 r9, QWORD PTR chunkY$[rsp]
  0054b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00551	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  00557	85 c0		 test	 eax, eax
  00559	74 19		 je	 SHORT $LN22@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  0055b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  00562	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN355@tick:
  00569	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 73   : 	if(!chunkGenProgram.setArgument(sizeof(const int), &chunkY)) GlobalThread::stop = true;

  0056e	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN22@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  00574	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  0057b	48 85 c9	 test	 rcx, rcx
  0057e	75 10		 jne	 SHORT $LN147@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00580	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  00587	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  0058e	eb 33		 jmp	 SHORT $LN356@tick
$LN147@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00590	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  00596	8b d0		 mov	 edx, eax
  00598	ff c0		 inc	 eax
  0059a	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax
  005a0	4c 8d 4c 24 70	 lea	 r9, QWORD PTR chunkZ$[rsp]
  005a5	41 b8 04 00 00
	00		 mov	 r8d, 4
  005ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  005b1	85 c0		 test	 eax, eax
  005b3	74 19		 je	 SHORT $LN21@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  005b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  005bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN356@tick:
  005c3	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 74   : 	if(!chunkGenProgram.setArgument(sizeof(const int), &chunkZ)) GlobalThread::stop = true;

  005c8	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN21@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  005ce	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  005d5	48 85 c9	 test	 rcx, rcx
  005d8	75 10		 jne	 SHORT $LN153@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  005da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  005e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  005e8	eb 35		 jmp	 SHORT $LN357@tick
$LN153@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  005ea	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  005f0	8b d0		 mov	 edx, eax
  005f2	ff c0		 inc	 eax
  005f4	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);

  005fa	4c 8d 8f 80 08
	00 00		 lea	 r9, QWORD PTR [rdi+2176]

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00601	41 b8 08 00 00
	00		 mov	 r8d, 8
  00607	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  0060d	85 c0		 test	 eax, eax
  0060f	74 19		 je	 SHORT $LN20@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00611	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  00618	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN357@tick:
  0061f	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 75   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &minHeightNoiseBuffer)) GlobalThread::stop = true;

  00624	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN20@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  0062a	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  00631	48 85 c9	 test	 rcx, rcx
  00634	75 10		 jne	 SHORT $LN159@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00636	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  0063d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  00644	eb 35		 jmp	 SHORT $LN358@tick
$LN159@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00646	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  0064c	8b d0		 mov	 edx, eax
  0064e	ff c0		 inc	 eax
  00650	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);

  00656	4c 8d 8f 98 08
	00 00		 lea	 r9, QWORD PTR [rdi+2200]

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  0065d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00663	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  00669	85 c0		 test	 eax, eax
  0066b	74 19		 je	 SHORT $LN19@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  0066d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  00674	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN358@tick:
  0067b	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 76   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &maxHeightNoiseBuffer)) GlobalThread::stop = true;

  00680	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN19@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  00686	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  0068d	48 85 c9	 test	 rcx, rcx
  00690	75 10		 jne	 SHORT $LN165@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00692	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  00699	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  006a0	eb 35		 jmp	 SHORT $LN359@tick
$LN165@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  006a2	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  006a8	8b d0		 mov	 edx, eax
  006aa	ff c0		 inc	 eax
  006ac	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);

  006b2	4c 8d 8f b0 08
	00 00		 lea	 r9, QWORD PTR [rdi+2224]

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  006b9	41 b8 08 00 00
	00		 mov	 r8d, 8
  006bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  006c5	85 c0		 test	 eax, eax
  006c7	74 19		 je	 SHORT $LN18@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  006c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  006d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN359@tick:
  006d7	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 77   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &smoothnessNoiseBuffer)) GlobalThread::stop = true;

  006dc	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN18@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  006e2	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  006e9	48 85 c9	 test	 rcx, rcx
  006ec	75 10		 jne	 SHORT $LN171@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  006ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  006f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  006fc	eb 35		 jmp	 SHORT $LN360@tick
$LN171@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  006fe	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  00704	8b d0		 mov	 edx, eax
  00706	ff c0		 inc	 eax
  00708	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);

  0070e	4c 8d 8f c8 08
	00 00		 lea	 r9, QWORD PTR [rdi+2248]

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00715	41 b8 08 00 00
	00		 mov	 r8d, 8
  0071b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  00721	85 c0		 test	 eax, eax
  00723	74 19		 je	 SHORT $LN17@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00725	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  0072c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN360@tick:
  00733	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 78   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &solidNoiseBuffer)) GlobalThread::stop = true;

  00738	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN17@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  0073e	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  00745	48 85 c9	 test	 rcx, rcx
  00748	75 10		 jne	 SHORT $LN177@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  0074a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  00751	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  00758	eb 35		 jmp	 SHORT $LN361@tick
$LN177@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  0075a	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  00760	8b d0		 mov	 edx, eax
  00762	ff c0		 inc	 eax
  00764	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);

  0076a	4c 8d 8f e0 08
	00 00		 lea	 r9, QWORD PTR [rdi+2272]

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00771	41 b8 08 00 00
	00		 mov	 r8d, 8
  00777	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  0077d	85 c0		 test	 eax, eax
  0077f	74 19		 je	 SHORT $LN16@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00781	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  00788	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN361@tick:
  0078f	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 79   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &stoneNoiseBuffer)) GlobalThread::stop = true;

  00794	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN16@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  0079a	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  007a1	48 85 c9	 test	 rcx, rcx
  007a4	75 10		 jne	 SHORT $LN183@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  007a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  007ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  007b4	eb 35		 jmp	 SHORT $LN362@tick
$LN183@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  007b6	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  007bc	8b d0		 mov	 edx, eax
  007be	ff c0		 inc	 eax
  007c0	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);

  007c6	4c 8d 8f f8 08
	00 00		 lea	 r9, QWORD PTR [rdi+2296]

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  007cd	41 b8 08 00 00
	00		 mov	 r8d, 8
  007d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  007d9	85 c0		 test	 eax, eax
  007db	74 19		 je	 SHORT $LN15@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  007dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  007e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN362@tick:
  007eb	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 80   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &temperatureNoiseBuffer)) GlobalThread::stop = true;

  007f0	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN15@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  007f6	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  007fd	48 85 c9	 test	 rcx, rcx
  00800	75 10		 jne	 SHORT $LN189@tick

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00802	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  00809	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  00810	eb 35		 jmp	 SHORT $LN363@tick
$LN189@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00812	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32
  00818	8b d0		 mov	 edx, eax
  0081a	ff c0		 inc	 eax
  0081c	89 05 20 00 00
	00		 mov	 DWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+32, eax

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);

  00822	4c 8d 8f 10 09
	00 00		 lea	 r9, QWORD PTR [rdi+2320]

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00829	41 b8 08 00 00
	00		 mov	 r8d, 8
  0082f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  00835	85 c0		 test	 eax, eax
  00837	74 19		 je	 SHORT $LN14@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00839	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  00840	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
$LN363@tick:
  00847	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 81   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &humidityNoiseBuffer)) GlobalThread::stop = true;

  0084c	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
$LN14@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 235  : 	if(!preparedKernel)

  00852	48 8b 15 28 00
	00 00		 mov	 rdx, QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40
  00859	48 85 d2	 test	 rdx, rdx
  0085c	75 10		 jne	 SHORT $LN193@tick

; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");

  0085e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952795
  00865	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952794

; 238  : 		return false;

  0086c	eb 47		 jmp	 SHORT $LN364@tick
$LN193@tick:

; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);

  0086e	48 8d 45 b8	 lea	 rax, QWORD PTR event$5[rbp-256]
  00872	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00877	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  0087c	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  00881	48 8d 45 28	 lea	 rax, QWORD PTR local_ws$[rbp-256]
  00885	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0088a	48 8d 45 10	 lea	 rax, QWORD PTR global_ws$[rbp-256]
  0088e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00893	45 33 c9	 xor	 r9d, r9d
  00896	45 8d 41 03	 lea	 r8d, QWORD PTR [r9+3]
  0089a	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0089d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueNDRangeKernel

; 245  : 	if(error != CL_SUCCESS)

  008a3	85 c0		 test	 eax, eax
  008a5	74 1b		 je	 SHORT $LN192@tick

; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");

  008a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952793
  008ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952792
$LN364@tick:
  008b5	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 82   : 	if(!chunkGenProgram.invoke(queue, 3, global_ws, local_ws)) GlobalThread::stop = true;

  008ba	88 1d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, bl ; GlobalThread::stop
  008c0	eb 2a		 jmp	 SHORT $LN13@tick
$LN192@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 251  : 	queue.addSyncEvent(event);

  008c2	48 8b 55 b8	 mov	 rdx, QWORD PTR event$5[rbp-256]
  008c6	48 8b ce	 mov	 rcx, rsi
  008c9	e8 00 00 00 00	 call	 ?addSyncEvent@CommandQueue@cl@@QEAAXPEAU_cl_event@@@Z ; cl::CommandQueue::addSyncEvent

; 252  : 
; 253  : 	preparedKernel = 0;

  008ce	4c 89 25 28 00
	00 00		 mov	 QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+40, r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  008d5	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+24
  008dc	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  008e1	85 c0		 test	 eax, eax
  008e3	74 07		 je	 SHORT $LN13@tick

; 33   : 		_Throw_C_error(_Res);

  008e5	8b c8		 mov	 ecx, eax
  008e7	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN13@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 83   : 	queue.sync();

  008ec	48 8b ce	 mov	 rcx, rsi
  008ef	e8 00 00 00 00	 call	 ?sync@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::sync

; 85   : 	if(!blockBuffer.read(queue, chunk->dataPtr())) GlobalThread::stop = true;

  008f4	49 8b 07	 mov	 rax, QWORD PTR [r15]
  008f7	49 8b cf	 mov	 rcx, r15
  008fa	ff 50 20	 call	 QWORD PTR [rax+32]
  008fd	48 8d 8f 60 08
	00 00		 lea	 rcx, QWORD PTR [rdi+2144]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 335  : 	return read(queue, 0, size, data);

  00904	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00909	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  0090d	48 8b d6	 mov	 rdx, rsi
  00910	e8 00 00 00 00	 call	 ?read@Buffer@cl@@QEAA_NAEAVCommandQueue@2@_K1PEAX@Z ; cl::Buffer::read
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 85   : 	if(!blockBuffer.read(queue, chunk->dataPtr())) GlobalThread::stop = true;

  00915	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  0091c	84 c0		 test	 al, al
  0091e	0f 44 d3	 cmove	 edx, ebx
  00921	88 15 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dl ; GlobalThread::stop

; 86   : 	queue.sync();

  00927	48 8b ce	 mov	 rcx, rsi
  0092a	e8 00 00 00 00	 call	 ?sync@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::sync
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0092f	49 8d 4f 28	 lea	 rcx, QWORD PTR [r15+40]
  00933	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00938	85 c0		 test	 eax, eax
  0093a	74 07		 je	 SHORT $LN217@tick

; 33   : 		_Throw_C_error(_Res);

  0093c	8b c8		 mov	 ecx, eax
  0093e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN217@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 95   : 	renderUpdateNeeded = flag;

  00943	66 41 c7 47 08
	01 01		 mov	 WORD PTR [r15+8], 257	; 00000101H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0094a	49 8d 4f 28	 lea	 rcx, QWORD PTR [r15+40]
  0094e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00953	85 c0		 test	 eax, eax
  00955	74 07		 je	 SHORT $LN240@tick

; 33   : 		_Throw_C_error(_Res);

  00957	8b c8		 mov	 ecx, eax
  00959	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN240@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0095e	48 c7 45 a0 00
	00 00 00	 mov	 QWORD PTR $T3[rbp-256], 0
  00966	48 c7 45 a8 00
	00 00 00	 mov	 QWORD PTR $T3[rbp-248], 0

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0096e	4d 85 f6	 test	 r14, r14
  00971	74 05		 je	 SHORT $LN252@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00973	f0 41 ff 46 08	 lock inc DWORD PTR [r14+8]
$LN252@tick:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00978	4d 8b c6	 mov	 r8, r14
  0097b	49 8b d7	 mov	 rdx, r15
  0097e	48 8d 4d a0	 lea	 rcx, QWORD PTR $T3[rbp-256]
  00982	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 133  : 	requestChunkDraw(chunk);

  00987	48 8d 4d a0	 lea	 rcx, QWORD PTR $T3[rbp-256]
  0098b	e8 00 00 00 00	 call	 ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkDraw

; 134  : 		
; 135  : 	for(int i = -1; i <= 1; i++)

  00990	41 83 ce ff	 or	 r14d, -1
  00994	45 8b ee	 mov	 r13d, r14d
  00997	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL11@tick:

; 136  : 	{
; 137  : 		for(int j = -1; j <= 1; j++)

  009a0	45 8b e6	 mov	 r12d, r14d
$LL8@tick:

; 139  : 			for(int k = -1; k <= 1; k++)

  009a3	41 8b f6	 mov	 esi, r14d
  009a6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@tick:

; 140  : 			{
; 141  : 				if(i | j | k)

  009b0	8b c6		 mov	 eax, esi
  009b2	41 0b c4	 or	 eax, r12d
  009b5	41 0b c5	 or	 eax, r13d
  009b8	0f 84 e9 00 00
	00		 je	 $LN4@tick

; 142  : 				{
; 143  : 					std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(i + chunk->pos.x, j + chunk->pos.y, k + chunk->pos.z);

  009be	41 8b 4f 20	 mov	 ecx, DWORD PTR [r15+32]
  009c2	03 ce		 add	 ecx, esi
  009c4	45 8b 4f 1c	 mov	 r9d, DWORD PTR [r15+28]
  009c8	45 03 cc	 add	 r9d, r12d
  009cb	45 8b 47 18	 mov	 r8d, DWORD PTR [r15+24]
  009cf	45 03 c5	 add	 r8d, r13d
  009d2	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  009d6	48 8d 55 80	 lea	 rdx, QWORD PTR c$1[rbp-256]
  009da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  009e1	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  009e6	90		 npad	 1

; 144  : 					if(!c->isEmpty() && c->isLoaded() && !c->isRenderUpdateNeeded())

  009e7	48 8b 7d 80	 mov	 rdi, QWORD PTR c$1[rbp-256]
  009eb	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  009ee	48 8b cf	 mov	 rcx, rdi
  009f1	ff 50 18	 call	 QWORD PTR [rax+24]
  009f4	84 c0		 test	 al, al
  009f6	75 78		 jne	 SHORT $LN352@tick
  009f8	38 47 09	 cmp	 BYTE PTR [rdi+9], al
  009fb	74 73		 je	 SHORT $LN352@tick
  009fd	38 47 08	 cmp	 BYTE PTR [rdi+8], al
  00a00	75 6e		 jne	 SHORT $LN352@tick
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 95   : 	renderUpdateNeeded = flag;

  00a02	c6 47 08 01	 mov	 BYTE PTR [rdi+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00a06	48 c7 45 90 00
	00 00 00	 mov	 QWORD PTR $T2[rbp-256], 0
  00a0e	48 c7 45 98 00
	00 00 00	 mov	 QWORD PTR $T2[rbp-248], 0

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00a16	48 8b 5d 88	 mov	 rbx, QWORD PTR c$1[rbp-248]
  00a1a	48 85 db	 test	 rbx, rbx
  00a1d	74 3e		 je	 SHORT $LN305@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00a1f	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00a23	48 8b 5d 98	 mov	 rbx, QWORD PTR $T2[rbp-248]
  00a27	48 85 db	 test	 rbx, rbx
  00a2a	74 29		 je	 SHORT $LN351@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00a2c	41 8b c6	 mov	 eax, r14d
  00a2f	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00a34	ff c8		 dec	 eax
  00a36	75 1d		 jne	 SHORT $LN351@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00a38	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a3b	48 8b cb	 mov	 rcx, rbx
  00a3e	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00a40	41 8b c6	 mov	 eax, r14d
  00a43	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  00a48	ff c8		 dec	 eax
  00a4a	75 09		 jne	 SHORT $LN351@tick

; 128  : 			_Delete_this();

  00a4c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a4f	48 8b cb	 mov	 rcx, rbx
  00a52	ff 50 08	 call	 QWORD PTR [rax+8]
$LN351@tick:
  00a55	48 8b 7d 80	 mov	 rdi, QWORD PTR c$1[rbp-256]
  00a59	48 8b 5d 88	 mov	 rbx, QWORD PTR c$1[rbp-248]
$LN305@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00a5d	48 89 5d 98	 mov	 QWORD PTR $T2[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  00a61	48 89 7d 90	 mov	 QWORD PTR $T2[rbp-256], rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 147  : 						requestLateChunkDraw(c);

  00a65	48 8d 4d 90	 lea	 rcx, QWORD PTR $T2[rbp-256]
  00a69	e8 00 00 00 00	 call	 ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestLateChunkDraw
  00a6e	eb 04		 jmp	 SHORT $LN1@tick
$LN352@tick:
  00a70	48 8b 5d 88	 mov	 rbx, QWORD PTR c$1[rbp-248]
$LN1@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00a74	48 85 db	 test	 rbx, rbx
  00a77	74 2e		 je	 SHORT $LN4@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00a79	41 8b c6	 mov	 eax, r14d
  00a7c	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00a81	ff c8		 dec	 eax
  00a83	75 22		 jne	 SHORT $LN4@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00a85	48 8b 5d 88	 mov	 rbx, QWORD PTR c$1[rbp-248]
  00a89	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a8c	48 8b cb	 mov	 rcx, rbx
  00a8f	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00a91	41 8b c6	 mov	 eax, r14d
  00a94	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  00a99	ff c8		 dec	 eax
  00a9b	75 0a		 jne	 SHORT $LN4@tick

; 128  : 			_Delete_this();

  00a9d	48 8b 4d 88	 mov	 rcx, QWORD PTR c$1[rbp-248]
  00aa1	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00aa4	ff 50 08	 call	 QWORD PTR [rax+8]
$LN4@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 139  : 			for(int k = -1; k <= 1; k++)

  00aa7	ff c6		 inc	 esi
  00aa9	83 fe 01	 cmp	 esi, 1
  00aac	0f 8e fe fe ff
	ff		 jle	 $LL5@tick

; 136  : 	{
; 137  : 		for(int j = -1; j <= 1; j++)

  00ab2	41 ff c4	 inc	 r12d
  00ab5	41 83 fc 01	 cmp	 r12d, 1
  00ab9	0f 8e e4 fe ff
	ff		 jle	 $LL8@tick

; 134  : 		
; 135  : 	for(int i = -1; i <= 1; i++)

  00abf	41 ff c5	 inc	 r13d
  00ac2	41 83 fd 01	 cmp	 r13d, 1
  00ac6	0f 8e d4 fe ff
	ff		 jle	 $LL11@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00acc	48 8b 5d b0	 mov	 rbx, QWORD PTR $T4[rbp-256]
  00ad0	48 85 db	 test	 rbx, rbx
  00ad3	74 23		 je	 SHORT $LN327@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00ad5	41 8b c6	 mov	 eax, r14d
  00ad8	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00add	ff c8		 dec	 eax
  00adf	75 17		 jne	 SHORT $LN327@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00ae1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00ae4	48 8b cb	 mov	 rcx, rbx
  00ae7	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00ae9	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00aed	75 09		 jne	 SHORT $LN327@tick

; 128  : 			_Delete_this();

  00aef	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00af2	48 8b cb	 mov	 rcx, rbx
  00af5	ff 50 08	 call	 QWORD PTR [rax+8]
$LN327@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 154  : 	return true;

  00af8	b0 01		 mov	 al, 1

; 155  : }

  00afa	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00afe	48 33 cc	 xor	 rcx, rsp
  00b01	e8 00 00 00 00	 call	 __security_check_cookie
  00b06	4c 8d 9c 24 90
	01 00 00	 lea	 r11, QWORD PTR [rsp+400]
  00b0e	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00b12	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00b16	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  00b1a	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00b1f	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  00b24	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00b29	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  00b2e	49 8b e3	 mov	 rsp, r11
  00b31	41 5f		 pop	 r15
  00b33	41 5e		 pop	 r14
  00b35	41 5d		 pop	 r13
  00b37	41 5c		 pop	 r12
  00b39	5d		 pop	 rbp
  00b3a	c3		 ret	 0
?tick@ChunkLoadThread@@MEAA_NXZ ENDP			; ChunkLoadThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunkZ$ = 112
chunkX$ = 116
chunkY$ = 120
c$1 = 128
$T2 = 144
$T3 = 160
$T4 = 176
event$5 = 184
$T6 = 192
chunk$ = 224
$T7 = 240
$T8 = 248
global_ws$ = 272
local_ws$ = 296
__$ArrayPad$ = 320
this$ = 448
?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$0
  00000	48 8d 8a e0 00
	00 00		 lea	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunkZ$ = 112
chunkX$ = 116
chunkY$ = 120
c$1 = 128
$T2 = 144
$T3 = 160
$T4 = 176
event$5 = 184
$T6 = 192
chunk$ = 224
$T7 = 240
$T8 = 248
global_ws$ = 272
local_ws$ = 296
__$ArrayPad$ = 320
this$ = 448
?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$3
  0000c	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR c$1[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestChunkLoad, COMDAT

; 158  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 159  : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d 48 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2376
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestChu

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 20 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2336
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d 48 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2376
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestChu

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestChu

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestChu

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestChu

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestChu:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 164  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestChunkLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestChunkLoad'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestChunkLoad'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00006	0f 94 c0	 sete	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 126  : 		}

  00009	c3		 ret	 0
?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty
_TEXT	ENDS
END
