; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?loaderThread@@3HA				; loaderThread
EXTRN	_time64:PROC
?loaderThread@@3HA DD 01H DUP (?)			; loaderThread
_BSS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
	ORG $+6
$SG4294957486 DB '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, 's', 00H, '\', 00H, 'g', 00H, 'e', 00H, 'n'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, '.', 00H, 'c', 00H, 'l', 00H, 00H, 00H
$SG4294957485 DB 'generateTerrain_1', 00H
PUBLIC	??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z	; std::shared_ptr<Cave>::`scalar deleting destructor'
PUBLIC	??$destroy@VLine@geom@@@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@@Z ; std::allocator<geom::Line>::destroy<geom::Line>
PUBLIC	??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z ; std::allocator<std::shared_ptr<Cave> >::destroy<std::shared_ptr<Cave> >
PUBLIC	??$destroy@VLine@geom@@@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SAXAEAV?$allocator@VLine@geom@@@1@PEAVLine@geom@@@Z ; std::allocator_traits<std::allocator<geom::Line> >::destroy<geom::Line>
PUBLIC	??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<Cave> > >::destroy<std::shared_ptr<Cave> >
PUBLIC	??0Line@geom@@QEAA@AEBV01@@Z			; geom::Line::Line
PUBLIC	??$_Uninit_move@PEAVLine@geom@@PEAV12@V?$allocator@VLine@geom@@@std@@V12@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<geom::Line * __ptr64,geom::Line * __ptr64,std::allocator<geom::Line>,geom::Line>
PUBLIC	??$_Val_type@PEAVLine@geom@@@std@@YAPEAVLine@geom@@PEAV12@@Z ; std::_Val_type<geom::Line * __ptr64>
PUBLIC	??$destroy@VLine@geom@@@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@@Z ; std::_Wrap_alloc<std::allocator<geom::Line> >::destroy<geom::Line>
PUBLIC	??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::destroy<std::shared_ptr<Cave> >
PUBLIC	??$construct@VLine@geom@@V12@@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@$$QEAV23@@Z ; std::allocator<geom::Line>::construct<geom::Line,geom::Line>
PUBLIC	??$_Uninitialized_move@PEAVLine@geom@@PEAV12@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z ; std::_Uninitialized_move<geom::Line * __ptr64,geom::Line * __ptr64,std::_Wrap_alloc<std::allocator<geom::Line> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAXPEAVLine@geom@@0AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<geom::Line> > >
PUBLIC	??$_Ptr_cat@VLine@geom@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAVLine@geom@@0@Z ; std::_Ptr_cat<geom::Line,geom::Line>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > > >
PUBLIC	??$_Ptr_cat@V?$shared_ptr@VCave@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VCave@@@0@0@Z ; std::_Ptr_cat<std::shared_ptr<Cave>,std::shared_ptr<Cave> >
PUBLIC	??$construct@VLine@geom@@V12@@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SAXAEAV?$allocator@VLine@geom@@@1@PEAVLine@geom@@$$QEAV34@@Z ; std::allocator_traits<std::allocator<geom::Line> >::construct<geom::Line,geom::Line>
PUBLIC	?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<Cave>::_Reset0
PUBLIC	?_Reset@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<Cave>::_Reset
PUBLIC	??$_Allocate@VLine@geom@@@std@@YAPEAVLine@geom@@_KPEAV12@@Z ; std::_Allocate<geom::Line>
PUBLIC	??$_Umove@PEAVLine@geom@@@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAPEAVLine@geom@@PEAV23@00@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Umove<geom::Line * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAXPEAVLine@geom@@0AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<geom::Line> > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > > >
PUBLIC	??$construct@VLine@geom@@V12@@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@$$QEAV23@@Z ; std::_Wrap_alloc<std::allocator<geom::Line> >::construct<geom::Line,geom::Line>
PUBLIC	??$forward@VLine@geom@@@std@@YA$$QEAVLine@geom@@AEAV12@@Z ; std::forward<geom::Line>
PUBLIC	??$addressof@VLine@geom@@@std@@YAPEAVLine@geom@@AEAV12@@Z ; std::addressof<geom::Line>
PUBLIC	??$_Reset@VCave@@@?$_Ptr_base@VCave@@@std@@QEAAXAEBV01@@Z ; std::_Ptr_base<Cave>::_Reset<Cave>
PUBLIC	?max_size@?$allocator@VLine@geom@@@std@@QEBA_KXZ ; std::allocator<geom::Line>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SA_KAEBV?$allocator@VLine@geom@@@2@@Z ; std::allocator_traits<std::allocator<geom::Line> >::max_size
PUBLIC	?allocate@?$allocator@VLine@geom@@@std@@QEAAPEAVLine@geom@@_K@Z ; std::allocator<geom::Line>::allocate
PUBLIC	??0?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAA@XZ ; std::allocator<std::shared_ptr<Cave> >::allocator<std::shared_ptr<Cave> >
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<geom::Line> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAPEAVLine@geom@@_K@Z ; std::_Wrap_alloc<std::allocator<geom::Line> >::allocate
PUBLIC	?deallocate@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@_K@Z ; std::allocator<geom::Line>::deallocate
PUBLIC	?capacity@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ; std::vector<geom::Line,std::allocator<geom::Line> >::capacity
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >
PUBLIC	?deallocate@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@2@_K@Z ; std::allocator<std::shared_ptr<Cave> >::deallocate
PUBLIC	??0?$_Vector_val@U?$_Simple_types@VLine@geom@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<geom::Line> >::_Vector_val<std::_Simple_types<geom::Line> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@_K@Z ; std::_Wrap_alloc<std::allocator<geom::Line> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<geom::Line> >::_Wrap_alloc<std::allocator<geom::Line> >
PUBLIC	?_Xlen@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXXZ ; std::vector<geom::Line,std::allocator<geom::Line> >::_Xlen
PUBLIC	?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reallocate
PUBLIC	?_Grow_to@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBA_K_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Grow_to
PUBLIC	?_Destroy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXPEAVLine@geom@@0@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Destroy
PUBLIC	?max_size@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ; std::vector<geom::Line,std::allocator<geom::Line> >::max_size
PUBLIC	?_Unused_capacity@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ; std::vector<geom::Line,std::allocator<geom::Line> >::_Unused_capacity
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::deallocate
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > > >::_Getal
PUBLIC	?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::_Destroy
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VLine@geom@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >
PUBLIC	??0?$allocator@VLine@geom@@@std@@QEAA@XZ	; std::allocator<geom::Line>::allocator<geom::Line>
PUBLIC	?_Orphan_range@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXPEAVLine@geom@@0@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Orphan_range
PUBLIC	?_Tidy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXXZ ; std::vector<geom::Line,std::allocator<geom::Line> >::_Tidy
PUBLIC	?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reserve
PUBLIC	?_Inside@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBA_NPEBVLine@geom@@@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Inside
PUBLIC	?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::_Tidy
PUBLIC	?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ	; std::_Ptr_base<Cave>::_Decref
PUBLIC	?_Get@?$_Ptr_base@VCave@@@std@@QEBAPEAVCave@@XZ	; std::_Ptr_base<Cave>::_Get
PUBLIC	??0?$_Ptr_base@VCave@@@std@@QEAA@XZ		; std::_Ptr_base<Cave>::_Ptr_base<Cave>
PUBLIC	??A?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAAEAVLine@geom@@_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::operator[]
PUBLIC	?size@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ; std::vector<geom::Line,std::allocator<geom::Line> >::size
PUBLIC	??1?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ ; std::vector<geom::Line,std::allocator<geom::Line> >::~vector<geom::Line,std::allocator<geom::Line> >
PUBLIC	?push_back@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAX$$QEAVLine@geom@@@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::push_back
PUBLIC	??0?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ ; std::vector<geom::Line,std::allocator<geom::Line> >::vector<geom::Line,std::allocator<geom::Line> >
PUBLIC	??A?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VCave@@@1@_K@Z ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::operator[]
PUBLIC	?size@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::size
PUBLIC	??1?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::~vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >
PUBLIC	??C?$shared_ptr@VCave@@@std@@QEBAPEAVCave@@XZ	; std::shared_ptr<Cave>::operator->
PUBLIC	??1?$shared_ptr@VCave@@@std@@QEAA@XZ		; std::shared_ptr<Cave>::~shared_ptr<Cave>
PUBLIC	??0?$shared_ptr@VCave@@@std@@QEAA@AEBV01@@Z	; std::shared_ptr<Cave>::shared_ptr<Cave>
PUBLIC	?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty
PUBLIC	?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkLoad
PUBLIC	?tick@ChunkLoadThread@@MEAA_NXZ			; ChunkLoadThread::tick
PUBLIC	?preStart@ChunkLoadThread@@MEAAXXZ		; ChunkLoadThread::preStart
PUBLIC	?staticInit@ChunkLoadThread@@SAXXZ		; ChunkLoadThread::staticInit
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::temperatureNoise
PUBLIC	?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::humidityNoise
PUBLIC	?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::minHeightNoise
PUBLIC	?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::solidNoise
PUBLIC	?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
PUBLIC	?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::stoneNoise
PUBLIC	?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::smoothnessNoise
PUBLIC	?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::maxHeightNoise
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A DB 030H DUP (?) ; ChunkLoadThread::temperatureNoise
?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A DB 030H DUP (?) ; ChunkLoadThread::humidityNoise
?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A DB 030H DUP (?) ; ChunkLoadThread::minHeightNoise
ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A DB 030H DUP (?) ; ChunkLoadThread::solidNoise
?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A DB 038H DUP (?) ; ChunkLoadThread::chunkGenProgram
piecewise_construct DB 01H DUP (?)
	ALIGN	4

?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A DB 030H DUP (?) ; ChunkLoadThread::stoneNoise
?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A DB 030H DUP (?) ; ChunkLoadThread::smoothnessNoise
?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A DB 030H DUP (?) ; ChunkLoadThread::maxHeightNoise
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z DD imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z DD imagerel $LN20+26
	DD	imagerel $LN20+75
	DD	imagerel $chain$0$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z DD imagerel $LN20+75
	DD	imagerel $LN20+89
	DD	imagerel $chain$1$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN19+19
	DD	imagerel $LN19+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN19+54
	DD	imagerel $LN19+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN21+19
	DD	imagerel $LN21+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN21+54
	DD	imagerel $LN21+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN23+19
	DD	imagerel $LN23+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD imagerel $LN23+54
	DD	imagerel $LN23+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAVLine@geom@@PEAV12@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAVLine@geom@@PEAV12@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31+10
	DD	imagerel $LN31+97
	DD	imagerel $chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31+97
	DD	imagerel $LN31+99
	DD	imagerel $chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+42
	DD	imagerel $LN15+84
	DD	imagerel $chain$0$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+84
	DD	imagerel $LN15+105
	DD	imagerel $chain$1$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+105
	DD	imagerel $LN15+114
	DD	imagerel $chain$2$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+114
	DD	imagerel $LN15+123
	DD	imagerel $chain$3$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@VLine@geom@@@std@@YAPEAVLine@geom@@_KPEAV12@@Z DD imagerel $LN14
	DD	imagerel $LN14+44
	DD	imagerel $unwind$??$_Allocate@VLine@geom@@@std@@YAPEAVLine@geom@@_KPEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAVLine@geom@@@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAPEAVLine@geom@@PEAV23@00@Z DD imagerel $LN10
	DD	imagerel $LN10+26
	DD	imagerel $unwind$??$_Umove@PEAVLine@geom@@@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAPEAVLine@geom@@PEAV23@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z DD imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z DD imagerel $LN35+10
	DD	imagerel $LN35+97
	DD	imagerel $chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z DD imagerel $LN35+97
	DD	imagerel $LN35+99
	DD	imagerel $chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@VLine@geom@@@std@@QEAAPEAVLine@geom@@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+54
	DD	imagerel $unwind$?allocate@?$allocator@VLine@geom@@@std@@QEAAPEAVLine@geom@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAPEAVLine@geom@@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+54
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAPEAVLine@geom@@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z DD imagerel $LN51
	DD	imagerel $LN51+73
	DD	imagerel $unwind$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z DD imagerel $LN51+73
	DD	imagerel $LN51+149
	DD	imagerel $chain$0$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z DD imagerel $LN51+149
	DD	imagerel $LN51+155
	DD	imagerel $chain$1$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z DD imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z DD imagerel $LN37+10
	DD	imagerel $LN37+97
	DD	imagerel $chain$1$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z DD imagerel $LN37+97
	DD	imagerel $LN37+99
	DD	imagerel $chain$2$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+41
	DD	imagerel $unwind$?_Tidy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z DD imagerel $LN44
	DD	imagerel $LN44+139
	DD	imagerel $unwind$?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+35
	DD	imagerel $LN47+100
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+100
	DD	imagerel $LN47+126
	DD	imagerel $chain$2$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+126
	DD	imagerel $LN47+137
	DD	imagerel $chain$3$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ DD imagerel $LN12+19
	DD	imagerel $LN12+54
	DD	imagerel $chain$0$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ DD imagerel $LN12+54
	DD	imagerel $LN12+60
	DD	imagerel $chain$1$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+41
	DD	imagerel $unwind$??1?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAX$$QEAVLine@geom@@@Z DD imagerel $LN75
	DD	imagerel $LN75+144
	DD	imagerel $unwind$?push_back@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAX$$QEAVLine@geom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@VCave@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VCave@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$shared_ptr@VCave@@@std@@QEAA@XZ DD imagerel $LN14+19
	DD	imagerel $LN14+54
	DD	imagerel $chain$0$??1?$shared_ptr@VCave@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$shared_ptr@VCave@@@std@@QEAA@XZ DD imagerel $LN14+54
	DD	imagerel $LN14+60
	DD	imagerel $chain$1$??1?$shared_ptr@VCave@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$shared_ptr@VCave@@@std@@QEAA@AEBV01@@Z DD imagerel $LN13
	DD	imagerel $LN13+49
	DD	imagerel $unwind$??0?$shared_ptr@VCave@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@ChunkLoadThread@@MEAA_NXZ DD imagerel $LN694
	DD	imagerel $LN694+4004
	DD	imagerel $unwind$?tick@ChunkLoadThread@@MEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?preStart@ChunkLoadThread@@MEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+299
	DD	imagerel $unwind$?preStart@ChunkLoadThread@@MEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?staticInit@ChunkLoadThread@@SAXXZ DD imagerel $LN19
	DD	imagerel $LN19+313
	DD	imagerel $unwind$?staticInit@ChunkLoadThread@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+76
	DD	imagerel $unwind$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+32
	DD	imagerel $unwind$??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+54
	DD	imagerel $unwind$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+32
	DD	imagerel $unwind$??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+54
	DD	imagerel $unwind$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+32
	DD	imagerel $unwind$??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+54
	DD	imagerel $unwind$??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+32
	DD	imagerel $unwind$??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+49
	DD	imagerel $unwind$??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+32
	DD	imagerel $unwind$??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+54
	DD	imagerel $unwind$??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+32
	DD	imagerel $unwind$??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+53
	DD	imagerel $unwind$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+32
	DD	imagerel $unwind$??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD imagerel ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ+51
	DD	imagerel $unwind$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+25
	DD	00H
	DD	imagerel ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+60
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?staticInit@ChunkLoadThread@@SAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?preStart@ChunkLoadThread@@MEAAXXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tick@ChunkLoadThread@@MEAA_NXZ DD imagerel ?tick@ChunkLoadThread@@MEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+240
	DD	00H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+1118
	DD	01H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+1230
	DD	02H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+1357
	DD	03H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+2226
	DD	02H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+2327
	DD	03H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+2353
	DD	02H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+3420
	DD	04H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+3546
	DD	05H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+3615
	DD	04H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+3667
	DD	02H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+3760
	DD	01H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+3775
	DD	00H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+3855
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tick@ChunkLoadThread@@MEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
	DD	02H
	DD	imagerel ?dtor$6@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
	DD	04H
	DD	imagerel ?dtor$8@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tick@ChunkLoadThread@@MEAA_NXZ DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	00H
	DD	00H
	DD	0fH
	DD	imagerel $ip2state$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	01d8H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@ChunkLoadThread@@MEAA_NXZ DD 0218119H
	DD	025f870H
	DD	026e868H
	DD	027d860H
	DD	028c858H
	DD	029b850H
	DD	02aa848H
	DD	02b9843H
	DD	02c883eH
	DD	02d7839H
	DD	02e6835H
	DD	0677431H
	DD	066642dH
	DD	0653429H
	DD	05e011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	024aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$shared_ptr@VCave@@@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$shared_ptr@VCave@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VCave@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$shared_ptr@VCave@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VCave@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@VCave@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAX$$QEAVLine@geom@@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD 020521H
	DD	075405H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+73
	DD	imagerel $unwind$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z DD 020521H
	DD	087405H
	DD	imagerel $LN51
	DD	imagerel $LN51+73
	DD	imagerel $unwind$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z DD 060f01H
	DD	0a540fH
	DD	09340fH
	DD	0600b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAPEAVLine@geom@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@VLine@geom@@@std@@QEAAPEAVLine@geom@@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAVLine@geom@@@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAPEAVLine@geom@@PEAV23@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@VLine@geom@@@std@@YAPEAVLine@geom@@_KPEAV12@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD 020021H
	DD	06e400H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD 020521H
	DD	06e405H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAVLine@geom@@PEAV12@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z DD 020521H
	DD	066405H
	DD	imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
?minHeightNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; ChunkLoadThread::minHeightNoise$initializer$
?maxHeightNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; ChunkLoadThread::maxHeightNoise$initializer$
?smoothnessNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; ChunkLoadThread::smoothnessNoise$initializer$
?solidNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; ChunkLoadThread::solidNoise$initializer$
?stoneNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; ChunkLoadThread::stoneNoise$initializer$
?temperatureNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; ChunkLoadThread::temperatureNoise$initializer$
?humidityNoise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; ChunkLoadThread::humidityNoise$initializer$
?chunkGenProgram$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ; ChunkLoadThread::chunkGenProgram$initializer$
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 40   : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
;	COMDAT time
_TEXT	SEGMENT
_Time$dead$ = 8
time	PROC						; COMDAT

; 133  :     return _time64(_Time);

  00000	33 c9		 xor	 ecx, ecx
  00002	e9 00 00 00 00	 jmp	 _time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::minHeightNoise'', COMDAT

; 9    : Noise::NoiseGenerator2D ChunkLoadThread::minHeightNoise(8, 12, 2.0f, time(0));

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 9    : Noise::NoiseGenerator2D ChunkLoadThread::minHeightNoise(8, 12, 2.0f, time(0));

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::minHeightNoise
  00012	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40000000
  0001a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0001e	e8 00 00 00 00	 call	 ??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator2D::NoiseGenerator2D
  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::minHeightNoise''
  0002a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002e	e9 00 00 00 00	 jmp	 atexit
??__E?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::minHeightNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::minHeightNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 187  : 	delete[] noiseMap;

  00004	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 188  : }

  00010	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16
  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__F?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::minHeightNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::maxHeightNoise'', COMDAT

; 10   : Noise::NoiseGenerator2D ChunkLoadThread::maxHeightNoise(8, 12, 2.0f, time(0) + 1);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 10   : Noise::NoiseGenerator2D ChunkLoadThread::maxHeightNoise(8, 12, 2.0f, time(0) + 1);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::maxHeightNoise
  00012	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40000000
  0001a	ff c0		 inc	 eax
  0001c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00020	e8 00 00 00 00	 call	 ??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator2D::NoiseGenerator2D
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::maxHeightNoise''
  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	e9 00 00 00 00	 jmp	 atexit
??__E?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::maxHeightNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::maxHeightNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 187  : 	delete[] noiseMap;

  00004	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 188  : }

  00010	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16
  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__F?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::maxHeightNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::smoothnessNoise'', COMDAT

; 11   : Noise::NoiseGenerator3D ChunkLoadThread::smoothnessNoise(8, 12, 2.5f, time(0) + 2);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 11   : Noise::NoiseGenerator3D ChunkLoadThread::smoothnessNoise(8, 12, 2.5f, time(0) + 2);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::smoothnessNoise
  00012	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40200000
  0001a	83 c0 02	 add	 eax, 2
  0001d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00021	e8 00 00 00 00	 call	 ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator3D::NoiseGenerator3D
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::smoothnessNoise''
  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	e9 00 00 00 00	 jmp	 atexit
??__E?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::smoothnessNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::smoothnessNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 327  : 	delete[] noiseMap;

  00004	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 328  : }

  00010	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+16
  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__F?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::smoothnessNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::solidNoise'', COMDAT

; 12   : Noise::NoiseGenerator3D ChunkLoadThread::solidNoise(8, 12, 0.0f, time(0) + 3);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 12   : Noise::NoiseGenerator3D ChunkLoadThread::solidNoise(8, 12, 0.0f, time(0) + 3);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::solidNoise
  00012	83 c0 03	 add	 eax, 3
  00015	0f 57 db	 xorps	 xmm3, xmm3
  00018	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0001c	e8 00 00 00 00	 call	 ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator3D::NoiseGenerator3D
  00021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::solidNoise''
  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	e9 00 00 00 00	 jmp	 atexit
??__E?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::solidNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::solidNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 327  : 	delete[] noiseMap;

  00004	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 328  : }

  00010	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+16
  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__F?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::solidNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::stoneNoise'', COMDAT

; 13   : Noise::NoiseGenerator3D ChunkLoadThread::stoneNoise(8, 12, 2.0f, time(0) + 4);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 13   : Noise::NoiseGenerator3D ChunkLoadThread::stoneNoise(8, 12, 2.0f, time(0) + 4);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::stoneNoise
  00012	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40000000
  0001a	83 c0 04	 add	 eax, 4
  0001d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00021	e8 00 00 00 00	 call	 ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator3D::NoiseGenerator3D
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::stoneNoise''
  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	e9 00 00 00 00	 jmp	 atexit
??__E?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::stoneNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::stoneNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 327  : 	delete[] noiseMap;

  00004	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 328  : }

  00010	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+16
  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__F?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::stoneNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::temperatureNoise'', COMDAT

; 14   : Noise::NoiseGenerator2D ChunkLoadThread::temperatureNoise(8, 12, 2.0f, time(0) + 5);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 14   : Noise::NoiseGenerator2D ChunkLoadThread::temperatureNoise(8, 12, 2.0f, time(0) + 5);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::temperatureNoise
  00012	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40000000
  0001a	83 c0 05	 add	 eax, 5
  0001d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00021	e8 00 00 00 00	 call	 ??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator2D::NoiseGenerator2D
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::temperatureNoise''
  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	e9 00 00 00 00	 jmp	 atexit
??__E?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::temperatureNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::temperatureNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 187  : 	delete[] noiseMap;

  00004	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 188  : }

  00010	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16
  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__F?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::temperatureNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::humidityNoise'', COMDAT

; 15   : Noise::NoiseGenerator2D ChunkLoadThread::humidityNoise(8, 12, 2.0f, time(0) + 6);

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00004	33 c9		 xor	 ecx, ecx
  00006	e8 00 00 00 00	 call	 _time64
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 15   : Noise::NoiseGenerator2D ChunkLoadThread::humidityNoise(8, 12, 2.0f, time(0) + 6);

  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::humidityNoise
  00012	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@40000000
  0001a	83 c0 06	 add	 eax, 6
  0001d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00021	e8 00 00 00 00	 call	 ??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z ; Noise::NoiseGenerator2D::NoiseGenerator2D
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::humidityNoise''
  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	e9 00 00 00 00	 jmp	 atexit
??__E?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::humidityNoise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::humidityNoise'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 187  : 	delete[] noiseMap;

  00004	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40
  0000b	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 188  : }

  00010	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16
  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__F?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::humidityNoise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::chunkGenProgram'', COMDAT

; 17   : cl::Program ChunkLoadThread::chunkGenProgram;

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 778  : 		this->_Myhead = _Buyheadnode();

  0000d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64> > > >::_Buyheadnode
  00012	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00019	ba 02 00 00 00	 mov	 edx, 2
  0001e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+24
  00025	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN31@chunkGenPr

; 33   : 		_Throw_C_error(_Res);

  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN31@chunkGenPr:
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 97   : {

  00035	c6 05 30 00 00
	00 00		 mov	 BYTE PTR ?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A+48, 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 17   : cl::Program ChunkLoadThread::chunkGenProgram;

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::chunkGenProgram''
  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	e9 00 00 00 00	 jmp	 atexit
??__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::chunkGenProgram''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'ChunkLoadThread::chunkGenProgram'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@QEAA@XZ
?dtor$0@?0???__E?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'ChunkLoadThread::chunkGenProgram'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
text$yd	SEGMENT
??__F?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::chunkGenProgram'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00007	e9 00 00 00 00	 jmp	 ??1Program@cl@@QEAA@XZ	; cl::Program::~Program
??__F?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::chunkGenProgram''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?staticInit@ChunkLoadThread@@SAXXZ
_TEXT	SEGMENT
$T1 = 32
?staticInit@ChunkLoadThread@@SAXXZ PROC			; ChunkLoadThread::staticInit, COMDAT

; 20   : {

$LN19:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 21   : 	ChunkLoadThread::chunkGenProgram.create(IOUtil::EXE_DIR + L"\\programs\\generation.cl");

  00004	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294957486
  0000b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00010	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  0001c	48 8b d0	 mov	 rdx, rax
  0001f	e8 00 00 00 00	 call	 ?create@Program@cl@@QEAA_NV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; cl::Program::create
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 239  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00024	48 63 15 04 00
	00 00		 movsxd	 rdx, DWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0002b	4c 8b 0d 28 00
	00 00		 mov	 r9, QWORD PTR ?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40
  00032	48 0f af d2	 imul	 rdx, rdx
  00036	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16
  0003d	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  00043	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
  00048	48 63 15 04 00
	00 00		 movsxd	 rdx, DWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  0004f	4c 8b 0d 28 00
	00 00		 mov	 r9, QWORD PTR ?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40
  00056	48 0f af d2	 imul	 rdx, rdx
  0005a	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16
  00061	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  00067	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 240  : }
; 241  : 
; 242  : void NoiseGenerator2D::fillNoiseBuffer(cl::CommandQueue& queue, cl::Buffer& buffer, unsigned int xs, unsigned int ys, float x, float y, float xd, float yd)
; 243  : {
; 244  : 	fillNoiseBuffer(queue, buffer, xs, ys, smoothness, x, y, xd, yd);
; 245  : }
; 246  : 
; 247  : void NoiseGenerator2D::fillNoiseBuffer(cl::CommandQueue& queue, cl::Buffer& buffer, unsigned int xs, unsigned int ys, float smoothness, float x, float y, float xd, float yd)
; 248  : {
; 249  : 	const size_t local_ws[] = {1, 1};
; 250  : 	const size_t global_ws[] = {xs, ys};
; 251  : 	
; 252  : 	noiseProgram.prepare("fillNoiseBuffer2d");
; 253  : 	noiseProgram.setArgument(sizeof(cl_mem), &buffer);
; 254  : 	noiseProgram.setArgument(sizeof(cl_mem), &noiseMapBuffer);
; 255  : 	noiseProgram.setArgument(sizeof(unsigned int), &sizeExponent);
; 256  : 	noiseProgram.setArgument(sizeof(float), &smoothness);
; 257  : 	noiseProgram.setArgument(sizeof(unsigned int), &octaves);
; 258  : 	noiseProgram.setArgument(sizeof(float), &x);
; 259  : 	noiseProgram.setArgument(sizeof(float), &y);
; 260  : 	noiseProgram.setArgument(sizeof(float), &xd);
; 261  : 	noiseProgram.setArgument(sizeof(float), &yd);
; 262  : 	noiseProgram.setArgument(sizeof(unsigned int), &xs);
; 263  : 	noiseProgram.setArgument(sizeof(unsigned int), &ys);
; 264  : 	noiseProgram.invoke(queue, 2, global_ws, local_ws);
; 265  : }
; 266  : 
; 267  : void NoiseGenerator2D::fillNoiseBufferWithSmoothness(cl::CommandQueue& queue, cl::Buffer& buffer, unsigned int xs, unsigned int ys, cl::Buffer& smoothness, float x, float y, float xd, float yd)
; 268  : {
; 269  : 	const size_t local_ws[] = {1, 1};
; 270  : 	const size_t global_ws[] = {xs, ys};
; 271  : 	
; 272  : 	noiseProgram.prepare("fillNoiseBufferWithSmoothness2d");
; 273  : 	noiseProgram.setArgument(sizeof(cl_mem), &buffer);
; 274  : 	noiseProgram.setArgument(sizeof(cl_mem), &noiseMapBuffer);
; 275  : 	noiseProgram.setArgument(sizeof(unsigned int), &sizeExponent);
; 276  : 	noiseProgram.setArgument(sizeof(cl_mem), &smoothness);
; 277  : 	noiseProgram.setArgument(sizeof(unsigned int), &octaves);
; 278  : 	noiseProgram.setArgument(sizeof(float), &x);
; 279  : 	noiseProgram.setArgument(sizeof(float), &y);
; 280  : 	noiseProgram.setArgument(sizeof(float), &xd);
; 281  : 	noiseProgram.setArgument(sizeof(float), &yd);
; 282  : 	noiseProgram.setArgument(sizeof(unsigned int), &xs);
; 283  : 	noiseProgram.setArgument(sizeof(unsigned int), &ys);
; 284  : 	noiseProgram.invoke(queue, 2, global_ws, local_ws);
; 285  : }
; 286  : 
; 287  : unsigned char NoiseGenerator3D::noiseAt(int &x, int &y, int &z)
; 288  : {
; 289  : 	const int andField = size - 1;
; 290  : 	return noiseMap[((x & andField) << sizeExponent | y & andField) << sizeExponent | z & andField];
; 291  : }
; 292  : 
; 293  : NoiseGenerator3D::NoiseGenerator3D()
; 294  : {
; 295  : 
; 296  : }
; 297  : 
; 298  : NoiseGenerator3D::NoiseGenerator3D(int sizeExponent, int octaves, float smoothness, unsigned int seed)
; 299  : 	: sizeExponent(sizeExponent), size(1 << sizeExponent), octaves(octaves), smoothness(smoothness), noiseMap(new unsigned char[size * size * size])
; 300  : {
; 301  : 	Random rand(seed);
; 302  : 	initNoise(rand);
; 303  : }
; 304  : 
; 305  : NoiseGenerator3D::NoiseGenerator3D(int sizeExponent, int octaves, float smoothness, Random& rand)
; 306  : 	: sizeExponent(sizeExponent), size(1 << sizeExponent), octaves(octaves), smoothness(smoothness), noiseMap(new unsigned char[size * size * size])
; 307  : {
; 308  : 	initNoise(rand);
; 309  : }
; 310  : 
; 311  : void NoiseGenerator3D::initNoise(Random& rand)
; 312  : {
; 313  : 	const int chunk_size = 32;
; 314  : 	for(int i = 0; i < size * size * size; i += chunk_size)
; 315  : 	{
; 316  : 		unsigned int r = rand.getUint();
; 317  : 		for(int j = 0; j < chunk_size; j++)
; 318  : 		{
; 319  : 			noiseMap[i + j] = r & 0x1;
; 320  : 			r >>= 1;
; 321  : 		}
; 322  : 	}
; 323  : }
; 324  : 
; 325  : NoiseGenerator3D::~NoiseGenerator3D()
; 326  : {
; 327  : 	delete[] noiseMap;
; 328  : }
; 329  : 
; 330  : float NoiseGenerator3D::getNoise(float x, float y, float z)
; 331  : {
; 332  : 	return getNoise(x, y, z, smoothness);
; 333  : }
; 334  : 
; 335  : float NoiseGenerator3D::getNoise(float x, float y, float z, float smoothness)
; 336  : {
; 337  : 	float noise = 0.0f;
; 338  : 	float value = 1.0f;
; 339  : 	float maxValue = 0.0f;
; 340  : 
; 341  : 	int ix;
; 342  : 	int ix1;
; 343  : 	int iy;
; 344  : 	int iy1;
; 345  : 	int iz;
; 346  : 	int iz1;
; 347  : 	float xMix;
; 348  : 	float xMixi;
; 349  : 	float yMix;
; 350  : 	float yMixi;
; 351  : 	float zMix;
; 352  : 	float zMixi;
; 353  : 
; 354  : 	for(int i = 0; i < octaves; i++)
; 355  : 	{
; 356  : 		maxValue += value;
; 357  : 
; 358  : 		ix = (int)floorf(x);
; 359  : 		ix1 = ix + 1;
; 360  : 		iy = (int)floorf(y);
; 361  : 		iy1 = iy + 1;
; 362  : 		iz = (int)floorf(z);
; 363  : 		iz1 = iz + 1;
; 364  : 		xMix = interpolate(x - ix);
; 365  : 		xMixi = 1.0f - xMix;
; 366  : 		yMix = interpolate(y - iy);
; 367  : 		yMixi = 1.0f - yMix;
; 368  : 		zMix = interpolate(z - iz);
; 369  : 		zMixi = 1.0f - zMix;
; 370  : 
; 371  : 		noise += (noiseAt(ix, iy, iz) * xMix * yMix * zMix
; 372  : 			+ noiseAt(ix1, iy, iz) * xMixi * yMix * zMix
; 373  : 			+ noiseAt(ix, iy1, iz) * xMix * yMixi * zMix
; 374  : 			+ noiseAt(ix1, iy1, iz) * xMixi * yMixi * zMix
; 375  : 			+ noiseAt(ix, iy, iz1) * xMix * yMix * zMixi
; 376  : 			+ noiseAt(ix1, iy, iz1) * xMixi * yMix * zMixi
; 377  : 			+ noiseAt(ix, iy1, iz1) * xMix * yMixi * zMixi
; 378  : 			+ noiseAt(ix1, iy1, iz1) * xMixi * yMixi * zMixi)
; 379  : 			* value;
; 380  : 
; 381  : 		x *= 0.5f;
; 382  : 		y *= 0.5f;
; 383  : 		z *= 0.5f;
; 384  : 		value *= smoothness;
; 385  : 	}
; 386  : 
; 387  : 	return noise / maxValue;
; 388  : }
; 389  : 
; 390  : void NoiseGenerator3D::prepareForCL()
; 391  : {
; 392  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  0006c	48 63 05 04 00
	00 00		 movsxd	 rax, DWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
  00073	4c 8b 0d 28 00
	00 00		 mov	 r9, QWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40
  0007a	48 8b d0	 mov	 rdx, rax
  0007d	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+16
  00084	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  0008a	48 0f af d0	 imul	 rdx, rax
  0008e	48 0f af d0	 imul	 rdx, rax
  00092	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
  00097	48 63 05 04 00
	00 00		 movsxd	 rax, DWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
  0009e	4c 8b 0d 28 00
	00 00		 mov	 r9, QWORD PTR ?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40
  000a5	48 8b d0	 mov	 rdx, rax
  000a8	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+16
  000af	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  000b5	48 0f af d0	 imul	 rdx, rax
  000b9	48 0f af d0	 imul	 rdx, rax
  000bd	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
  000c2	48 63 05 04 00
	00 00		 movsxd	 rax, DWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
  000c9	4c 8b 0d 28 00
	00 00		 mov	 r9, QWORD PTR ?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+40
  000d0	48 8b d0	 mov	 rdx, rax
  000d3	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+16
  000da	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  000e0	48 0f af d0	 imul	 rdx, rax
  000e4	48 0f af d0	 imul	 rdx, rax
  000e8	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 239  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  000ed	48 63 15 04 00
	00 00		 movsxd	 rdx, DWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  000f4	4c 8b 0d 28 00
	00 00		 mov	 r9, QWORD PTR ?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40
  000fb	48 0f af d2	 imul	 rdx, rdx
  000ff	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16
  00106	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  0010c	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
  00111	48 63 15 04 00
	00 00		 movsxd	 rdx, DWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+4
  00118	4c 8b 0d 28 00
	00 00		 mov	 r9, QWORD PTR ?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+40
  0011f	48 0f af d2	 imul	 rdx, rdx
  00123	48 8d 0d 10 00
	00 00		 lea	 rcx, OFFSET FLAT:?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A+16
  0012a	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 29   : }

  00130	48 83 c4 48	 add	 rsp, 72			; 00000048H
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 239  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00134	e9 00 00 00 00	 jmp	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
?staticInit@ChunkLoadThread@@SAXXZ ENDP			; ChunkLoadThread::staticInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?preStart@ChunkLoadThread@@MEAAXXZ
_TEXT	SEGMENT
error$1 = 32
this$ = 64
?preStart@ChunkLoadThread@@MEAAXXZ PROC			; ChunkLoadThread::preStart, COMDAT

; 32   : {

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00006	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?device@cl@@3PEAU_cl_device_id@@EA ; cl::device
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 32   : {

  0000d	48 8b d9	 mov	 rbx, rcx
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00017	4c 8d 4c 24 20	 lea	 r9, QWORD PTR error$1[rsp]
  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR error$1[rsp], 0
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateCommandQueue

; 56   : 	if(error != CL_SUCCESS)

  0002d	83 7c 24 20 00	 cmp	 DWORD PTR error$1[rsp], 0
  00032	48 89 83 38 08
	00 00		 mov	 QWORD PTR [rbx+2104], rax
  00039	74 0c		 je	 SHORT $LN3@preStart
  0003b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR error$1[rsp]
  00040	e8 00 00 00 00	 call	 ?create@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::create
  00045	eb 07		 jmp	 SHORT $LN4@preStart
$LN3@preStart:

; 57   : 	{
; 58   : 		GLWindow::instance->postError("Could not create command queue: " + to_string(error), "Command queue creation error");
; 59   : 		return false;
; 60   : 	}
; 61   : 
; 62   : 	okay = true;

  00047	c6 83 58 08 00
	00 01		 mov	 BYTE PTR [rbx+2136], 1
$LN4@preStart:
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 34   : 	blockBuffer.create(sizeof(unsigned short) * 16 * 16 * 16, CL_MEM_READ_WRITE);

  0004e	45 33 c9	 xor	 r9d, r9d
  00051	48 8d 8b 60 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2144]
  00058	ba 00 20 00 00	 mov	 edx, 8192		; 00002000H
  0005d	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00061	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 35   : 	minHeightNoiseBuffer.create(sizeof(float) * 18 * 18, CL_MEM_READ_WRITE);

  00066	45 33 c9	 xor	 r9d, r9d
  00069	48 8d 8b 78 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2168]
  00070	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00074	ba 10 05 00 00	 mov	 edx, 1296		; 00000510H
  00079	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 36   : 	maxHeightNoiseBuffer.create(sizeof(float) * 18 * 18, CL_MEM_READ_WRITE);

  0007e	45 33 c9	 xor	 r9d, r9d
  00081	48 8d 8b 90 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2192]
  00088	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  0008c	ba 10 05 00 00	 mov	 edx, 1296		; 00000510H
  00091	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 37   : 	smoothnessNoiseBuffer.create(sizeof(float) * 18 * 18 * 18, CL_MEM_READ_WRITE);

  00096	45 33 c9	 xor	 r9d, r9d
  00099	48 8d 8b a8 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2216]
  000a0	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  000a4	ba 20 5b 00 00	 mov	 edx, 23328		; 00005b20H
  000a9	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 38   : 	solidNoiseBuffer.create(sizeof(float) * 18 * 18 * 18, CL_MEM_READ_WRITE);

  000ae	45 33 c9	 xor	 r9d, r9d
  000b1	48 8d 8b c0 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2240]
  000b8	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  000bc	ba 20 5b 00 00	 mov	 edx, 23328		; 00005b20H
  000c1	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 39   : 	stoneNoiseBuffer.create(sizeof(float) * 18 * 18 * 18, CL_MEM_READ_WRITE);

  000c6	45 33 c9	 xor	 r9d, r9d
  000c9	48 8d 8b d8 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2264]
  000d0	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  000d4	ba 20 5b 00 00	 mov	 edx, 23328		; 00005b20H
  000d9	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 40   : 	temperatureNoiseBuffer.create(sizeof(float) * 18 * 18, CL_MEM_READ_WRITE);

  000de	45 33 c9	 xor	 r9d, r9d
  000e1	48 8d 8b f0 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2288]
  000e8	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  000ec	ba 10 05 00 00	 mov	 edx, 1296		; 00000510H
  000f1	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 41   : 	humidityNoiseBuffer.create(sizeof(float) * 18 * 18, CL_MEM_READ_WRITE);

  000f6	45 33 c9	 xor	 r9d, r9d
  000f9	48 8d 8b 08 09
	00 00		 lea	 rcx, QWORD PTR [rbx+2312]
  00100	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  00104	ba 10 05 00 00	 mov	 edx, 1296		; 00000510H
  00109	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 42   : 	caveLinesBuffer.create(sizeof(geom::Line) * 256, CL_MEM_READ_ONLY);

  0010e	45 33 c9	 xor	 r9d, r9d
  00111	48 8d 8b 20 09
	00 00		 lea	 rcx, QWORD PTR [rbx+2336]
  00118	45 8d 41 04	 lea	 r8d, QWORD PTR [r9+4]
  0011c	ba 00 20 00 00	 mov	 edx, 8192		; 00002000H

; 43   : }

  00121	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00125	5b		 pop	 rbx

; 42   : 	caveLinesBuffer.create(sizeof(geom::Line) * 256, CL_MEM_READ_ONLY);

  00126	e9 00 00 00 00	 jmp	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
?preStart@ChunkLoadThread@@MEAAXXZ ENDP			; ChunkLoadThread::preStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?tick@ChunkLoadThread@@MEAA_NXZ
_TEXT	SEGMENT
chunkX$ = 112
chunkZ$ = 116
boundingBox$1$ = 120
chunkY$ = 124
lines$ = 128
tv3591 = 152
i$1$ = 156
tv3589 = 160
tv3590 = 164
c$1 = 168
$T2 = 184
amountOfLines$ = 200
$T3 = 208
tv3615 = 224
$T4 = 224
boundingBox$ = 232
$T5 = 264
caves$1$ = 272
$T6 = 280
$T7 = 320
caves$ = 336
$T8 = 360
$T9 = 376
this$GSCopy$1$ = 392
tv3613 = 400
$T10 = 408
$T11 = 424
$T12 = 440
$T13 = 472
chunk$ = 480
cave$14 = 496
$T15 = 512
global_ws$ = 536
local_ws$ = 560
__$ArrayPad$ = 584
this$ = 800
?tick@ChunkLoadThread@@MEAA_NXZ PROC			; ChunkLoadThread::tick, COMDAT

; 46   : {

$LN694:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d a8 e8 fd
	ff ff		 lea	 rbp, QWORD PTR [rax-536]
  00013	48 81 ec f0 02
	00 00		 sub	 rsp, 752		; 000002f0H
  0001a	48 c7 85 d8 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T13[rbp-256], -2
  00025	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00029	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0002d	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00031	0f 29 70 c8	 movaps	 XMMWORD PTR [rax-56], xmm6
  00035	0f 29 78 b8	 movaps	 XMMWORD PTR [rax-72], xmm7
  00039	44 0f 29 40 a8	 movaps	 XMMWORD PTR [rax-88], xmm8
  0003e	44 0f 29 48 98	 movaps	 XMMWORD PTR [rax-104], xmm9
  00043	44 0f 29 50 88	 movaps	 XMMWORD PTR [rax-120], xmm10
  00048	44 0f 29 98 78
	ff ff ff	 movaps	 XMMWORD PTR [rax-136], xmm11
  00050	44 0f 29 a0 68
	ff ff ff	 movaps	 XMMWORD PTR [rax-152], xmm12
  00058	44 0f 29 a8 58
	ff ff ff	 movaps	 XMMWORD PTR [rax-168], xmm13
  00060	44 0f 29 b0 48
	ff ff ff	 movaps	 XMMWORD PTR [rax-184], xmm14
  00068	44 0f 29 b8 38
	ff ff ff	 movaps	 XMMWORD PTR [rax-200], xmm15
  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00077	48 33 c4	 xor	 rax, rsp
  0007a	48 89 85 48 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00081	4c 8b f1	 mov	 r14, rcx
  00084	48 89 8d 88 00
	00 00		 mov	 QWORD PTR this$GSCopy$1$[rbp-256], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  0008b	48 83 b9 58 09
	00 00 00	 cmp	 QWORD PTR [rcx+2392], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 47   : 	if(ChunkLoadThread::loadQueue.empty())

  00093	0f 84 a1 0e 00
	00		 je	 $LN659@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  00099	48 8d 95 00 01
	00 00		 lea	 rdx, QWORD PTR $T15[rbp-256]
  000a0	48 81 c1 38 09
	00 00		 add	 rcx, 2360		; 00000938H
  000a7	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  000ac	48 8b c8	 mov	 rcx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  000af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b2	48 85 c0	 test	 rax, rax
  000b5	74 03		 je	 SHORT $LN63@tick
  000b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN63@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  000ba	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  000be	48 ff ca	 dec	 rdx
  000c1	48 23 51 10	 and	 rdx, QWORD PTR [rcx+16]

; 1426 : 		return (*begin());

  000c5	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c9	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  000cd	4c 8b 6a 08	 mov	 r13, QWORD PTR [rdx+8]
  000d1	4c 89 6d 08	 mov	 QWORD PTR $T5[rbp-256], r13
  000d5	4c 8b 22	 mov	 r12, QWORD PTR [rdx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  000d8	4d 85 ed	 test	 r13, r13
  000db	74 05		 je	 SHORT $LN83@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  000dd	f0 41 ff 45 08	 lock inc DWORD PTR [r13+8]
$LN83@tick:

; 426  : 		_Rep = _Other_rep;

  000e2	4c 89 ad e8 00
	00 00		 mov	 QWORD PTR chunk$[rbp-248], r13

; 427  : 		_Ptr = _Other_ptr;

  000e9	4c 89 a5 e0 00
	00 00		 mov	 QWORD PTR chunk$[rbp-256], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 160  : 		c.pop_front();

  000f0	49 8d 8e 38 09
	00 00		 lea	 rcx, QWORD PTR [r14+2360]
  000f7	e8 00 00 00 00	 call	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 55   : 	const int chunkX = chunk->pos.x;

  000fc	41 8b 54 24 18	 mov	 edx, DWORD PTR [r12+24]
  00101	89 54 24 70	 mov	 DWORD PTR chunkX$[rsp], edx

; 56   : 	const int chunkY = chunk->pos.y;

  00105	41 8b 4c 24 1c	 mov	 ecx, DWORD PTR [r12+28]
  0010a	89 4c 24 7c	 mov	 DWORD PTR chunkY$[rsp], ecx

; 57   : 	const int chunkZ = chunk->pos.z;

  0010e	41 8b 44 24 20	 mov	 eax, DWORD PTR [r12+32]
  00113	89 44 24 74	 mov	 DWORD PTR chunkZ$[rsp], eax
  00117	66 0f 6e d0	 movd	 xmm2, eax

; 58   : 
; 59   : 	smoothnessNoise.fillNoiseBuffer(queue, smoothnessNoiseBuffer, 18, 18, 18, chunkX * 16.0f - 1.0f, chunkY * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 16.0f, 16.0f, 16.0f);

  0011b	0f 5b d2	 cvtdq2ps xmm2, xmm2
  0011e	f3 44 0f 10 15
	00 00 00 00	 movss	 xmm10, DWORD PTR __real@41800000
  00127	f3 41 0f 59 d2	 mulss	 xmm2, xmm10
  0012c	f3 44 0f 10 0d
	00 00 00 00	 movss	 xmm9, DWORD PTR __real@3f800000
  00135	f3 41 0f 5c d1	 subss	 xmm2, xmm9
  0013a	66 0f 6e c9	 movd	 xmm1, ecx
  0013e	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00141	f3 41 0f 59 ca	 mulss	 xmm1, xmm10
  00146	f3 41 0f 5c c9	 subss	 xmm1, xmm9
  0014b	66 0f 6e c2	 movd	 xmm0, edx
  0014f	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00152	f3 41 0f 59 c2	 mulss	 xmm0, xmm10
  00157	f3 41 0f 5c c1	 subss	 xmm0, xmm9
  0015c	49 8d 9e a8 08
	00 00		 lea	 rbx, QWORD PTR [r14+2216]
  00163	4d 8d be 38 08
	00 00		 lea	 r15, QWORD PTR [r14+2104]
  0016a	4c 89 7d e0	 mov	 QWORD PTR tv3615[rbp-256], r15
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 397  : 	fillNoiseBuffer(queue, buffer, xs, ys, zs, smoothness, x, y, z, xd, yd, zd);

  0016e	f3 44 0f 11 54
	24 60		 movss	 DWORD PTR [rsp+96], xmm10
  00175	f3 44 0f 11 54
	24 58		 movss	 DWORD PTR [rsp+88], xmm10
  0017c	f3 44 0f 11 54
	24 50		 movss	 DWORD PTR [rsp+80], xmm10
  00183	f3 0f 11 54 24
	48		 movss	 DWORD PTR [rsp+72], xmm2
  00189	f3 0f 11 4c 24
	40		 movss	 DWORD PTR [rsp+64], xmm1
  0018f	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  00195	f3 0f 10 05 0c
	00 00 00	 movss	 xmm0, DWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+12
  0019d	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  001a3	4c 8b c3	 mov	 r8, rbx
  001a6	49 8b d7	 mov	 rdx, r15
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::smoothnessNoise
  001b0	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBuffer
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 60   : 	queue.sync();

  001b5	49 8b cf	 mov	 rcx, r15
  001b8	e8 00 00 00 00	 call	 ?sync@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::sync
  001bd	66 0f 6e 4c 24
	74		 movd	 xmm1, DWORD PTR chunkZ$[rsp]

; 61   : 	minHeightNoise.fillNoiseBuffer(queue, minHeightNoiseBuffer, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 4.0f, 4.0f);

  001c3	0f 5b c9	 cvtdq2ps xmm1, xmm1
  001c6	f3 41 0f 59 ca	 mulss	 xmm1, xmm10
  001cb	f3 41 0f 5c c9	 subss	 xmm1, xmm9
  001d0	66 0f 6e 44 24
	70		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  001d6	0f 5b c0	 cvtdq2ps xmm0, xmm0
  001d9	f3 41 0f 59 c2	 mulss	 xmm0, xmm10
  001de	f3 41 0f 5c c1	 subss	 xmm0, xmm9
  001e3	4d 8d 86 78 08
	00 00		 lea	 r8, QWORD PTR [r14+2168]
  001ea	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@40800000
  001f3	f3 44 0f 11 44
	24 48		 movss	 DWORD PTR [rsp+72], xmm8
  001fa	f3 44 0f 11 44
	24 40		 movss	 DWORD PTR [rsp+64], xmm8
  00201	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  00207	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  0020d	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@40000000
  00215	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  0021b	49 8b d7	 mov	 rdx, r15
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?minHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::minHeightNoise
  00225	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer
  0022a	66 0f 6e 4c 24
	74		 movd	 xmm1, DWORD PTR chunkZ$[rsp]

; 62   : 	maxHeightNoise.fillNoiseBuffer(queue, maxHeightNoiseBuffer, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 4.0f, 4.0f);

  00230	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00233	f3 41 0f 59 ca	 mulss	 xmm1, xmm10
  00238	f3 41 0f 5c c9	 subss	 xmm1, xmm9
  0023d	66 0f 6e 44 24
	70		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  00243	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00246	f3 41 0f 59 c2	 mulss	 xmm0, xmm10
  0024b	f3 41 0f 5c c1	 subss	 xmm0, xmm9
  00250	4d 8d 86 90 08
	00 00		 lea	 r8, QWORD PTR [r14+2192]
  00257	f3 44 0f 11 44
	24 48		 movss	 DWORD PTR [rsp+72], xmm8
  0025e	f3 44 0f 11 44
	24 40		 movss	 DWORD PTR [rsp+64], xmm8
  00265	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  0026b	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00271	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  00277	49 8b d7	 mov	 rdx, r15
  0027a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?maxHeightNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::maxHeightNoise
  00281	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer
  00286	66 0f 6e 5c 24
	74		 movd	 xmm3, DWORD PTR chunkZ$[rsp]

; 63   : 	solidNoise.fillNoiseBufferWithSmoothness(queue, solidNoiseBuffer, 18, 18, 18, smoothnessNoiseBuffer, chunkX * 16.0f - 1.0f, chunkY * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 20.0f, 25.0f, 20.0f);

  0028c	0f 5b db	 cvtdq2ps xmm3, xmm3
  0028f	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  00294	f3 41 0f 5c d9	 subss	 xmm3, xmm9
  00299	66 0f 6e 54 24
	7c		 movd	 xmm2, DWORD PTR chunkY$[rsp]
  0029f	0f 5b d2	 cvtdq2ps xmm2, xmm2
  002a2	f3 41 0f 59 d2	 mulss	 xmm2, xmm10
  002a7	f3 41 0f 5c d1	 subss	 xmm2, xmm9
  002ac	66 0f 6e 4c 24
	70		 movd	 xmm1, DWORD PTR chunkX$[rsp]
  002b2	0f 5b c9	 cvtdq2ps xmm1, xmm1
  002b5	f3 41 0f 59 ca	 mulss	 xmm1, xmm10
  002ba	f3 41 0f 5c c9	 subss	 xmm1, xmm9
  002bf	4d 8d 86 c0 08
	00 00		 lea	 r8, QWORD PTR [r14+2240]
  002c6	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@41a00000
  002ce	f3 0f 11 74 24
	60		 movss	 DWORD PTR [rsp+96], xmm6
  002d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41c80000
  002dc	f3 0f 11 44 24
	58		 movss	 DWORD PTR [rsp+88], xmm0
  002e2	f3 0f 11 74 24
	50		 movss	 DWORD PTR [rsp+80], xmm6
  002e8	f3 0f 11 5c 24
	48		 movss	 DWORD PTR [rsp+72], xmm3
  002ee	f3 0f 11 54 24
	40		 movss	 DWORD PTR [rsp+64], xmm2
  002f4	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  002fa	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  002ff	49 8b d7	 mov	 rdx, r15
  00302	e8 00 00 00 00	 call	 ?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBufferWithSmoothness
  00307	66 0f 6e 54 24
	74		 movd	 xmm2, DWORD PTR chunkZ$[rsp]

; 64   : 	stoneNoise.fillNoiseBuffer(queue, stoneNoiseBuffer, 18, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkY * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 20.0f, 20.0f, 20.0f);

  0030d	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00310	f3 41 0f 59 d2	 mulss	 xmm2, xmm10
  00315	f3 41 0f 5c d1	 subss	 xmm2, xmm9
  0031a	66 0f 6e 4c 24
	7c		 movd	 xmm1, DWORD PTR chunkY$[rsp]
  00320	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00323	f3 41 0f 59 ca	 mulss	 xmm1, xmm10
  00328	f3 41 0f 5c c9	 subss	 xmm1, xmm9
  0032d	66 0f 6e 44 24
	70		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  00333	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00336	f3 41 0f 59 c2	 mulss	 xmm0, xmm10
  0033b	f3 41 0f 5c c1	 subss	 xmm0, xmm9
  00340	4d 8d 86 d8 08
	00 00		 lea	 r8, QWORD PTR [r14+2264]
  00347	f3 0f 11 74 24
	60		 movss	 DWORD PTR [rsp+96], xmm6
  0034d	f3 0f 11 74 24
	58		 movss	 DWORD PTR [rsp+88], xmm6
  00353	f3 0f 11 74 24
	50		 movss	 DWORD PTR [rsp+80], xmm6
  00359	f3 0f 11 54 24
	48		 movss	 DWORD PTR [rsp+72], xmm2
  0035f	f3 0f 11 4c 24
	40		 movss	 DWORD PTR [rsp+64], xmm1
  00365	f3 0f 11 44 24
	38		 movss	 DWORD PTR [rsp+56], xmm0
  0036b	f3 0f 11 7c 24
	30		 movss	 DWORD PTR [rsp+48], xmm7
  00371	49 8b d7	 mov	 rdx, r15
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?stoneNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::stoneNoise
  0037b	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBuffer
  00380	66 0f 6e 4c 24
	74		 movd	 xmm1, DWORD PTR chunkZ$[rsp]

; 65   : 	temperatureNoise.fillNoiseBuffer(queue, temperatureNoiseBuffer, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 4.0f, 4.0f);

  00386	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00389	f3 41 0f 59 ca	 mulss	 xmm1, xmm10
  0038e	f3 41 0f 5c c9	 subss	 xmm1, xmm9
  00393	66 0f 6e 44 24
	70		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  00399	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0039c	f3 41 0f 59 c2	 mulss	 xmm0, xmm10
  003a1	f3 41 0f 5c c1	 subss	 xmm0, xmm9
  003a6	4d 8d 86 f0 08
	00 00		 lea	 r8, QWORD PTR [r14+2288]
  003ad	f3 44 0f 11 44
	24 48		 movss	 DWORD PTR [rsp+72], xmm8
  003b4	f3 44 0f 11 44
	24 40		 movss	 DWORD PTR [rsp+64], xmm8
  003bb	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  003c1	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  003c7	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  003cd	49 8b d7	 mov	 rdx, r15
  003d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?temperatureNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::temperatureNoise
  003d7	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer
  003dc	66 0f 6e 4c 24
	74		 movd	 xmm1, DWORD PTR chunkZ$[rsp]

; 66   : 	humidityNoise.fillNoiseBuffer(queue, humidityNoiseBuffer, 18, 18, 2.0f, chunkX * 16.0f - 1.0f, chunkZ * 16.0f - 1.0f, 4.0f, 4.0f);

  003e2	0f 5b c9	 cvtdq2ps xmm1, xmm1
  003e5	f3 41 0f 59 ca	 mulss	 xmm1, xmm10
  003ea	f3 41 0f 5c c9	 subss	 xmm1, xmm9
  003ef	66 0f 6e 44 24
	70		 movd	 xmm0, DWORD PTR chunkX$[rsp]
  003f5	0f 5b c0	 cvtdq2ps xmm0, xmm0
  003f8	f3 41 0f 59 c2	 mulss	 xmm0, xmm10
  003fd	f3 41 0f 5c c1	 subss	 xmm0, xmm9
  00402	4d 8d 86 08 09
	00 00		 lea	 r8, QWORD PTR [r14+2312]
  00409	f3 44 0f 11 44
	24 48		 movss	 DWORD PTR [rsp+72], xmm8
  00410	f3 44 0f 11 44
	24 40		 movss	 DWORD PTR [rsp+64], xmm8
  00417	f3 0f 11 4c 24
	38		 movss	 DWORD PTR [rsp+56], xmm1
  0041d	f3 0f 11 44 24
	30		 movss	 DWORD PTR [rsp+48], xmm0
  00423	f3 0f 11 7c 24
	28		 movss	 DWORD PTR [rsp+40], xmm7
  00429	49 8b d7	 mov	 rdx, r15
  0042c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?humidityNoise@ChunkLoadThread@@2VNoiseGenerator2D@Noise@@A ; ChunkLoadThread::humidityNoise
  00433	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer

; 67   : 
; 68   : 	std::vector<std::shared_ptr<Cave>> caves = CaveCache::getCavesInRegion(chunk->pos);

  00438	41 8b 44 24 18	 mov	 eax, DWORD PTR [r12+24]
  0043d	89 45 40	 mov	 DWORD PTR $T7[rbp-256], eax
  00440	41 8b 44 24 1c	 mov	 eax, DWORD PTR [r12+28]
  00445	89 45 44	 mov	 DWORD PTR $T7[rbp-252], eax
  00448	41 8b 44 24 20	 mov	 eax, DWORD PTR [r12+32]
  0044d	89 45 48	 mov	 DWORD PTR $T7[rbp-248], eax
  00450	48 8d 55 40	 lea	 rdx, QWORD PTR $T7[rbp-256]
  00454	48 8d 4d 50	 lea	 rcx, QWORD PTR caves$[rbp-256]
  00458	e8 00 00 00 00	 call	 ?getCavesInRegion@CaveCache@@SA?AV?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@VChunkPosition@@@Z ; CaveCache::getCavesInRegion
  0045d	90		 npad	 1
  0045e	66 41 0f 6e 5c
	24 20		 movd	 xmm3, DWORD PTR [r12+32]
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 105  : 	return geom::AxisAlignedCube(geom::Vector(pos.x, pos.y, pos.z) * 16.0f, geom::Vector(16.0f, 16.0f, 16.0f));

  00465	0f 5b db	 cvtdq2ps xmm3, xmm3
  00468	66 45 0f 6e 7c
	24 1c		 movd	 xmm15, DWORD PTR [r12+28]
  0046f	45 0f 5b ff	 cvtdq2ps xmm15, xmm15
  00473	66 45 0f 6e 74
	24 18		 movd	 xmm14, DWORD PTR [r12+24]
  0047a	45 0f 5b f6	 cvtdq2ps xmm14, xmm14
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 63   : 	return Vector(x * f, y * f, z * f);

  0047e	f3 41 0f 59 da	 mulss	 xmm3, xmm10
  00483	f3 45 0f 59 fa	 mulss	 xmm15, xmm10
  00488	f3 45 0f 59 f2	 mulss	 xmm14, xmm10

; 11   : 	
; 12   : }
; 13   : 
; 14   : Vector::Vector(float x, float y, float z, float w)
; 15   : 	: x(x), y(y), z(z), w(w)
; 16   : {
; 17   : 	
; 18   : }
; 19   : 
; 20   : Vector Vector::normalize()
; 21   : {
; 22   : 	return *this /= ~*this;
; 23   : }
; 24   : 
; 25   : Vector Vector::wDivide()
; 26   : {
; 27   : 	x /= w;
; 28   : 	y /= w;
; 29   : 	z /= w;
; 30   : 	return *this;
; 31   : }
; 32   : 
; 33   : Vector Vector::operator+(const Vector &vec) const
; 34   : {
; 35   : 	return Vector(x + vec.x, y + vec.y, z + vec.z);
; 36   : }
; 37   : 
; 38   : Vector Vector::operator-(const Vector &vec) const
; 39   : {
; 40   : 	return Vector(x - vec.x, y - vec.y, z - vec.z);

  0048d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41000000
  00495	f3 0f 5c d8	 subss	 xmm3, xmm0
  00499	f3 0f 11 5c 24
	78		 movss	 DWORD PTR boundingBox$1$[rsp], xmm3
  0049f	f3 44 0f 5c f8	 subss	 xmm15, xmm0
  004a4	f3 44 0f 5c f0	 subss	 xmm14, xmm0

; 10   : {

  004a9	f3 44 0f 11 75
	e8		 movss	 DWORD PTR boundingBox$[rbp-256], xmm14
  004af	f3 44 0f 11 7d
	ec		 movss	 DWORD PTR boundingBox$[rbp-252], xmm15
  004b5	f3 0f 11 5d f0	 movss	 DWORD PTR boundingBox$[rbp-248], xmm3
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  004ba	45 33 d2	 xor	 r10d, r10d
  004bd	4c 89 55 80	 mov	 QWORD PTR lines$[rbp-256], r10

; 487  : 		_Mylast = pointer();

  004c1	33 d2		 xor	 edx, edx
  004c3	48 89 55 88	 mov	 QWORD PTR lines$[rbp-248], rdx

; 488  : 		_Myend = pointer();

  004c7	45 33 c0	 xor	 r8d, r8d
  004ca	4c 89 45 90	 mov	 QWORD PTR lines$[rbp-240], r8
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 71   : 	for(int i = 0; i < caves.size(); i++)

  004ce	33 ff		 xor	 edi, edi
  004d0	89 7d 9c	 mov	 DWORD PTR i$1$[rbp-256], edi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  004d3	48 8b 45 58	 mov	 rax, QWORD PTR caves$[rbp-248]
  004d7	48 8b 5d 50	 mov	 rbx, QWORD PTR caves$[rbp-256]
  004db	48 89 5d 10	 mov	 QWORD PTR caves$1$[rbp-256], rbx
  004df	48 2b c3	 sub	 rax, rbx
  004e2	48 c1 f8 04	 sar	 rax, 4
  004e6	48 89 85 90 00
	00 00		 mov	 QWORD PTR tv3613[rbp-256], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 71   : 	for(int i = 0; i < caves.size(); i++)

  004ed	83 ce ff	 or	 esi, -1
  004f0	48 85 c0	 test	 rax, rax
  004f3	0f 84 47 04 00
	00		 je	 $LN687@tick
$LN693@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 426  : 		_Rep = _Other_rep;

  004f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42000000
  00501	49 bb ff ff ff
	ff ff ff ff 07	 mov	 r11, 576460752303423487	; 07ffffffffffffffH

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  0050b	4c 8b 73 08	 mov	 r14, QWORD PTR [rbx+8]
  0050f	4c 8b 2b	 mov	 r13, QWORD PTR [rbx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00512	4d 85 f6	 test	 r14, r14
  00515	74 28		 je	 SHORT $LN177@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00517	f0 41 ff 46 08	 lock inc DWORD PTR [r14+8]
  0051c	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR boundingBox$[rbp-248]
  00521	f3 0f 11 5c 24
	78		 movss	 DWORD PTR boundingBox$1$[rsp], xmm3
  00527	f3 44 0f 10 7d
	ec		 movss	 xmm15, DWORD PTR boundingBox$[rbp-252]
  0052d	f3 44 0f 10 75
	e8		 movss	 xmm14, DWORD PTR boundingBox$[rbp-256]
  00533	4c 8b 45 90	 mov	 r8, QWORD PTR lines$[rbp-240]
  00537	48 8b 55 88	 mov	 rdx, QWORD PTR lines$[rbp-248]
  0053b	4c 8b 55 80	 mov	 r10, QWORD PTR lines$[rbp-256]
$LN177@tick:

; 426  : 		_Rep = _Other_rep;

  0053f	4c 89 b5 f8 00
	00 00		 mov	 QWORD PTR cave$14[rbp-248], r14

; 427  : 		_Ptr = _Other_ptr;

  00546	4c 89 ad f0 00
	00 00		 mov	 QWORD PTR cave$14[rbp-256], r13
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 74   : 		for(int i = 1; i <= cave->length; i++)

  0054d	41 bf 01 00 00
	00		 mov	 r15d, 1
  00553	45 39 7d 0c	 cmp	 DWORD PTR [r13+12], r15d
  00557	0f 8c 55 03 00
	00		 jl	 $LN31@tick
  0055d	41 0f 28 e7	 movaps	 xmm4, xmm15
  00561	f3 0f 58 e0	 addss	 xmm4, xmm0
  00565	f3 0f 11 65 98	 movss	 DWORD PTR tv3591[rbp-256], xmm4
  0056a	0f 28 eb	 movaps	 xmm5, xmm3
  0056d	f3 0f 58 e8	 addss	 xmm5, xmm0
  00571	f3 0f 11 6d a4	 movss	 DWORD PTR tv3590[rbp-256], xmm5
  00576	45 0f 28 ce	 movaps	 xmm9, xmm14
  0057a	f3 44 0f 58 c8	 addss	 xmm9, xmm0
  0057f	f3 44 0f 11 4d
	a0		 movss	 DWORD PTR tv3589[rbp-256], xmm9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 426  : 		_Rep = _Other_rep;

  00585	bf 10 00 00 00	 mov	 edi, 16
  0058a	66 0f 1f 44 00
	00		 npad	 6
$LL33@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 76   : 			geom::Vector& back = cave->nodes[i - 1].pos;

  00590	4d 8b 4d 30	 mov	 r9, QWORD PTR [r13+48]
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00594	f3 42 0f 10 74
	0f f0		 movss	 xmm6, DWORD PTR [rdi+r9-16]
  0059b	f3 0f 11 b5 98
	00 00 00	 movss	 DWORD PTR $T10[rbp-256], xmm6
  005a3	f3 42 0f 10 7c
	0f f4		 movss	 xmm7, DWORD PTR [rdi+r9-12]
  005aa	f3 0f 11 bd 9c
	00 00 00	 movss	 DWORD PTR $T10[rbp-252], xmm7
  005b2	f3 46 0f 10 44
	0f f8		 movss	 xmm8, DWORD PTR [rdi+r9-8]
  005b9	f3 44 0f 11 85
	a0 00 00 00	 movss	 DWORD PTR $T10[rbp-248], xmm8

; 64   : }
; 65   : 
; 66   : Vector Vector::operator/(const Vector &vec) const
; 67   : {
; 68   : 	return Vector(x / vec.x, y / vec.y, z / vec.z);
; 69   : }
; 70   : 
; 71   : Vector Vector::operator/(float f) const
; 72   : {
; 73   : 	return Vector(x / f, y / f, z / f);
; 74   : }
; 75   : 
; 76   : Vector Vector::operator&(const Vector &vec) const
; 77   : {
; 78   : 	return Vector(y * vec.z - z * vec.y, z * vec.x - x * vec.z, x * vec.y - y * vec.x);
; 79   : }
; 80   : 
; 81   : float Vector::operator|(const Vector &vec) const
; 82   : {
; 83   : 	return x * vec.x + y * vec.y + z * vec.z;
; 84   : }
; 85   : 
; 86   : Vector Vector::operator-() const
; 87   : {
; 88   : 	return Vector(-x, -y, -z);
; 89   : }
; 90   : 
; 91   : float Vector::operator~() const
; 92   : {
; 93   : 	return sqrtf(x * x + y * y + z * z);
; 94   : }
; 95   : 
; 96   : Vector Vector::operator+=(const Vector &vec)
; 97   : {
; 98   : 	return Vector(x += vec.x, y += vec.y, z += vec.z);
; 99   : }
; 100  : 
; 101  : Vector Vector::operator-=(const Vector &vec)
; 102  : {
; 103  : 	return Vector(x -= vec.x, y -= vec.y, z -= vec.z);
; 104  : }
; 105  : 
; 106  : Vector Vector::operator*=(const Vector &vec)
; 107  : {
; 108  : 	return Vector(x *= vec.x, y *= vec.y, z *= vec.z);
; 109  : }
; 110  : 
; 111  : Vector Vector::operator*=(const Matrix &mat)
; 112  : {
; 113  : 	//return Vector(x * vec.x, y * vec.y, z * vec.z, w * vec.w);
; 114  : 	return *this;
; 115  : }
; 116  : 
; 117  : Vector Vector::operator*=(float f)
; 118  : {
; 119  : 	return Vector(x *= f, y *= f, z *= f);
; 120  : }
; 121  : 
; 122  : Vector Vector::operator/=(const Vector &vec)
; 123  : {
; 124  : 	return Vector(x /= vec.x, y /= vec.y, z /= vec.z);
; 125  : }
; 126  : 
; 127  : Vector Vector::operator/=(float f)
; 128  : {
; 129  : 	return Vector(x /= f, y /= f, z /= f);
; 130  : }
; 131  : 
; 132  : 
; 133  : 
; 134  : int Matrix::index(int x, int y) const
; 135  : {
; 136  : 	return x + (y << 2);
; 137  : }
; 138  : 
; 139  : Matrix::Matrix()
; 140  : {
; 141  : 	for(int i = 0; i < 16; i++)
; 142  : 	{
; 143  : 		data[i] = 0.0f;
; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;
; 224  : 	result[5] = 1.0f;
; 225  : 	result[10] = 1.0f;
; 226  : 	result[15] = 1.0f;
; 227  : 
; 228  : 	return result;
; 229  : }
; 230  : 
; 231  : Matrix Matrix::scale(float x, float y, float z)
; 232  : {
; 233  : 	Matrix result;
; 234  : 	result[0] = x;
; 235  : 	result[5] = y;
; 236  : 	result[10] = z;
; 237  : 	result[15] = 1.0f;
; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;
; 246  : 	result[7] = y;
; 247  : 	result[11] = z;
; 248  : 
; 249  : 	return result;
; 250  : }
; 251  : 
; 252  : Matrix Matrix::ortho2D(float left, float bottom, float right, float top)
; 253  : {
; 254  : 	float matData[] = {
; 255  : 		2.0f / (right - left), 0.0f, 0.0f, (right + left) / (left - right),
; 256  : 		0.0f, 2.0f / (top - bottom), 0.0f, (top + bottom) / (bottom - top),
; 257  : 		0.0f, 0.0f, 1.0f, 0.0f,
; 258  : 		0.0f, 0.0f, 0.0f, 1.0f
; 259  : 	};
; 260  : 
; 261  : 	return Matrix(matData);
; 262  : }
; 263  : 
; 264  : Matrix Matrix::ortho(float left, float bottom, float n, float right, float top, float f)
; 265  : {
; 266  : 	float matData[] = {
; 267  : 		2.0f / (right - left), 0.0f, 0.0f, (right + left) / (left - right),
; 268  : 		0.0f, 2.0f / (top - bottom), 0.0f, (top + bottom) / (bottom - top),
; 269  : 		0.0f, 0.0f, 2.0f / (f - n), (f + n) / (n - f),
; 270  : 		0.0f, 0.0f, 0.0f, 1.0f
; 271  : 	};
; 272  : 
; 273  : 	return Matrix(matData);
; 274  : }
; 275  : 
; 276  : Matrix Matrix::rotate(float degrees, float x, float y, float z)
; 277  : {
; 278  : 	float s = (float)sin(degrees * M_PI / 180.0f);
; 279  : 	float c = (float)cos(degrees * M_PI / 180.0f);
; 280  : 
; 281  : 	float matData[] = {
; 282  : 		x + (y + z) * c, z * -s, y * s, 0.0f,
; 283  : 		z * s, y + (x + z) * c, x * -s, 0.0f,
; 284  : 		y * -s, x * s, z + (x + y) * c, 0.0f,
; 285  : 		0.0f, 0.0f, 0.0f, 1.0f
; 286  : 	};
; 287  : 
; 288  : 	return Matrix(matData);
; 289  : }
; 290  : 
; 291  : Matrix Matrix::perspective(float fov, float aspect, float n, float f)
; 292  : {
; 293  : 	float frustumDepth = f - n;
; 294  :     float oneOverDepth = 1 / frustumDepth;
; 295  : 
; 296  : 	float matData[] = {
; 297  : 		(1.0f / (float)tan(fov * M_PI / 360.0f)) / aspect, 0.0f, 0.0f, 0.0f,
; 298  : 		0.0f, 1.0f / (float)tan(fov * M_PI / 360.0f), 0.0f, 0.0f,
; 299  : 		0.0f, 0.0f, f * oneOverDepth, -f * n * oneOverDepth,
; 300  : 		0.0f, 0.0f, 1.0f, 0.0f
; 301  : 	};
; 302  : 
; 303  : 	return Matrix(matData);
; 304  : }
; 305  : 
; 306  : Plane::Plane(Vector pos, Vector normal)
; 307  : 	: pos(pos), normal(normal)
; 308  : {
; 309  : 
; 310  : }
; 311  : 
; 312  : Ray::Ray(Vector pos, Vector dir)
; 313  : 	: pos(pos), dir(dir)
; 314  : {
; 315  : 
; 316  : }
; 317  : 
; 318  : Vector Ray::trace(float t)
; 319  : {
; 320  : 	return pos + dir * t;
; 321  : }
; 322  : 
; 323  : Triangle::Triangle(Vector vec1, Vector vec2, Vector vec3)
; 324  : 	: vec1(vec1), vec2(vec2), vec3(vec3)
; 325  : {
; 326  : 
; 327  : }
; 328  : 
; 329  : Vector Triangle::normal()
; 330  : {
; 331  : 	return (vec2 - vec1) & (vec3 - vec1);
; 332  : }
; 333  : 
; 334  : Quad::Quad(Vector vec1, Vector vec2, Vector vec3, Vector vec4)
; 335  : 	: vec1(vec1), vec2(vec2), vec3(vec3), vec4(vec4)
; 336  : {
; 337  : 
; 338  : }
; 339  : 
; 340  : Vector Quad::normal()
; 341  : {
; 342  : 	return (vec2 - vec1) & (vec3 - vec1);
; 343  : }
; 344  : 
; 345  : Line::Line(Vector vec1, Vector vec2)
; 346  : 	: vec1(vec1), vec2(vec2)
; 347  : {
; 348  : 
; 349  : }
; 350  : 
; 351  : Vector Line::getV() const
; 352  : {
; 353  : 	return vec2 - vec1;
; 354  : }
; 355  : 
; 356  : Vector Line::trace(float t)
; 357  : {
; 358  : 	return getV() * t + vec1;
; 359  : }
; 360  : 
; 361  : AxisAlignedFace::AxisAlignedFace(Vector pos, float width, float height)
; 362  : 	: pos(pos), width(width), height(height)
; 363  : {
; 364  : 
; 365  : }
; 366  : 
; 367  : AxisAlignedXY::AxisAlignedXY(Vector pos, float width, float height)
; 368  : 	: AxisAlignedFace(pos, width, height)
; 369  : {
; 370  : 
; 371  : }
; 372  : 
; 373  : Vector AxisAlignedXY::getNormal()
; 374  : {
; 375  : 	return Vector(0.0f, 0.0f, 1.0f);
; 376  : }
; 377  : 
; 378  : bool AxisAlignedXY::inside(Vector vec)
; 379  : {
; 380  : 	return vec.x >= pos.x & vec.x <= pos.x + width & vec.y >= pos.y & vec.y <= pos.y + height;
; 381  : }
; 382  : 
; 383  : AxisAlignedXZ::AxisAlignedXZ(Vector pos, float width, float height)
; 384  : 	: AxisAlignedFace(pos, width, height)
; 385  : {
; 386  : 
; 387  : }
; 388  : 
; 389  : Vector AxisAlignedXZ::getNormal()
; 390  : {
; 391  : 	return Vector(0.0f, 1.0f, 0.0f);
; 392  : }
; 393  : 
; 394  : bool AxisAlignedXZ::inside(Vector vec)
; 395  : {
; 396  : 	return vec.x >= pos.x & vec.x <= pos.x + width & vec.z >= pos.z & vec.z <= pos.z + height;
; 397  : }
; 398  : 
; 399  : AxisAlignedYZ::AxisAlignedYZ(Vector pos, float width, float height)
; 400  : 	: AxisAlignedFace(pos, width, height)
; 401  : {
; 402  : 
; 403  : }
; 404  : 
; 405  : Vector AxisAlignedYZ::getNormal()
; 406  : {
; 407  : 	return Vector(1.0f, 0.0f, 0.0f);
; 408  : }
; 409  : 
; 410  : bool AxisAlignedYZ::inside(Vector vec)
; 411  : {
; 412  : 	return vec.y >= pos.y & vec.y <= pos.y + width & vec.z >= pos.z & vec.z <= pos.z + height;
; 413  : }
; 414  : 
; 415  : AxisAlignedCube::AxisAlignedCube(Vector pos, Vector size)
; 416  : 	: pos(pos), size(size)
; 417  : {
; 418  : 
; 419  : }
; 420  : 
; 421  : AxisAlignedCube AxisAlignedCube::expand(float f)
; 422  : {
; 423  : 	Vector ex(f, f, f);
; 424  : 	return AxisAlignedCube(pos - ex, size + ex * 2.0f);
; 425  : }
; 426  : 
; 427  : AxisAlignedYZ AxisAlignedCube::getLeft()
; 428  : {
; 429  : 	return AxisAlignedYZ(pos, size.z, size.y);
; 430  : }
; 431  : 
; 432  : AxisAlignedYZ AxisAlignedCube::getRight()
; 433  : {
; 434  : 	return AxisAlignedYZ(Vector(pos.x + size.x, pos.y, pos.z), size.z, size.y);
; 435  : }
; 436  : 
; 437  : AxisAlignedXZ AxisAlignedCube::getBottom()
; 438  : {
; 439  : 	return AxisAlignedXZ(pos, size.x, size.z);
; 440  : }
; 441  : 
; 442  : AxisAlignedXZ AxisAlignedCube::getTop()
; 443  : {
; 444  : 	return AxisAlignedXZ(Vector(pos.x, pos.y + size.y, pos.z), size.x, size.z);
; 445  : }
; 446  : 
; 447  : AxisAlignedXY AxisAlignedCube::getFront()
; 448  : {
; 449  : 	return AxisAlignedXY(pos, size.x, size.y);
; 450  : }
; 451  : 
; 452  : AxisAlignedXY AxisAlignedCube::getBack()
; 453  : {
; 454  : 	return AxisAlignedXY(Vector(pos.x, pos.y, pos.z + size.z), size.x, size.y);
; 455  : }
; 456  : 
; 457  : bool AxisAlignedCube::inside(Vector vec)
; 458  : {
; 459  : 	return vec.x >= pos.x & vec.x <= pos.x + size.x & vec.y >= pos.y & vec.y <= pos.y + size.y & vec.z >= pos.z & vec.z <= pos.z + size.z;

  005c2	41 0f 2f f6	 comiss	 xmm6, xmm14
  005c6	0f 93 c1	 setae	 cl
  005c9	41 0f 2f ff	 comiss	 xmm7, xmm15
  005cd	0f 93 c0	 setae	 al
  005d0	22 c8		 and	 cl, al
  005d2	44 0f 2f c3	 comiss	 xmm8, xmm3
  005d6	0f 93 c0	 setae	 al
  005d9	22 c8		 and	 cl, al
  005db	44 0f 2f ce	 comiss	 xmm9, xmm6
  005df	0f 93 c0	 setae	 al
  005e2	22 c8		 and	 cl, al
  005e4	41 0f 2f e8	 comiss	 xmm5, xmm8
  005e8	0f 93 c0	 setae	 al
  005eb	22 c8		 and	 cl, al
  005ed	0f 2f e7	 comiss	 xmm4, xmm7
  005f0	0f 93 c0	 setae	 al
  005f3	84 c8		 test	 cl, al
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 78   : 			if(boundingBox.inside(back) || boundingBox.inside(front))

  005f5	75 63		 jne	 SHORT $LN29@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  005f7	f3 42 0f 10 04
	0f		 movss	 xmm0, DWORD PTR [rdi+r9]
  005fd	f3 0f 11 85 a8
	00 00 00	 movss	 DWORD PTR $T11[rbp-256], xmm0
  00605	f3 42 0f 10 54
	0f 04		 movss	 xmm2, DWORD PTR [rdi+r9+4]
  0060c	f3 0f 11 95 ac
	00 00 00	 movss	 DWORD PTR $T11[rbp-252], xmm2
  00614	f3 42 0f 10 4c
	0f 08		 movss	 xmm1, DWORD PTR [rdi+r9+8]
  0061b	f3 0f 11 8d b0
	00 00 00	 movss	 DWORD PTR $T11[rbp-248], xmm1

; 64   : }
; 65   : 
; 66   : Vector Vector::operator/(const Vector &vec) const
; 67   : {
; 68   : 	return Vector(x / vec.x, y / vec.y, z / vec.z);
; 69   : }
; 70   : 
; 71   : Vector Vector::operator/(float f) const
; 72   : {
; 73   : 	return Vector(x / f, y / f, z / f);
; 74   : }
; 75   : 
; 76   : Vector Vector::operator&(const Vector &vec) const
; 77   : {
; 78   : 	return Vector(y * vec.z - z * vec.y, z * vec.x - x * vec.z, x * vec.y - y * vec.x);
; 79   : }
; 80   : 
; 81   : float Vector::operator|(const Vector &vec) const
; 82   : {
; 83   : 	return x * vec.x + y * vec.y + z * vec.z;
; 84   : }
; 85   : 
; 86   : Vector Vector::operator-() const
; 87   : {
; 88   : 	return Vector(-x, -y, -z);
; 89   : }
; 90   : 
; 91   : float Vector::operator~() const
; 92   : {
; 93   : 	return sqrtf(x * x + y * y + z * z);
; 94   : }
; 95   : 
; 96   : Vector Vector::operator+=(const Vector &vec)
; 97   : {
; 98   : 	return Vector(x += vec.x, y += vec.y, z += vec.z);
; 99   : }
; 100  : 
; 101  : Vector Vector::operator-=(const Vector &vec)
; 102  : {
; 103  : 	return Vector(x -= vec.x, y -= vec.y, z -= vec.z);
; 104  : }
; 105  : 
; 106  : Vector Vector::operator*=(const Vector &vec)
; 107  : {
; 108  : 	return Vector(x *= vec.x, y *= vec.y, z *= vec.z);
; 109  : }
; 110  : 
; 111  : Vector Vector::operator*=(const Matrix &mat)
; 112  : {
; 113  : 	//return Vector(x * vec.x, y * vec.y, z * vec.z, w * vec.w);
; 114  : 	return *this;
; 115  : }
; 116  : 
; 117  : Vector Vector::operator*=(float f)
; 118  : {
; 119  : 	return Vector(x *= f, y *= f, z *= f);
; 120  : }
; 121  : 
; 122  : Vector Vector::operator/=(const Vector &vec)
; 123  : {
; 124  : 	return Vector(x /= vec.x, y /= vec.y, z /= vec.z);
; 125  : }
; 126  : 
; 127  : Vector Vector::operator/=(float f)
; 128  : {
; 129  : 	return Vector(x /= f, y /= f, z /= f);
; 130  : }
; 131  : 
; 132  : 
; 133  : 
; 134  : int Matrix::index(int x, int y) const
; 135  : {
; 136  : 	return x + (y << 2);
; 137  : }
; 138  : 
; 139  : Matrix::Matrix()
; 140  : {
; 141  : 	for(int i = 0; i < 16; i++)
; 142  : 	{
; 143  : 		data[i] = 0.0f;
; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;
; 224  : 	result[5] = 1.0f;
; 225  : 	result[10] = 1.0f;
; 226  : 	result[15] = 1.0f;
; 227  : 
; 228  : 	return result;
; 229  : }
; 230  : 
; 231  : Matrix Matrix::scale(float x, float y, float z)
; 232  : {
; 233  : 	Matrix result;
; 234  : 	result[0] = x;
; 235  : 	result[5] = y;
; 236  : 	result[10] = z;
; 237  : 	result[15] = 1.0f;
; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;
; 246  : 	result[7] = y;
; 247  : 	result[11] = z;
; 248  : 
; 249  : 	return result;
; 250  : }
; 251  : 
; 252  : Matrix Matrix::ortho2D(float left, float bottom, float right, float top)
; 253  : {
; 254  : 	float matData[] = {
; 255  : 		2.0f / (right - left), 0.0f, 0.0f, (right + left) / (left - right),
; 256  : 		0.0f, 2.0f / (top - bottom), 0.0f, (top + bottom) / (bottom - top),
; 257  : 		0.0f, 0.0f, 1.0f, 0.0f,
; 258  : 		0.0f, 0.0f, 0.0f, 1.0f
; 259  : 	};
; 260  : 
; 261  : 	return Matrix(matData);
; 262  : }
; 263  : 
; 264  : Matrix Matrix::ortho(float left, float bottom, float n, float right, float top, float f)
; 265  : {
; 266  : 	float matData[] = {
; 267  : 		2.0f / (right - left), 0.0f, 0.0f, (right + left) / (left - right),
; 268  : 		0.0f, 2.0f / (top - bottom), 0.0f, (top + bottom) / (bottom - top),
; 269  : 		0.0f, 0.0f, 2.0f / (f - n), (f + n) / (n - f),
; 270  : 		0.0f, 0.0f, 0.0f, 1.0f
; 271  : 	};
; 272  : 
; 273  : 	return Matrix(matData);
; 274  : }
; 275  : 
; 276  : Matrix Matrix::rotate(float degrees, float x, float y, float z)
; 277  : {
; 278  : 	float s = (float)sin(degrees * M_PI / 180.0f);
; 279  : 	float c = (float)cos(degrees * M_PI / 180.0f);
; 280  : 
; 281  : 	float matData[] = {
; 282  : 		x + (y + z) * c, z * -s, y * s, 0.0f,
; 283  : 		z * s, y + (x + z) * c, x * -s, 0.0f,
; 284  : 		y * -s, x * s, z + (x + y) * c, 0.0f,
; 285  : 		0.0f, 0.0f, 0.0f, 1.0f
; 286  : 	};
; 287  : 
; 288  : 	return Matrix(matData);
; 289  : }
; 290  : 
; 291  : Matrix Matrix::perspective(float fov, float aspect, float n, float f)
; 292  : {
; 293  : 	float frustumDepth = f - n;
; 294  :     float oneOverDepth = 1 / frustumDepth;
; 295  : 
; 296  : 	float matData[] = {
; 297  : 		(1.0f / (float)tan(fov * M_PI / 360.0f)) / aspect, 0.0f, 0.0f, 0.0f,
; 298  : 		0.0f, 1.0f / (float)tan(fov * M_PI / 360.0f), 0.0f, 0.0f,
; 299  : 		0.0f, 0.0f, f * oneOverDepth, -f * n * oneOverDepth,
; 300  : 		0.0f, 0.0f, 1.0f, 0.0f
; 301  : 	};
; 302  : 
; 303  : 	return Matrix(matData);
; 304  : }
; 305  : 
; 306  : Plane::Plane(Vector pos, Vector normal)
; 307  : 	: pos(pos), normal(normal)
; 308  : {
; 309  : 
; 310  : }
; 311  : 
; 312  : Ray::Ray(Vector pos, Vector dir)
; 313  : 	: pos(pos), dir(dir)
; 314  : {
; 315  : 
; 316  : }
; 317  : 
; 318  : Vector Ray::trace(float t)
; 319  : {
; 320  : 	return pos + dir * t;
; 321  : }
; 322  : 
; 323  : Triangle::Triangle(Vector vec1, Vector vec2, Vector vec3)
; 324  : 	: vec1(vec1), vec2(vec2), vec3(vec3)
; 325  : {
; 326  : 
; 327  : }
; 328  : 
; 329  : Vector Triangle::normal()
; 330  : {
; 331  : 	return (vec2 - vec1) & (vec3 - vec1);
; 332  : }
; 333  : 
; 334  : Quad::Quad(Vector vec1, Vector vec2, Vector vec3, Vector vec4)
; 335  : 	: vec1(vec1), vec2(vec2), vec3(vec3), vec4(vec4)
; 336  : {
; 337  : 
; 338  : }
; 339  : 
; 340  : Vector Quad::normal()
; 341  : {
; 342  : 	return (vec2 - vec1) & (vec3 - vec1);
; 343  : }
; 344  : 
; 345  : Line::Line(Vector vec1, Vector vec2)
; 346  : 	: vec1(vec1), vec2(vec2)
; 347  : {
; 348  : 
; 349  : }
; 350  : 
; 351  : Vector Line::getV() const
; 352  : {
; 353  : 	return vec2 - vec1;
; 354  : }
; 355  : 
; 356  : Vector Line::trace(float t)
; 357  : {
; 358  : 	return getV() * t + vec1;
; 359  : }
; 360  : 
; 361  : AxisAlignedFace::AxisAlignedFace(Vector pos, float width, float height)
; 362  : 	: pos(pos), width(width), height(height)
; 363  : {
; 364  : 
; 365  : }
; 366  : 
; 367  : AxisAlignedXY::AxisAlignedXY(Vector pos, float width, float height)
; 368  : 	: AxisAlignedFace(pos, width, height)
; 369  : {
; 370  : 
; 371  : }
; 372  : 
; 373  : Vector AxisAlignedXY::getNormal()
; 374  : {
; 375  : 	return Vector(0.0f, 0.0f, 1.0f);
; 376  : }
; 377  : 
; 378  : bool AxisAlignedXY::inside(Vector vec)
; 379  : {
; 380  : 	return vec.x >= pos.x & vec.x <= pos.x + width & vec.y >= pos.y & vec.y <= pos.y + height;
; 381  : }
; 382  : 
; 383  : AxisAlignedXZ::AxisAlignedXZ(Vector pos, float width, float height)
; 384  : 	: AxisAlignedFace(pos, width, height)
; 385  : {
; 386  : 
; 387  : }
; 388  : 
; 389  : Vector AxisAlignedXZ::getNormal()
; 390  : {
; 391  : 	return Vector(0.0f, 1.0f, 0.0f);
; 392  : }
; 393  : 
; 394  : bool AxisAlignedXZ::inside(Vector vec)
; 395  : {
; 396  : 	return vec.x >= pos.x & vec.x <= pos.x + width & vec.z >= pos.z & vec.z <= pos.z + height;
; 397  : }
; 398  : 
; 399  : AxisAlignedYZ::AxisAlignedYZ(Vector pos, float width, float height)
; 400  : 	: AxisAlignedFace(pos, width, height)
; 401  : {
; 402  : 
; 403  : }
; 404  : 
; 405  : Vector AxisAlignedYZ::getNormal()
; 406  : {
; 407  : 	return Vector(1.0f, 0.0f, 0.0f);
; 408  : }
; 409  : 
; 410  : bool AxisAlignedYZ::inside(Vector vec)
; 411  : {
; 412  : 	return vec.y >= pos.y & vec.y <= pos.y + width & vec.z >= pos.z & vec.z <= pos.z + height;
; 413  : }
; 414  : 
; 415  : AxisAlignedCube::AxisAlignedCube(Vector pos, Vector size)
; 416  : 	: pos(pos), size(size)
; 417  : {
; 418  : 
; 419  : }
; 420  : 
; 421  : AxisAlignedCube AxisAlignedCube::expand(float f)
; 422  : {
; 423  : 	Vector ex(f, f, f);
; 424  : 	return AxisAlignedCube(pos - ex, size + ex * 2.0f);
; 425  : }
; 426  : 
; 427  : AxisAlignedYZ AxisAlignedCube::getLeft()
; 428  : {
; 429  : 	return AxisAlignedYZ(pos, size.z, size.y);
; 430  : }
; 431  : 
; 432  : AxisAlignedYZ AxisAlignedCube::getRight()
; 433  : {
; 434  : 	return AxisAlignedYZ(Vector(pos.x + size.x, pos.y, pos.z), size.z, size.y);
; 435  : }
; 436  : 
; 437  : AxisAlignedXZ AxisAlignedCube::getBottom()
; 438  : {
; 439  : 	return AxisAlignedXZ(pos, size.x, size.z);
; 440  : }
; 441  : 
; 442  : AxisAlignedXZ AxisAlignedCube::getTop()
; 443  : {
; 444  : 	return AxisAlignedXZ(Vector(pos.x, pos.y + size.y, pos.z), size.x, size.z);
; 445  : }
; 446  : 
; 447  : AxisAlignedXY AxisAlignedCube::getFront()
; 448  : {
; 449  : 	return AxisAlignedXY(pos, size.x, size.y);
; 450  : }
; 451  : 
; 452  : AxisAlignedXY AxisAlignedCube::getBack()
; 453  : {
; 454  : 	return AxisAlignedXY(Vector(pos.x, pos.y, pos.z + size.z), size.x, size.y);
; 455  : }
; 456  : 
; 457  : bool AxisAlignedCube::inside(Vector vec)
; 458  : {
; 459  : 	return vec.x >= pos.x & vec.x <= pos.x + size.x & vec.y >= pos.y & vec.y <= pos.y + size.y & vec.z >= pos.z & vec.z <= pos.z + size.z;

  00623	41 0f 2f c6	 comiss	 xmm0, xmm14
  00627	0f 93 c1	 setae	 cl
  0062a	41 0f 2f d7	 comiss	 xmm2, xmm15
  0062e	0f 93 c0	 setae	 al
  00631	22 c8		 and	 cl, al
  00633	0f 2f cb	 comiss	 xmm1, xmm3
  00636	0f 93 c0	 setae	 al
  00639	22 c8		 and	 cl, al
  0063b	44 0f 2f c8	 comiss	 xmm9, xmm0
  0063f	0f 93 c0	 setae	 al
  00642	22 c8		 and	 cl, al
  00644	0f 2f e9	 comiss	 xmm5, xmm1
  00647	0f 93 c0	 setae	 al
  0064a	22 c8		 and	 cl, al
  0064c	0f 2f e2	 comiss	 xmm4, xmm2
  0064f	0f 93 c0	 setae	 al
  00652	84 c8		 test	 cl, al
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 78   : 			if(boundingBox.inside(back) || boundingBox.inside(front))

  00654	0f 84 40 02 00
	00		 je	 $LN32@tick
$LN29@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  0065a	f3 46 0f 10 0c
	0f		 movss	 xmm9, DWORD PTR [rdi+r9]
  00660	f3 44 0f 11 4d
	68		 movss	 DWORD PTR $T8[rbp-256], xmm9
  00666	f3 46 0f 10 54
	0f 04		 movss	 xmm10, DWORD PTR [rdi+r9+4]
  0066d	f3 44 0f 11 55
	6c		 movss	 DWORD PTR $T8[rbp-252], xmm10
  00673	f3 46 0f 10 5c
	0f 08		 movss	 xmm11, DWORD PTR [rdi+r9+8]
  0067a	f3 44 0f 11 5d
	70		 movss	 DWORD PTR $T8[rbp-248], xmm11
  00680	f3 46 0f 10 64
	0f 0c		 movss	 xmm12, DWORD PTR [rdi+r9+12]
  00687	f3 44 0f 11 65
	74		 movss	 DWORD PTR $T8[rbp-244], xmm12
  0068d	f3 0f 11 75 78	 movss	 DWORD PTR $T9[rbp-256], xmm6
  00692	f3 0f 11 7d 7c	 movss	 DWORD PTR $T9[rbp-252], xmm7
  00697	f3 44 0f 11 85
	80 00 00 00	 movss	 DWORD PTR $T9[rbp-248], xmm8
  006a0	f3 46 0f 10 6c
	0f fc		 movss	 xmm13, DWORD PTR [rdi+r9-4]
  006a7	f3 44 0f 11 ad
	84 00 00 00	 movss	 DWORD PTR $T9[rbp-244], xmm13
  006b0	f3 0f 11 75 18	 movss	 DWORD PTR $T6[rbp-256], xmm6
  006b5	f3 0f 11 7d 1c	 movss	 DWORD PTR $T6[rbp-252], xmm7
  006ba	f3 44 0f 11 45
	20		 movss	 DWORD PTR $T6[rbp-248], xmm8
  006c0	f3 44 0f 11 6d
	24		 movss	 DWORD PTR $T6[rbp-244], xmm13
  006c6	f3 44 0f 11 4d
	28		 movss	 DWORD PTR $T6[rbp-240], xmm9
  006cc	f3 44 0f 11 55
	2c		 movss	 DWORD PTR $T6[rbp-236], xmm10
  006d2	f3 44 0f 11 5d
	30		 movss	 DWORD PTR $T6[rbp-232], xmm11
  006d8	f3 44 0f 11 65
	34		 movss	 DWORD PTR $T6[rbp-228], xmm12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  006de	48 8d 45 18	 lea	 rax, QWORD PTR $T6[rbp-256]
  006e2	48 3b c2	 cmp	 rax, rdx
  006e5	0f 83 e3 00 00
	00		 jae	 $LN213@tick
  006eb	48 8d 45 18	 lea	 rax, QWORD PTR $T6[rbp-256]
  006ef	4c 3b d0	 cmp	 r10, rax
  006f2	0f 87 d6 00 00
	00		 ja	 $LN213@tick

; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  006f8	48 8d 5d 18	 lea	 rbx, QWORD PTR $T6[rbp-256]
  006fc	49 2b da	 sub	 rbx, r10

; 840  : 			if (this->_Mylast == this->_Myend)

  006ff	49 3b d0	 cmp	 rdx, r8
  00702	0f 85 83 00 00
	00		 jne	 $LN225@tick

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00708	49 8b c0	 mov	 rax, r8
  0070b	48 2b c2	 sub	 rax, rdx
  0070e	48 c1 f8 05	 sar	 rax, 5

; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)

  00712	48 83 f8 01	 cmp	 rax, 1
  00716	73 73		 jae	 SHORT $LN225@tick

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00718	49 2b d2	 sub	 rdx, r10
  0071b	48 c1 fa 05	 sar	 rdx, 5

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0071f	49 8b c3	 mov	 rax, r11
  00722	48 2b c2	 sub	 rax, rdx
  00725	48 83 f8 01	 cmp	 rax, 1
  00729	0f 82 e8 01 00
	00		 jb	 $LN668@tick

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  0072f	48 ff c2	 inc	 rdx

; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);

  00732	4d 2b c2	 sub	 r8, r10
  00735	49 c1 f8 05	 sar	 r8, 5

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00739	49 8b c8	 mov	 rcx, r8
  0073c	48 d1 e9	 shr	 rcx, 1
  0073f	49 8b c3	 mov	 rax, r11
  00742	48 2b c1	 sub	 rax, rcx
  00745	49 3b c0	 cmp	 rax, r8
  00748	73 05		 jae	 SHORT $LN250@tick
  0074a	45 33 c0	 xor	 r8d, r8d
  0074d	eb 03		 jmp	 SHORT $LN251@tick
$LN250@tick:
  0074f	4c 03 c1	 add	 r8, rcx
$LN251@tick:

; 1489 : 		if (_Capacity < _Count)

  00752	4c 3b c2	 cmp	 r8, rdx
  00755	4c 0f 42 c2	 cmovb	 r8, rdx

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00759	49 8b d0	 mov	 rdx, r8
  0075c	48 8d 4d 80	 lea	 rcx, QWORD PTR lines$[rbp-256]
  00760	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reallocate
  00765	4c 8b 45 90	 mov	 r8, QWORD PTR lines$[rbp-240]
  00769	48 8b 55 88	 mov	 rdx, QWORD PTR lines$[rbp-248]
  0076d	4c 8b 55 80	 mov	 r10, QWORD PTR lines$[rbp-256]
  00771	f3 0f 10 5c 24
	78		 movss	 xmm3, DWORD PTR boundingBox$1$[rsp]
  00777	f3 0f 10 65 98	 movss	 xmm4, DWORD PTR tv3591[rbp-256]
  0077c	f3 0f 10 6d a4	 movss	 xmm5, DWORD PTR tv3590[rbp-256]
  00781	49 bb ff ff ff
	ff ff ff ff 07	 mov	 r11, 576460752303423487	; 07ffffffffffffffH
$LN225@tick:

; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

  0078b	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H
  0078f	49 03 da	 add	 rbx, r10
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00792	48 85 d2	 test	 rdx, rdx
  00795	0f 84 f1 00 00
	00		 je	 $LN349@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  0079b	8b 03		 mov	 eax, DWORD PTR [rbx]
  0079d	89 02		 mov	 DWORD PTR [rdx], eax
  0079f	8b 43 04	 mov	 eax, DWORD PTR [rbx+4]
  007a2	89 42 04	 mov	 DWORD PTR [rdx+4], eax
  007a5	8b 43 08	 mov	 eax, DWORD PTR [rbx+8]
  007a8	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  007ab	8b 43 0c	 mov	 eax, DWORD PTR [rbx+12]
  007ae	89 42 0c	 mov	 DWORD PTR [rdx+12], eax
  007b1	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  007b4	89 42 10	 mov	 DWORD PTR [rdx+16], eax
  007b7	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  007ba	89 42 14	 mov	 DWORD PTR [rdx+20], eax
  007bd	8b 43 18	 mov	 eax, DWORD PTR [rbx+24]
  007c0	89 42 18	 mov	 DWORD PTR [rdx+24], eax
  007c3	8b 43 1c	 mov	 eax, DWORD PTR [rbx+28]
  007c6	89 42 1c	 mov	 DWORD PTR [rdx+28], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 847  : 		else

  007c9	e9 be 00 00 00	 jmp	 $LN349@tick
$LN213@tick:

; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)

  007ce	49 3b d0	 cmp	 rdx, r8
  007d1	0f 85 83 00 00
	00		 jne	 $LN294@tick

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  007d7	49 8b c0	 mov	 rax, r8
  007da	48 2b c2	 sub	 rax, rdx
  007dd	48 c1 f8 05	 sar	 rax, 5

; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)

  007e1	48 83 f8 01	 cmp	 rax, 1
  007e5	73 73		 jae	 SHORT $LN294@tick

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  007e7	49 2b d2	 sub	 rdx, r10
  007ea	48 c1 fa 05	 sar	 rdx, 5

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  007ee	49 8b c3	 mov	 rax, r11
  007f1	48 2b c2	 sub	 rax, rdx
  007f4	48 83 f8 01	 cmp	 rax, 1
  007f8	0f 82 26 01 00
	00		 jb	 $LN669@tick

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  007fe	48 ff c2	 inc	 rdx

; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);

  00801	4d 2b c2	 sub	 r8, r10
  00804	49 c1 f8 05	 sar	 r8, 5

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00808	49 8b c8	 mov	 rcx, r8
  0080b	48 d1 e9	 shr	 rcx, 1
  0080e	49 8b c3	 mov	 rax, r11
  00811	48 2b c1	 sub	 rax, rcx
  00814	49 3b c0	 cmp	 rax, r8
  00817	73 05		 jae	 SHORT $LN319@tick
  00819	45 33 c0	 xor	 r8d, r8d
  0081c	eb 03		 jmp	 SHORT $LN320@tick
$LN319@tick:
  0081e	4c 03 c1	 add	 r8, rcx
$LN320@tick:

; 1489 : 		if (_Capacity < _Count)

  00821	4c 3b c2	 cmp	 r8, rdx
  00824	4c 0f 42 c2	 cmovb	 r8, rdx

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00828	49 8b d0	 mov	 rdx, r8
  0082b	48 8d 4d 80	 lea	 rcx, QWORD PTR lines$[rbp-256]
  0082f	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reallocate
  00834	4c 8b 45 90	 mov	 r8, QWORD PTR lines$[rbp-240]
  00838	48 8b 55 88	 mov	 rdx, QWORD PTR lines$[rbp-248]
  0083c	4c 8b 55 80	 mov	 r10, QWORD PTR lines$[rbp-256]
  00840	f3 0f 10 5c 24
	78		 movss	 xmm3, DWORD PTR boundingBox$1$[rsp]
  00846	f3 0f 10 65 98	 movss	 xmm4, DWORD PTR tv3591[rbp-256]
  0084b	f3 0f 10 6d a4	 movss	 xmm5, DWORD PTR tv3590[rbp-256]
  00850	49 bb ff ff ff
	ff ff ff ff 07	 mov	 r11, 576460752303423487	; 07ffffffffffffffH
$LN294@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0085a	48 85 d2	 test	 rdx, rdx
  0085d	74 2d		 je	 SHORT $LN349@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  0085f	f3 0f 11 32	 movss	 DWORD PTR [rdx], xmm6
  00863	f3 0f 11 7a 04	 movss	 DWORD PTR [rdx+4], xmm7
  00868	f3 44 0f 11 42
	08		 movss	 DWORD PTR [rdx+8], xmm8
  0086e	f3 44 0f 11 6a
	0c		 movss	 DWORD PTR [rdx+12], xmm13
  00874	f3 44 0f 11 4a
	10		 movss	 DWORD PTR [rdx+16], xmm9
  0087a	f3 44 0f 11 52
	14		 movss	 DWORD PTR [rdx+20], xmm10
  00880	f3 44 0f 11 5a
	18		 movss	 DWORD PTR [rdx+24], xmm11
  00886	f3 44 0f 11 62
	1c		 movss	 DWORD PTR [rdx+28], xmm12
$LN349@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 854  : 			++this->_Mylast;

  0088c	48 83 c2 20	 add	 rdx, 32			; 00000020H
  00890	f3 44 0f 10 4d
	a0		 movss	 xmm9, DWORD PTR tv3589[rbp-256]
  00896	48 89 55 88	 mov	 QWORD PTR lines$[rbp-248], rdx
$LN32@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 74   : 		for(int i = 1; i <= cave->length; i++)

  0089a	41 ff c7	 inc	 r15d
  0089d	48 83 c7 10	 add	 rdi, 16
  008a1	45 3b 7d 0c	 cmp	 r15d, DWORD PTR [r13+12]
  008a5	0f 8e e5 fc ff
	ff		 jle	 $LL33@tick
  008ab	48 8b 5d 10	 mov	 rbx, QWORD PTR caves$1$[rbp-256]
  008af	8b 7d 9c	 mov	 edi, DWORD PTR i$1$[rbp-256]
$LN31@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  008b2	4d 85 f6	 test	 r14, r14
  008b5	74 42		 je	 SHORT $LN35@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  008b7	f0 41 ff 4e 08	 lock dec DWORD PTR [r14+8]
  008bc	75 18		 jne	 SHORT $LN683@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  008be	49 8b 06	 mov	 rax, QWORD PTR [r14]
  008c1	49 8b ce	 mov	 rcx, r14
  008c4	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  008c6	f0 41 ff 4e 0c	 lock dec DWORD PTR [r14+12]
  008cb	75 09		 jne	 SHORT $LN683@tick

; 128  : 			_Delete_this();

  008cd	49 8b 06	 mov	 rax, QWORD PTR [r14]
  008d0	49 8b ce	 mov	 rcx, r14
  008d3	ff 50 08	 call	 QWORD PTR [rax+8]
$LN683@tick:
  008d6	f3 0f 10 5d f0	 movss	 xmm3, DWORD PTR boundingBox$[rbp-248]
  008db	4c 8b 55 80	 mov	 r10, QWORD PTR lines$[rbp-256]
  008df	48 8b 55 88	 mov	 rdx, QWORD PTR lines$[rbp-248]
  008e3	4c 8b 45 90	 mov	 r8, QWORD PTR lines$[rbp-240]
  008e7	f3 44 0f 10 75
	e8		 movss	 xmm14, DWORD PTR boundingBox$[rbp-256]
  008ed	f3 44 0f 10 7d
	ec		 movss	 xmm15, DWORD PTR boundingBox$[rbp-252]
  008f3	f3 0f 11 5c 24
	78		 movss	 DWORD PTR boundingBox$1$[rsp], xmm3
$LN35@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 71   : 	for(int i = 0; i < caves.size(); i++)

  008f9	ff c7		 inc	 edi
  008fb	89 7d 9c	 mov	 DWORD PTR i$1$[rbp-256], edi
  008fe	48 83 c3 10	 add	 rbx, 16
  00902	48 89 5d 10	 mov	 QWORD PTR caves$1$[rbp-256], rbx
  00906	48 63 c7	 movsxd	 rax, edi
  00909	48 3b 85 90 00
	00 00		 cmp	 rax, QWORD PTR tv3613[rbp-256]
  00910	73 1f		 jae	 SHORT $LN688@tick
  00912	e9 e2 fb ff ff	 jmp	 $LN693@tick
$LN668@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1667 : 		_Xlength_error("vector<T> too long");

  00917	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0091e	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00923	cc		 int	 3
$LN669@tick:
  00924	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0092b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00930	90		 npad	 1
$LN688@tick:
  00931	4c 8b b5 88 00
	00 00		 mov	 r14, QWORD PTR this$GSCopy$1$[rbp-256]
  00938	4c 8b 7d e0	 mov	 r15, QWORD PTR tv3615[rbp-256]
  0093c	4c 8b 6d 08	 mov	 r13, QWORD PTR $T5[rbp-256]
$LN687@tick:

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00940	49 2b d2	 sub	 rdx, r10
  00943	48 c1 fa 05	 sar	 rdx, 5
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 85   : 	const int amountOfLines = lines.size();

  00947	89 55 c8	 mov	 DWORD PTR amountOfLines$[rbp-256], edx

; 86   : 	if(amountOfLines > 0)

  0094a	85 d2		 test	 edx, edx
  0094c	7e 1b		 jle	 SHORT $LN28@tick

; 87   : 	{
; 88   : 		caveLinesBuffer.write(queue, 0, sizeof(geom::Line) * amountOfLines, &lines[0]);

  0094e	4c 63 ca	 movsxd	 r9, edx
  00951	49 c1 e1 05	 shl	 r9, 5
  00955	49 8d 8e 20 09
	00 00		 lea	 rcx, QWORD PTR [r14+2336]
  0095c	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  00961	49 8b d7	 mov	 rdx, r15
  00964	e8 00 00 00 00	 call	 ?write@Buffer@cl@@QEAA_NAEAVCommandQueue@2@_K1PEBX@Z ; cl::Buffer::write
$LN28@tick:

; 89   : 	}
; 90   : 
; 91   : 	queue.sync();

  00969	49 8b cf	 mov	 rcx, r15
  0096c	e8 00 00 00 00	 call	 ?sync@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::sync

; 92   : 
; 93   : 	const size_t local_ws[] = {1, 1, 1};

  00971	bb 01 00 00 00	 mov	 ebx, 1
  00976	48 89 9d 30 01
	00 00		 mov	 QWORD PTR local_ws$[rbp-256], rbx
  0097d	48 89 9d 38 01
	00 00		 mov	 QWORD PTR local_ws$[rbp-248], rbx
  00984	48 89 9d 40 01
	00 00		 mov	 QWORD PTR local_ws$[rbp-240], rbx

; 94   : 	const size_t global_ws[] = {16, 16, 16};

  0098b	48 c7 85 18 01
	00 00 10 00 00
	00		 mov	 QWORD PTR global_ws$[rbp-256], 16
  00996	48 c7 85 20 01
	00 00 10 00 00
	00		 mov	 QWORD PTR global_ws$[rbp-248], 16
  009a1	48 c7 85 28 01
	00 00 10 00 00
	00		 mov	 QWORD PTR global_ws$[rbp-240], 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  009ac	48 c7 85 d0 00
	00 00 0f 00 00
	00		 mov	 QWORD PTR $T12[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  009b7	48 c7 85 c8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR $T12[rbp-240], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  009c2	c6 85 b8 00 00
	00 00		 mov	 BYTE PTR $T12[rbp-256], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  009c9	44 8d 43 10	 lea	 r8d, QWORD PTR [rbx+16]
  009cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294957485
  009d4	48 8d 8d b8 00
	00 00		 lea	 rcx, QWORD PTR $T12[rbp-256]
  009db	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 96   : 	if(!chunkGenProgram.prepare("generateTerrain_1")) GlobalThread::stop = true;

  009e0	48 8d 95 b8 00
	00 00		 lea	 rdx, QWORD PTR $T12[rbp-256]
  009e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  009ee	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  009f3	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  009fa	84 c0		 test	 al, al
  009fc	0f 44 cb	 cmove	 ecx, ebx
  009ff	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00a05	4d 8d 86 68 08
	00 00		 lea	 r8, QWORD PTR [r14+2152]
  00a0c	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00a0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00a16	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 97   : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &blockBuffer)) GlobalThread::stop = true;

  00a1b	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00a22	84 c0		 test	 al, al
  00a24	0f 44 cb	 cmove	 ecx, ebx
  00a27	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop

; 98   : 	if(!chunkGenProgram.setArgument(sizeof(const int), &chunkX)) GlobalThread::stop = true;

  00a2d	4c 8d 44 24 70	 lea	 r8, QWORD PTR chunkX$[rsp]
  00a32	8d 53 03	 lea	 edx, QWORD PTR [rbx+3]
  00a35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00a3c	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  00a41	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00a48	84 c0		 test	 al, al
  00a4a	0f 44 cb	 cmove	 ecx, ebx
  00a4d	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop

; 99   : 	if(!chunkGenProgram.setArgument(sizeof(const int), &chunkY)) GlobalThread::stop = true;

  00a53	4c 8d 44 24 7c	 lea	 r8, QWORD PTR chunkY$[rsp]
  00a58	8d 53 03	 lea	 edx, QWORD PTR [rbx+3]
  00a5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00a62	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  00a67	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00a6e	84 c0		 test	 al, al
  00a70	0f 44 cb	 cmove	 ecx, ebx
  00a73	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop

; 100  : 	if(!chunkGenProgram.setArgument(sizeof(const int), &chunkZ)) GlobalThread::stop = true;

  00a79	4c 8d 44 24 74	 lea	 r8, QWORD PTR chunkZ$[rsp]
  00a7e	8d 53 03	 lea	 edx, QWORD PTR [rbx+3]
  00a81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00a88	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  00a8d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00a94	84 c0		 test	 al, al
  00a96	0f 44 cb	 cmove	 ecx, ebx
  00a99	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00a9f	4d 8d 86 80 08
	00 00		 lea	 r8, QWORD PTR [r14+2176]
  00aa6	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00aa9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00ab0	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 101  : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &minHeightNoiseBuffer)) GlobalThread::stop = true;

  00ab5	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00abc	84 c0		 test	 al, al
  00abe	0f 44 cb	 cmove	 ecx, ebx
  00ac1	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00ac7	4d 8d 86 98 08
	00 00		 lea	 r8, QWORD PTR [r14+2200]
  00ace	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00ad1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00ad8	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 102  : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &maxHeightNoiseBuffer)) GlobalThread::stop = true;

  00add	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00ae4	84 c0		 test	 al, al
  00ae6	0f 44 cb	 cmove	 ecx, ebx
  00ae9	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00aef	4d 8d 86 b0 08
	00 00		 lea	 r8, QWORD PTR [r14+2224]
  00af6	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00af9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00b00	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 103  : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &smoothnessNoiseBuffer)) GlobalThread::stop = true;

  00b05	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00b0c	84 c0		 test	 al, al
  00b0e	0f 44 cb	 cmove	 ecx, ebx
  00b11	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00b17	4d 8d 86 c8 08
	00 00		 lea	 r8, QWORD PTR [r14+2248]
  00b1e	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00b21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00b28	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 104  : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &solidNoiseBuffer)) GlobalThread::stop = true;

  00b2d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00b34	84 c0		 test	 al, al
  00b36	0f 44 cb	 cmove	 ecx, ebx
  00b39	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00b3f	4d 8d 86 e0 08
	00 00		 lea	 r8, QWORD PTR [r14+2272]
  00b46	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00b49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00b50	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 105  : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &stoneNoiseBuffer)) GlobalThread::stop = true;

  00b55	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00b5c	84 c0		 test	 al, al
  00b5e	0f 44 cb	 cmove	 ecx, ebx
  00b61	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00b67	4d 8d 86 f8 08
	00 00		 lea	 r8, QWORD PTR [r14+2296]
  00b6e	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00b71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00b78	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 106  : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &temperatureNoiseBuffer)) GlobalThread::stop = true;

  00b7d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00b84	84 c0		 test	 al, al
  00b86	0f 44 cb	 cmove	 ecx, ebx
  00b89	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00b8f	4d 8d 86 10 09
	00 00		 lea	 r8, QWORD PTR [r14+2320]
  00b96	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00b99	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00ba0	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 107  : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &humidityNoiseBuffer)) GlobalThread::stop = true;

  00ba5	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00bac	84 c0		 test	 al, al
  00bae	0f 44 cb	 cmove	 ecx, ebx
  00bb1	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00bb7	4d 8d 86 28 09
	00 00		 lea	 r8, QWORD PTR [r14+2344]
  00bbe	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  00bc1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00bc8	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 108  : 	if(!chunkGenProgram.setArgument(sizeof(cl_mem), &caveLinesBuffer)) GlobalThread::stop = true;

  00bcd	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00bd4	84 c0		 test	 al, al
  00bd6	0f 44 cb	 cmove	 ecx, ebx
  00bd9	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop

; 109  : 	if(!chunkGenProgram.setArgument(sizeof(const int), &amountOfLines)) GlobalThread::stop = true;

  00bdf	4c 8d 45 c8	 lea	 r8, QWORD PTR amountOfLines$[rbp-256]
  00be3	8d 53 03	 lea	 edx, QWORD PTR [rbx+3]
  00be6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00bed	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  00bf2	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00bf9	84 c0		 test	 al, al
  00bfb	0f 44 d3	 cmove	 edx, ebx
  00bfe	88 15 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dl ; GlobalThread::stop

; 110  : 	if(!chunkGenProgram.invoke(queue, 3, global_ws, local_ws)) GlobalThread::stop = true;

  00c04	48 8d 85 30 01
	00 00		 lea	 rax, QWORD PTR local_ws$[rbp-256]
  00c0b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c10	4c 8d 8d 18 01
	00 00		 lea	 r9, QWORD PTR global_ws$[rbp-256]
  00c17	44 8d 43 02	 lea	 r8d, QWORD PTR [rbx+2]
  00c1b	49 8b d7	 mov	 rdx, r15
  00c1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?chunkGenProgram@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::chunkGenProgram
  00c25	e8 00 00 00 00	 call	 ?invoke@Program@cl@@QEAA_NAEAVCommandQueue@2@IPEB_K1@Z ; cl::Program::invoke
  00c2a	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00c31	84 c0		 test	 al, al
  00c33	0f 44 cb	 cmove	 ecx, ebx
  00c36	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop

; 111  : 	queue.sync();

  00c3c	49 8b cf	 mov	 rcx, r15
  00c3f	e8 00 00 00 00	 call	 ?sync@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::sync

; 113  : 	if(!blockBuffer.read(queue, chunk->dataPtr())) GlobalThread::stop = true;

  00c44	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00c48	49 8b cc	 mov	 rcx, r12
  00c4b	ff 50 20	 call	 QWORD PTR [rax+32]
  00c4e	49 8d 8e 60 08
	00 00		 lea	 rcx, QWORD PTR [r14+2144]
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 335  : 	return read(queue, 0, size, data);

  00c55	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c5a	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00c5e	49 8b d7	 mov	 rdx, r15
  00c61	e8 00 00 00 00	 call	 ?read@Buffer@cl@@QEAA_NAEAVCommandQueue@2@_K1PEAX@Z ; cl::Buffer::read
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 113  : 	if(!blockBuffer.read(queue, chunk->dataPtr())) GlobalThread::stop = true;

  00c66	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00c6d	84 c0		 test	 al, al
  00c6f	0f 44 d3	 cmove	 edx, ebx
  00c72	88 15 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dl ; GlobalThread::stop

; 114  : 	queue.sync();

  00c78	49 8b cf	 mov	 rcx, r15
  00c7b	e8 00 00 00 00	 call	 ?sync@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::sync
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00c80	49 8d 4c 24 28	 lea	 rcx, QWORD PTR [r12+40]
  00c85	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00c8a	85 c0		 test	 eax, eax
  00c8c	74 07		 je	 SHORT $LN453@tick

; 33   : 		_Throw_C_error(_Res);

  00c8e	8b c8		 mov	 ecx, eax
  00c90	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN453@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 95   : 	renderUpdateNeeded = flag;

  00c95	66 41 c7 44 24
	08 01 01	 mov	 WORD PTR [r12+8], 257	; 00000101H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00c9d	49 8d 4c 24 28	 lea	 rcx, QWORD PTR [r12+40]
  00ca2	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00ca7	85 c0		 test	 eax, eax
  00ca9	74 07		 je	 SHORT $LN476@tick

; 33   : 		_Throw_C_error(_Res);

  00cab	8b c8		 mov	 ecx, eax
  00cad	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN476@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00cb2	33 db		 xor	 ebx, ebx
  00cb4	48 89 5d d0	 mov	 QWORD PTR $T3[rbp-256], rbx
  00cb8	48 89 5d d8	 mov	 QWORD PTR $T3[rbp-248], rbx

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00cbc	4d 85 ed	 test	 r13, r13
  00cbf	74 2d		 je	 SHORT $LN496@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00cc1	f0 41 ff 45 08	 lock inc DWORD PTR [r13+8]

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00cc6	48 8b 5d d8	 mov	 rbx, QWORD PTR $T3[rbp-248]
  00cca	48 85 db	 test	 rbx, rbx
  00ccd	74 1d		 je	 SHORT $LN691@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00ccf	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00cd3	75 17		 jne	 SHORT $LN691@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00cd5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00cd8	48 8b cb	 mov	 rcx, rbx
  00cdb	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00cdd	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00ce1	75 09		 jne	 SHORT $LN691@tick

; 128  : 			_Delete_this();

  00ce3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00ce6	48 8b cb	 mov	 rcx, rbx
  00ce9	ff 50 08	 call	 QWORD PTR [rax+8]
$LN691@tick:
  00cec	33 db		 xor	 ebx, ebx
$LN496@tick:

; 426  : 		_Rep = _Other_rep;

  00cee	4c 89 6d d8	 mov	 QWORD PTR $T3[rbp-248], r13

; 427  : 		_Ptr = _Other_ptr;

  00cf2	4c 89 65 d0	 mov	 QWORD PTR $T3[rbp-256], r12
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 189  : 	requestChunkDraw(chunk);

  00cf6	48 8d 4d d0	 lea	 rcx, QWORD PTR $T3[rbp-256]
  00cfa	e8 00 00 00 00	 call	 ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkDraw

; 190  : 		
; 191  : 	for(int i = -1; i <= 1; i++)

  00cff	44 8b ee	 mov	 r13d, esi
  00d02	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL11@tick:

; 192  : 	{
; 193  : 		for(int j = -1; j <= 1; j++)

  00d10	44 8b fe	 mov	 r15d, esi
$LL8@tick:

; 195  : 			for(int k = -1; k <= 1; k++)

  00d13	44 8b f6	 mov	 r14d, esi
  00d16	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@tick:

; 196  : 			{
; 197  : 				if(i | j | k)

  00d20	41 8b c6	 mov	 eax, r14d
  00d23	41 0b c7	 or	 eax, r15d
  00d26	41 0b c5	 or	 eax, r13d
  00d29	0f 84 55 01 00
	00		 je	 $LN4@tick

; 198  : 				{
; 199  : 					std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(i + chunk->pos.x, j + chunk->pos.y, k + chunk->pos.z);

  00d2f	41 8b 4c 24 20	 mov	 ecx, DWORD PTR [r12+32]
  00d34	41 03 ce	 add	 ecx, r14d
  00d37	45 8b 4c 24 1c	 mov	 r9d, DWORD PTR [r12+28]
  00d3c	45 03 cf	 add	 r9d, r15d
  00d3f	45 8b 44 24 18	 mov	 r8d, DWORD PTR [r12+24]
  00d44	45 03 c5	 add	 r8d, r13d
  00d47	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00d4b	48 8d 55 a8	 lea	 rdx, QWORD PTR c$1[rbp-256]
  00d4f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00d56	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  00d5b	90		 npad	 1

; 200  : 					if(!c->isEmpty() && c->isLoaded() && !c->isRenderUpdateNeeded())

  00d5c	48 8b 7d a8	 mov	 rdi, QWORD PTR c$1[rbp-256]
  00d60	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00d63	48 8b cf	 mov	 rcx, rdi
  00d66	ff 50 18	 call	 QWORD PTR [rax+24]
  00d69	84 c0		 test	 al, al
  00d6b	0f 85 de 00 00
	00		 jne	 $LN685@tick
  00d71	38 47 09	 cmp	 BYTE PTR [rdi+9], al
  00d74	0f 84 d5 00 00
	00		 je	 $LN685@tick
  00d7a	38 47 08	 cmp	 BYTE PTR [rdi+8], al
  00d7d	0f 85 cc 00 00
	00		 jne	 $LN685@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 95   : 	renderUpdateNeeded = flag;

  00d83	c6 47 08 01	 mov	 BYTE PTR [rdi+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00d87	48 89 5d b8	 mov	 QWORD PTR $T2[rbp-256], rbx
  00d8b	48 89 5d c0	 mov	 QWORD PTR $T2[rbp-248], rbx

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00d8f	48 8b 5d b0	 mov	 rbx, QWORD PTR c$1[rbp-248]
  00d93	48 85 db	 test	 rbx, rbx
  00d96	74 32		 je	 SHORT $LN550@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00d98	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00d9c	48 8b 5d c0	 mov	 rbx, QWORD PTR $T2[rbp-248]
  00da0	48 85 db	 test	 rbx, rbx
  00da3	74 1d		 je	 SHORT $LN684@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00da5	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00da9	75 17		 jne	 SHORT $LN684@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00dab	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00dae	48 8b cb	 mov	 rcx, rbx
  00db1	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00db3	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00db7	75 09		 jne	 SHORT $LN684@tick

; 128  : 			_Delete_this();

  00db9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00dbc	48 8b cb	 mov	 rcx, rbx
  00dbf	ff 50 08	 call	 QWORD PTR [rax+8]
$LN684@tick:
  00dc2	48 8b 7d a8	 mov	 rdi, QWORD PTR c$1[rbp-256]
  00dc6	48 8b 5d b0	 mov	 rbx, QWORD PTR c$1[rbp-248]
$LN550@tick:

; 426  : 		_Rep = _Other_rep;

  00dca	48 89 5d c0	 mov	 QWORD PTR $T2[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  00dce	48 89 7d b8	 mov	 QWORD PTR $T2[rbp-256], rdi
  00dd2	48 8d 45 b8	 lea	 rax, QWORD PTR $T2[rbp-256]
  00dd6	48 89 45 e0	 mov	 QWORD PTR $T4[rbp-256], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 129  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  00dda	ff 05 00 00 00
	00		 inc	 DWORD PTR ?drawerThread@@3HA ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00de0	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  00de7	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00dec	85 c0		 test	 eax, eax
  00dee	74 07		 je	 SHORT $LN560@tick

; 33   : 		_Throw_C_error(_Res);

  00df0	8b c8		 mov	 ecx, eax
  00df2	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN560@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00df7	48 8d 55 b8	 lea	 rdx, QWORD PTR $T2[rbp-256]
  00dfb	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2184
  00e02	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00e07	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  00e0e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00e13	85 c0		 test	 eax, eax
  00e15	74 08		 je	 SHORT $LN569@tick

; 33   : 		_Throw_C_error(_Res);

  00e17	8b c8		 mov	 ecx, eax
  00e19	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00e1e	90		 npad	 1
$LN569@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00e1f	48 8b 7d c0	 mov	 rdi, QWORD PTR $T2[rbp-248]
  00e23	48 85 ff	 test	 rdi, rdi
  00e26	74 2b		 je	 SHORT $LN580@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00e28	8b c6		 mov	 eax, esi
  00e2a	f0 0f c1 47 08	 lock xadd DWORD PTR [rdi+8], eax
  00e2f	ff c8		 dec	 eax
  00e31	75 1c		 jne	 SHORT $LN685@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00e33	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00e36	48 8b cf	 mov	 rcx, rdi
  00e39	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00e3b	8b c6		 mov	 eax, esi
  00e3d	f0 0f c1 47 0c	 lock xadd DWORD PTR [rdi+12], eax
  00e42	ff c8		 dec	 eax
  00e44	75 09		 jne	 SHORT $LN685@tick

; 128  : 			_Delete_this();

  00e46	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00e49	48 8b cf	 mov	 rcx, rdi
  00e4c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN685@tick:
  00e4f	48 8b 5d b0	 mov	 rbx, QWORD PTR c$1[rbp-248]
$LN580@tick:

; 345  : 		if (_Rep != 0)

  00e53	48 85 db	 test	 rbx, rbx
  00e56	74 2c		 je	 SHORT $LN4@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00e58	8b c6		 mov	 eax, esi
  00e5a	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00e5f	ff c8		 dec	 eax
  00e61	75 21		 jne	 SHORT $LN4@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00e63	48 8b 5d b0	 mov	 rbx, QWORD PTR c$1[rbp-248]
  00e67	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00e6a	48 8b cb	 mov	 rcx, rbx
  00e6d	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00e6f	8b c6		 mov	 eax, esi
  00e71	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  00e76	ff c8		 dec	 eax
  00e78	75 0a		 jne	 SHORT $LN4@tick

; 128  : 			_Delete_this();

  00e7a	48 8b 4d b0	 mov	 rcx, QWORD PTR c$1[rbp-248]
  00e7e	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00e81	ff 50 08	 call	 QWORD PTR [rax+8]
$LN4@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 195  : 			for(int k = -1; k <= 1; k++)

  00e84	41 ff c6	 inc	 r14d
  00e87	41 83 fe 01	 cmp	 r14d, 1
  00e8b	bb 00 00 00 00	 mov	 ebx, 0
  00e90	0f 8e 8a fe ff
	ff		 jle	 $LL5@tick

; 192  : 	{
; 193  : 		for(int j = -1; j <= 1; j++)

  00e96	41 ff c7	 inc	 r15d
  00e99	41 83 ff 01	 cmp	 r15d, 1
  00e9d	0f 8e 70 fe ff
	ff		 jle	 $LL8@tick

; 190  : 		
; 191  : 	for(int i = -1; i <= 1; i++)

  00ea3	41 ff c5	 inc	 r13d
  00ea6	41 83 fd 01	 cmp	 r13d, 1
  00eaa	0f 8e 60 fe ff
	ff		 jle	 $LL11@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  00eb0	48 8b 4d 80	 mov	 rcx, QWORD PTR lines$[rbp-256]
  00eb4	48 85 c9	 test	 rcx, rcx
  00eb7	74 06		 je	 SHORT $LN596@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00eb9	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00ebe	90		 npad	 1
$LN596@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  00ebf	48 8b 4d 50	 mov	 rcx, QWORD PTR caves$[rbp-256]
  00ec3	48 85 c9	 test	 rcx, rcx
  00ec6	74 47		 je	 SHORT $LN609@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00ec8	48 3b 4d 58	 cmp	 rcx, QWORD PTR caves$[rbp-248]
  00ecc	74 3b		 je	 SHORT $LN620@tick

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00ece	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
$LL622@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00ed2	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00ed5	48 85 db	 test	 rbx, rbx
  00ed8	74 1d		 je	 SHORT $LN686@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00eda	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00ede	75 17		 jne	 SHORT $LN686@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00ee0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00ee3	48 8b cb	 mov	 rcx, rbx
  00ee6	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00ee8	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00eec	75 09		 jne	 SHORT $LN686@tick

; 128  : 			_Delete_this();

  00eee	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00ef1	48 8b cb	 mov	 rcx, rbx
  00ef4	ff 50 08	 call	 QWORD PTR [rax+8]
$LN686@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00ef7	48 83 c7 10	 add	 rdi, 16
  00efb	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  00eff	48 3b 45 58	 cmp	 rax, QWORD PTR caves$[rbp-248]
  00f03	75 cd		 jne	 SHORT $LL622@tick
  00f05	48 8b 4d 50	 mov	 rcx, QWORD PTR caves$[rbp-256]
$LN620@tick:

; 586  : 		::operator delete(_Ptr);

  00f09	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00f0e	90		 npad	 1
$LN609@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00f0f	48 8b 5d 08	 mov	 rbx, QWORD PTR $T5[rbp-256]
  00f13	48 85 db	 test	 rbx, rbx
  00f16	74 22		 je	 SHORT $LN659@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00f18	8b c6		 mov	 eax, esi
  00f1a	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00f1f	ff c8		 dec	 eax
  00f21	75 17		 jne	 SHORT $LN659@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00f23	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00f26	48 8b cb	 mov	 rcx, rbx
  00f29	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00f2b	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00f2f	75 09		 jne	 SHORT $LN659@tick

; 128  : 			_Delete_this();

  00f31	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00f34	48 8b cb	 mov	 rcx, rbx
  00f37	ff 50 08	 call	 QWORD PTR [rax+8]
$LN659@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 210  : 	return true;

  00f3a	b0 01		 mov	 al, 1

; 211  : }

  00f3c	48 8b 8d 48 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00f43	48 33 cc	 xor	 rcx, rsp
  00f46	e8 00 00 00 00	 call	 __security_check_cookie
  00f4b	4c 8d 9c 24 f0
	02 00 00	 lea	 r11, QWORD PTR [rsp+752]
  00f53	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00f57	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00f5b	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  00f5f	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00f64	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  00f69	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00f6e	45 0f 28 4b c0	 movaps	 xmm9, XMMWORD PTR [r11-64]
  00f73	45 0f 28 53 b0	 movaps	 xmm10, XMMWORD PTR [r11-80]
  00f78	45 0f 28 5b a0	 movaps	 xmm11, XMMWORD PTR [r11-96]
  00f7d	45 0f 28 63 90	 movaps	 xmm12, XMMWORD PTR [r11-112]
  00f82	45 0f 28 6b 80	 movaps	 xmm13, XMMWORD PTR [r11-128]
  00f87	45 0f 28 b3 70
	ff ff ff	 movaps	 xmm14, XMMWORD PTR [r11-144]
  00f8f	45 0f 28 bb 60
	ff ff ff	 movaps	 xmm15, XMMWORD PTR [r11-160]
  00f97	49 8b e3	 mov	 rsp, r11
  00f9a	41 5f		 pop	 r15
  00f9c	41 5e		 pop	 r14
  00f9e	41 5d		 pop	 r13
  00fa0	41 5c		 pop	 r12
  00fa2	5d		 pop	 rbp
  00fa3	c3		 ret	 0
$LN692@tick:
?tick@ChunkLoadThread@@MEAA_NXZ ENDP			; ChunkLoadThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunkX$ = 112
chunkZ$ = 116
boundingBox$1$ = 120
chunkY$ = 124
lines$ = 128
tv3591 = 152
i$1$ = 156
tv3589 = 160
tv3590 = 164
c$1 = 168
$T2 = 184
amountOfLines$ = 200
$T3 = 208
tv3615 = 224
$T4 = 224
boundingBox$ = 232
$T5 = 264
caves$1$ = 272
$T6 = 280
$T7 = 320
caves$ = 336
$T8 = 360
$T9 = 376
this$GSCopy$1$ = 392
tv3613 = 400
$T10 = 408
$T11 = 424
$T12 = 440
$T13 = 472
chunk$ = 480
cave$14 = 496
$T15 = 512
global_ws$ = 536
local_ws$ = 560
__$ArrayPad$ = 584
this$ = 800
?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$0
  00000	48 8d 8a e0 01
	00 00		 lea	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunkX$ = 112
chunkZ$ = 116
boundingBox$1$ = 120
chunkY$ = 124
lines$ = 128
tv3591 = 152
i$1$ = 156
tv3589 = 160
tv3590 = 164
c$1 = 168
$T2 = 184
amountOfLines$ = 200
$T3 = 208
tv3615 = 224
$T4 = 224
boundingBox$ = 232
$T5 = 264
caves$1$ = 272
$T6 = 280
$T7 = 320
caves$ = 336
$T8 = 360
$T9 = 376
this$GSCopy$1$ = 392
tv3613 = 400
$T10 = 408
$T11 = 424
$T12 = 440
$T13 = 472
chunk$ = 480
cave$14 = 496
$T15 = 512
global_ws$ = 536
local_ws$ = 560
__$ArrayPad$ = 584
this$ = 800
?dtor$1@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$1
  0000c	48 8d 8a 50 01
	00 00		 lea	 rcx, QWORD PTR caves$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::~vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >
?dtor$1@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunkX$ = 112
chunkZ$ = 116
boundingBox$1$ = 120
chunkY$ = 124
lines$ = 128
tv3591 = 152
i$1$ = 156
tv3589 = 160
tv3590 = 164
c$1 = 168
$T2 = 184
amountOfLines$ = 200
$T3 = 208
tv3615 = 224
$T4 = 224
boundingBox$ = 232
$T5 = 264
caves$1$ = 272
$T6 = 280
$T7 = 320
caves$ = 336
$T8 = 360
$T9 = 376
this$GSCopy$1$ = 392
tv3613 = 400
$T10 = 408
$T11 = 424
$T12 = 440
$T13 = 472
chunk$ = 480
cave$14 = 496
$T15 = 512
global_ws$ = 536
local_ws$ = 560
__$ArrayPad$ = 584
this$ = 800
?dtor$2@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$2
  00018	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR lines$[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ ; std::vector<geom::Line,std::allocator<geom::Line> >::~vector<geom::Line,std::allocator<geom::Line> >
?dtor$2@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunkX$ = 112
chunkZ$ = 116
boundingBox$1$ = 120
chunkY$ = 124
lines$ = 128
tv3591 = 152
i$1$ = 156
tv3589 = 160
tv3590 = 164
c$1 = 168
$T2 = 184
amountOfLines$ = 200
$T3 = 208
tv3615 = 224
$T4 = 224
boundingBox$ = 232
$T5 = 264
caves$1$ = 272
$T6 = 280
$T7 = 320
caves$ = 336
$T8 = 360
$T9 = 376
this$GSCopy$1$ = 392
tv3613 = 400
$T10 = 408
$T11 = 424
$T12 = 440
$T13 = 472
chunk$ = 480
cave$14 = 496
$T15 = 512
global_ws$ = 536
local_ws$ = 560
__$ArrayPad$ = 584
this$ = 800
?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$3
  00024	48 8d 8a f0 01
	00 00		 lea	 rcx, QWORD PTR cave$14[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VCave@@@std@@QEAA@XZ ; std::shared_ptr<Cave>::~shared_ptr<Cave>
?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunkX$ = 112
chunkZ$ = 116
boundingBox$1$ = 120
chunkY$ = 124
lines$ = 128
tv3591 = 152
i$1$ = 156
tv3589 = 160
tv3590 = 164
c$1 = 168
$T2 = 184
amountOfLines$ = 200
$T3 = 208
tv3615 = 224
$T4 = 224
boundingBox$ = 232
$T5 = 264
caves$1$ = 272
$T6 = 280
$T7 = 320
caves$ = 336
$T8 = 360
$T9 = 376
this$GSCopy$1$ = 392
tv3613 = 400
$T10 = 408
$T11 = 424
$T12 = 440
$T13 = 472
chunk$ = 480
cave$14 = 496
$T15 = 512
global_ws$ = 536
local_ws$ = 560
__$ArrayPad$ = 584
this$ = 800
?dtor$6@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$6
  00030	48 8d 8a a8 00
	00 00		 lea	 rcx, QWORD PTR c$1[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$6@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunkX$ = 112
chunkZ$ = 116
boundingBox$1$ = 120
chunkY$ = 124
lines$ = 128
tv3591 = 152
i$1$ = 156
tv3589 = 160
tv3590 = 164
c$1 = 168
$T2 = 184
amountOfLines$ = 200
$T3 = 208
tv3615 = 224
$T4 = 224
boundingBox$ = 232
$T5 = 264
caves$1$ = 272
$T6 = 280
$T7 = 320
caves$ = 336
$T8 = 360
$T9 = 376
this$GSCopy$1$ = 392
tv3613 = 400
$T10 = 408
$T11 = 424
$T12 = 440
$T13 = 472
chunk$ = 480
cave$14 = 496
$T15 = 512
global_ws$ = 536
local_ws$ = 560
__$ArrayPad$ = 584
this$ = 800
?dtor$8@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$8
  0003c	48 8b 8a e0 00
	00 00		 mov	 rcx, QWORD PTR $T4[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$8@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestChunkLoad, COMDAT

; 214  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 215  : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d 60 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2400
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestChu

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 38 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2360
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d 60 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2400
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestChu

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestChu

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestChu

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestChu

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestChu:
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 220  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestChunkLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestChunkLoad'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestChunkLoad'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00006	0f 94 c0	 sete	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 126  : 		}

  00009	c3		 ret	 0
?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VCave@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0?$shared_ptr@VCave@@@std@@QEAA@AEBV01@@Z PROC	; std::shared_ptr<Cave>::shared_ptr<Cave>, COMDAT

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00008	48 8b d9	 mov	 rbx, rcx

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00012	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00016	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00019	4d 85 c0	 test	 r8, r8
  0001c	74 05		 je	 SHORT $LN10@shared_ptr

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0001e	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN10@shared_ptr:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00023	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<Cave>::_Reset0

; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}

  00028	48 8b c3	 mov	 rax, rbx
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
??0?$shared_ptr@VCave@@@std@@QEAA@AEBV01@@Z ENDP	; std::shared_ptr<Cave>::shared_ptr<Cave>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$shared_ptr@VCave@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@VCave@@@std@@QEAA@XZ PROC		; std::shared_ptr<Cave>::~shared_ptr<Cave>, COMDAT

; 622  : 		{	// release resource

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN9@shared_ptr

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN12@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN12@shared_ptr

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN12@shared_ptr:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN9@shared_ptr:

; 623  : 		this->_Decref();
; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$shared_ptr@VCave@@@std@@QEAA@XZ ENDP		; std::shared_ptr<Cave>::~shared_ptr<Cave>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??C?$shared_ptr@VCave@@@std@@QEBAPEAVCave@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$shared_ptr@VCave@@@std@@QEBAPEAVCave@@XZ PROC	; std::shared_ptr<Cave>::operator->, COMDAT

; 691  : 		return (this->_Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 692  : 		}

  00003	c3		 ret	 0
??C?$shared_ptr@VCave@@@std@@QEBAPEAVCave@@XZ ENDP	; std::shared_ptr<Cave>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::~vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >, COMDAT

; 900  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::_Tidy
??1?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::~vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::size, COMDAT

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 04	 sar	 rax, 4

; 1088 : 		}

  0000b	c3		 ret	 0
?size@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VCave@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VCave@@@1@_K@Z PROC ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::operator[], COMDAT

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

  00000	48 c1 e2 04	 shl	 rdx, 4
  00004	48 03 11	 add	 rdx, QWORD PTR [rcx]
  00007	48 8b c2	 mov	 rax, rdx

; 1149 : 		}

  0000a	c3		 ret	 0
??A?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VCave@@@1@_K@Z ENDP ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::vector<geom::Line,std::allocator<geom::Line> >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 686  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::vector<geom::Line,std::allocator<geom::Line> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAX$$QEAVLine@geom@@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAX$$QEAVLine@geom@@@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::push_back, COMDAT

; 836  : 		{	// insert by moving into element at end

$LN75:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);
; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);
; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);
; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 836  : 		{	// insert by moving into element at end

  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx

; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);
; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);
; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);
; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00014	48 3b d0	 cmp	 rdx, rax
  00017	73 22		 jae	 SHORT $LN4@push_back
  00019	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001c	48 3b ca	 cmp	 rcx, rdx
  0001f	77 1a		 ja	 SHORT $LN4@push_back

; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)

  00021	48 2b f9	 sub	 rdi, rcx
  00024	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  00028	75 08		 jne	 SHORT $LN3@push_back

; 841  : 				_Reserve(1);

  0002a	48 8b cb	 mov	 rcx, rbx
  0002d	e8 00 00 00 00	 call	 ?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reserve
$LN3@push_back:

; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));

  00032	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H
  00036	48 03 3b	 add	 rdi, QWORD PTR [rbx]

; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else

  00039	eb 0e		 jmp	 SHORT $LN1@push_back
$LN4@push_back:

; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)

  0003b	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  0003f	75 08		 jne	 SHORT $LN1@push_back

; 850  : 				_Reserve(1);

  00041	48 8b cb	 mov	 rcx, rbx
  00044	e8 00 00 00 00	 call	 ?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00049	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0004d	48 85 c9	 test	 rcx, rcx
  00050	74 2e		 je	 SHORT $LN59@push_back
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00052	8b 07		 mov	 eax, DWORD PTR [rdi]
  00054	89 01		 mov	 DWORD PTR [rcx], eax
  00056	8b 47 04	 mov	 eax, DWORD PTR [rdi+4]
  00059	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0005c	8b 47 08	 mov	 eax, DWORD PTR [rdi+8]
  0005f	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00062	8b 47 0c	 mov	 eax, DWORD PTR [rdi+12]
  00065	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  00068	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
  0006b	89 41 10	 mov	 DWORD PTR [rcx+16], eax
  0006e	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  00071	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00074	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00077	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  0007a	8b 47 1c	 mov	 eax, DWORD PTR [rdi+28]
  0007d	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
$LN59@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 854  : 			++this->_Mylast;

  00080	48 83 43 08 20	 add	 QWORD PTR [rbx+8], 32	; 00000020H

; 855  : 			}
; 856  : 		}

  00085	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?push_back@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAX$$QEAVLine@geom@@@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::~vector<geom::Line,std::allocator<geom::Line> >, COMDAT

; 899  : 		{	// destroy the object

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);
; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);
; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);
; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)
; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)
; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));
; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 12		 je	 SHORT $LN3@vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00011	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00016	33 c0		 xor	 eax, eax
  00018	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1543 : 			this->_Mylast = pointer();

  0001b	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1544 : 			this->_Myend = pointer();

  0001f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN3@vector:

; 900  : 		_Tidy();
; 901  : 		}

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??1?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::~vector<geom::Line,std::allocator<geom::Line> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::size, COMDAT

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 05	 sar	 rax, 5

; 1088 : 		}

  0000b	c3		 ret	 0
?size@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAAEAVLine@geom@@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$dead$ = 16
??A?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAAEAVLine@geom@@_K@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::operator[], COMDAT

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1149 : 		}

  00003	c3		 ret	 0
??A?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEAAAEAVLine@geom@@_K@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VCave@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Ptr_base@VCave@@@std@@QEAA@XZ PROC		; std::_Ptr_base<Cave>::_Ptr_base<Cave>, COMDAT

; 282  : 		{	// construct

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$_Ptr_base@VCave@@@std@@QEAA@XZ ENDP		; std::_Ptr_base<Cave>::_Ptr_base<Cave>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get@?$_Ptr_base@VCave@@@std@@QEBAPEAVCave@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Ptr_base@VCave@@@std@@QEBAPEAVCave@@XZ PROC	; std::_Ptr_base<Cave>::_Get, COMDAT

; 335  : 		return (_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 336  : 		}

  00003	c3		 ret	 0
?_Get@?$_Ptr_base@VCave@@@std@@QEBAPEAVCave@@XZ ENDP	; std::_Ptr_base<Cave>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ PROC		; std::_Ptr_base<Cave>::_Decref, COMDAT

; 344  : 		{	// decrement reference count

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN7@Decref

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN10@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN10@Decref

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Decref:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN7@Decref:

; 346  : 			_Rep->_Decref();
; 347  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
?_Decref@?$_Ptr_base@VCave@@@std@@QEAAXXZ ENDP		; std::_Ptr_base<Cave>::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ PROC ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::_Tidy, COMDAT

; 1535 : 		{	// free all storage

$LN47:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1536 : 		if (this->_Myfirst != pointer())

  0000a	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  0000d	48 8b f1	 mov	 rsi, rcx
  00010	48 85 ff	 test	 rdi, rdi
  00013	74 69		 je	 SHORT $LN1@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00015	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0001a	48 8b 69 08	 mov	 rbp, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  0001e	48 3b fd	 cmp	 rdi, rbp
  00021	74 41		 je	 SHORT $LN12@Tidy
  00023	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL14@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00030	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00034	48 85 db	 test	 rbx, rbx
  00037	74 1d		 je	 SHORT $LN34@Tidy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00039	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0003d	75 17		 jne	 SHORT $LN34@Tidy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00047	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004b	75 09		 jne	 SHORT $LN34@Tidy

; 128  : 			_Delete_this();

  0004d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00050	48 8b cb	 mov	 rcx, rbx
  00053	ff 50 08	 call	 QWORD PTR [rax+8]
$LN34@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00056	48 83 c7 10	 add	 rdi, 16
  0005a	48 3b fd	 cmp	 rdi, rbp
  0005d	75 d1		 jne	 SHORT $LL14@Tidy
  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN12@Tidy:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  00064	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00067	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0006c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00071	33 c0		 xor	 eax, eax
  00073	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1543 : 			this->_Mylast = pointer();

  00076	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 1544 : 			this->_Myend = pointer();

  0007a	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
$LN1@Tidy:

; 1545 : 			}
; 1546 : 		}

  0007e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
?_Tidy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXXZ ENDP ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBA_NPEBVLine@geom@@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBA_NPEBVLine@geom@@@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Inside, COMDAT

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00000	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00004	73 08		 jae	 SHORT $LN3@Inside
  00006	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00009	77 03		 ja	 SHORT $LN3@Inside
  0000b	b0 01		 mov	 al, 1

; 1497 : 		}

  0000d	c3		 ret	 0
$LN3@Inside:

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000e	32 c0		 xor	 al, al

; 1497 : 		}

  00010	c3		 ret	 0
?_Inside@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBA_NPEBVLine@geom@@@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reserve, COMDAT

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

$LN44:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00004	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  00008	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	49 2b c0	 sub	 rax, r8
  00012	48 c1 f8 05	 sar	 rax, 5

; 1526 : 		if (_Unused_capacity() < _Count)

  00016	48 83 f8 01	 cmp	 rax, 1
  0001a	73 5d		 jae	 SHORT $LN2@Reserve

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0001c	4c 8b 11	 mov	 r10, QWORD PTR [rcx]

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0001f	49 b9 ff ff ff
	ff ff ff ff 07	 mov	 r9, 576460752303423487	; 07ffffffffffffffH

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00029	4d 2b c2	 sub	 r8, r10

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0002c	49 8b c1	 mov	 rax, r9

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0002f	49 c1 f8 05	 sar	 r8, 5

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  00033	49 2b c0	 sub	 rax, r8
  00036	48 83 f8 01	 cmp	 rax, 1
  0003a	72 42		 jb	 SHORT $LN42@Reserve

; 967  : 		return (this->_Myend - this->_Myfirst);

  0003c	49 2b d2	 sub	 rdx, r10

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  0003f	49 ff c0	 inc	 r8

; 967  : 		return (this->_Myend - this->_Myfirst);

  00042	48 c1 fa 05	 sar	 rdx, 5

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00046	48 8b c2	 mov	 rax, rdx
  00049	48 d1 e8	 shr	 rax, 1
  0004c	4c 2b c8	 sub	 r9, rax
  0004f	4c 3b ca	 cmp	 r9, rdx
  00052	73 12		 jae	 SHORT $LN27@Reserve
  00054	33 d2		 xor	 edx, edx

; 1489 : 		if (_Capacity < _Count)

  00056	49 3b d0	 cmp	 rdx, r8
  00059	49 0f 42 d0	 cmovb	 rdx, r8

; 1531 : 			}
; 1532 : 		}

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00061	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reallocate
$LN27@Reserve:

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00066	48 03 d0	 add	 rdx, rax

; 1489 : 		if (_Capacity < _Count)

  00069	49 3b d0	 cmp	 rdx, r8
  0006c	49 0f 42 d0	 cmovb	 rdx, r8

; 1531 : 			}
; 1532 : 		}

  00070	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00074	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reallocate
$LN2@Reserve:

; 1531 : 			}
; 1532 : 		}

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	c3		 ret	 0
$LN42@Reserve:

; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())
; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);
; 1542 : 			this->_Myfirst = pointer();
; 1543 : 			this->_Mylast = pointer();
; 1544 : 			this->_Myend = pointer();
; 1545 : 			}
; 1546 : 		}
; 1547 : 
; 1548 : 	template<class _Iter>
; 1549 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1550 : 		{	// copy initializing [_First, _Last), using allocator
; 1551 : 		_Alty _Alval(this->_Getal());
; 1552 : 		return (_Uninitialized_copy(_First, _Last,
; 1553 : 			_Ptr, _Alval));
; 1554 : 		}
; 1555 : 
; 1556 : 	template<class _Iter>
; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());
; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));
; 1562 : 		}
; 1563 : 
; 1564 : 	iterator _Insert_n(const_iterator _Where,
; 1565 : 		size_type _Count, const value_type& _Val)
; 1566 : 		{	// insert _Count * _Val at _Where
; 1567 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1568 : 		if (_VICONT(_Where) != this
; 1569 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1570 : 			|| this->_Mylast < _VIPTR(_Where))
; 1571 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1572 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 
; 1574 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1575 : 		if (_Count == 0)
; 1576 : 			;
; 1577 : 		else if (_Unused_capacity() < _Count)
; 1578 : 			{	// not enough room, reallocate
; 1579 : 			if (max_size() - size() < _Count)
; 1580 : 				_Xlen();	// result too long
; 1581 : 
; 1582 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1583 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1584 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1585 : 			int _Ncopied = 0;
; 1586 : 
; 1587 : 			_TRY_BEGIN
; 1588 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1589 : 				_STD addressof(_Val));	// add new stuff
; 1590 : 			++_Ncopied;
; 1591 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1592 : 				_Newvec);	// copy prefix
; 1593 : 			++_Ncopied;
; 1594 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1595 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1596 : 			_CATCH_ALL
; 1597 : 			if (1 < _Ncopied)
; 1598 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1599 : 			if (0 < _Ncopied)
; 1600 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1601 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1602 : 			_RERAISE;
; 1603 : 			_CATCH_END
; 1604 : 
; 1605 : 			_Count += size();
; 1606 : 			if (this->_Myfirst != pointer())
; 1607 : 				{	// destroy and deallocate old array
; 1608 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1609 : 				this->_Getal().deallocate(this->_Myfirst,
; 1610 : 					this->_Myend - this->_Myfirst);
; 1611 : 				}
; 1612 : 
; 1613 : 			this->_Orphan_all();
; 1614 : 			this->_Myend = _Newvec + _Capacity;
; 1615 : 			this->_Mylast = _Newvec + _Count;
; 1616 : 			this->_Myfirst = _Newvec;
; 1617 : 			}
; 1618 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1619 : 			< _Count)
; 1620 : 			{	// new stuff spills off end
; 1621 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1622 : 
; 1623 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1624 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1625 : 
; 1626 : 			_TRY_BEGIN
; 1627 : 			_Ufill(this->_Mylast,
; 1628 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1629 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1630 : 			_CATCH_ALL
; 1631 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1632 : 				this->_Mylast + _Count);
; 1633 : 			_RERAISE;
; 1634 : 			_CATCH_END
; 1635 : 
; 1636 : 			this->_Mylast += _Count;
; 1637 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1638 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1639 : 				_Tmp);	// insert up to old end
; 1640 : 			}
; 1641 : 		else
; 1642 : 			{	// new stuff can all be assigned
; 1643 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1644 : 
; 1645 : 			pointer _Oldend = this->_Mylast;
; 1646 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1647 : 				this->_Mylast);	// copy suffix
; 1648 : 
; 1649 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1650 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1651 : 				_Oldend);	// copy hole
; 1652 : 			_STD fill(_VIPTR(_Where),
; 1653 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1654 : 			}
; 1655 : 		return (begin() + _Off);
; 1656 : 		}
; 1657 : 
; 1658 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1659 : 		{	// copy initializing _Count * _Val, using allocator
; 1660 : 		_Alty _Alval(this->_Getal());
; 1661 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1662 : 		return (_Ptr + _Count);
; 1663 : 		}
; 1664 : 
; 1665 : 	__declspec(noreturn) void _Xlen() const
; 1666 : 		{	// report a length_error
; 1667 : 		_Xlength_error("vector<T> too long");

  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00085	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0008a	cc		 int	 3
$LN41@Reserve:
?_Reserve@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXXZ PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Tidy, COMDAT

; 1535 : 		{	// free all storage

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1536 : 		if (this->_Myfirst != pointer())

  00009	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000c	48 85 c9	 test	 rcx, rcx
  0000f	74 12		 je	 SHORT $LN1@Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00011	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00016	33 c0		 xor	 eax, eax
  00018	48 89 03	 mov	 QWORD PTR [rbx], rax

; 1543 : 			this->_Mylast = pointer();

  0001b	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 1544 : 			this->_Myend = pointer();

  0001f	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN1@Tidy:

; 1545 : 			}
; 1546 : 		}

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
?_Tidy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXXZ ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXPEAVLine@geom@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXPEAVLine@geom@@0@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Orphan_range, COMDAT

; 1694 : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_range@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXPEAVLine@geom@@0@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VLine@geom@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@VLine@geom@@@std@@QEAA@XZ PROC		; std::allocator<geom::Line>::allocator<geom::Line>, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@VLine@geom@@@std@@QEAA@XZ ENDP		; std::allocator<geom::Line>::allocator<geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VLine@geom@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VLine@geom@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 594  : 		{	// construct allocator from _Al
; 595  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@@std@@QEAA@AEBV?$allocator@VLine@geom@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >::_Getal, COMDAT

; 647  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 648  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<geom::Line,std::allocator<geom::Line> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z PROC ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::_Destroy, COMDAT

; 1478 : 		{	// destroy [_First, _Last) using allocator

$LN37:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00000	49 3b d0	 cmp	 rdx, r8
  00003	74 5c		 je	 SHORT $LN35@Destroy
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1478 : 		{	// destroy [_First, _Last) using allocator

  00014	49 8b f0	 mov	 rsi, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	48 8d 7a 08	 lea	 rdi, QWORD PTR [rdx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL9@Destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN29@Destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN29@Destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN29@Destroy

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL9@Destroy
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1481 : 		}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN35@Destroy:
  00061	f3 c3		 fatret	 0
?_Destroy@?$vector@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VCave@@@2@0@Z ENDP ; std::vector<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > > >::_Getal, COMDAT

; 647  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 648  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VCave@@@std@@V?$allocator@V?$shared_ptr@VCave@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<Cave>,std::allocator<std::shared_ptr<Cave> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Unused_capacity, COMDAT

; 972  : 		return (this->_Myend - this->_Mylast);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 41 08	 sub	 rax, QWORD PTR [rcx+8]
  00008	48 c1 f8 05	 sar	 rax, 5

; 973  : 		}

  0000c	c3		 ret	 0
?_Unused_capacity@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::max_size, COMDAT

; 1092 : 		return (this->_Getal().max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH

; 1093 : 		}

  0000a	c3		 ret	 0
?max_size@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXPEAVLine@geom@@0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXPEAVLine@geom@@0@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Destroy, COMDAT

; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}

  00000	c2 00 00	 ret	 0
?_Destroy@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAXPEAVLine@geom@@0@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBA_K_K@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Grow_to, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00004	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH

; 967  : 		return (this->_Myend - this->_Myfirst);

  0000e	4c 2b 01	 sub	 r8, QWORD PTR [rcx]
  00011	49 c1 f8 05	 sar	 r8, 5

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00015	49 8b c8	 mov	 rcx, r8
  00018	48 d1 e9	 shr	 rcx, 1
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	49 3b c0	 cmp	 rax, r8
  00021	73 0e		 jae	 SHORT $LN4@Grow_to
  00023	45 33 c0	 xor	 r8d, r8d

; 1489 : 		if (_Capacity < _Count)

  00026	4c 3b c2	 cmp	 r8, rdx
  00029	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0002d	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  00030	c3		 ret	 0
$LN4@Grow_to:

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00031	4c 03 c1	 add	 r8, rcx

; 1489 : 		if (_Capacity < _Count)

  00034	4c 3b c2	 cmp	 r8, rdx
  00037	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0003b	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  0003e	c3		 ret	 0
?_Grow_to@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBA_K_K@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reallocate, COMDAT

; 1500 : 		{	// move to array of exactly _Count elements

$LN51:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  0000f	33 ed		 xor	 ebp, ebp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1500 : 		{	// move to array of exactly _Count elements

  00011	48 8b da	 mov	 rbx, rdx
  00014	48 8b f1	 mov	 rsi, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00017	48 85 d2	 test	 rdx, rdx
  0001a	74 23		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001c	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  00026	48 3b d0	 cmp	 rdx, rax
  00029	77 6a		 ja	 SHORT $LN49@Reallocate
  0002b	48 8b ca	 mov	 rcx, rdx
  0002e	48 c1 e1 05	 shl	 rcx, 5
  00032	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00037	48 8b e8	 mov	 rbp, rax
  0003a	48 85 c0	 test	 rax, rax
  0003d	74 56		 je	 SHORT $LN49@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0003f	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
  00043	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00046	4c 8b c5	 mov	 r8, rbp
  00049	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0004e	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAVLine@geom@@PEAV12@V?$allocator@VLine@geom@@@std@@V12@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<geom::Line * __ptr64,geom::Line * __ptr64,std::allocator<geom::Line>,geom::Line>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00053	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00056	48 8b 7e 08	 mov	 rdi, QWORD PTR [rsi+8]
  0005a	48 2b f9	 sub	 rdi, rcx

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())

  0005d	48 85 c9	 test	 rcx, rcx
  00060	74 05		 je	 SHORT $LN44@Reallocate
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00062	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN44@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1519 : 		this->_Myend = _Ptr + _Count;

  00067	48 c1 e3 05	 shl	 rbx, 5

; 1520 : 		this->_Mylast = _Ptr + _Size;

  0006b	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 1521 : 		this->_Myfirst = _Ptr;

  0006f	48 89 2e	 mov	 QWORD PTR [rsi], rbp
  00072	48 03 dd	 add	 rbx, rbp
  00075	48 03 fd	 add	 rdi, rbp

; 1522 : 		}

  00078	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0007d	48 89 7e 08	 mov	 QWORD PTR [rsi+8], rdi
  00081	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00086	48 89 5e 10	 mov	 QWORD PTR [rsi+16], rbx
  0008a	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00093	5e		 pop	 rsi
  00094	c3		 ret	 0
$LN49@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00095	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0009a	cc		 int	 3
$LN48@Reallocate:
?_Reallocate@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAX_K@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXXZ PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Xlen, COMDAT

; 1666 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1667 : 		_Xlength_error("vector<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEBAXXZ ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<geom::Line> >::_Wrap_alloc<std::allocator<geom::Line> >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<geom::Line> >::_Wrap_alloc<std::allocator<geom::Line> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<geom::Line> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<geom::Line> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@VLine@geom@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@VLine@geom@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<geom::Line> >::_Vector_val<std::_Simple_types<geom::Line> >, COMDAT

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 489  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@VLine@geom@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<geom::Line> >::_Vector_val<std::_Simple_types<geom::Line> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<Cave> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<Cave> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::capacity, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 05	 sar	 rax, 5

; 968  : 		}

  0000b	c3		 ret	 0
?capacity@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@_K@Z PROC ; std::allocator<geom::Line>::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@_K@Z ENDP ; std::allocator<geom::Line>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAPEAVLine@geom@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAPEAVLine@geom@@_K@Z PROC ; std::_Wrap_alloc<std::allocator<geom::Line> >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 20		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 16		 ja	 SHORT $LN14@allocate
  0001a	48 c1 e2 05	 shl	 rdx, 5
  0001e	48 8b ca	 mov	 rcx, rdx
  00021	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00026	48 85 c0	 test	 rax, rax
  00029	74 05		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00035	cc		 int	 3
$LN13@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAPEAVLine@geom@@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<geom::Line> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<geom::Line> >::max_size, COMDAT

; 914  : 		return (_Mytraits::max_size(*this));

  00000	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH

; 915  : 		}

  0000a	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<geom::Line> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::shared_ptr<Cave> >::allocator<std::shared_ptr<Cave> >, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::shared_ptr<Cave> >::allocator<std::shared_ptr<Cave> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VLine@geom@@@std@@QEAAPEAVLine@geom@@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@VLine@geom@@@std@@QEAAPEAVLine@geom@@_K@Z PROC ; std::allocator<geom::Line>::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 20		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 16		 ja	 SHORT $LN11@allocate
  0001a	48 c1 e2 05	 shl	 rdx, 5
  0001e	48 8b ca	 mov	 rcx, rdx
  00021	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00026	48 85 c0	 test	 rax, rax
  00029	74 05		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00035	cc		 int	 3
$LN10@allocate:
?allocate@?$allocator@VLine@geom@@@std@@QEAAPEAVLine@geom@@_K@Z ENDP ; std::allocator<geom::Line>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SA_KAEBV?$allocator@VLine@geom@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SA_KAEBV?$allocator@VLine@geom@@@2@@Z PROC ; std::allocator_traits<std::allocator<geom::Line> >::max_size, COMDAT

; 762  : 		return (_Al.max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH

; 763  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SA_KAEBV?$allocator@VLine@geom@@@2@@Z ENDP ; std::allocator_traits<std::allocator<geom::Line> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VLine@geom@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@VLine@geom@@@std@@QEBA_KXZ PROC	; std::allocator<geom::Line>::max_size, COMDAT

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH

; 629  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator@VLine@geom@@@std@@QEBA_KXZ ENDP	; std::allocator<geom::Line>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Reset@VCave@@@?$_Ptr_base@VCave@@@std@@QEAAXAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??$_Reset@VCave@@@?$_Ptr_base@VCave@@@std@@QEAAXAEBV01@@Z PROC ; std::_Ptr_base<Cave>::_Reset<Cave>, COMDAT

; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00007	4d 85 c0	 test	 r8, r8
  0000a	74 05		 je	 SHORT $LN6@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0000c	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN6@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00011	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<Cave>::_Reset0
??$_Reset@VCave@@@?$_Ptr_base@VCave@@@std@@QEAAXAEBV01@@Z ENDP ; std::_Ptr_base<Cave>::_Reset<Cave>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@VLine@geom@@@std@@YAPEAVLine@geom@@AEAV12@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@VLine@geom@@@std@@YAPEAVLine@geom@@AEAV12@@Z PROC ; std::addressof<geom::Line>, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@VLine@geom@@@std@@YAPEAVLine@geom@@AEAV12@@Z ENDP ; std::addressof<geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@VLine@geom@@@std@@YA$$QEAVLine@geom@@AEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@VLine@geom@@@std@@YA$$QEAVLine@geom@@AEAV12@@Z PROC ; std::forward<geom::Line>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@VLine@geom@@@std@@YA$$QEAVLine@geom@@AEAV12@@Z ENDP ; std::forward<geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@VLine@geom@@V12@@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@$$QEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@VLine@geom@@V12@@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@$$QEAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<geom::Line> >::construct<geom::Line,geom::Line>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 36		 je	 SHORT $LN11@construct
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	89 02		 mov	 DWORD PTR [rdx], eax
  0000a	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  0000e	89 42 04	 mov	 DWORD PTR [rdx+4], eax
  00011	41 8b 40 08	 mov	 eax, DWORD PTR [r8+8]
  00015	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  00018	41 8b 40 0c	 mov	 eax, DWORD PTR [r8+12]
  0001c	89 42 0c	 mov	 DWORD PTR [rdx+12], eax
  0001f	41 8b 40 10	 mov	 eax, DWORD PTR [r8+16]
  00023	89 42 10	 mov	 DWORD PTR [rdx+16], eax
  00026	41 8b 40 14	 mov	 eax, DWORD PTR [r8+20]
  0002a	89 42 14	 mov	 DWORD PTR [rdx+20], eax
  0002d	41 8b 40 18	 mov	 eax, DWORD PTR [r8+24]
  00031	89 42 18	 mov	 DWORD PTR [rdx+24], eax
  00034	41 8b 40 1c	 mov	 eax, DWORD PTR [r8+28]
  00038	89 42 1c	 mov	 DWORD PTR [rdx+28], eax
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0003b	f3 c3		 fatret	 0
??$construct@VLine@geom@@V12@@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@$$QEAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<geom::Line> >::construct<geom::Line,geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

$LN35:

; 88   : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5c		 je	 SHORT $LN33@Destroy_ra
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 79   : 	{	// destroy [_First, _Last)

  00014	48 8b f2	 mov	 rsi, rdx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL7@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN27@Destroy_ra

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN27@Destroy_ra

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN27@Destroy_ra

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN27@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL7@Destroy_ra
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 81   : 	}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN33@Destroy_ra:
  00061	f3 c3		 fatret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAXPEAVLine@geom@@0AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAXPEAVLine@geom@@0AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<geom::Line> > >, COMDAT

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 81   : 	}

  00000	c2 00 00	 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAXPEAVLine@geom@@0AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<geom::Line> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PEAVLine@geom@@@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAPEAVLine@geom@@PEAV23@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAVLine@geom@@@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAPEAVLine@geom@@PEAV23@00@Z PROC ; std::vector<geom::Line,std::allocator<geom::Line> >::_Umove<geom::Line * __ptr64>, COMDAT

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	49 8b c0	 mov	 rax, r8
  00007	48 8b ca	 mov	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0000a	4d 8b c1	 mov	 r8, r9
  0000d	48 8b d0	 mov	 rdx, rax
  00010	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAVLine@geom@@PEAV12@V?$allocator@VLine@geom@@@std@@V12@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<geom::Line * __ptr64,geom::Line * __ptr64,std::allocator<geom::Line>,geom::Line>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1562 : 		}

  00015	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00019	c3		 ret	 0
??$_Umove@PEAVLine@geom@@@?$vector@VLine@geom@@V?$allocator@VLine@geom@@@std@@@std@@IEAAPEAVLine@geom@@PEAV23@00@Z ENDP ; std::vector<geom::Line,std::allocator<geom::Line> >::_Umove<geom::Line * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@VLine@geom@@@std@@YAPEAVLine@geom@@_KPEAV12@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@VLine@geom@@@std@@YAPEAVLine@geom@@_KPEAV12@@Z PROC ; std::_Allocate<geom::Line>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 ff ff ff
	ff ff ff ff 07	 mov	 rax, 576460752303423487	; 07ffffffffffffffH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 13		 ja	 SHORT $LN12@Allocate
  00013	48 c1 e1 05	 shl	 rcx, 5
  00017	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00026	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002b	cc		 int	 3
$LN11@Allocate:
??$_Allocate@VLine@geom@@@std@@YAPEAVLine@geom@@_KPEAV12@@Z ENDP ; std::_Allocate<geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 8
_Other_ptr$ = 16
_Other_rep$ = 24
?_Reset@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<Cave>::_Reset, COMDAT

; 407  : 		if (_Other_rep)

  00000	4d 85 c0	 test	 r8, r8
  00003	74 05		 je	 SHORT $LN4@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00005	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN4@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0000a	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<Cave>::_Reset0
?_Reset@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<Cave>::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 48
_Other_ptr$ = 56
_Other_rep$ = 64
?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<Cave>::_Reset0, COMDAT

; 423  : 		{	// release resource and take new resource

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 424  : 		if (_Rep != 0)

  00014	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00018	49 8b f0	 mov	 rsi, r8
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	48 85 ff	 test	 rdi, rdi
  00024	74 4c		 je	 SHORT $LN12@Reset0

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00026	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  0002a	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0002f	75 38		 jne	 SHORT $LN11@Reset0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00031	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00034	48 8b cf	 mov	 rcx, rdi
  00037	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00039	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0003d	75 09		 jne	 SHORT $LN10@Reset0

; 128  : 			_Delete_this();

  0003f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00042	48 8b cf	 mov	 rcx, rdi
  00045	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00048	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi

; 427  : 		_Ptr = _Other_ptr;

  0004c	48 89 2b	 mov	 QWORD PTR [rbx], rbp
$LN13@Reset0:
  0004f	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
$LN7@Reset0:

; 428  : 		}

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0005e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN11@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00069	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  0006d	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00070	eb dd		 jmp	 SHORT $LN13@Reset0
$LN12@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00072	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  00076	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00079	eb d9		 jmp	 SHORT $LN7@Reset0
?_Reset0@?$_Ptr_base@VCave@@@std@@QEAAXPEAVCave@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<Cave>::_Reset0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@VLine@geom@@V12@@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SAXAEAV?$allocator@VLine@geom@@@1@PEAVLine@geom@@$$QEAV34@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@VLine@geom@@V12@@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SAXAEAV?$allocator@VLine@geom@@@1@PEAVLine@geom@@$$QEAV34@@Z PROC ; std::allocator_traits<std::allocator<geom::Line> >::construct<geom::Line,geom::Line>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 36		 je	 SHORT $LN7@construct
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	89 02		 mov	 DWORD PTR [rdx], eax
  0000a	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  0000e	89 42 04	 mov	 DWORD PTR [rdx+4], eax
  00011	41 8b 40 08	 mov	 eax, DWORD PTR [r8+8]
  00015	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  00018	41 8b 40 0c	 mov	 eax, DWORD PTR [r8+12]
  0001c	89 42 0c	 mov	 DWORD PTR [rdx+12], eax
  0001f	41 8b 40 10	 mov	 eax, DWORD PTR [r8+16]
  00023	89 42 10	 mov	 DWORD PTR [rdx+16], eax
  00026	41 8b 40 14	 mov	 eax, DWORD PTR [r8+20]
  0002a	89 42 14	 mov	 DWORD PTR [rdx+20], eax
  0002d	41 8b 40 18	 mov	 eax, DWORD PTR [r8+24]
  00031	89 42 18	 mov	 DWORD PTR [rdx+24], eax
  00034	41 8b 40 1c	 mov	 eax, DWORD PTR [r8+28]
  00038	89 42 1c	 mov	 DWORD PTR [rdx+28], eax
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0003b	f3 c3		 fatret	 0
??$construct@VLine@geom@@V12@@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SAXAEAV?$allocator@VLine@geom@@@1@PEAVLine@geom@@$$QEAV34@@Z ENDP ; std::allocator_traits<std::allocator<geom::Line> >::construct<geom::Line,geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$shared_ptr@VCave@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VCave@@@0@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@V?$shared_ptr@VCave@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VCave@@@0@0@Z PROC ; std::_Ptr_cat<std::shared_ptr<Cave>,std::shared_ptr<Cave> >, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00005	0f b6 44 24 10	 movzx	 eax, BYTE PTR _Cat$[rsp]

; 440  : 	}

  0000a	c3		 ret	 0
??$_Ptr_cat@V?$shared_ptr@VCave@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VCave@@@0@0@Z ENDP ; std::_Ptr_cat<std::shared_ptr<Cave>,std::shared_ptr<Cave> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
__formal$dead$ = 72
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > > >, COMDAT

; 87   : 	{	// destroy [_First, _Last), arbitrary type

$LN31:

; 88   : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5c		 je	 SHORT $LN29@Destroy_ra
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 87   : 	{	// destroy [_First, _Last), arbitrary type

  00014	48 8b f2	 mov	 rsi, rdx

; 88   : 	for (; _First != _Last; ++_First)

  00017	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL3@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN23@Destroy_ra

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN23@Destroy_ra

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN23@Destroy_ra

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN23@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL3@Destroy_ra
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 89   : 		_Al.destroy(_First);
; 90   : 	}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN29@Destroy_ra:
  00061	f3 c3		 fatret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VCave@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@VLine@geom@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAVLine@geom@@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@VLine@geom@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAVLine@geom@@0@Z PROC ; std::_Ptr_cat<geom::Line,geom::Line>, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00005	0f b6 44 24 10	 movzx	 eax, BYTE PTR _Cat$[rsp]

; 440  : 	}

  0000a	c3		 ret	 0
??$_Ptr_cat@VLine@geom@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAVLine@geom@@0@Z ENDP ; std::_Ptr_cat<geom::Line,geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAXPEAVLine@geom@@0AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAXPEAVLine@geom@@0AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<geom::Line> > >, COMDAT

; 88   : 	for (; _First != _Last; ++_First)
; 89   : 		_Al.destroy(_First);
; 90   : 	}

  00000	c2 00 00	 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAXPEAVLine@geom@@0AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<geom::Line> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAVLine@geom@@PEAV12@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAVLine@geom@@PEAV12@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z PROC ; std::_Uninitialized_move<geom::Line * __ptr64,geom::Line * __ptr64,std::_Wrap_alloc<std::allocator<geom::Line> > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAVLine@geom@@PEAV12@V?$allocator@VLine@geom@@@std@@V12@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<geom::Line * __ptr64,geom::Line * __ptr64,std::allocator<geom::Line>,geom::Line>

; 474  : 	}

  00009	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000d	c3		 ret	 0
??$_Uninitialized_move@PEAVLine@geom@@PEAV12@U?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<geom::Line * __ptr64,geom::Line * __ptr64,std::_Wrap_alloc<std::allocator<geom::Line> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@VLine@geom@@V12@@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@$$QEAV23@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@VLine@geom@@V12@@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@$$QEAV23@@Z PROC ; std::allocator<geom::Line>::construct<geom::Line,geom::Line>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 36		 je	 SHORT $LN3@construct
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00005	41 8b 00	 mov	 eax, DWORD PTR [r8]
  00008	89 02		 mov	 DWORD PTR [rdx], eax
  0000a	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  0000e	89 42 04	 mov	 DWORD PTR [rdx+4], eax
  00011	41 8b 40 08	 mov	 eax, DWORD PTR [r8+8]
  00015	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  00018	41 8b 40 0c	 mov	 eax, DWORD PTR [r8+12]
  0001c	89 42 0c	 mov	 DWORD PTR [rdx+12], eax
  0001f	41 8b 40 10	 mov	 eax, DWORD PTR [r8+16]
  00023	89 42 10	 mov	 DWORD PTR [rdx+16], eax
  00026	41 8b 40 14	 mov	 eax, DWORD PTR [r8+20]
  0002a	89 42 14	 mov	 DWORD PTR [rdx+20], eax
  0002d	41 8b 40 18	 mov	 eax, DWORD PTR [r8+24]
  00031	89 42 18	 mov	 DWORD PTR [rdx+24], eax
  00034	41 8b 40 1c	 mov	 eax, DWORD PTR [r8+28]
  00038	89 42 1c	 mov	 DWORD PTR [rdx+28], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0003b	f3 c3		 fatret	 0
??$construct@VLine@geom@@V12@@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@$$QEAV23@@Z ENDP ; std::allocator<geom::Line>::construct<geom::Line,geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::destroy<std::shared_ptr<Cave> >, COMDAT

; 907  : 		void destroy(_Ty *_Ptr)

$LN23:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN18@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN21@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN21@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN21@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN18@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 910  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VCave@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<Cave> > >::destroy<std::shared_ptr<Cave> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@VLine@geom@@@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@VLine@geom@@@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@@Z PROC ; std::_Wrap_alloc<std::allocator<geom::Line> >::destroy<geom::Line>, COMDAT

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@VLine@geom@@@?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@std@@QEAAXPEAVLine@geom@@@Z ENDP ; std::_Wrap_alloc<std::allocator<geom::Line> >::destroy<geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAVLine@geom@@@std@@YAPEAVLine@geom@@PEAV12@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAVLine@geom@@@std@@YAPEAVLine@geom@@PEAV12@@Z PROC ; std::_Val_type<geom::Line * __ptr64>, COMDAT

; 711  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 712  : 	}

  00002	c3		 ret	 0
??$_Val_type@PEAVLine@geom@@@std@@YAPEAVLine@geom@@PEAV12@@Z ENDP ; std::_Val_type<geom::Line * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAVLine@geom@@PEAV12@V?$allocator@VLine@geom@@@std@@V12@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_move@PEAVLine@geom@@PEAV12@V?$allocator@VLine@geom@@@std@@V12@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<geom::Line * __ptr64,geom::Line * __ptr64,std::allocator<geom::Line>,geom::Line>, COMDAT

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5a		 je	 SHORT $LN4@Uninit_mov
  00005	4d 8d 48 18	 lea	 r9, QWORD PTR [r8+24]
  00009	48 83 c1 18	 add	 rcx, 24
  0000d	0f 1f 00	 npad	 3
$LL6@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00010	4d 85 c0	 test	 r8, r8
  00013	74 35		 je	 SHORT $LN24@Uninit_mov
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00015	8b 41 e8	 mov	 eax, DWORD PTR [rcx-24]
  00018	41 89 00	 mov	 DWORD PTR [r8], eax
  0001b	8b 41 ec	 mov	 eax, DWORD PTR [rcx-20]
  0001e	41 89 41 ec	 mov	 DWORD PTR [r9-20], eax
  00022	8b 41 f0	 mov	 eax, DWORD PTR [rcx-16]
  00025	41 89 41 f0	 mov	 DWORD PTR [r9-16], eax
  00029	8b 41 f4	 mov	 eax, DWORD PTR [rcx-12]
  0002c	41 89 41 f4	 mov	 DWORD PTR [r9-12], eax
  00030	8b 41 f8	 mov	 eax, DWORD PTR [rcx-8]
  00033	41 89 41 f8	 mov	 DWORD PTR [r9-8], eax
  00037	8b 41 fc	 mov	 eax, DWORD PTR [rcx-4]
  0003a	41 89 41 fc	 mov	 DWORD PTR [r9-4], eax
  0003e	8b 01		 mov	 eax, DWORD PTR [rcx]
  00040	41 89 01	 mov	 DWORD PTR [r9], eax
  00043	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00046	41 89 41 04	 mov	 DWORD PTR [r9+4], eax
$LN24@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  0004a	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0004e	49 83 c0 20	 add	 r8, 32			; 00000020H
  00052	49 83 c1 20	 add	 r9, 32			; 00000020H
  00056	48 8d 41 e8	 lea	 rax, QWORD PTR [rcx-24]
  0005a	48 3b c2	 cmp	 rax, rdx
  0005d	75 b1		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 433  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 434  : 	_CATCH_ALL
; 435  : 	for (; _Next != _Dest; ++_Next)
; 436  : 		_Al.destroy(_Next);
; 437  : 	_RERAISE;
; 438  : 	_CATCH_END
; 439  : 	return (_Dest);

  0005f	49 8b c0	 mov	 rax, r8

; 440  : 	}

  00062	c3		 ret	 0
??$_Uninit_move@PEAVLine@geom@@PEAV12@V?$allocator@VLine@geom@@@std@@V12@@std@@YAPEAVLine@geom@@PEAV12@00AEAU?$_Wrap_alloc@V?$allocator@VLine@geom@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<geom::Line * __ptr64,geom::Line * __ptr64,std::allocator<geom::Line>,geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
;	COMDAT ??0Line@geom@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Line@geom@@QEAA@AEBV01@@Z PROC			; geom::Line::Line, COMDAT

; 10   : {

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	89 01		 mov	 DWORD PTR [rcx], eax
  00004	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00007	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0000a	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  0000d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00010	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]
  00013	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
  00016	8b 42 10	 mov	 eax, DWORD PTR [rdx+16]
  00019	89 41 10	 mov	 DWORD PTR [rcx+16], eax
  0001c	8b 42 14	 mov	 eax, DWORD PTR [rdx+20]
  0001f	89 41 14	 mov	 DWORD PTR [rcx+20], eax
  00022	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  00025	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  00028	8b 42 1c	 mov	 eax, DWORD PTR [rdx+28]
  0002b	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
  0002e	48 8b c1	 mov	 rax, rcx
  00031	c3		 ret	 0
??0Line@geom@@QEAA@AEBV01@@Z ENDP			; geom::Line::Line
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<Cave> > >::destroy<std::shared_ptr<Cave> >, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN16@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN19@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN19@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN19@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 758  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VCave@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VCave@@@std@@@1@PEAV?$shared_ptr@VCave@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<Cave> > >::destroy<std::shared_ptr<Cave> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@VLine@geom@@@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SAXAEAV?$allocator@VLine@geom@@@1@PEAVLine@geom@@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$dead$ = 16
??$destroy@VLine@geom@@@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SAXAEAV?$allocator@VLine@geom@@@1@PEAVLine@geom@@@Z PROC ; std::allocator_traits<std::allocator<geom::Line> >::destroy<geom::Line>, COMDAT

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);
; 758  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@VLine@geom@@@?$allocator_traits@V?$allocator@VLine@geom@@@std@@@std@@SAXAEAV?$allocator@VLine@geom@@@1@PEAVLine@geom@@@Z ENDP ; std::allocator_traits<std::allocator<geom::Line> >::destroy<geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z PROC ; std::allocator<std::shared_ptr<Cave> >::destroy<std::shared_ptr<Cave> >, COMDAT

; 621  : 		void destroy(_Uty *_Ptr)

$LN19:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN14@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN17@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN17@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN17@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN14@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VCave@@@std@@@?$allocator@V?$shared_ptr@VCave@@@std@@@std@@QEAAXPEAV?$shared_ptr@VCave@@@1@@Z ENDP ; std::allocator<std::shared_ptr<Cave> >::destroy<std::shared_ptr<Cave> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@VLine@geom@@@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$dead$ = 16
??$destroy@VLine@geom@@@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@@Z PROC ; std::allocator<geom::Line>::destroy<geom::Line>, COMDAT

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@VLine@geom@@@?$allocator@VLine@geom@@@std@@QEAAXPEAVLine@geom@@@Z ENDP ; std::allocator<geom::Line>::destroy<geom::Line>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z PROC		; std::shared_ptr<Cave>::`scalar deleting destructor', COMDAT
$LN20:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  0000a	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 35		 je	 SHORT $LN17@scalar

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00016	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0001a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001f	75 17		 jne	 SHORT $LN16@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00021	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00024	48 8b cb	 mov	 rcx, rbx
  00027	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00029	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0002d	75 09		 jne	 SHORT $LN16@scalar

; 128  : 			_Delete_this();

  0002f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00032	48 8b cb	 mov	 rcx, rbx
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
$LN16@scalar:
  00038	48 8b c7	 mov	 rax, rdi
  0003b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00040	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN17@scalar:
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
??_G?$shared_ptr@VCave@@@std@@QEAAPEAXI@Z ENDP		; std::shared_ptr<Cave>::`scalar deleting destructor'
_TEXT	ENDS
END
