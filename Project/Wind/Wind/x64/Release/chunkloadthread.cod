; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?loaderThread@@3HA				; loaderThread
EXTRN	_time64:PROC
?loaderThread@@3HA DD 01H DUP (?)			; loaderThread
_BSS	ENDS
$SG4294961463 DB 'generateTerrain_p1', 00H
PUBLIC	?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty
PUBLIC	?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkLoad
PUBLIC	?tick@ChunkLoadThread@@MEAA_NXZ			; ChunkLoadThread::tick
PUBLIC	?preStart@ChunkLoadThread@@MEAAXXZ		; ChunkLoadThread::preStart
PUBLIC	??0id@locale@std@@QEAA@_K@Z			; std::locale::id::id
PUBLIC	?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
PUBLIC	?id@?$numpunct@_W@std@@2V0locale@2@A		; std::numpunct<wchar_t>::id
PUBLIC	?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
PUBLIC	?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::noise2
PUBLIC	?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A	; ChunkLoadThread::noiseBuffer
PUBLIC	?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A	; ChunkLoadThread::noise2Buffer
PUBLIC	?program@ChunkLoadThread@@2VProgram@cl@@A	; ChunkLoadThread::program
PUBLIC	?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::noise
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
_BSS	ENDS
;	COMDAT ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@_W@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@_W@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<wchar_t>::id
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A DQ 01H DUP (?) ; std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::id
	ALIGN	4

?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A DB 020H DUP (?) ; ChunkLoadThread::noise2
ignore	DB	01H DUP (?)
	ALIGN	4

?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A DB 018H DUP (?) ; ChunkLoadThread::noiseBuffer
allocator_arg DB 01H DUP (?)
	ALIGN	4

?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A DB 018H DUP (?) ; ChunkLoadThread::noise2Buffer
piecewise_construct DB 01H DUP (?)
	ALIGN	4

?program@ChunkLoadThread@@2VProgram@cl@@A DB 030H DUP (?) ; ChunkLoadThread::program
?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A DB 020H DUP (?) ; ChunkLoadThread::noise
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DQ 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@ChunkLoadThread@@MEAA_NXZ DD imagerel $LN320
	DD	imagerel $LN320+1561
	DD	imagerel $unwind$?tick@ChunkLoadThread@@MEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?preStart@ChunkLoadThread@@MEAAXXZ DD imagerel $LN10
	DD	imagerel $LN10+186
	DD	imagerel $unwind$?preStart@ChunkLoadThread@@MEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ DD imagerel ??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ
	DD	imagerel ??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ+58
	DD	imagerel $unwind$??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ DD imagerel ??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ
	DD	imagerel ??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ+58
	DD	imagerel $unwind$??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD imagerel ??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	imagerel ??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+76
	DD	imagerel $unwind$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+182
	DD	imagerel $unwind$??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD imagerel ??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
	DD	imagerel ??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ+182
	DD	imagerel $unwind$??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD imagerel ??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+25
	DD	00H
	DD	imagerel ??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ+60
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?preStart@ChunkLoadThread@@MEAAXXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tick@ChunkLoadThread@@MEAA_NXZ DD imagerel ?tick@ChunkLoadThread@@MEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+159
	DD	00H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+1224
	DD	01H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+1380
	DD	00H
	DD	imagerel ?tick@ChunkLoadThread@@MEAA_NXZ+1470
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tick@ChunkLoadThread@@MEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tick@ChunkLoadThread@@MEAA_NXZ DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	0d0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@ChunkLoadThread@@MEAA_NXZ DD 0d3919H
	DD	02f742bH
	DD	02e6427H
	DD	02d3423H
	DD	0260117H
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?tick@ChunkLoadThread@@MEAA_NXZ
	DD	0122H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
?noise$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; ChunkLoadThread::noise$initializer$
?noise2$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; ChunkLoadThread::noise2$initializer$
?program$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ; ChunkLoadThread::program$initializer$
?noiseBuffer$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ ; ChunkLoadThread::noiseBuffer$initializer$
?noise2Buffer$initializer$@ChunkLoadThread@@2P6AXXZEA DQ FLAT:??__E?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ ; ChunkLoadThread::noise2Buffer$initializer$
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
;	COMDAT time
_TEXT	SEGMENT
_Time$dead$ = 8
time	PROC						; COMDAT

; 133  :     return _time64(_Time);

  00000	33 c9		 xor	 ecx, ecx
  00002	e9 00 00 00 00	 jmp	 _time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xlocale
;	COMDAT ??0id@locale@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??0id@locale@std@@QEAA@_K@Z PROC			; std::locale::id::id, COMDAT

; 74   : 			{	// construct with specified stamp value

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 75   : 			}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0id@locale@std@@QEAA@_K@Z ENDP			; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::noise'', COMDAT

; 6    : Noise::NoiseGenerator3D ChunkLoadThread::noise(4, 8, 2.5, time(0));

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  0000a	33 c9		 xor	 ecx, ecx
  0000c	e8 00 00 00 00	 call	 _time64
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 107  : {

  00011	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00016	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A, 4
  00020	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40200000
  00028	f3 0f 11 05 0c
	00 00 00	 movss	 DWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+12, xmm0
  00030	c7 05 04 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4, 16
  0003a	c7 05 08 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+8, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  00044	48 8b d8	 mov	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 107  : {

  00047	89 05 10 00 00
	00		 mov	 DWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+16, eax
  0004d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 108  : 	srand(seed);

  00052	8b cb		 mov	 ecx, ebx
  00054	48 89 05 18 00
	00 00		 mov	 QWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24, rax
  0005b	e8 00 00 00 00	 call	 srand

; 109  : 	for(int i = 0; i < size * size * size; i++)

  00060	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
  00066	33 db		 xor	 ebx, ebx
  00068	8b c8		 mov	 ecx, eax
  0006a	8b fb		 mov	 edi, ebx
  0006c	0f af c8	 imul	 ecx, eax
  0006f	0f af c8	 imul	 ecx, eax
  00072	85 c9		 test	 ecx, ecx
  00074	7e 2a		 jle	 SHORT $LN5@noise
$LL7@noise:

; 110  : 	{
; 111  : 		noiseMap[i] = rand() & 1;

  00076	e8 00 00 00 00	 call	 rand
  0007b	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24
  00082	ff c3		 inc	 ebx
  00084	24 01		 and	 al, 1
  00086	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
  0008a	88 44 0f ff	 mov	 BYTE PTR [rdi+rcx-1], al
  0008e	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
  00094	8b c8		 mov	 ecx, eax
  00096	0f af c8	 imul	 ecx, eax
  00099	0f af c8	 imul	 ecx, eax
  0009c	3b d9		 cmp	 ebx, ecx
  0009e	7c d6		 jl	 SHORT $LL7@noise
$LN5@noise:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 6    : Noise::NoiseGenerator3D ChunkLoadThread::noise(4, 8, 2.5, time(0));

  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::noise''
  000a7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b0	5f		 pop	 rdi
  000b1	e9 00 00 00 00	 jmp	 atexit
??__E?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::noise''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::noise'', COMDAT

; 117  : 	delete[] noiseMap;

  00000	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24
  00007	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??__F?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::noise''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yc	SEGMENT
??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::noise2'', COMDAT

; 7    : Noise::NoiseGenerator3D ChunkLoadThread::noise2(4, 8, 2.5, time(0) + 50);

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\time.inl

; 133  :     return _time64(_Time);

  0000a	33 c9		 xor	 ecx, ecx
  0000c	e8 00 00 00 00	 call	 _time64
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 107  : {

  00011	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00016	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A, 4
  00020	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40200000
  00028	f3 0f 11 05 0c
	00 00 00	 movss	 DWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+12, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 7    : Noise::NoiseGenerator3D ChunkLoadThread::noise2(4, 8, 2.5, time(0) + 50);

  00030	8d 58 32	 lea	 ebx, DWORD PTR [rax+50]
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp

; 107  : {

  00033	c7 05 04 00 00
	00 10 00 00 00	 mov	 DWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4, 16
  0003d	c7 05 08 00 00
	00 08 00 00 00	 mov	 DWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+8, 8
  00047	89 1d 10 00 00
	00		 mov	 DWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+16, ebx
  0004d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 108  : 	srand(seed);

  00052	8b cb		 mov	 ecx, ebx
  00054	48 89 05 18 00
	00 00		 mov	 QWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24, rax
  0005b	e8 00 00 00 00	 call	 srand

; 109  : 	for(int i = 0; i < size * size * size; i++)

  00060	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
  00066	33 db		 xor	 ebx, ebx
  00068	8b c8		 mov	 ecx, eax
  0006a	8b fb		 mov	 edi, ebx
  0006c	0f af c8	 imul	 ecx, eax
  0006f	0f af c8	 imul	 ecx, eax
  00072	85 c9		 test	 ecx, ecx
  00074	7e 2a		 jle	 SHORT $LN5@noise2
$LL7@noise2:

; 110  : 	{
; 111  : 		noiseMap[i] = rand() & 1;

  00076	e8 00 00 00 00	 call	 rand
  0007b	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24
  00082	ff c3		 inc	 ebx
  00084	24 01		 and	 al, 1
  00086	48 8d 7f 01	 lea	 rdi, QWORD PTR [rdi+1]
  0008a	88 44 0f ff	 mov	 BYTE PTR [rdi+rcx-1], al
  0008e	8b 05 04 00 00
	00		 mov	 eax, DWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+4
  00094	8b c8		 mov	 ecx, eax
  00096	0f af c8	 imul	 ecx, eax
  00099	0f af c8	 imul	 ecx, eax
  0009c	3b d9		 cmp	 ebx, ecx
  0009e	7c d6		 jl	 SHORT $LL7@noise2
$LN5@noise2:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 7    : Noise::NoiseGenerator3D ChunkLoadThread::noise2(4, 8, 2.5, time(0) + 50);

  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::noise2''
  000a7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ac	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b0	5f		 pop	 rdi
  000b1	e9 00 00 00 00	 jmp	 atexit
??__E?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::noise2''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__F?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ
text$yd	SEGMENT
??__F?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::noise2'', COMDAT

; 117  : 	delete[] noiseMap;

  00000	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24
  00007	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
??__F?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::noise2''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::program'', COMDAT

; 9    : cl::Program ChunkLoadThread::program;

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 778  : 		this->_Myhead = _Buyheadnode();

  0000d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64> > > >::_Buyheadnode
  00012	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00019	ba 02 00 00 00	 mov	 edx, 2
  0001e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@ChunkLoadThread@@2VProgram@cl@@A+24
  00025	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN31@program

; 33   : 		_Throw_C_error(_Res);

  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN31@program:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 68   : {

  00035	c6 05 28 00 00
	00 00		 mov	 BYTE PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+40, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 9    : cl::Program ChunkLoadThread::program;

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::program''
  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	e9 00 00 00 00	 jmp	 atexit
??__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::program''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA PROC ; ``dynamic initializer for 'ChunkLoadThread::program'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::program
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@QEAA@XZ
?dtor$0@?0???__E?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ@4HA ENDP ; ``dynamic initializer for 'ChunkLoadThread::program'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__F?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ
text$yd	SEGMENT
??__F?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::program'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::program
  00007	e9 00 00 00 00	 jmp	 ??1Program@cl@@QEAA@XZ	; cl::Program::~Program
??__F?program@ChunkLoadThread@@2VProgram@cl@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::program''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ
text$yc	SEGMENT
??__E?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::noiseBuffer'', COMDAT

; 10   : cl::Buffer ChunkLoadThread::noiseBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::noiseBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__E?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::noiseBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ
text$yd	SEGMENT
??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::noiseBuffer'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 247  : 	if(okay)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A, 0
  0000b	74 28		 je	 SHORT $LN3@noiseBuffe

; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);

  0000d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A+8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 250  : 		if(error != CL_SUCCESS)

  0001a	85 c0		 test	 eax, eax
  0001c	74 17		 je	 SHORT $LN3@noiseBuffe

; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956356
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956355
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN3@noiseBuffe:
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??__F?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::noiseBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ??__E?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ
text$yc	SEGMENT
??__E?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ PROC ; `dynamic initializer for 'ChunkLoadThread::noise2Buffer'', COMDAT

; 11   : cl::Buffer ChunkLoadThread::noise2Buffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ ; `dynamic atexit destructor for 'ChunkLoadThread::noise2Buffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__E?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ ENDP ; `dynamic initializer for 'ChunkLoadThread::noise2Buffer''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ
text$yd	SEGMENT
??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'ChunkLoadThread::noise2Buffer'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 247  : 	if(okay)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A, 0
  0000b	74 28		 je	 SHORT $LN3@noise2Buff

; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);

  0000d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A+8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 250  : 		if(error != CL_SUCCESS)

  0001a	85 c0		 test	 eax, eax
  0001c	74 17		 je	 SHORT $LN3@noise2Buff

; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956356
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956355
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN3@noise2Buff:
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??__F?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'ChunkLoadThread::noise2Buffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?preStart@ChunkLoadThread@@MEAAXXZ
_TEXT	SEGMENT
error$1 = 64
this$ = 64
error$2 = 72
?preStart@ChunkLoadThread@@MEAAXXZ PROC			; ChunkLoadThread::preStart, COMDAT

; 14   : {

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00006	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?device@cl@@3PEAU_cl_device_id@@EA ; cl::device
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 14   : {

  0000d	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00017	4c 8d 4c 24 40	 lea	 r9, QWORD PTR error$1[rsp]
  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR error$1[rsp], 0
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateCommandQueue

; 56   : 	if(error != CL_SUCCESS)

  0002d	83 7c 24 40 00	 cmp	 DWORD PTR error$1[rsp], 0
  00032	48 89 83 38 08
	00 00		 mov	 QWORD PTR [rbx+2104], rax
  00039	74 15		 je	 SHORT $LN3@preStart

; 57   : 	{
; 58   : 		GLWindow::instance->postError("Could not create command queue", "Command queue creation error");

  0003b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956381
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956380
  00049	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 59   : 		return false;

  0004e	eb 07		 jmp	 SHORT $LN4@preStart
$LN3@preStart:

; 60   : 	}
; 61   : 
; 62   : 	okay = true;

  00050	c6 83 40 08 00
	00 01		 mov	 BYTE PTR [rbx+2112], 1
$LN4@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : cl::Program::Program()
; 67   : 	: okay(false)
; 68   : {
; 69   : 
; 70   : }
; 71   : 
; 72   : cl::Program::Program(std::wstring fileName)
; 73   : 	: okay(false), preparedKernel(0)
; 74   : {
; 75   : 	create(fileName);
; 76   : }
; 77   : 
; 78   : bool cl::Program::create(std::wstring fileName)
; 79   : {
; 80   : 	cl_int error = 0;
; 81   : 
; 82   : 	std::ifstream file(fileName);
; 83   : 
; 84   : 	if(!file.good())
; 85   : 	{
; 86   : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 87   : 		file.close();
; 88   : 		return false;
; 89   : 	}
; 90   : 
; 91   : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 92   : 	file.close();
; 93   : 	const char* source = source_str.c_str();
; 94   : 
; 95   : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 96   : 	if(error != CL_SUCCESS)
; 97   : 	{
; 98   : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 99   : 		return false;
; 100  : 	}
; 101  : 
; 102  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 103  : 	if(error != CL_SUCCESS)
; 104  : 	{
; 105  : 		size_t log_size;
; 106  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 107  : 		char* log_msg = new char[log_size + 1];
; 108  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 109  : 
; 110  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 111  : 
; 112  : 		delete[] log_msg;
; 113  : 		return false;
; 114  : 	}
; 115  : 
; 116  : 	okay = true;
; 117  : 	return true;
; 118  : }
; 119  : 
; 120  : cl::Program::~Program()
; 121  : {
; 122  : 	if(okay)
; 123  : 	{
; 124  : 		cl_int error;
; 125  : 
; 126  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 127  : 		{
; 128  : 			error = clReleaseKernel(iter->second);
; 129  : 			if(error != CL_SUCCESS)
; 130  : 			{
; 131  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 132  : 			}
; 133  : 		}
; 134  : 		error = clReleaseProgram(program);
; 135  : 		if(error != CL_SUCCESS)
; 136  : 		{
; 137  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 138  : 		}
; 139  : 	}
; 140  : }
; 141  : 
; 142  : cl_kernel cl::Program::getKernel(std::string kernel)
; 143  : {
; 144  : 	if(!okay) return 0;
; 145  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 146  : 	if(it != kernels.end())
; 147  : 	{
; 148  : 		return it->second;
; 149  : 	}
; 150  : 
; 151  : 	cl_int error = 0;
; 152  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 153  : 
; 154  : 	if(error == CL_SUCCESS)
; 155  : 	{
; 156  : 		kernels[kernel] = k;
; 157  : 		return k;
; 158  : 	}
; 159  : 
; 160  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 161  : 	return 0;
; 162  : }
; 163  : 
; 164  : bool cl::Program::prepare(std::string kernel)
; 165  : {
; 166  : 	cl_kernel k = getKernel(kernel);
; 167  : 
; 168  : 	if(k)
; 169  : 	{
; 170  : 		mut.lock();
; 171  : 		preparedKernel = k;
; 172  : 		return true;
; 173  : 	}
; 174  : 	else
; 175  : 	{
; 176  : 		return false;
; 177  : 	}
; 178  : }
; 179  : 
; 180  : bool cl::Program::setArgument(int index, size_t size, const void* value)
; 181  : {
; 182  : 	if(!preparedKernel)
; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 185  : 		return false;
; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);
; 188  : 	if(error != CL_SUCCESS)
; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 191  : 		return false;
; 192  : 	}
; 193  : 	return true;
; 194  : }
; 195  : 
; 196  : bool cl::Program::setArgument(int index, size_t size, Buffer* value)
; 197  : {
; 198  : 	return setArgument(index, size, &value->mem);
; 199  : }
; 200  : 
; 201  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 202  : {
; 203  : 	if(!preparedKernel)
; 204  : 	{
; 205  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 206  : 		return false;
; 207  : 	}
; 208  : 
; 209  : 	cl_int error;
; 210  : 	cl_event event;
; 211  : 
; 212  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 213  : 	if(error != CL_SUCCESS)
; 214  : 	{
; 215  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 216  : 		return false;
; 217  : 	}
; 218  : 
; 219  : 	error = clWaitForEvents(1, &event);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to wait for kernel finish event", "OpenCL program execution error");
; 223  : 		return false;
; 224  : 	}
; 225  : 
; 226  : 	error = clReleaseEvent(event);
; 227  : 	if(error != CL_SUCCESS)
; 228  : 	{
; 229  : 		GLWindow::instance->postError("Failed to release kernel finish event", "OpenCL program execution error");
; 230  : 		return false;
; 231  : 	}
; 232  : 
; 233  : 	preparedKernel = 0;
; 234  : 	mut.unlock();
; 235  : 
; 236  : 	return true;
; 237  : }
; 238  : 
; 239  : cl::Buffer::Buffer()
; 240  : 	: okay(false)
; 241  : {
; 242  : 
; 243  : }
; 244  : 
; 245  : cl::Buffer::~Buffer()
; 246  : {
; 247  : 	if(okay)
; 248  : 	{
; 249  : 		cl_int error = clReleaseMemObject(mem);
; 250  : 		if(error != CL_SUCCESS)
; 251  : 		{
; 252  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 253  : 		}
; 254  : 	}
; 255  : }
; 256  : 
; 257  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 258  : {
; 259  : 	cl_int error;
; 260  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  0005e	45 33 c9	 xor	 r9d, r9d
  00061	48 8d 44 24 48	 lea	 rax, QWORD PTR error$2[rsp]
  00066	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  0006a	41 b8 00 20 00
	00		 mov	 r8d, 8192		; 00002000H
  00070	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 261  : 	if(error != CL_SUCCESS)

  0007b	83 7c 24 48 00	 cmp	 DWORD PTR error$2[rsp], 0
  00080	48 89 83 50 08
	00 00		 mov	 QWORD PTR [rbx+2128], rax
  00087	74 19		 je	 SHORT $LN6@preStart

; 262  : 	{
; 263  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00089	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956354
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956353
  00097	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 17   : }

  0009c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a0	5b		 pop	 rbx
  000a1	c3		 ret	 0
$LN6@preStart:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 267  : 	this->size = size;

  000a2	48 c7 83 58 08
	00 00 00 20 00
	00		 mov	 QWORD PTR [rbx+2136], 8192 ; 00002000H

; 268  : 	okay = true;

  000ad	c6 83 48 08 00
	00 01		 mov	 BYTE PTR [rbx+2120], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 17   : }

  000b4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b8	5b		 pop	 rbx
  000b9	c3		 ret	 0
?preStart@ChunkLoadThread@@MEAAXXZ ENDP			; ChunkLoadThread::preStart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?tick@ChunkLoadThread@@MEAA_NXZ
_TEXT	SEGMENT
c$1 = 80
chunkZ$ = 96
chunkY$ = 100
chunkX$ = 104
$T2 = 112
event$3 = 128
$T4 = 136
$T5 = 144
$T6 = 160
chunk$ = 192
$T7 = 208
$T8 = 216
global_ws$ = 240
local_ws$ = 264
__$ArrayPad$ = 288
this$ = 352
?tick@ChunkLoadThread@@MEAA_NXZ PROC			; ChunkLoadThread::tick, COMDAT

; 20   : {

$LN320:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d 68 a8	 lea	 rbp, QWORD PTR [rax-88]
  00010	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00017	48 c7 45 d0 fe
	ff ff ff	 mov	 QWORD PTR $T7[rbp-256], -2
  0001f	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00023	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  00027	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00032	48 33 c4	 xor	 rax, rsp
  00035	48 89 45 20	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00039	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  0003c	48 83 b9 80 08
	00 00 00	 cmp	 QWORD PTR [rcx+2176], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 21   : 	if(ChunkLoadThread::loadQueue.empty())

  00044	0f 84 a0 05 00
	00		 je	 $LN292@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  0004a	48 8d 55 d8	 lea	 rdx, QWORD PTR $T8[rbp-256]
  0004e	48 81 c1 60 08
	00 00		 add	 rcx, 2144		; 00000860H
  00055	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  0005a	48 8b c8	 mov	 rcx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0005d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00060	45 33 f6	 xor	 r14d, r14d
  00063	48 85 c0	 test	 rax, rax
  00066	75 05		 jne	 SHORT $LN43@tick
  00068	41 8b c6	 mov	 eax, r14d
  0006b	eb 03		 jmp	 SHORT $LN44@tick
$LN43@tick:
  0006d	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN44@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00070	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00074	48 ff ca	 dec	 rdx
  00077	48 23 51 10	 and	 rdx, QWORD PTR [rcx+16]

; 1426 : 		return (*begin());

  0007b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007f	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00083	48 8b 72 08	 mov	 rsi, QWORD PTR [rdx+8]
  00087	48 89 75 88	 mov	 QWORD PTR $T4[rbp-256], rsi
  0008b	4c 8b 2a	 mov	 r13, QWORD PTR [rdx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0008e	48 85 f6	 test	 rsi, rsi
  00091	74 04		 je	 SHORT $LN64@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00093	f0 ff 46 08	 lock inc DWORD PTR [rsi+8]
$LN64@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00097	48 89 75 c8	 mov	 QWORD PTR chunk$[rbp-248], rsi

; 427  : 		_Ptr = _Other_ptr;

  0009b	4c 89 6d c0	 mov	 QWORD PTR chunk$[rbp-256], r13
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 160  : 		c.pop_front();

  0009f	48 8d 8b 60 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2144]
  000a6	e8 00 00 00 00	 call	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 29   : 	const int chunkX = chunk->pos.x;

  000ab	41 8b 45 18	 mov	 eax, DWORD PTR [r13+24]
  000af	89 44 24 68	 mov	 DWORD PTR chunkX$[rsp], eax

; 30   : 	const int chunkY = chunk->pos.y;

  000b3	41 8b 45 1c	 mov	 eax, DWORD PTR [r13+28]
  000b7	89 44 24 64	 mov	 DWORD PTR chunkY$[rsp], eax

; 31   : 	const int chunkZ = chunk->pos.z;

  000bb	41 8b 45 20	 mov	 eax, DWORD PTR [r13+32]
  000bf	89 44 24 60	 mov	 DWORD PTR chunkZ$[rsp], eax

; 32   : 
; 33   : 	const size_t local_ws[] = {1, 1, 1};

  000c3	bf 01 00 00 00	 mov	 edi, 1
  000c8	48 89 7d 08	 mov	 QWORD PTR local_ws$[rbp-256], rdi
  000cc	48 89 7d 10	 mov	 QWORD PTR local_ws$[rbp-248], rdi
  000d0	48 89 7d 18	 mov	 QWORD PTR local_ws$[rbp-240], rdi

; 34   : 	const size_t global_ws[] = {16, 16, 16};

  000d4	48 c7 45 f0 10
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-256], 16
  000dc	48 c7 45 f8 10
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-248], 16
  000e4	48 c7 45 00 10
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-240], 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  000ec	48 c7 45 b8 0f
	00 00 00	 mov	 QWORD PTR $T6[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000f4	4c 89 75 b0	 mov	 QWORD PTR $T6[rbp-240], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000f8	c6 45 a0 00	 mov	 BYTE PTR $T6[rbp-256], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  000fc	44 8d 47 11	 lea	 r8d, QWORD PTR [rdi+17]
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294961463
  00107	48 8d 4d a0	 lea	 rcx, QWORD PTR $T6[rbp-256]
  0010b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 36   : 	if(!program.prepare("generateTerrain_p1")) GlobalThread::stop = true;

  00110	48 8d 55 a0	 lea	 rdx, QWORD PTR $T6[rbp-256]
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::program
  0011b	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  00120	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00127	84 c0		 test	 al, al
  00129	0f 44 cf	 cmove	 ecx, edi
  0012c	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  00132	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+32
  00139	48 85 c9	 test	 rcx, rcx
  0013c	75 10		 jne	 SHORT $LN128@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  0013e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956368
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956367

; 185  : 		return false;

  0014c	eb 25		 jmp	 SHORT $LN313@tick
$LN128@tick:

; 191  : 		return false;
; 192  : 	}
; 193  : 	return true;
; 194  : }
; 195  : 
; 196  : bool cl::Program::setArgument(int index, size_t size, Buffer* value)
; 197  : {
; 198  : 	return setArgument(index, size, &value->mem);

  0014e	4c 8d 8b 50 08
	00 00		 lea	 r9, QWORD PTR [rbx+2128]

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00155	33 d2		 xor	 edx, edx
  00157	44 8d 42 08	 lea	 r8d, QWORD PTR [rdx+8]
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  00161	85 c0		 test	 eax, eax
  00163	74 1a		 je	 SHORT $LN19@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00165	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
$LN313@tick:
  00173	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 37   : 	if(!program.setArgument(0, sizeof(cl_mem), &blockBuffer)) GlobalThread::stop = true;

  00178	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dil ; GlobalThread::stop
$LN19@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  0017f	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+32
  00186	48 85 c9	 test	 rcx, rcx
  00189	75 10		 jne	 SHORT $LN132@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  0018b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956368
  00192	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956367

; 185  : 		return false;

  00199	eb 25		 jmp	 SHORT $LN314@tick
$LN132@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  0019b	4c 8d 4c 24 68	 lea	 r9, QWORD PTR chunkX$[rsp]
  001a0	41 b8 04 00 00
	00		 mov	 r8d, 4
  001a6	8b d7		 mov	 edx, edi
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  001ae	85 c0		 test	 eax, eax
  001b0	74 1a		 je	 SHORT $LN18@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  001b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  001b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
$LN314@tick:
  001c0	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 38   : 	if(!program.setArgument(1, sizeof(const int), &chunkX)) GlobalThread::stop = true;

  001c5	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dil ; GlobalThread::stop
$LN18@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  001cc	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+32
  001d3	48 85 c9	 test	 rcx, rcx
  001d6	75 10		 jne	 SHORT $LN136@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  001d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956368
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956367

; 185  : 		return false;

  001e6	eb 26		 jmp	 SHORT $LN315@tick
$LN136@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  001e8	4c 8d 4c 24 64	 lea	 r9, QWORD PTR chunkY$[rsp]
  001ed	ba 02 00 00 00	 mov	 edx, 2
  001f2	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  001fc	85 c0		 test	 eax, eax
  001fe	74 1a		 je	 SHORT $LN17@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00200	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00207	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
$LN315@tick:
  0020e	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 39   : 	if(!program.setArgument(2, sizeof(const int), &chunkY)) GlobalThread::stop = true;

  00213	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dil ; GlobalThread::stop
$LN17@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  0021a	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+32
  00221	48 85 c9	 test	 rcx, rcx
  00224	75 10		 jne	 SHORT $LN140@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00226	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956368
  0022d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956367

; 185  : 		return false;

  00234	eb 26		 jmp	 SHORT $LN316@tick
$LN140@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00236	4c 8d 4c 24 60	 lea	 r9, QWORD PTR chunkZ$[rsp]
  0023b	ba 03 00 00 00	 mov	 edx, 3
  00240	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  0024a	85 c0		 test	 eax, eax
  0024c	74 1a		 je	 SHORT $LN16@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  0024e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  00255	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
$LN316@tick:
  0025c	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 40   : 	if(!program.setArgument(3, sizeof(const int), &chunkZ)) GlobalThread::stop = true;

  00261	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dil ; GlobalThread::stop
$LN16@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  00268	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+32
  0026f	48 85 c9	 test	 rcx, rcx
  00272	75 10		 jne	 SHORT $LN146@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  00274	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956368
  0027b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956367

; 185  : 		return false;

  00282	eb 28		 jmp	 SHORT $LN317@tick
$LN146@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  00284	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A+8
  0028b	ba 04 00 00 00	 mov	 edx, 4
  00290	44 8d 42 04	 lea	 r8d, QWORD PTR [rdx+4]
  00294	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  0029a	85 c0		 test	 eax, eax
  0029c	74 1a		 je	 SHORT $LN15@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  0029e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  002a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
$LN317@tick:
  002ac	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 41   : 	if(!program.setArgument(4, sizeof(cl_mem), &noiseBuffer)) GlobalThread::stop = true;

  002b1	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dil ; GlobalThread::stop
$LN15@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 182  : 	if(!preparedKernel)

  002b8	48 8b 0d 20 00
	00 00		 mov	 rcx, QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+32
  002bf	48 85 c9	 test	 rcx, rcx
  002c2	75 10		 jne	 SHORT $LN152@tick

; 183  : 	{
; 184  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  002c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956368
  002cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956367

; 185  : 		return false;

  002d2	eb 28		 jmp	 SHORT $LN318@tick
$LN152@tick:

; 186  : 	}
; 187  : 	cl_int error = clSetKernelArg(preparedKernel, index, size, value);

  002d4	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A+8
  002db	ba 05 00 00 00	 mov	 edx, 5
  002e0	44 8d 42 03	 lea	 r8d, QWORD PTR [rdx+3]
  002e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 188  : 	if(error != CL_SUCCESS)

  002ea	85 c0		 test	 eax, eax
  002ec	74 1a		 je	 SHORT $LN14@tick

; 189  : 	{
; 190  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  002ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956366
  002f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956365
$LN318@tick:
  002fc	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 42   : 	if(!program.setArgument(5, sizeof(cl_mem), &noise2Buffer)) GlobalThread::stop = true;

  00301	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dil ; GlobalThread::stop
$LN14@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 203  : 	if(!preparedKernel)

  00308	48 8b 15 20 00
	00 00		 mov	 rdx, QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+32
  0030f	48 85 d2	 test	 rdx, rdx
  00312	75 13		 jne	 SHORT $LN158@tick

; 204  : 	{
; 205  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");

  00314	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956364
  0031b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956363

; 206  : 		return false;

  00322	e9 89 00 00 00	 jmp	 $LN319@tick
$LN158@tick:

; 207  : 	}
; 208  : 
; 209  : 	cl_int error;
; 210  : 	cl_event event;
; 211  : 
; 212  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);

  00327	48 8d 45 80	 lea	 rax, QWORD PTR event$3[rbp-256]
  0032b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00330	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00335	44 89 74 24 30	 mov	 DWORD PTR [rsp+48], r14d
  0033a	48 8d 45 08	 lea	 rax, QWORD PTR local_ws$[rbp-256]
  0033e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00343	48 8d 45 f0	 lea	 rax, QWORD PTR global_ws$[rbp-256]
  00347	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034c	45 33 c9	 xor	 r9d, r9d
  0034f	45 8d 41 03	 lea	 r8d, QWORD PTR [r9+3]
  00353	48 8b 8b 38 08
	00 00		 mov	 rcx, QWORD PTR [rbx+2104]
  0035a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueNDRangeKernel

; 213  : 	if(error != CL_SUCCESS)

  00360	85 c0		 test	 eax, eax
  00362	74 10		 je	 SHORT $LN157@tick

; 214  : 	{
; 215  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");

  00364	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956362
  0036b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956361

; 216  : 		return false;

  00372	eb 3c		 jmp	 SHORT $LN319@tick
$LN157@tick:

; 217  : 	}
; 218  : 
; 219  : 	error = clWaitForEvents(1, &event);

  00374	48 8d 55 80	 lea	 rdx, QWORD PTR event$3[rbp-256]
  00378	8b cf		 mov	 ecx, edi
  0037a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clWaitForEvents

; 220  : 	if(error != CL_SUCCESS)

  00380	85 c0		 test	 eax, eax
  00382	74 10		 je	 SHORT $LN156@tick

; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to wait for kernel finish event", "OpenCL program execution error");

  00384	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956360
  0038b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956359

; 223  : 		return false;

  00392	eb 1c		 jmp	 SHORT $LN319@tick
$LN156@tick:

; 224  : 	}
; 225  : 
; 226  : 	error = clReleaseEvent(event);

  00394	48 8b 4d 80	 mov	 rcx, QWORD PTR event$3[rbp-256]
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseEvent

; 227  : 	if(error != CL_SUCCESS)

  0039e	85 c0		 test	 eax, eax
  003a0	74 1c		 je	 SHORT $LN155@tick

; 228  : 	{
; 229  : 		GLWindow::instance->postError("Failed to release kernel finish event", "OpenCL program execution error");

  003a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294956358
  003a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294956357
$LN319@tick:
  003b0	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 43   : 	if(!program.invoke(queue, 3, global_ws, local_ws)) GlobalThread::stop = true;

  003b5	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, dil ; GlobalThread::stop
  003bc	eb 1e		 jmp	 SHORT $LN13@tick
$LN155@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 233  : 	preparedKernel = 0;

  003be	4c 89 35 20 00
	00 00		 mov	 QWORD PTR ?program@ChunkLoadThread@@2VProgram@cl@@A+32, r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  003c5	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@ChunkLoadThread@@2VProgram@cl@@A+24
  003cc	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  003d1	85 c0		 test	 eax, eax
  003d3	74 07		 je	 SHORT $LN13@tick

; 33   : 		_Throw_C_error(_Res);

  003d5	8b c8		 mov	 ecx, eax
  003d7	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN13@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 45   : 	if(!blockBuffer.read(queue, chunk->dataPtr())) GlobalThread::stop = true;

  003dc	49 8b 45 00	 mov	 rax, QWORD PTR [r13]
  003e0	49 8b cd	 mov	 rcx, r13
  003e3	ff 50 20	 call	 QWORD PTR [rax+32]
  003e6	48 8d 8b 48 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2120]
  003ed	48 8d 93 38 08
	00 00		 lea	 rdx, QWORD PTR [rbx+2104]
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 339  : 	return read(queue, 0, size, data);

  003f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f9	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  003fd	e8 00 00 00 00	 call	 ?read@Buffer@cl@@QEAA_NAEAVCommandQueue@2@_K1PEAX@Z ; cl::Buffer::read
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 45   : 	if(!blockBuffer.read(queue, chunk->dataPtr())) GlobalThread::stop = true;

  00402	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00409	84 c0		 test	 al, al
  0040b	0f 44 cf	 cmove	 ecx, edi
  0040e	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00414	49 8d 4d 28	 lea	 rcx, QWORD PTR [r13+40]
  00418	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0041d	85 c0		 test	 eax, eax
  0041f	74 07		 je	 SHORT $LN182@tick

; 33   : 		_Throw_C_error(_Res);

  00421	8b c8		 mov	 ecx, eax
  00423	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN182@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 95   : 	renderUpdateNeeded = flag;

  00428	66 41 c7 45 08
	01 01		 mov	 WORD PTR [r13+8], 257	; 00000101H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0042f	49 8d 4d 28	 lea	 rcx, QWORD PTR [r13+40]
  00433	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00438	85 c0		 test	 eax, eax
  0043a	74 07		 je	 SHORT $LN205@tick

; 33   : 		_Throw_C_error(_Res);

  0043c	8b c8		 mov	 ecx, eax
  0043e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN205@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00443	48 c7 45 90 00
	00 00 00	 mov	 QWORD PTR $T5[rbp-256], 0
  0044b	48 c7 45 98 00
	00 00 00	 mov	 QWORD PTR $T5[rbp-248], 0

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00453	48 85 f6	 test	 rsi, rsi
  00456	74 04		 je	 SHORT $LN217@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00458	f0 ff 46 08	 lock inc DWORD PTR [rsi+8]
$LN217@tick:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0045c	4c 8b c6	 mov	 r8, rsi
  0045f	49 8b d5	 mov	 rdx, r13
  00462	48 8d 4d 90	 lea	 rcx, QWORD PTR $T5[rbp-256]
  00466	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 92   : 	requestChunkDraw(chunk);

  0046b	48 8d 4d 90	 lea	 rcx, QWORD PTR $T5[rbp-256]
  0046f	e8 00 00 00 00	 call	 ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkDraw

; 93   : 		
; 94   : 	for(int i = -1; i <= 1; i++)

  00474	41 83 ce ff	 or	 r14d, -1
  00478	45 8b e6	 mov	 r12d, r14d
  0047b	0f 1f 44 00 00	 npad	 5
$LL11@tick:

; 95   : 	{
; 96   : 		for(int j = -1; j <= 1; j++)

  00480	45 8b fe	 mov	 r15d, r14d
$LL8@tick:

; 98   : 			for(int k = -1; k <= 1; k++)

  00483	41 8b f6	 mov	 esi, r14d
  00486	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL5@tick:

; 99   : 			{
; 100  : 				if(i | j | k)

  00490	8b c6		 mov	 eax, esi
  00492	41 0b c7	 or	 eax, r15d
  00495	41 0b c4	 or	 eax, r12d
  00498	0f 84 fb 00 00
	00		 je	 $LN4@tick

; 101  : 				{
; 102  : 					std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(i + chunk->pos.x, j + chunk->pos.y, k + chunk->pos.z);

  0049e	41 8b 4d 20	 mov	 ecx, DWORD PTR [r13+32]
  004a2	03 ce		 add	 ecx, esi
  004a4	45 8b 4d 1c	 mov	 r9d, DWORD PTR [r13+28]
  004a8	45 03 cf	 add	 r9d, r15d
  004ab	45 8b 45 18	 mov	 r8d, DWORD PTR [r13+24]
  004af	45 03 c4	 add	 r8d, r12d
  004b2	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  004b6	48 8d 54 24 50	 lea	 rdx, QWORD PTR c$1[rsp]
  004bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  004c2	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  004c7	90		 npad	 1

; 103  : 					if(!c->isEmpty() && c->isLoaded() && !c->isRenderUpdateNeeded())

  004c8	48 8b 7c 24 50	 mov	 rdi, QWORD PTR c$1[rsp]
  004cd	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  004d0	48 8b cf	 mov	 rcx, rdi
  004d3	ff 50 18	 call	 QWORD PTR [rax+24]
  004d6	84 c0		 test	 al, al
  004d8	0f 85 81 00 00
	00		 jne	 $LN312@tick
  004de	38 47 09	 cmp	 BYTE PTR [rdi+9], al
  004e1	74 7c		 je	 SHORT $LN312@tick
  004e3	38 47 08	 cmp	 BYTE PTR [rdi+8], al
  004e6	75 77		 jne	 SHORT $LN312@tick
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 95   : 	renderUpdateNeeded = flag;

  004e8	c6 47 08 01	 mov	 BYTE PTR [rdi+8], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  004ec	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR $T2[rsp], 0
  004f5	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR $T2[rsp+8], 0

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  004fe	48 8b 5c 24 58	 mov	 rbx, QWORD PTR c$1[rsp+8]
  00503	48 85 db	 test	 rbx, rbx
  00506	74 41		 je	 SHORT $LN270@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00508	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  0050c	48 8b 5c 24 78	 mov	 rbx, QWORD PTR $T2[rsp+8]
  00511	48 85 db	 test	 rbx, rbx
  00514	74 29		 je	 SHORT $LN311@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00516	41 8b c6	 mov	 eax, r14d
  00519	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  0051e	ff c8		 dec	 eax
  00520	75 1d		 jne	 SHORT $LN311@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00522	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00525	48 8b cb	 mov	 rcx, rbx
  00528	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0052a	41 8b c6	 mov	 eax, r14d
  0052d	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  00532	ff c8		 dec	 eax
  00534	75 09		 jne	 SHORT $LN311@tick

; 128  : 			_Delete_this();

  00536	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00539	48 8b cb	 mov	 rcx, rbx
  0053c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN311@tick:
  0053f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR c$1[rsp]
  00544	48 8b 5c 24 58	 mov	 rbx, QWORD PTR c$1[rsp+8]
$LN270@tick:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00549	48 89 5c 24 78	 mov	 QWORD PTR $T2[rsp+8], rbx

; 427  : 		_Ptr = _Other_ptr;

  0054e	48 89 7c 24 70	 mov	 QWORD PTR $T2[rsp], rdi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 106  : 						requestLateChunkDraw(c);

  00553	48 8d 4c 24 70	 lea	 rcx, QWORD PTR $T2[rsp]
  00558	e8 00 00 00 00	 call	 ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestLateChunkDraw
  0055d	eb 05		 jmp	 SHORT $LN1@tick
$LN312@tick:
  0055f	48 8b 5c 24 58	 mov	 rbx, QWORD PTR c$1[rsp+8]
$LN1@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00564	48 85 db	 test	 rbx, rbx
  00567	74 30		 je	 SHORT $LN4@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00569	41 8b c6	 mov	 eax, r14d
  0056c	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00571	ff c8		 dec	 eax
  00573	75 24		 jne	 SHORT $LN4@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00575	48 8b 5c 24 58	 mov	 rbx, QWORD PTR c$1[rsp+8]
  0057a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0057d	48 8b cb	 mov	 rcx, rbx
  00580	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00582	41 8b c6	 mov	 eax, r14d
  00585	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  0058a	ff c8		 dec	 eax
  0058c	75 0b		 jne	 SHORT $LN4@tick

; 128  : 			_Delete_this();

  0058e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR c$1[rsp+8]
  00593	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00596	ff 50 08	 call	 QWORD PTR [rax+8]
$LN4@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 98   : 			for(int k = -1; k <= 1; k++)

  00599	ff c6		 inc	 esi
  0059b	83 fe 01	 cmp	 esi, 1
  0059e	0f 8e ec fe ff
	ff		 jle	 $LL5@tick

; 95   : 	{
; 96   : 		for(int j = -1; j <= 1; j++)

  005a4	41 ff c7	 inc	 r15d
  005a7	41 83 ff 01	 cmp	 r15d, 1
  005ab	0f 8e d2 fe ff
	ff		 jle	 $LL8@tick

; 93   : 		
; 94   : 	for(int i = -1; i <= 1; i++)

  005b1	41 ff c4	 inc	 r12d
  005b4	41 83 fc 01	 cmp	 r12d, 1
  005b8	0f 8e c2 fe ff
	ff		 jle	 $LL11@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  005be	48 8b 5d 88	 mov	 rbx, QWORD PTR $T4[rbp-256]
  005c2	48 85 db	 test	 rbx, rbx
  005c5	74 23		 je	 SHORT $LN292@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  005c7	41 8b c6	 mov	 eax, r14d
  005ca	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  005cf	ff c8		 dec	 eax
  005d1	75 17		 jne	 SHORT $LN292@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  005d3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  005d6	48 8b cb	 mov	 rcx, rbx
  005d9	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  005db	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  005df	75 09		 jne	 SHORT $LN292@tick

; 128  : 			_Delete_this();

  005e1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  005e4	48 8b cb	 mov	 rcx, rbx
  005e7	ff 50 08	 call	 QWORD PTR [rax+8]
$LN292@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 113  : 	return true;

  005ea	b0 01		 mov	 al, 1

; 114  : }

  005ec	48 8b 4d 20	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  005f0	48 33 cc	 xor	 rcx, rsp
  005f3	e8 00 00 00 00	 call	 __security_check_cookie
  005f8	4c 8d 9c 24 30
	01 00 00	 lea	 r11, QWORD PTR [rsp+304]
  00600	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00604	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00608	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  0060c	49 8b e3	 mov	 rsp, r11
  0060f	41 5f		 pop	 r15
  00611	41 5e		 pop	 r14
  00613	41 5d		 pop	 r13
  00615	41 5c		 pop	 r12
  00617	5d		 pop	 rbp
  00618	c3		 ret	 0
?tick@ChunkLoadThread@@MEAA_NXZ ENDP			; ChunkLoadThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 80
chunkZ$ = 96
chunkY$ = 100
chunkX$ = 104
$T2 = 112
event$3 = 128
$T4 = 136
$T5 = 144
$T6 = 160
chunk$ = 192
$T7 = 208
$T8 = 216
global_ws$ = 240
local_ws$ = 264
__$ArrayPad$ = 288
this$ = 352
?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$0
  00000	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 80
chunkZ$ = 96
chunkY$ = 100
chunkX$ = 104
$T2 = 112
event$3 = 128
$T4 = 136
$T5 = 144
$T6 = 160
chunk$ = 192
$T7 = 208
$T8 = 216
global_ws$ = 240
local_ws$ = 264
__$ArrayPad$ = 288
this$ = 352
?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA PROC	; `ChunkLoadThread::tick'::`1'::dtor$3
  0000c	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR c$1[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$3@?0??tick@ChunkLoadThread@@MEAA_NXZ@4HA ENDP	; `ChunkLoadThread::tick'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
;	COMDAT ?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestChunkLoad, COMDAT

; 117  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 118  : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2184
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestChu

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 60 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2144
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2184
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestChu

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestChu

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestChu

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestChu

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestChu:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 123  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestChunkLoad
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestChunkLoad'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestChunkLoad@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestChunkLoad'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00006	0f 94 c0	 sete	 al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 126  : 		}

  00009	c3		 ret	 0
?empty@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_NXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::empty
_TEXT	ENDS
END
