; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07DCLBNMLN@generic?$AA@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error?$AA@		; `string'
PUBLIC	??_C@_08LLGCOLLL@iostream?$AA@			; `string'
PUBLIC	??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@	; `string'
PUBLIC	??_C@_06FHFOAHML@system?$AA@			; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	?drawerThread@@3HA				; drawerThread
PUBLIC	?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
PUBLIC	?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelException
PUBLIC	?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
PUBLIC	?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_structured
PUBLIC	?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_localCancel
PUBLIC	?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_reserved
PUBLIC	?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
PUBLIC	?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
PUBLIC	?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
PUBLIC	?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
PUBLIC	?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
PUBLIC	?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
PUBLIC	?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB ; Concurrency::details::_TaskCollectionBase::_S_notInlined
PUBLIC	?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
PUBLIC	?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB ; Concurrency::details::_TaskCollectionBase::_S_nonNull
PUBLIC	PPLParallelInvokeEventGuid
PUBLIC	ChoreEventGuid
PUBLIC	ScheduleGroupEventGuid
PUBLIC	SchedulerEventGuid
PUBLIC	VirtualProcessorEventGuid
PUBLIC	ContextEventGuid
PUBLIC	ConcRTEventGuid
PUBLIC	PPLParallelForeachEventGuid
PUBLIC	PPLParallelForEventGuid
PUBLIC	AgentEventGuid
PUBLIC	ConcRT_ProviderGuid
PUBLIC	ResourceManagerEventGuid
PUBLIC	LockEventGuid
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@	; std::_Ref_count<gfxu::VertexStream>::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 ; std::_Ref_count<gfxu::VertexStream> `RTTI Type Descriptor'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category@std@@@8	; std::_Iostream_error_category `RTTI Type Descriptor'
PUBLIC	??_R0?AV_Ref_count_base@std@@@8			; std::_Ref_count_base `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category@std@@8	; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4error_category@std@@6B@			; std::error_category::`RTTI Complete Object Locator'
PUBLIC	??_R4_Ref_count_base@std@@6B@			; std::_Ref_count_base::`RTTI Complete Object Locator'
PUBLIC	??_R4_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`RTTI Complete Object Locator'
PUBLIC	??_7_Ref_count_base@std@@6B@			; std::_Ref_count_base::`vftable'
PUBLIC	??_R2_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Base Class Array'
PUBLIC	??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8	; std::_Ref_count<gfxu::VertexStream>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8	; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Array'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R3_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@_Ref_count_base@std@@8		; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@	; std::_Ref_count<gfxu::VertexStream>::`vftable'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_7_Iostream_error_category@std@@6B@		; std::_Iostream_error_category::`vftable'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7error_category@std@@6B@			; std::error_category::`vftable'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	?binary@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::binary
PUBLIC	?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::_Hardfail
PUBLIC	?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::eofbit
PUBLIC	?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B ; std::ios_base::failure::_Stream_err
PUBLIC	?app@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::app
PUBLIC	?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::uppercase
PUBLIC	?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::trunc
PUBLIC	?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::skipws
PUBLIC	?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::basefield
PUBLIC	?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::_Stdio
PUBLIC	?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::left
PUBLIC	?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpos
PUBLIC	?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::adjustfield
PUBLIC	?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B		; std::_Iosb<int>::badbit
PUBLIC	?in@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::in
PUBLIC	?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::oct
PUBLIC	?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::hex
PUBLIC	?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showbase
PUBLIC	?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::showpoint
PUBLIC	?collate@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::collate
PUBLIC	?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::beg
PUBLIC	?table_size@?$ctype@D@std@@2_KB			; std::ctype<char>::table_size
PUBLIC	?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::failbit
PUBLIC	?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::unitbuf
PUBLIC	?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::right
PUBLIC	?ctype@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::ctype
PUBLIC	?out@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::out
PUBLIC	?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::internal
PUBLIC	?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B	; std::_Iosb<int>::goodbit
PUBLIC	?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::boolalpha
PUBLIC	?ate@?$_Iosb@H@std@@2W4_Openmode@12@B		; std::_Iosb<int>::ate
PUBLIC	?all@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::all
PUBLIC	?numeric@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::numeric
PUBLIC	?end@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::end
PUBLIC	?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Noreplace
PUBLIC	?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B		; std::_Iosb<int>::cur
PUBLIC	?time@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::time
PUBLIC	?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::hexfloat
PUBLIC	?messages@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::messages
PUBLIC	?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::fixed
PUBLIC	?none@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::none
PUBLIC	?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::floatfield
PUBLIC	?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B	; std::_Iosb<int>::_Nocreate
PUBLIC	?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B	; std::_Iosb<int>::scientific
PUBLIC	?monetary@?$_Locbase@H@std@@2HB			; std::_Locbase<int>::monetary
PUBLIC	?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B		; std::_Iosb<int>::dec
PUBLIC	??_R2_Iostream_error_category@std@@8		; std::_Iostream_error_category::`RTTI Base Class Array'
EXTRN	_Mtx_lock:PROC
EXTRN	_purecall:PROC
EXTRN	_Mtx_unlock:PROC
EXTRN	atexit:PROC
EXTRN	memmove:PROC
EXTRN	?_Xlength_error@std@@YAXPEBD@Z:PROC		; std::_Xlength_error
EXTRN	??0_Lockit@std@@QEAA@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QEAA@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Xout_of_range@std@@YAXPEBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Syserror_map@std@@YAPEBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Throw_C_error@std@@YAXH@Z:PROC		; std::_Throw_C_error
EXTRN	?_Winerror_map@std@@YAPEBDH@Z:PROC		; std::_Winerror_map
?drawerThread@@3HA DD 01H DUP (?)			; drawerThread
_BSS	ENDS
CONST	ENDS
;	COMDAT ??_R2_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?dec@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0200H		; std::_Iosb<int>::dec
CONST	ENDS
;	COMDAT ?monetary@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?monetary@?$_Locbase@H@std@@2HB DD 04H			; std::_Locbase<int>::monetary
CONST	ENDS
;	COMDAT ?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?scientific@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01000H	; std::_Iosb<int>::scientific
CONST	ENDS
;	COMDAT ?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Nocreate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 040H	; std::_Iosb<int>::_Nocreate
CONST	ENDS
;	COMDAT ?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?floatfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::floatfield
CONST	ENDS
;	COMDAT ?none@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?none@?$_Locbase@H@std@@2HB DD 00H			; std::_Locbase<int>::none
CONST	ENDS
;	COMDAT ?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?fixed@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02000H	; std::_Iosb<int>::fixed
CONST	ENDS
;	COMDAT ?messages@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?messages@?$_Locbase@H@std@@2HB DD 020H			; std::_Locbase<int>::messages
CONST	ENDS
;	COMDAT ?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hexfloat@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 03000H	; std::_Iosb<int>::hexfloat
CONST	ENDS
;	COMDAT ?time@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?time@?$_Locbase@H@std@@2HB DD 010H			; std::_Locbase<int>::time
CONST	ENDS
;	COMDAT ?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?cur@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 01H		; std::_Iosb<int>::cur
CONST	ENDS
;	COMDAT ?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?_Noreplace@?$_Iosb@H@std@@2W4_Openmode@12@B DD 080H	; std::_Iosb<int>::_Noreplace
CONST	ENDS
;	COMDAT ?end@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?end@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 02H		; std::_Iosb<int>::end
CONST	ENDS
;	COMDAT ?numeric@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?numeric@?$_Locbase@H@std@@2HB DD 08H			; std::_Locbase<int>::numeric
CONST	ENDS
;	COMDAT ?all@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?all@?$_Locbase@H@std@@2HB DD 03fH			; std::_Locbase<int>::all
CONST	ENDS
;	COMDAT ?ate@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?ate@?$_Iosb@H@std@@2W4_Openmode@12@B DD 04H		; std::_Iosb<int>::ate
CONST	ENDS
;	COMDAT ?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?boolalpha@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04000H	; std::_Iosb<int>::boolalpha
CONST	ENDS
;	COMDAT ?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?goodbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 00H		; std::_Iosb<int>::goodbit
CONST	ENDS
;	COMDAT ?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?internal@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0100H	; std::_Iosb<int>::internal
CONST	ENDS
;	COMDAT ?out@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?out@?$_Iosb@H@std@@2W4_Openmode@12@B DD 02H		; std::_Iosb<int>::out
CONST	ENDS
;	COMDAT ?ctype@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?ctype@?$_Locbase@H@std@@2HB DD 02H			; std::_Locbase<int>::ctype
CONST	ENDS
;	COMDAT ?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?right@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 080H		; std::_Iosb<int>::right
CONST	ENDS
;	COMDAT ?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?unitbuf@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 02H	; std::_Iosb<int>::unitbuf
CONST	ENDS
;	COMDAT ?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?failbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 02H		; std::_Iosb<int>::failbit
CONST	ENDS
;	COMDAT ?table_size@?$ctype@D@std@@2_KB
CONST	SEGMENT
?table_size@?$ctype@D@std@@2_KB DQ 0000000000000100H	; std::ctype<char>::table_size
CONST	ENDS
;	COMDAT ?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B
CONST	SEGMENT
?beg@?$_Iosb@H@std@@2W4_Seekdir@12@B DD 00H		; std::_Iosb<int>::beg
CONST	ENDS
;	COMDAT ?collate@?$_Locbase@H@std@@2HB
CONST	SEGMENT
?collate@?$_Locbase@H@std@@2HB DD 01H			; std::_Locbase<int>::collate
CONST	ENDS
;	COMDAT ?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpoint@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 010H	; std::_Iosb<int>::showpoint
CONST	ENDS
;	COMDAT ?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showbase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08H	; std::_Iosb<int>::showbase
CONST	ENDS
;	COMDAT ?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?hex@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0800H		; std::_Iosb<int>::hex
CONST	ENDS
;	COMDAT ?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?oct@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0400H		; std::_Iosb<int>::oct
CONST	ENDS
;	COMDAT ?in@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?in@?$_Iosb@H@std@@2W4_Openmode@12@B DD 01H		; std::_Iosb<int>::in
CONST	ENDS
;	COMDAT ?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?badbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 04H		; std::_Iosb<int>::badbit
CONST	ENDS
;	COMDAT ?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?adjustfield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01c0H	; std::_Iosb<int>::adjustfield
CONST	ENDS
;	COMDAT ?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?showpos@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 020H	; std::_Iosb<int>::showpos
CONST	ENDS
;	COMDAT ?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?left@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 040H		; std::_Iosb<int>::left
CONST	ENDS
;	COMDAT ?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?_Stdio@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 08000H	; std::_Iosb<int>::_Stdio
CONST	ENDS
;	COMDAT ?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?basefield@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 0e00H	; std::_Iosb<int>::basefield
CONST	ENDS
;	COMDAT ?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?skipws@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 01H		; std::_Iosb<int>::skipws
CONST	ENDS
;	COMDAT ?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?trunc@?$_Iosb@H@std@@2W4_Openmode@12@B DD 010H		; std::_Iosb<int>::trunc
CONST	ENDS
;	COMDAT ?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B
CONST	SEGMENT
?uppercase@?$_Iosb@H@std@@2W4_Fmtflags@12@B DD 04H	; std::_Iosb<int>::uppercase
CONST	ENDS
;	COMDAT ?app@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?app@?$_Iosb@H@std@@2W4_Openmode@12@B DD 08H		; std::_Iosb<int>::app
CONST	ENDS
;	COMDAT ?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B
CONST	SEGMENT
?_Stream_err@failure@ios_base@std@@0W4io_errc@43@B DD 01H ; std::ios_base::failure::_Stream_err
CONST	ENDS
;	COMDAT ?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?eofbit@?$_Iosb@H@std@@2W4_Iostate@12@B DD 01H		; std::_Iosb<int>::eofbit
CONST	ENDS
;	COMDAT ?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B
CONST	SEGMENT
?_Hardfail@?$_Iosb@H@std@@2W4_Iostate@12@B DD 010H	; std::_Iosb<int>::_Hardfail
CONST	ENDS
;	COMDAT ?binary@?$_Iosb@H@std@@2W4_Openmode@12@B
CONST	SEGMENT
?binary@?$_Iosb@H@std@@2W4_Openmode@12@B DD 020H	; std::_Iosb<int>::binary
CONST	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Generic_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 01H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error_category@std@@@8
	DD	imagerel ??_R3_System_error_category@std@@8
	DD	imagerel ??_R4_System_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_7error_category@std@@6B@
CONST	SEGMENT
??_7error_category@std@@6B@ DQ FLAT:??_R4error_category@std@@6B@ ; std::error_category::`vftable'
	DQ	FLAT:??_Eerror_category@std@@UEAAPEAXI@Z
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD imagerel ??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7_Iostream_error_category@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category@std@@6B@ DQ FLAT:??_R4_Iostream_error_category@std@@6B@ ; std::_Iostream_error_category::`vftable'
	DQ	FLAT:??_E_Iostream_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_Iostream_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_Iostream_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
_DATA	SEGMENT
??_R0?AVerror_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVerror_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DQ FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DQ	FLAT:??_E_System_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_System_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ DQ FLAT:??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ ; std::_Ref_count<gfxu::VertexStream>::`vftable'
	DQ	FLAT:?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ
	DQ	FLAT:?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ
	DQ	FLAT:??_E?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Ref_count_base@std@@8 DD imagerel ??_R0?AV_Ref_count_base@std@@@8 ; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category@std@@8 DD 00H		; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD imagerel ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R3_Ref_count_base@std@@8 DD 00H			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD imagerel ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_System_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD 00H	; std::_Ref_count<gfxu::VertexStream>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R2_Ref_count_base@std@@8 DD imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8 ; std::_Ref_count_base::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7_Ref_count_base@std@@6B@
CONST	SEGMENT
??_7_Ref_count_base@std@@6B@ DQ FLAT:??_R4_Ref_count_base@std@@6B@ ; std::_Ref_count_base::`vftable'
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:??_E_Ref_count_base@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R4_Iostream_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category@std@@6B@ DD 01H		; std::_Iostream_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Iostream_error_category@std@@@8
	DD	imagerel ??_R3_Iostream_error_category@std@@8
	DD	imagerel ??_R4_Iostream_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4_Ref_count_base@std@@6B@
rdata$r	SEGMENT
??_R4_Ref_count_base@std@@6B@ DD 01H			; std::_Ref_count_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Ref_count_base@std@@@8
	DD	imagerel ??_R3_Ref_count_base@std@@8
	DD	imagerel ??_R4_Ref_count_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4error_category@std@@6B@
rdata$r	SEGMENT
??_R4error_category@std@@6B@ DD 01H			; std::error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVerror_category@std@@@8
	DD	imagerel ??_R3error_category@std@@8
	DD	imagerel ??_R4error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category@std@@8 DD imagerel ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Iostream_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD imagerel ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Ref_count_base@std@@@8
_DATA	SEGMENT
??_R0?AV_Ref_count_base@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Ref_count_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category@std@@@8
_DATA	SEGMENT
??_R0?AV_Iostream_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Iostream_error_category@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 01H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Generic_error_category@std@@@8
	DD	imagerel ??_R3_Generic_error_category@std@@8
	DD	imagerel ??_R4_Generic_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count<gfxu::VertexStream> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Ref_count@VVertexStream@gfxu@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DQ FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DQ	FLAT:??_E_Generic_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_Generic_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Generic_error_category@std@@8
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD imagerel ??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ DD 01H	; std::_Ref_count<gfxu::VertexStream>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8
	DD	imagerel ??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
	DD	imagerel ??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT LockEventGuid
CONST	SEGMENT
LockEventGuid DD 079a60dc6H
	DW	05fc8H
	DW	04952H
	DB	0a4H
	DB	01cH
	DB	011H
	DB	063H
	DB	0aeH
	DB	0ecH
	DB	05eH
	DB	0b8H
CONST	ENDS
;	COMDAT ResourceManagerEventGuid
CONST	SEGMENT
ResourceManagerEventGuid DD 02718d25bH
	DW	05bf5H
	DW	04479H
	DB	08eH
	DB	088H
	DB	0baH
	DB	0bcH
	DB	064H
	DB	0bdH
	DB	0bfH
	DB	0caH
CONST	ENDS
;	COMDAT ConcRT_ProviderGuid
CONST	SEGMENT
ConcRT_ProviderGuid DD 0f7b697a3H
	DW	04db5H
	DW	04d3bH
	DB	0beH
	DB	071H
	DB	0c4H
	DB	0d2H
	DB	084H
	DB	0e6H
	DB	059H
	DB	02fH
CONST	ENDS
;	COMDAT AgentEventGuid
CONST	SEGMENT
AgentEventGuid DD 0b9b5b78cH
	DW	0713H
	DW	04898H
	DB	0a2H
	DB	01aH
	DB	0c6H
	DB	079H
	DB	049H
	DB	0dcH
	DB	0edH
	DB	07H
CONST	ENDS
;	COMDAT PPLParallelForEventGuid
CONST	SEGMENT
PPLParallelForEventGuid DD 031c8da6bH
	DW	06165H
	DW	04042H
	DB	08bH
	DB	092H
	DB	094H
	DB	09eH
	DB	031H
	DB	05fH
	DB	04dH
	DB	084H
CONST	ENDS
;	COMDAT PPLParallelForeachEventGuid
CONST	SEGMENT
PPLParallelForeachEventGuid DD 05cb7d785H
	DW	09d66H
	DW	0465dH
	DB	0baH
	DB	0e1H
	DB	046H
	DB	011H
	DB	06H
	DB	01bH
	DB	054H
	DB	034H
CONST	ENDS
;	COMDAT ConcRTEventGuid
CONST	SEGMENT
ConcRTEventGuid DD 072b14a7dH
	DW	0704cH
	DW	0423eH
	DB	092H
	DB	0f8H
	DB	07eH
	DB	06dH
	DB	064H
	DB	0bcH
	DB	0b9H
	DB	02aH
CONST	ENDS
;	COMDAT ContextEventGuid
CONST	SEGMENT
ContextEventGuid DD 05727a00fH
	DW	050beH
	DW	04519H
	DB	082H
	DB	056H
	DB	0f7H
	DB	069H
	DB	098H
	DB	071H
	DB	0feH
	DB	0cbH
CONST	ENDS
;	COMDAT VirtualProcessorEventGuid
CONST	SEGMENT
VirtualProcessorEventGuid DD 02f27805fH
	DW	01676H
	DW	04eccH
	DB	096H
	DB	0faH
	DB	07eH
	DB	0b0H
	DB	09dH
	DB	044H
	DB	030H
	DB	02fH
CONST	ENDS
;	COMDAT SchedulerEventGuid
CONST	SEGMENT
SchedulerEventGuid DD 0e2091f8aH
	DW	01e0aH
	DW	04731H
	DB	084H
	DB	0a2H
	DB	0dH
	DB	0d5H
	DB	07cH
	DB	08aH
	DB	052H
	DB	061H
CONST	ENDS
;	COMDAT ScheduleGroupEventGuid
CONST	SEGMENT
ScheduleGroupEventGuid DD 0e8a3bf1fH
	DW	0a86bH
	DW	04390H
	DB	09cH
	DB	060H
	DB	053H
	DB	090H
	DB	0b9H
	DB	069H
	DB	0d2H
	DB	02cH
CONST	ENDS
;	COMDAT ChoreEventGuid
CONST	SEGMENT
ChoreEventGuid DD 07e854ec7H
	DW	0cdc4H
	DW	0405aH
	DB	0b5H
	DB	0b2H
	DB	0aaH
	DB	0f7H
	DB	0c9H
	DB	0e7H
	DB	0d4H
	DB	0cH
CONST	ENDS
;	COMDAT PPLParallelInvokeEventGuid
CONST	SEGMENT
PPLParallelInvokeEventGuid DD 0d1b5b133H
	DW	0ec3dH
	DW	049f4H
	DB	098H
	DB	0a3H
	DB	046H
	DB	04dH
	DB	01aH
	DB	09eH
	DB	046H
	DB	082H
CONST	ENDS
;	COMDAT ?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_nonNull@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000008H ; Concurrency::details::_TaskCollectionBase::_S_nonNull
CONST	ENDS
;	COMDAT ?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CALLED@_CancellationTokenRegistration@details@Concurrency@@0JB DD 03H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CALLED
CONST	ENDS
;	COMDAT ?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_notInlined@_TaskCollectionBase@details@Concurrency@@1HB DD 0ffffffffH ; Concurrency::details::_TaskCollectionBase::_S_notInlined
CONST	ENDS
;	COMDAT ?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelBitsMask@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelBitsMask
CONST	ENDS
;	COMDAT ?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelDeferredShootdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000002H ; Concurrency::details::_TaskCollectionBase::_S_cancelDeferredShootdownOwner
CONST	ENDS
;	COMDAT ?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelStarted@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000001H ; Concurrency::details::_TaskCollectionBase::_S_cancelStarted
CONST	ENDS
;	COMDAT ?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_CLEAR@_CancellationTokenRegistration@details@Concurrency@@0JB DD 00H ; Concurrency::details::_CancellationTokenRegistration::_STATE_CLEAR
CONST	ENDS
;	COMDAT ?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_SYNCHRONIZE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 02H ; Concurrency::details::_CancellationTokenRegistration::_STATE_SYNCHRONIZE
CONST	ENDS
;	COMDAT ?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelShotdownOwner@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000003H ; Concurrency::details::_TaskCollectionBase::_S_cancelShotdownOwner
CONST	ENDS
;	COMDAT ?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_reserved@_TaskCollectionBase@details@Concurrency@@1HB DD 0cH ; Concurrency::details::_TaskCollectionBase::_S_reserved
CONST	ENDS
;	COMDAT ?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_localCancel@_TaskCollectionBase@details@Concurrency@@1HB DD 02H ; Concurrency::details::_TaskCollectionBase::_S_localCancel
CONST	ENDS
;	COMDAT ?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB
CONST	SEGMENT
?_S_structured@_TaskCollectionBase@details@Concurrency@@1HB DD 01H ; Concurrency::details::_TaskCollectionBase::_S_structured
CONST	ENDS
;	COMDAT ?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB
CONST	SEGMENT
?_STATE_DEFER_DELETE@_CancellationTokenRegistration@details@Concurrency@@0JB DD 01H ; Concurrency::details::_CancellationTokenRegistration::_STATE_DEFER_DELETE
CONST	ENDS
;	COMDAT ?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelException@_TaskCollectionBase@details@Concurrency@@1_KB DQ 000000000000000cH ; Concurrency::details::_TaskCollectionBase::_S_cancelException
CONST	ENDS
;	COMDAT ?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB
CONST	SEGMENT
?_S_cancelNone@_TaskCollectionBase@details@Concurrency@@1_KB DQ 0000000000000000H ; Concurrency::details::_TaskCollectionBase::_S_cancelNone
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system?$AA@
CONST	SEGMENT
??_C@_06FHFOAHML@system?$AA@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
CONST	SEGMENT
??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ DB 'iostream stream error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream?$AA@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream?$AA@ DB 'iostream', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error?$AA@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic?$AA@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic?$AA@ DB 'generic', 00H		; `string'
PUBLIC	??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z	; std::shared_ptr<ChunkBase>::`scalar deleting destructor'
PUBLIC	??$_Fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@_KAEBQEAV10@@Z ; std::_Fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$destroy@PEAD@?$allocator@D@std@@QEAAXPEAPEAD@Z ; std::allocator<char>::destroy<char * __ptr64>
PUBLIC	??$construct@PEADAEAPEAD@?$allocator@D@std@@QEAAXPEAPEADAEAPEAD@Z ; std::allocator<char>::construct<char * __ptr64,char * __ptr64 & __ptr64>
PUBLIC	??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@1@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>
PUBLIC	??1?$_Ref_count@VVertexStream@gfxu@@@std@@UEAA@XZ ; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>
PUBLIC	??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ ; std::_Ref_count<gfxu::VertexStream>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ ; std::_Ref_count<gfxu::VertexStream>::_Destroy
PUBLIC	??0?$_Ref_count@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>
PUBLIC	?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@AEBV32@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
PUBLIC	??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Val_type@PEAPEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@@Z ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Ptr_cat@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAV?$shared_ptr@VChunkBase@@@0@0@Z ; std::_Ptr_cat<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocator<std::shared_ptr<ChunkBase> * __ptr64><std::shared_ptr<ChunkBase> >
PUBLIC	??$_Move@AEAPEAVVertexStream@gfxu@@@std@@YA$$QEAPEAVVertexStream@gfxu@@AEAPEAV12@@Z ; std::_Move<gfxu::VertexStream * __ptr64 & __ptr64>
PUBLIC	??$_Move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z ; std::_Move<std::_Ref_count_base * __ptr64 & __ptr64>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEBV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>
PUBLIC	??$forward@AEBV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ; std::forward<std::shared_ptr<ChunkBase> const & __ptr64>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$destroy@PEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char * __ptr64>
PUBLIC	??$construct@PEADAEAPEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEADAEAPEAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>
PUBLIC	??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z	; std::forward<char * __ptr64 & __ptr64>
PUBLIC	??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
PUBLIC	?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
PUBLIC	?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
PUBLIC	?_Reset@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset
PUBLIC	?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset
PUBLIC	??$_Allocate@D@std@@YAPEAD_KPEAD@Z		; std::_Allocate<char>
PUBLIC	??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z ; std::_Allocate<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z ; std::_Allocate<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
PUBLIC	??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$swap@PEAVVertexStream@gfxu@@@std@@YAXAEAPEAVVertexStream@gfxu@@0@Z ; std::swap<gfxu::VertexStream * __ptr64>
PUBLIC	??$swap@PEAV_Ref_count_base@std@@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base * __ptr64>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEBV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEBV01@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$destroy@PEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char * __ptr64>
PUBLIC	??$construct@PEADAEAPEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEADAEAPEAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>
PUBLIC	??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEBV01@@Z ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>
PUBLIC	??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>
PUBLIC	?max_size@?$allocator@D@std@@QEBA_KXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEBA_KXZ ; std::allocator<std::shared_ptr<ChunkBase> >::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocate
PUBLIC	?deallocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEBV?$shared_ptr@VChunkBase@@@1@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::deallocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> >::allocate
PUBLIC	?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
PUBLIC	?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_NPEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEAV?$shared_ptr@VChunkBase@@@1@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_K_K@Z ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
PUBLIC	?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
PUBLIC	?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_NXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty
PUBLIC	?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
PUBLIC	?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Swap
PUBLIC	??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ	; std::_Ptr_base<ChunkBase>::_Decref
PUBLIC	?_Get@?$_Ptr_base@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ ; std::_Ptr_base<ChunkBase>::_Get
PUBLIC	??0?$_Ptr_base@VChunkBase@@@std@@QEAA@XZ	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
PUBLIC	?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
PUBLIC	?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
PUBLIC	?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front
PUBLIC	?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
PUBLIC	?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ ; std::_Ptr_base<gfxu::VertexStream>::_Decref
PUBLIC	?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z ; std::shared_ptr<gfxu::VertexStream>::swap
PUBLIC	??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??C?$shared_ptr@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ ; std::shared_ptr<ChunkBase>::operator->
PUBLIC	??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ	; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop
PUBLIC	?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push
PUBLIC	?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front
PUBLIC	?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_KXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size
PUBLIC	??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z ; std::shared_ptr<gfxu::VertexStream>::operator=
PUBLIC	??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestLateChunkDraw
PUBLIC	?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkDraw
PUBLIC	?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestQuickChunkDraw
PUBLIC	?tick@ChunkDrawThread@@MEAA_NXZ			; ChunkDrawThread::tick
PUBLIC	?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
PUBLIC	?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; renderChunk
PUBLIC	?system_category@std@@YAAEBVerror_category@1@XZ	; std::system_category
PUBLIC	?generic_category@std@@YAAEBVerror_category@1@XZ ; std::generic_category
PUBLIC	??1_System_error_category@std@@UEAA@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UEAAPEAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?name@_System_error_category@std@@UEBAPEBDXZ	; std::_System_error_category::name
PUBLIC	??0_System_error_category@std@@QEAA@XZ		; std::_System_error_category::_System_error_category
PUBLIC	??1_Iostream_error_category@std@@UEAA@XZ	; std::_Iostream_error_category::~_Iostream_error_category
PUBLIC	??_G_Iostream_error_category@std@@UEAAPEAXI@Z	; std::_Iostream_error_category::`scalar deleting destructor'
PUBLIC	?message@_Iostream_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message
PUBLIC	?name@_Iostream_error_category@std@@UEBAPEBDXZ	; std::_Iostream_error_category::name
PUBLIC	??0_Iostream_error_category@std@@QEAA@XZ	; std::_Iostream_error_category::_Iostream_error_category
PUBLIC	??1_Generic_error_category@std@@UEAA@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UEAAPEAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	?name@_Generic_error_category@std@@UEBAPEBDXZ	; std::_Generic_error_category::name
PUBLIC	??0_Generic_error_category@std@@QEAA@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	??8error_condition@std@@QEBA_NAEBV01@@Z		; std::error_condition::operator==
PUBLIC	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
PUBLIC	?value@error_condition@std@@QEBAHXZ		; std::error_condition::value
PUBLIC	??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
PUBLIC	?value@error_code@std@@QEBAHXZ			; std::error_code::value
PUBLIC	??_Gerror_category@std@@UEAAPEAXI@Z		; std::error_category::`scalar deleting destructor'
PUBLIC	??8error_category@std@@QEBA_NAEBV01@@Z		; std::error_category::operator==
PUBLIC	??1error_category@std@@UEAA@XZ			; std::error_category::~error_category
PUBLIC	??0error_category@std@@QEAA@XZ			; std::error_category::error_category
PUBLIC	?_Enable_shared@std@@YAXPEDX0@Z			; std::_Enable_shared
PUBLIC	??_G_Ref_count_base@std@@UEAAPEAXI@Z		; std::_Ref_count_base::`scalar deleting destructor'
PUBLIC	?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z ; std::_Ref_count_base::_Get_deleter
PUBLIC	?_Decwref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	?_Decref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Incref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Incref
PUBLIC	??1_Ref_count_base@std@@UEAA@XZ			; std::_Ref_count_base::~_Ref_count_base
PUBLIC	??0_Ref_count_base@std@@IEAA@XZ			; std::_Ref_count_base::_Ref_count_base
PUBLIC	?unlock@_Mutex_base@std@@QEAAXXZ		; std::_Mutex_base::unlock
PUBLIC	?lock@_Mutex_base@std@@QEAAXXZ			; std::_Mutex_base::lock
PUBLIC	?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z ; std::_Mtx_unlockX
PUBLIC	?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z ; std::_Mtx_lockX
PUBLIC	?_Check_C_return@std@@YAHH@Z			; std::_Check_C_return
PUBLIC	?_Init_atomic_counter@std@@YAXAEAKK@Z		; std::_Init_atomic_counter
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QEAAXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	??1_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::~_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??3@YAXPEAX0@Z					; operator delete
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?assign@?$char_traits@D@std@@SAXAEADAEBD@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z	; std::char_traits<char>::move
PUBLIC	?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SA_KPEBD@Z		; std::char_traits<char>::length
PUBLIC	?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
PUBLIC	?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; std::_Error_objects<int>::_Iostream_object
PUBLIC	?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object
EXTRN	??_E_Generic_error_category@std@@UEAAPEAXI@Z:PROC ; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category@std@@UEAAPEAXI@Z:PROC ; std::_Iostream_error_category::`vector deleting destructor'
EXTRN	??_E?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z:PROC ; std::_Ref_count<gfxu::VertexStream>::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UEAAPEAXI@Z:PROC ; std::_System_error_category::`vector deleting destructor'
EXTRN	??_E_Ref_count_base@std@@UEAAPEAXI@Z:PROC	; std::_Ref_count_base::`vector deleting destructor'
EXTRN	??_Eerror_category@std@@UEAAPEAXI@Z:PROC	; std::error_category::`vector deleting destructor'
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD imagerel $LN20+26
	DD	imagerel $LN20+75
	DD	imagerel $chain$0$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD imagerel $LN20+75
	DD	imagerel $LN20+89
	DD	imagerel $chain$1$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN19+19
	DD	imagerel $LN19+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN19+54
	DD	imagerel $LN19+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN12
	DD	imagerel $LN12+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN12+9
	DD	imagerel $LN12+28
	DD	imagerel $chain$0$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN12+28
	DD	imagerel $LN12+33
	DD	imagerel $chain$1$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN21+19
	DD	imagerel $LN21+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN21+54
	DD	imagerel $LN21+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD imagerel $LN26
	DD	imagerel $LN26+99
	DD	imagerel $unwind$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA DD imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA+42
	DD	imagerel $unwind$?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+42
	DD	imagerel $LN15+84
	DD	imagerel $chain$0$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+84
	DD	imagerel $LN15+105
	DD	imagerel $chain$1$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+105
	DD	imagerel $LN15+114
	DD	imagerel $chain$2$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+114
	DD	imagerel $LN15+123
	DD	imagerel $chain$3$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+42
	DD	imagerel $LN15+84
	DD	imagerel $chain$0$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+84
	DD	imagerel $LN15+105
	DD	imagerel $chain$1$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+105
	DD	imagerel $LN15+114
	DD	imagerel $chain$2$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+114
	DD	imagerel $LN15+123
	DD	imagerel $chain$3$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@D@std@@YAPEAD_KPEAD@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$??$_Allocate@D@std@@YAPEAD_KPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z DD imagerel $LN14
	DD	imagerel $LN14+48
	DD	imagerel $unwind$??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z DD imagerel $LN14
	DD	imagerel $LN14+44
	DD	imagerel $unwind$??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN18+9
	DD	imagerel $LN18+28
	DD	imagerel $chain$0$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN18+28
	DD	imagerel $LN18+33
	DD	imagerel $chain$1$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+47
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN23+19
	DD	imagerel $LN23+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN23+54
	DD	imagerel $LN23+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN13
	DD	imagerel $LN13+41
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z DD imagerel $LN11
	DD	imagerel $LN11+50
	DD	imagerel $unwind$?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z DD imagerel $LN16
	DD	imagerel $LN16+41
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD imagerel $LN16
	DD	imagerel $LN16+95
	DD	imagerel $unwind$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+55
	DD	imagerel $unwind$?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD imagerel $LN185
	DD	imagerel $LN185+257
	DD	imagerel $unwind$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+67
	DD	imagerel $unwind$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+62
	DD	imagerel $unwind$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN43
	DD	imagerel $LN43+203
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z DD imagerel $LN20
	DD	imagerel $LN20+61
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD imagerel $LN18
	DD	imagerel $LN18+95
	DD	imagerel $unwind$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+55
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+54
	DD	imagerel $unwind$?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN70
	DD	imagerel $LN70+30
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN70+30
	DD	imagerel $LN70+64
	DD	imagerel $chain$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN70+64
	DD	imagerel $LN70+86
	DD	imagerel $chain$1$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN70+86
	DD	imagerel $LN70+124
	DD	imagerel $chain$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN70+124
	DD	imagerel $LN70+147
	DD	imagerel $chain$3$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN70+147
	DD	imagerel $LN70+190
	DD	imagerel $chain$4$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN70+190
	DD	imagerel $LN70+203
	DD	imagerel $chain$5$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD imagerel $LN129
	DD	imagerel $LN129+299
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+54
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134
	DD	imagerel $LN134+77
	DD	imagerel $unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+77
	DD	imagerel $LN134+150
	DD	imagerel $chain$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+150
	DD	imagerel $LN134+229
	DD	imagerel $chain$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+229
	DD	imagerel $LN134+279
	DD	imagerel $chain$4$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+279
	DD	imagerel $LN134+379
	DD	imagerel $chain$5$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+379
	DD	imagerel $LN134+409
	DD	imagerel $chain$6$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+409
	DD	imagerel $LN134+415
	DD	imagerel $chain$8$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+415
	DD	imagerel $LN134+428
	DD	imagerel $chain$9$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z DD imagerel $LN118
	DD	imagerel $LN118+306
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD imagerel $LN12+19
	DD	imagerel $LN12+54
	DD	imagerel $chain$0$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD imagerel $LN12+54
	DD	imagerel $LN12+60
	DD	imagerel $chain$1$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD imagerel $LN54
	DD	imagerel $LN54+176
	DD	imagerel $unwind$?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34
	DD	imagerel $LN34+24
	DD	imagerel $unwind$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34+24
	DD	imagerel $LN34+53
	DD	imagerel $chain$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34+53
	DD	imagerel $LN34+88
	DD	imagerel $chain$1$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34+88
	DD	imagerel $LN34+99
	DD	imagerel $chain$2$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34+99
	DD	imagerel $LN34+123
	DD	imagerel $chain$3$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ DD imagerel $LN14
	DD	imagerel $LN14+52
	DD	imagerel $unwind$?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD imagerel $LN12+19
	DD	imagerel $LN12+54
	DD	imagerel $chain$0$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD imagerel $LN12+54
	DD	imagerel $LN12+60
	DD	imagerel $chain$1$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z DD imagerel $LN13
	DD	imagerel $LN13+49
	DD	imagerel $unwind$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD imagerel $LN33
	DD	imagerel $LN33+27
	DD	imagerel $unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD imagerel $LN33+27
	DD	imagerel $LN33+62
	DD	imagerel $chain$0$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD imagerel $LN33+62
	DD	imagerel $LN33+89
	DD	imagerel $chain$1$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD imagerel $LN14+19
	DD	imagerel $LN14+54
	DD	imagerel $chain$0$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD imagerel $LN14+54
	DD	imagerel $LN14+60
	DD	imagerel $chain$1$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z DD imagerel $LN13
	DD	imagerel $LN13+49
	DD	imagerel $unwind$??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ DD imagerel $LN16
	DD	imagerel $LN16+52
	DD	imagerel $unwind$?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+57
	DD	imagerel $LN59+86
	DD	imagerel $chain$1$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+86
	DD	imagerel $LN59+111
	DD	imagerel $chain$2$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+111
	DD	imagerel $LN59+120
	DD	imagerel $chain$3$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD imagerel $LN14+19
	DD	imagerel $LN14+54
	DD	imagerel $chain$0$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD imagerel $LN14+54
	DD	imagerel $LN14+60
	DD	imagerel $chain$1$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN34
	DD	imagerel $LN34+49
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z DD imagerel $LN47
	DD	imagerel $LN47+60
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@ChunkDrawThread@@MEAA_NXZ DD imagerel $LN21
	DD	imagerel $LN21+116
	DD	imagerel $unwind$?tick@ChunkDrawThread@@MEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD imagerel $LN184
	DD	imagerel $LN184+592
	DD	imagerel $unwind$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN487
	DD	imagerel $LN487+1667
	DD	imagerel $unwind$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error_category@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+38
	DD	imagerel $unwind$??_G_System_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD imagerel $LN15
	DD	imagerel $LN15+63
	DD	imagerel $unwind$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN51
	DD	imagerel $LN51+98
	DD	imagerel $unwind$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Iostream_error_category@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+38
	DD	imagerel $unwind$??_G_Iostream_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_Iostream_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN53
	DD	imagerel $LN53+77
	DD	imagerel $unwind$?message@_Iostream_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Generic_error_category@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$??_G_Generic_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN51
	DD	imagerel $LN51+98
	DD	imagerel $unwind$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD imagerel $LN18
	DD	imagerel $LN18+55
	DD	imagerel $unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gerror_category@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+38
	DD	imagerel $unwind$??_Gerror_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Ref_count_base@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+38
	DD	imagerel $unwind$??_G_Ref_count_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+50
	DD	imagerel $unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unlock@_Mutex_base@std@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+29
	DD	imagerel $unwind$?unlock@_Mutex_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lock@_Mutex_base@std@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+29
	DD	imagerel $unwind$?lock@_Mutex_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z DD imagerel $LN8
	DD	imagerel $LN8+32
	DD	imagerel $unwind$?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z DD imagerel $LN8
	DD	imagerel $LN8+32
	DD	imagerel $unwind$?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_C_return@std@@YAHH@Z DD imagerel $LN6
	DD	imagerel $LN6+25
	DD	imagerel $unwind$?_Check_C_return@std@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD imagerel $LN9
	DD	imagerel $LN9+50
	DD	imagerel $unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+28
	DD	imagerel $unwind$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z
pdata	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZEA DQ FLAT:??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Generic_object$initializer$
;	COMDAT ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
_DATA	SEGMENT
?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A DQ FLAT:??_7_Generic_error_category@std@@6B@ ; std::_Error_objects<int>::_Generic_object
_DATA	ENDS
;	COMDAT ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
_DATA	SEGMENT
?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A DQ FLAT:??_7_Iostream_error_category@std@@6B@ ; std::_Error_objects<int>::_Iostream_object
_DATA	ENDS
;	COMDAT ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
_DATA	SEGMENT
?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A DQ FLAT:??_7_System_error_category@std@@6B@ ; std::_Error_objects<int>::_System_object
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_C_return@std@@YAHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lock@_Mutex_base@std@@QEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unlock@_Mutex_base@std@@QEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Ref_count_base@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gerror_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Generic_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_Iostream_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Iostream_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 040a01H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+49
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+236
	DD	01H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+258
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+389
	DD	0ffffffffH
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+440
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+492
	DD	02H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+516
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+530
	DD	03H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+555
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+734
	DD	04H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+792
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+821
	DD	04H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+828
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1226
	DD	05H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1250
	DD	06H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1440
	DD	05H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1492
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1546
	DD	0ffffffffH
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1559
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1584
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$3@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$6@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$5@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	07H
	DD	imagerel $stateUnwindMap$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	015H
	DD	imagerel $ip2state$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0b0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 0e2e11H
	DD	0c782eH
	DD	0d682aH
	DD	01d011eH
	DD	0e011f013H
	DD	0c00dd00fH
	DD	0600a700bH
	DD	050083009H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z+154
	DD	00H
	DD	imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z+449
	DD	0ffffffffH
	DD	imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z+510
	DD	00H
	DD	imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z+516
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD 0c2511H
	DD	0137425H
	DD	0126421H
	DD	011541dH
	DD	0103419H
	DD	0f009b20dH
	DD	0c005e007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@ChunkDrawThread@@MEAA_NXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	096405H
	DD	imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+27
	DD	imagerel $unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD 020521H
	DD	066405H
	DD	imagerel $LN33
	DD	imagerel $LN33+27
	DD	imagerel $unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+24
	DD	imagerel $unwind$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN34+24
	DD	imagerel $LN34+53
	DD	imagerel $chain$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	066405H
	DD	imagerel $LN34+24
	DD	imagerel $LN34+53
	DD	imagerel $chain$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN34
	DD	imagerel $LN34+24
	DD	imagerel $unwind$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN134
	DD	imagerel $LN134+77
	DD	imagerel $unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 040021H
	DD	04f400H
	DD	085400H
	DD	imagerel $LN134
	DD	imagerel $LN134+77
	DD	imagerel $unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN134+77
	DD	imagerel $LN134+150
	DD	imagerel $chain$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN134+150
	DD	imagerel $LN134+229
	DD	imagerel $chain$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 020521H
	DD	0ac405H
	DD	imagerel $LN134+150
	DD	imagerel $LN134+229
	DD	imagerel $chain$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 041221H
	DD	0be412H
	DD	097405H
	DD	imagerel $LN134+77
	DD	imagerel $LN134+150
	DD	imagerel $chain$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 041021H
	DD	04f410H
	DD	085405H
	DD	imagerel $LN134
	DD	imagerel $LN134+77
	DD	imagerel $unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 030701H
	DD	060034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 021H
	DD	imagerel $LN70
	DD	imagerel $LN70+30
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 021H
	DD	imagerel $LN70+30
	DD	imagerel $LN70+64
	DD	imagerel $chain$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 021H
	DD	imagerel $LN70+64
	DD	imagerel $LN70+86
	DD	imagerel $chain$1$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 020521H
	DD	08e405H
	DD	imagerel $LN70+64
	DD	imagerel $LN70+86
	DD	imagerel $chain$1$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 020521H
	DD	076405H
	DD	imagerel $LN70+30
	DD	imagerel $LN70+64
	DD	imagerel $chain$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 020521H
	DD	065405H
	DD	imagerel $LN70
	DD	imagerel $LN70+30
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	0ffffffffH
	DD	imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z+110
	DD	00H
	DD	imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z+147
	DD	0ffffffffH
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+13
	DD	01H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+21
	DD	02H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+53
	DD	00H
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+14
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$1$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 00H
	DD	00H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$1$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	02H
	DD	imagerel $tryMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	08H
	DD	imagerel $ip2state$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 052119H
	DD	0e0146218H
	DD	060117012H
	DD	03010H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN18
	DD	imagerel $LN18+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@D@std@@YAPEAD_KPEAD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 020021H
	DD	06e400H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 020521H
	DD	06e405H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 020021H
	DD	06e400H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 020521H
	DD	06e405H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD imagerel ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z+30
	DD	00H
	DD	imagerel ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z+88
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 041819H
	DD	083418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN12
	DD	imagerel $LN12+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD 020521H
	DD	066405H
	DD	imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZEA DQ FLAT:??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_Iostream_object$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZEA DQ FLAT:??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; std::_Error_objects<int>::_System_object$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SA_KPEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$char_traits@D@std@@SA_KPEBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

  00000	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00003	75 03		 jne	 SHORT $LN3@length
  00005	33 c0		 xor	 eax, eax

; 524  : 		}

  00007	c3		 ret	 0
$LN3@length:

; 522  : 		return (*_First == 0 ? 0
; 523  : 			: _CSTD strlen(_First));

  00008	48 83 c8 ff	 or	 rax, -1
  0000c	0f 1f 40 00	 npad	 4
$LL5@length:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 01 00	 cmp	 BYTE PTR [rcx+rax], 0
  00017	75 f7		 jne	 SHORT $LL5@length

; 524  : 		}

  00019	f3 c3		 fatret	 0
?length@?$char_traits@D@std@@SA_KPEBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z PROC	; std::char_traits<char>::copy, COMDAT

; 528  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 529  : 		return (_Count == 0 ? _First1
; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00009	4d 85 c0	 test	 r8, r8
  0000c	74 05		 je	 SHORT $LN5@copy
  0000e	e8 00 00 00 00	 call	 memcpy
$LN5@copy:
  00013	48 8b c3	 mov	 rax, rbx

; 531  : 		}

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z ENDP	; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?move@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z PROC	; std::char_traits<char>::move, COMDAT

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00000	4d 85 c0	 test	 r8, r8
  00003	75 04		 jne	 SHORT $LN3@move
  00005	48 8b c1	 mov	 rax, rcx

; 554  : 		}

  00008	c3		 ret	 0
$LN3@move:

; 552  : 		return (_Count == 0 ? _First1
; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00009	e9 00 00 00 00	 jmp	 memmove
?move@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z ENDP	; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$char_traits@D@std@@SAXAEADAEBD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		_Left = _Right;

  00000	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00003	88 01		 mov	 BYTE PTR [rcx], al

; 565  : 		}

  00005	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAEADAEBD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 60   : 	return (_Where);

  00000	48 8b c2	 mov	 rax, rdx

; 61   : 	}

  00003	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\new
;	COMDAT ??3@YAXPEAX0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??3@YAXPEAX0@Z PROC					; operator delete, COMDAT

; 65   : 	}

  00000	c2 00 00	 ret	 0
??3@YAXPEAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT

; 113  : 		{	// construct orphaned iterator

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 114  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT

; 138  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 139  : 		_Lockit _Lock(_LOCK_DEBUG);
; 140  : 		_Orphan_me();
; 141  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 142  : 		}

  00000	c2 00 00	 ret	 0
??1_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
this$ = 48
_Lock$1 = 56
_Parent$ = 56
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT

; 145  : 		{	// adopt this iterator by parent

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 146  : 		if (_Parent == 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	75 1e		 jne	 SHORT $LN2@Adopt

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  00009	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0000e	ba 03 00 00 00	 mov	 edx, 3
  00013	e8 00 00 00 00	 call	 ??0_Lockit@std@@QEAA@H@Z ; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  00018	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0001d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QEAA@XZ	; std::_Lockit::~_Lockit

; 167  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 168  : 			}
; 169  : 		}

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN2@Adopt:

; 151  : 		else
; 152  : 			{	// have a parent, do adoption
; 153  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 154  : 
; 155  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 156  : 			if (_Myproxy != _Parent_proxy)
; 157  : 				{	// change parentage
; 158  : 				_Lockit _Lock(_LOCK_DEBUG);
; 159  : 				_Orphan_me();
; 160  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 161  : 				_Parent_proxy->_Myfirstiter = this;
; 162  : 				_Myproxy = _Parent_proxy;
; 163  : 				}
; 164  : 
; 165  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 166  : 			_Myproxy = _Parent_proxy;

  00027	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 167  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 168  : 			}
; 169  : 		}

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 85 c0	 test	 rax, rax
  00006	75 02		 jne	 SHORT $LN3@Getcont

; 179  : 		}

  00008	f3 c3		 fatret	 0
$LN3@Getcont:

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 179  : 		}

  0000d	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_me@_Iterator_base12@std@@QEAAXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT

; 188  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 189  : 		if (_Myproxy != 0)
; 190  : 			{	// adopted, remove self from list
; 191  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 192  : 			while (*_Pnext != 0 && *_Pnext != this)
; 193  : 				_Pnext = &(*_Pnext)->_Mynextiter;
; 194  : 
; 195  : 			if (*_Pnext == 0)
; 196  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");
; 197  : 			*_Pnext = _Mynextiter;
; 198  : 			_Myproxy = 0;
; 199  : 			}
; 200  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 201  : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 210  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 211  : 	if (_Myproxy != 0)
; 212  : 		{	// proxy allocated, drain it
; 213  : 		_Lockit _Lock(_LOCK_DEBUG);
; 214  : 
; 215  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 216  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 217  : 			(*_Pnext)->_Myproxy = 0;
; 218  : 		_Myproxy->_Myfirstiter = 0;
; 219  : 		}
; 220  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 221  : 	}

  00000	c2 00 00	 ret	 0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
;	COMDAT ?_Init_atomic_counter@std@@YAXAEAKK@Z
_TEXT	SEGMENT
_Counter$ = 8
_Value$ = 16
?_Init_atomic_counter@std@@YAXAEAKK@Z PROC		; std::_Init_atomic_counter, COMDAT

; 219  : 	_Counter = _Value;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 220  : 	}

  00002	c3		 ret	 0
?_Init_atomic_counter@std@@YAXAEAKK@Z ENDP		; std::_Init_atomic_counter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Check_C_return@std@@YAHH@Z
_TEXT	SEGMENT
_Res$ = 48
?_Check_C_return@std@@YAHH@Z PROC			; std::_Check_C_return, COMDAT

; 31   : 	{	// throw exception on failure

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 32   : 	if (_Res != _Thrd_success)

  00008	85 c9		 test	 ecx, ecx
  0000a	74 05		 je	 SHORT $LN4@Check_C_re

; 33   : 		_Throw_C_error(_Res);

  0000c	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN4@Check_C_re:

; 34   : 	return (_Res);

  00011	8b c3		 mov	 eax, ebx

; 35   : 	}

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
?_Check_C_return@std@@YAHH@Z ENDP			; std::_Check_C_return
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z
_TEXT	SEGMENT
_Mtx$ = 48
?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z PROC	; std::_Mtx_lockX, COMDAT

; 67   : 	{	// throw exception on failure

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00006	e8 00 00 00 00	 call	 _Mtx_lock
  0000b	8b d8		 mov	 ebx, eax

; 32   : 	if (_Res != _Thrd_success)

  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN3@Mtx_lockX

; 33   : 		_Throw_C_error(_Res);

  00011	8b c8		 mov	 ecx, eax
  00013	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00018	8b c3		 mov	 eax, ebx
$LN3@Mtx_lockX:

; 69   : 	}

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z ENDP	; std::_Mtx_lockX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z
_TEXT	SEGMENT
_Mtx$ = 48
?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z PROC ; std::_Mtx_unlockX, COMDAT

; 82   : 	{	// throw exception on failure

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00006	e8 00 00 00 00	 call	 _Mtx_unlock
  0000b	8b d8		 mov	 ebx, eax

; 32   : 	if (_Res != _Thrd_success)

  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN3@Mtx_unlock

; 33   : 		_Throw_C_error(_Res);

  00011	8b c8		 mov	 ecx, eax
  00013	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00018	8b c3		 mov	 eax, ebx
$LN3@Mtx_unlock:

; 84   : 	}

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z ENDP ; std::_Mtx_unlockX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ?lock@_Mutex_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?lock@_Mutex_base@std@@QEAAXXZ PROC			; std::_Mutex_base::lock, COMDAT

; 42   : 		{	// lock the mutex

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00004	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00009	85 c0		 test	 eax, eax
  0000b	74 0b		 je	 SHORT $LN5@lock

; 33   : 		_Throw_C_error(_Res);

  0000d	8b c8		 mov	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 44   : 		}

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 33   : 		_Throw_C_error(_Res);

  00013	e9 00 00 00 00	 jmp	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN5@lock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 44   : 		}

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
?lock@_Mutex_base@std@@QEAAXXZ ENDP			; std::_Mutex_base::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ?unlock@_Mutex_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?unlock@_Mutex_base@std@@QEAAXXZ PROC			; std::_Mutex_base::unlock, COMDAT

; 52   : 		{	// unlock the mutex

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00004	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00009	85 c0		 test	 eax, eax
  0000b	74 0b		 je	 SHORT $LN5@unlock

; 33   : 		_Throw_C_error(_Res);

  0000d	8b c8		 mov	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 54   : 		}

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 33   : 		_Throw_C_error(_Res);

  00013	e9 00 00 00 00	 jmp	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN5@unlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 54   : 		}

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
?unlock@_Mutex_base@std@@QEAAXXZ ENDP			; std::_Mutex_base::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0_Ref_count_base@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Ref_count_base@std@@IEAA@XZ PROC			; std::_Ref_count_base::_Ref_count_base, COMDAT

; 61   : 	_Ref_count_base()

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00007	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [rcx+8], 1
  0000e	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 61   : 	_Ref_count_base()

  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 62   : 		{	// construct
; 63   : 		_Init_atomic_counter(_Uses, 1);
; 64   : 		_Init_atomic_counter(_Weaks, 1);
; 65   : 		}

  00018	48 8b c1	 mov	 rax, rcx
  0001b	c3		 ret	 0
??0_Ref_count_base@std@@IEAA@XZ ENDP			; std::_Ref_count_base::_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1_Ref_count_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Ref_count_base@std@@UEAA@XZ PROC			; std::_Ref_count_base::~_Ref_count_base, COMDAT

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 70   : 		}

  0000a	c3		 ret	 0
??1_Ref_count_base@std@@UEAA@XZ ENDP			; std::_Ref_count_base::~_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Incref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Incref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Incref, COMDAT

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00000	f0 ff 41 08	 lock inc DWORD PTR [rcx+8]

; 109  : 		}

  00004	c3		 ret	 0
?_Incref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT

; 117  : 		{	// decrement use count

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000a	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	75 14		 jne	 SHORT $LN4@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00013	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00016	ff 10		 call	 QWORD PTR [rax]

; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00018	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0001c	75 09		 jne	 SHORT $LN4@Decref

; 128  : 			_Delete_this();

  0001e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00021	48 8b cb	 mov	 rcx, rbx
  00024	ff 50 08	 call	 QWORD PTR [rax+8]
$LN4@Decref:

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
?_Decref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Decwref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT

; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00000	f0 ff 49 0c	 lock dec DWORD PTR [rcx+12]
  00004	75 07		 jne	 SHORT $LN1@Decwref

; 128  : 			_Delete_this();

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 ff 60 08	 rex_jmp QWORD PTR [rax+8]
$LN1@Decwref:

; 129  : 		}

  0000d	f3 c3		 fatret	 0
?_Decwref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z PROC ; std::_Ref_count_base::_Get_deleter, COMDAT

; 143  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 144  : 		}

  00002	c3		 ret	 0
?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z ENDP ; std::_Ref_count_base::_Get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G_Ref_count_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Ref_count_base@std@@UEAAPEAXI@Z PROC		; std::_Ref_count_base::`scalar deleting destructor', COMDAT
$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN6@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN6@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G_Ref_count_base@std@@UEAAPEAXI@Z ENDP		; std::_Ref_count_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Enable_shared@std@@YAXPEDX0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?_Enable_shared@std@@YAXPEDX0@Z PROC			; std::_Enable_shared, COMDAT

; 269  : 	}

  00000	c2 00 00	 ret	 0
?_Enable_shared@std@@YAXPEDX0@Z ENDP			; std::_Enable_shared
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_category@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0error_category@std@@QEAA@XZ PROC			; std::error_category::error_category, COMDAT

; 162  : 	error_category()

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 163  : 		{	// default constructor
; 164  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0error_category@std@@QEAA@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1error_category@std@@UEAA@XZ PROC			; std::error_category::~error_category, COMDAT

; 167  : 		{	// destroy the object

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 168  : 		}

  0000a	c3		 ret	 0
??1error_category@std@@UEAA@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_category@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8error_category@std@@QEBA_NAEBV01@@Z PROC		; std::error_category::operator==, COMDAT

; 185  : 		return (this == &_Right);

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	0f 94 c0	 sete	 al

; 186  : 		}

  00006	c3		 ret	 0
??8error_category@std@@QEBA_NAEBV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??_Gerror_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gerror_category@std@@UEAAPEAXI@Z PROC		; std::error_category::`scalar deleting destructor', COMDAT
$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 167  : 		{	// destroy the object

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN6@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN6@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_Gerror_category@std@@UEAAPEAXI@Z ENDP		; std::error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_code@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_code@std@@QEBAHXZ PROC			; std::error_code::value, COMDAT

; 252  : 		return (_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]

; 253  : 		}

  00002	c3		 ret	 0
?value@error_code@std@@QEBAHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_code@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_code@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_code::category, COMDAT

; 257  : 		return (*_Mycat);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 258  : 		}

  00004	c3		 ret	 0
?category@error_code@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT

; 316  : 		{	// construct from error code and category

  00000	89 11		 mov	 DWORD PTR [rcx], edx
  00002	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 317  : 		}

  00006	48 8b c1	 mov	 rax, rcx
  00009	c3		 ret	 0
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?value@error_condition@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_condition@std@@QEBAHXZ PROC		; std::error_condition::value, COMDAT

; 350  : 		return (_Myval);

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]

; 351  : 		}

  00002	c3		 ret	 0
?value@error_condition@std@@QEBAHXZ ENDP		; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?category@error_condition@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT

; 355  : 		return (*_Mycat);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 356  : 		}

  00004	c3		 ret	 0
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??8error_condition@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8error_condition@std@@QEBA_NAEBV01@@Z PROC		; std::error_condition::operator==, COMDAT

; 185  : 		return (this == &_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	48 39 41 08	 cmp	 QWORD PTR [rcx+8], rax

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

  00008	75 09		 jne	 SHORT $LN3@operator
  0000a	8b 02		 mov	 eax, DWORD PTR [rdx]
  0000c	39 01		 cmp	 DWORD PTR [rcx], eax
  0000e	75 03		 jne	 SHORT $LN3@operator
  00010	b0 01		 mov	 al, 1

; 379  : 		}

  00012	c3		 ret	 0
$LN3@operator:

; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

  00013	32 c0		 xor	 al, al

; 379  : 		}

  00015	c3		 ret	 0
??8error_condition@std@@QEBA_NAEBV01@@Z ENDP		; std::error_condition::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Errval$ = 24
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT

; 316  : 		{	// construct from error code and category

  00000	44 89 02	 mov	 DWORD PTR [rdx], r8d
  00003	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 402  : 	return (error_condition(_Errval, *this));

  00007	48 8b c2	 mov	 rax, rdx

; 403  : 	}

  0000a	c3		 ret	 0
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Errval$ = 72
_Cond$ = 80
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT

; 408  : 	{	// test if error code same condition

$LN18:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 409  : 	return (default_error_condition(_Errval) == _Cond);

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	49 8b d8	 mov	 rbx, r8
  0000c	44 8b c2	 mov	 r8d, edx
  0000f	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00014	ff 50 18	 call	 QWORD PTR [rax+24]

; 185  : 		return (this == &_Right);

  00017	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0001b	48 39 48 08	 cmp	 QWORD PTR [rax+8], rcx

; 186  : 		}
; 187  : 
; 188  : 	bool operator!=(const error_category& _Right) const _NOEXCEPT
; 189  : 		{	// compare categories for inequality
; 190  : 		return (!(*this == _Right));
; 191  : 		}
; 192  : 
; 193  : 	bool operator<(const error_category& _Right) const _NOEXCEPT
; 194  : 		{	// compare categories for order
; 195  : 		return (this < &_Right);
; 196  : 		}
; 197  : 
; 198  : private:
; 199  : 	error_category(const error_category&);	// not defined
; 200  : 
; 201  : 	error_category& operator=(const error_category&);	// not defined
; 202  : 	};
; 203  : 
; 204  : 		// CLASS error_code
; 205  : class error_code
; 206  : 	{	// store an implementation-specific error code and category
; 207  : public:
; 208  : 	typedef error_code _Myt;
; 209  : 
; 210  : 	error_code()
; 211  : 		: _Myval(0),
; 212  : 			_Mycat(&system_category())
; 213  : 		{	// construct non-error
; 214  : 		}
; 215  : 
; 216  : 	error_code(int _Val, const error_category& _Cat)
; 217  : 		: _Myval(_Val), _Mycat(&_Cat)
; 218  : 		{	// construct from error code and category
; 219  : 		}
; 220  : 
; 221  : 	template<class _Enum>
; 222  : 		error_code(_Enum _Errcode,
; 223  : 			typename enable_if<is_error_code_enum<_Enum>::value,
; 224  : 				void>::type ** = 0)
; 225  : 		: _Myval(0), _Mycat(0)
; 226  : 		{	// construct from enumerated error code
; 227  : 		*this = make_error_code(_Errcode);	// using ADL
; 228  : 		}
; 229  : 
; 230  : 	void assign(int _Val, const error_category& _Cat)
; 231  : 		{	// assign error code and category
; 232  : 		_Myval = _Val;
; 233  : 		_Mycat = &_Cat;
; 234  : 		}
; 235  : 
; 236  : 	template<class _Enum>
; 237  : 		typename enable_if<is_error_code_enum<_Enum>::value,
; 238  : 			error_code>::type& operator=(_Enum _Errcode)
; 239  : 		{	// assign enumerated error code
; 240  : 		*this = make_error_code(_Errcode);	// using ADL
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	void clear() _NOEXCEPT
; 245  : 		{	// assign non-error
; 246  : 		_Myval = 0;
; 247  : 		_Mycat = &system_category();
; 248  : 		}
; 249  : 
; 250  : 	int value() const
; 251  : 		{	// get error code
; 252  : 		return (_Myval);
; 253  : 		}
; 254  : 
; 255  : 	const error_category& category() const
; 256  : 		{	// get category
; 257  : 		return (*_Mycat);
; 258  : 		}
; 259  : 
; 260  : 	error_condition default_error_condition() const;
; 261  : 
; 262  : 	string message() const
; 263  : 		{	// get name of error code
; 264  : 		return (category().message(value()));
; 265  : 		}
; 266  : 
; 267  : 	_TYPEDEF_BOOL_TYPE;
; 268  : 
; 269  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 270  : 		{	// test for actual error
; 271  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 272  : 		}
; 273  : 
; 274  : 	bool operator!() const _NOEXCEPT
; 275  : 		{	// test for actual error
; 276  : 		return (value() == 0);
; 277  : 		}
; 278  : 
; 279  : 	bool operator==(const error_code& _Right) const _NOEXCEPT
; 280  : 		{	// test if *this == _Right
; 281  : 		return (category() == _Right.category()
; 282  : 			&& value() == _Right.value());
; 283  : 		}
; 284  : 
; 285  : 	bool operator!=(const error_code& _Right) const _NOEXCEPT
; 286  : 		{	// test if *this != _Right
; 287  : 		return (!(*this == _Right));
; 288  : 		}
; 289  : 
; 290  : 	bool operator<(const error_code& _Right) const _NOEXCEPT
; 291  : 		{	// test if *this == _Right
; 292  : 		return (category() < _Right.category()
; 293  : 			|| category() == _Right.category()
; 294  : 				&& value() < _Right.value());
; 295  : 		}
; 296  : 
; 297  : private:
; 298  : 	int _Myval;	// the stored error number
; 299  : 	const error_category *_Mycat;	// pointer to error category
; 300  : 	};
; 301  : 
; 302  : 		// CLASS error_condition
; 303  : class error_condition
; 304  : 	{	// store an abstract error code and category
; 305  : public:
; 306  : 	typedef error_condition _Myt;
; 307  : 
; 308  : 	error_condition() _NOEXCEPT
; 309  : 		: _Myval(0),
; 310  : 			_Mycat(&generic_category())
; 311  : 		{	// construct non-error
; 312  : 		}
; 313  : 
; 314  : 	error_condition(int _Val, const error_category& _Cat) _NOEXCEPT
; 315  : 		: _Myval(_Val), _Mycat(&_Cat)
; 316  : 		{	// construct from error code and category
; 317  : 		}
; 318  : 
; 319  : 	template<class _Enum>
; 320  : 		error_condition(_Enum _Errcode,
; 321  : 			typename enable_if<is_error_condition_enum<_Enum>::value,
; 322  : 				void>::type ** = 0) _NOEXCEPT
; 323  : 		: _Myval(0), _Mycat(0)
; 324  : 		{	// construct from enumerated error code
; 325  : 		*this = make_error_condition(_Errcode);	// using ADL
; 326  : 		}
; 327  : 
; 328  : 	void assign(int _Val, const error_category& _Cat) _NOEXCEPT
; 329  : 		{	// assign error code and category
; 330  : 		_Myval = _Val;
; 331  : 		_Mycat = &_Cat;
; 332  : 		}
; 333  : 
; 334  : 	template<class _Enum>
; 335  : 		typename enable_if<is_error_condition_enum<_Enum>::value,
; 336  : 			error_condition>::type& operator=(_Enum _Errcode) _NOEXCEPT
; 337  : 		{	// assign enumerated error code
; 338  : 		*this = make_error_condition(_Errcode);	// using ADL
; 339  : 		return (*this);
; 340  : 		}
; 341  : 
; 342  : 	void clear() _NOEXCEPT
; 343  : 		{	// assign non-error
; 344  : 		_Myval = 0;
; 345  : 		_Mycat = &generic_category();
; 346  : 		}
; 347  : 
; 348  : 	int value() const _NOEXCEPT
; 349  : 		{	// get error code
; 350  : 		return (_Myval);
; 351  : 		}
; 352  : 
; 353  : 	const error_category& category() const _NOEXCEPT
; 354  : 		{	// get category
; 355  : 		return (*_Mycat);
; 356  : 		}
; 357  : 
; 358  : 	string message() const
; 359  : 		{	// get name of error code
; 360  : 		return (category().message(value()));
; 361  : 		}
; 362  : 
; 363  : 	_TYPEDEF_BOOL_TYPE;
; 364  : 
; 365  : 	_OPERATOR_BOOL() const _NOEXCEPT
; 366  : 		{	// test for actual error
; 367  : 		return (value() != 0 ? _CONVERTIBLE_TO_TRUE : 0);
; 368  : 		}
; 369  : 
; 370  : 	bool operator!() const _NOEXCEPT
; 371  : 		{	// test for actual error
; 372  : 		return (value() == 0);
; 373  : 		}
; 374  : 
; 375  : 	bool operator==(const error_condition& _Right) const _NOEXCEPT
; 376  : 		{	// test if *this == _Right
; 377  : 		return (category() == _Right.category()
; 378  : 			&& value() == _Right.value());

  0001f	75 0e		 jne	 SHORT $LN5@equivalent
  00021	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00023	39 08		 cmp	 DWORD PTR [rax], ecx
  00025	75 08		 jne	 SHORT $LN5@equivalent

; 409  : 	return (default_error_condition(_Errval) == _Cond);

  00027	b0 01		 mov	 al, 1

; 410  : 	}

  00029	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
$LN5@equivalent:

; 409  : 	return (default_error_condition(_Errval) == _Cond);

  0002f	32 c0		 xor	 al, al

; 410  : 	}

  00031	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00035	5b		 pop	 rbx
  00036	c3		 ret	 0
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
_TEXT	SEGMENT
this$ = 8
_Code$ = 16
_Errval$ = 24
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT

; 185  : 		return (this == &_Right);

  00000	48 3b 4a 08	 cmp	 rcx, QWORD PTR [rdx+8]

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  00004	75 08		 jne	 SHORT $LN3@equivalent
  00006	44 39 02	 cmp	 DWORD PTR [rdx], r8d
  00009	75 03		 jne	 SHORT $LN3@equivalent
  0000b	b0 01		 mov	 al, 1

; 417  : 	}

  0000d	c3		 ret	 0
$LN3@equivalent:

; 416  : 	return (*this == _Code.category() && _Code.value() == _Errval);

  0000e	32 c0		 xor	 al, al

; 417  : 	}

  00010	c3		 ret	 0
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Generic_error_category@std@@QEAA@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT

; 580  : 	_Generic_error_category()

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Generic_error_category@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 581  : 		{	// default constructor
; 582  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0_Generic_error_category@std@@QEAA@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_Generic_error_category@std@@UEBAPEBDXZ PROC	; std::_Generic_error_category::name, COMDAT

; 586  : 		return ("generic");

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07DCLBNMLN@generic?$AA@

; 587  : 		}

  00007	c3		 ret	 0
?name@_Generic_error_category@std@@UEBAPEBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
_Errcode$ = 80
?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT

; 590  : 		{	// convert to name of error

$LN51:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	33 db		 xor	 ebx, ebx

; 591  : 		const char *_Name = _Syserror_map(_Errcode);

  0000c	41 8b c8	 mov	 ecx, r8d
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	89 5c 24 20	 mov	 DWORD PTR $T1[rsp], ebx
  00016	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPEBDH@Z ; std::_Syserror_map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0001b	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  00023	48 85 c0	 test	 rax, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00026	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 592  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@BFJCFAAK@unknown?5error?$AA@
  00031	48 0f 45 d0	 cmovne	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00035	88 1f		 mov	 BYTE PTR [rdi], bl

; 523  : 			: _CSTD strlen(_First));

  00037	38 1a		 cmp	 BYTE PTR [rdx], bl
  00039	74 0e		 je	 SHORT $LN48@message
  0003b	48 83 cb ff	 or	 rbx, -1
  0003f	90		 npad	 1
$LL49@message:
  00040	48 ff c3	 inc	 rbx
  00043	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  00047	75 f7		 jne	 SHORT $LL49@message
$LN48@message:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00049	4c 8b c3	 mov	 r8, rbx
  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 593  : 		}

  00054	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00059	48 8b c7	 mov	 rax, rdi
  0005c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??_G_Generic_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Generic_error_category@std@@UEAAPEAXI@Z PROC	; std::_Generic_error_category::`scalar deleting destructor', COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 167  : 		{	// destroy the object

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN8@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN8@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G_Generic_error_category@std@@UEAAPEAXI@Z ENDP	; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1_Generic_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Generic_error_category@std@@UEAA@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT

; 167  : 		{	// destroy the object

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1_Generic_error_category@std@@UEAA@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_Iostream_error_category@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Iostream_error_category@std@@QEAA@XZ PROC		; std::_Iostream_error_category::_Iostream_error_category, COMDAT

; 601  : 	_Iostream_error_category()

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Iostream_error_category@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 602  : 		{	// default constructor
; 603  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0_Iostream_error_category@std@@QEAA@XZ ENDP		; std::_Iostream_error_category::_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_Iostream_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_Iostream_error_category@std@@UEBAPEBDXZ PROC	; std::_Iostream_error_category::name, COMDAT

; 607  : 		return ("iostream");

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08LLGCOLLL@iostream?$AA@

; 608  : 		}

  00007	c3		 ret	 0
?name@_Iostream_error_category@std@@UEBAPEBDXZ ENDP	; std::_Iostream_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_Iostream_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
_Errcode$ = 80
?message@_Iostream_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category::message, COMDAT

; 611  : 		{	// convert to name of error

$LN53:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	33 c0		 xor	 eax, eax
  00008	48 8b da	 mov	 rbx, rdx
  0000b	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 612  : 		if (_Errcode == (int)io_errc::stream)

  0000f	41 83 f8 01	 cmp	 r8d, 1
  00013	75 2a		 jne	 SHORT $LN2@message
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00015	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001d	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00021	88 02		 mov	 BYTE PTR [rdx], al
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
  0002a	44 8d 40 15	 lea	 r8d, QWORD PTR [rax+21]
  0002e	48 8b cb	 mov	 rcx, rbx
  00031	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 615  : 			return (_Generic_error_category::message(_Errcode));

  00036	48 8b c3	 mov	 rax, rbx

; 616  : 		}

  00039	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003d	5b		 pop	 rbx
  0003e	c3		 ret	 0
$LN2@message:

; 615  : 			return (_Generic_error_category::message(_Errcode));

  0003f	e8 00 00 00 00	 call	 ?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
  00044	48 8b c3	 mov	 rax, rbx

; 616  : 		}

  00047	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004b	5b		 pop	 rbx
  0004c	c3		 ret	 0
?message@_Iostream_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??_G_Iostream_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Iostream_error_category@std@@UEAAPEAXI@Z PROC	; std::_Iostream_error_category::`scalar deleting destructor', COMDAT
$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 167  : 		{	// destroy the object

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN10@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN10@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G_Iostream_error_category@std@@UEAAPEAXI@Z ENDP	; std::_Iostream_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1_Iostream_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Iostream_error_category@std@@UEAA@XZ PROC		; std::_Iostream_error_category::~_Iostream_error_category, COMDAT

; 167  : 		{	// destroy the object

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1_Iostream_error_category@std@@UEAA@XZ ENDP		; std::_Iostream_error_category::~_Iostream_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??0_System_error_category@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_System_error_category@std@@QEAA@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT

; 624  : 	_System_error_category()

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_System_error_category@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 625  : 		{	// default constructor
; 626  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0_System_error_category@std@@QEAA@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?name@_System_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_System_error_category@std@@UEBAPEBDXZ PROC	; std::_System_error_category::name, COMDAT

; 630  : 		return ("system");

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_06FHFOAHML@system?$AA@

; 631  : 		}

  00007	c3		 ret	 0
?name@_System_error_category@std@@UEBAPEBDXZ ENDP	; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
_Errcode$ = 80
?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT

; 634  : 		{	// convert to name of error

$LN51:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	33 db		 xor	 ebx, ebx

; 635  : 		const char *_Name = _Winerror_map(_Errcode);

  0000c	41 8b c8	 mov	 ecx, r8d
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	89 5c 24 20	 mov	 DWORD PTR $T1[rsp], ebx
  00016	e8 00 00 00 00	 call	 ?_Winerror_map@std@@YAPEBDH@Z ; std::_Winerror_map
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0001b	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  00023	48 85 c0	 test	 rax, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00026	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 636  : 		return (string(_Name != 0 ? _Name : "unknown error"));

  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@BFJCFAAK@unknown?5error?$AA@
  00031	48 0f 45 d0	 cmovne	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00035	88 1f		 mov	 BYTE PTR [rdi], bl

; 523  : 			: _CSTD strlen(_First));

  00037	38 1a		 cmp	 BYTE PTR [rdx], bl
  00039	74 0e		 je	 SHORT $LN48@message
  0003b	48 83 cb ff	 or	 rbx, -1
  0003f	90		 npad	 1
$LL49@message:
  00040	48 ff c3	 inc	 rbx
  00043	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  00047	75 f7		 jne	 SHORT $LL49@message
$LN48@message:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00049	4c 8b c3	 mov	 r8, rbx
  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error

; 637  : 		}

  00054	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00059	48 8b c7	 mov	 rax, rdi
  0005c	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Errval$ = 64
?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT

; 641  : 		{	// make error_condition for error code (generic if possible)

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 642  : 		if (_Syserror_map(_Errval))

  0000a	41 8b c8	 mov	 ecx, r8d
  0000d	41 8b f8	 mov	 edi, r8d
  00010	48 8b da	 mov	 rbx, rdx
  00013	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPEBDH@Z ; std::_Syserror_map

; 316  : 		{	// construct from error code and category

  00018	89 3b		 mov	 DWORD PTR [rbx], edi

; 642  : 		if (_Syserror_map(_Errval))

  0001a	48 85 c0	 test	 rax, rax

; 316  : 		{	// construct from error code and category

  0001d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 642  : 		if (_Syserror_map(_Errval))

  00024	75 07		 jne	 SHORT $LN13@default_er

; 316  : 		{	// construct from error code and category

  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object
$LN13@default_er:
  0002d	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 643  : 			return (error_condition(_Errval, generic_category()));
; 644  : 		else
; 645  : 			return (error_condition(_Errval, system_category()));

  00031	48 8b c3	 mov	 rax, rbx

; 646  : 		}

  00034	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??_G_System_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error_category@std@@UEAAPEAXI@Z PROC	; std::_System_error_category::`scalar deleting destructor', COMDAT
$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 167  : 		{	// destroy the object

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN10@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN10@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G_System_error_category@std@@UEAAPEAXI@Z ENDP	; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??1_System_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_System_error_category@std@@UEAA@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT

; 167  : 		{	// destroy the object

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1_System_error_category@std@@UEAA@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?generic_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAAEBVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 670  : 	return (_Error_objects<int>::_Generic_object);

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Error_objects<int>::_Generic_object

; 671  : 	}

  00007	c3		 ret	 0
?generic_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ?system_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAAEBVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 680  : 	return (_Error_objects<int>::_System_object);

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_Error_objects<int>::_System_object

; 681  : 	}

  00007	c3		 ret	 0
?system_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
c$2 = 96
cx$1$ = 112
chunk$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; renderChunk, COMDAT

; 6    : {

$LN487:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00007	55		 push	 rbp
  00008	53		 push	 rbx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  00017	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001e	48 c7 45 e7 fe
	ff ff ff	 mov	 QWORD PTR $T7[rbp-201], -2
  00026	0f 29 70 a8	 movaps	 XMMWORD PTR [rax-88], xmm6
  0002a	0f 29 78 98	 movaps	 XMMWORD PTR [rax-104], xmm7
  0002e	4c 8b e1	 mov	 r12, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00031	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  00034	48 83 c1 28	 add	 rcx, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00038	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0003d	85 c0		 test	 eax, eax
  0003f	74 07		 je	 SHORT $LN42@renderChun

; 33   : 		_Throw_C_error(_Res);

  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN42@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00048	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 10   : 	if(!chunk->shouldRender() || !chunk->isRenderUpdateNeeded() || chunk->isUnloaded())

  0004c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0004f	ff 50 28	 call	 QWORD PTR [rax+40]
  00052	84 c0		 test	 al, al
  00054	0f 84 bd 05 00
	00		 je	 $LN20@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  0005a	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 10   : 	if(!chunk->shouldRender() || !chunk->isRenderUpdateNeeded() || chunk->isUnloaded())

  0005e	80 78 08 00	 cmp	 BYTE PTR [rax+8], 0
  00062	0f 84 af 05 00
	00		 je	 $LN20@renderChun
  00068	80 78 0a 00	 cmp	 BYTE PTR [rax+10], 0
  0006c	0f 85 a5 05 00
	00		 jne	 $LN20@renderChun
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 95   : 	renderUpdateNeeded = flag;

  00072	c6 40 08 00	 mov	 BYTE PTR [rax+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00076	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  0007a	48 83 c1 28	 add	 rcx, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0007e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00083	85 c0		 test	 eax, eax
  00085	74 07		 je	 SHORT $LN97@renderChun

; 33   : 		_Throw_C_error(_Res);

  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN97@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 18   : 	for(int i = -1; i < 2; i++)

  0008e	83 ce ff	 or	 esi, -1
  00091	44 8b fe	 mov	 r15d, esi
  00094	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL19@renderChun:

; 19   : 	{
; 20   : 		for(int j = -1; j < 2; j++)

  000a0	44 8b f6	 mov	 r14d, esi
  000a3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL16@renderChun:

; 22   : 			for(int k = -1; k < 2; k++)

  000b0	8b fe		 mov	 edi, esi
  000b2	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL13@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  000c0	49 8b 14 24	 mov	 rdx, QWORD PTR [r12]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 24   : 				std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(chunk->pos.x + i, chunk->pos.y + j, chunk->pos.z + k);

  000c4	8b 4a 20	 mov	 ecx, DWORD PTR [rdx+32]
  000c7	03 cf		 add	 ecx, edi
  000c9	44 8b 4a 1c	 mov	 r9d, DWORD PTR [rdx+28]
  000cd	45 03 ce	 add	 r9d, r14d
  000d0	44 8b 42 18	 mov	 r8d, DWORD PTR [rdx+24]
  000d4	45 03 c7	 add	 r8d, r15d
  000d7	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000db	48 8d 55 97	 lea	 rdx, QWORD PTR c$2[rbp-201]
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  000e6	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  000eb	90		 npad	 1

; 25   : 				if(!c->isEmpty() && !c->isLoaded())

  000ec	48 8b 5d 97	 mov	 rbx, QWORD PTR c$2[rbp-201]
  000f0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000f3	48 8b cb	 mov	 rcx, rbx
  000f6	ff 50 18	 call	 QWORD PTR [rax+24]
  000f9	84 c0		 test	 al, al
  000fb	75 05		 jne	 SHORT $LN10@renderChun
  000fd	38 43 09	 cmp	 BYTE PTR [rbx+9], al
  00100	74 4d		 je	 SHORT $LN455@renderChun
$LN10@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00102	48 8b 4d 9f	 mov	 rcx, QWORD PTR c$2[rbp-193]
  00106	48 85 c9	 test	 rcx, rcx
  00109	74 22		 je	 SHORT $LN12@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0010b	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  0010f	75 1c		 jne	 SHORT $LN12@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00111	48 8b 5d 9f	 mov	 rbx, QWORD PTR c$2[rbp-193]
  00115	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00118	48 8b cb	 mov	 rcx, rbx
  0011b	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0011d	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00121	75 0a		 jne	 SHORT $LN12@renderChun

; 128  : 			_Delete_this();

  00123	48 8b 4d 9f	 mov	 rcx, QWORD PTR c$2[rbp-193]
  00127	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0012a	ff 50 08	 call	 QWORD PTR [rax+8]
$LN12@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 22   : 			for(int k = -1; k < 2; k++)

  0012d	ff c7		 inc	 edi
  0012f	83 ff 02	 cmp	 edi, 2
  00132	7c 8c		 jl	 SHORT $LL13@renderChun

; 19   : 	{
; 20   : 		for(int j = -1; j < 2; j++)

  00134	41 ff c6	 inc	 r14d
  00137	41 83 fe 02	 cmp	 r14d, 2
  0013b	0f 8c 6f ff ff
	ff		 jl	 $LL16@renderChun

; 18   : 	for(int i = -1; i < 2; i++)

  00141	41 ff c7	 inc	 r15d
  00144	41 83 ff 02	 cmp	 r15d, 2
  00148	7d 6e		 jge	 SHORT $LN473@renderChun
  0014a	e9 51 ff ff ff	 jmp	 $LL19@renderChun
$LN455@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0014f	48 8b 4d 9f	 mov	 rcx, QWORD PTR c$2[rbp-193]
  00153	48 85 c9	 test	 rcx, rcx
  00156	74 2d		 je	 SHORT $LN130@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00158	8b c6		 mov	 eax, esi
  0015a	f0 0f c1 41 08	 lock xadd DWORD PTR [rcx+8], eax
  0015f	ff c8		 dec	 eax
  00161	75 22		 jne	 SHORT $LN130@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00163	48 8b 5d 9f	 mov	 rbx, QWORD PTR c$2[rbp-193]
  00167	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0016a	48 8b cb	 mov	 rcx, rbx
  0016d	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0016f	8b c6		 mov	 eax, esi
  00171	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  00176	ff c8		 dec	 eax
  00178	75 0b		 jne	 SHORT $LN130@renderChun

; 128  : 			_Delete_this();

  0017a	48 8b 4d 9f	 mov	 rcx, QWORD PTR c$2[rbp-193]
  0017e	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00181	ff 50 08	 call	 QWORD PTR [rax+8]
  00184	90		 npad	 1
$LN130@renderChun:

; 345  : 		if (_Rep != 0)

  00185	49 8b 5c 24 08	 mov	 rbx, QWORD PTR [r12+8]
  0018a	48 85 db	 test	 rbx, rbx
  0018d	74 22		 je	 SHORT $LN141@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0018f	8b c6		 mov	 eax, esi
  00191	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00196	ff c8		 dec	 eax
  00198	75 17		 jne	 SHORT $LN141@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0019a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0019d	48 8b cb	 mov	 rcx, rbx
  001a0	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  001a2	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  001a6	75 09		 jne	 SHORT $LN141@renderChun

; 128  : 			_Delete_this();

  001a8	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001ab	48 8b cb	 mov	 rcx, rbx
  001ae	ff 50 08	 call	 QWORD PTR [rax+8]
$LN141@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 27   : 					return false;

  001b1	32 c0		 xor	 al, al
  001b3	e9 a7 04 00 00	 jmp	 $LN22@renderChun
$LN473@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  001b8	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 33   : 	const int cx = chunk->pos.x * 16;

  001bc	44 8b 70 18	 mov	 r14d, DWORD PTR [rax+24]
  001c0	41 c1 e6 04	 shl	 r14d, 4
  001c4	44 89 75 a7	 mov	 DWORD PTR cx$1$[rbp-201], r14d

; 34   : 	const int cy = chunk->pos.y * 16;

  001c8	44 8b 78 1c	 mov	 r15d, DWORD PTR [rax+28]
  001cc	41 c1 e7 04	 shl	 r15d, 4
  001d0	44 89 7c 24 38	 mov	 DWORD PTR cy$1$[rsp], r15d

; 35   : 	const int cz = chunk->pos.z * 16;

  001d5	8b 78 20	 mov	 edi, DWORD PTR [rax+32]
  001d8	c1 e7 04	 shl	 edi, 4
  001db	89 7d 6f	 mov	 DWORD PTR cz$1$[rbp-201], edi

; 36   : 
; 37   : 	gfxu::VertexStream* firstPass = new gfxu::VertexStream(8192);

  001de	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  001e3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  001e8	48 89 45 77	 mov	 QWORD PTR $T9[rbp-201], rax
  001ec	48 85 c0	 test	 rax, rax
  001ef	74 0d		 je	 SHORT $LN24@renderChun
  001f1	48 8b c8	 mov	 rcx, rax
  001f4	e8 00 00 00 00	 call	 ??0VertexStream@gfxu@@QEAA@H@Z ; gfxu::VertexStream::VertexStream
  001f9	48 8b d8	 mov	 rbx, rax
  001fc	eb 02		 jmp	 SHORT $LN479@renderChun
$LN24@renderChun:
  001fe	33 db		 xor	 ebx, ebx
$LN479@renderChun:
  00200	48 89 5d bf	 mov	 QWORD PTR $T4[rbp-201], rbx

; 38   : 	gfxu::VertexStream* secondPass = new gfxu::VertexStream(8192);

  00204	b9 58 00 00 00	 mov	 ecx, 88			; 00000058H
  00209	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0020e	48 89 45 77	 mov	 QWORD PTR $T8[rbp-201], rax
  00212	48 85 c0	 test	 rax, rax
  00215	74 0d		 je	 SHORT $LN26@renderChun
  00217	48 8b c8	 mov	 rcx, rax
  0021a	e8 00 00 00 00	 call	 ??0VertexStream@gfxu@@QEAA@H@Z ; gfxu::VertexStream::VertexStream
  0021f	48 8b c8	 mov	 rcx, rax
  00222	eb 02		 jmp	 SHORT $LN480@renderChun
$LN26@renderChun:
  00224	33 c9		 xor	 ecx, ecx
$LN480@renderChun:
  00226	48 89 4c 24 30	 mov	 QWORD PTR $T1[rsp], rcx

; 39   : 	for(unsigned int i = 0; i < 16; i++)

  0022b	45 33 c0	 xor	 r8d, r8d
  0022e	44 89 45 7f	 mov	 DWORD PTR i$1$[rbp-201], r8d
  00232	eb 11		 jmp	 SHORT $LN9@renderChun
  00234	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL476@renderChun:
  00240	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
$LN9@renderChun:

; 40   : 	{
; 41   : 		for(unsigned int j = 0; j < 16; j++)

  00245	33 d2		 xor	 edx, edx
  00247	89 55 77	 mov	 DWORD PTR j$1$[rbp-201], edx
  0024a	41 8b c0	 mov	 eax, r8d
  0024d	0f 57 ff	 xorps	 xmm7, xmm7
  00250	f3 48 0f 2a f8	 cvtsi2ss xmm7, rax
  00255	45 8b e8	 mov	 r13d, r8d
  00258	45 0b ee	 or	 r13d, r14d
  0025b	eb 08		 jmp	 SHORT $LN6@renderChun
  0025d	0f 1f 00	 npad	 3
$LL475@renderChun:
  00260	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
$LN6@renderChun:

; 42   : 		{
; 43   : 			for(unsigned int k = 0; k < 16; k++)

  00265	45 33 e4	 xor	 r12d, r12d
  00268	8b c2		 mov	 eax, edx
  0026a	0f 57 f6	 xorps	 xmm6, xmm6
  0026d	f3 48 0f 2a f0	 cvtsi2ss xmm6, rax
  00272	44 8b f2	 mov	 r14d, edx
  00275	45 0b f7	 or	 r14d, r15d
  00278	eb 0b		 jmp	 SHORT $LN3@renderChun
  0027a	66 0f 1f 44 00
	00		 npad	 6
$LL474@renderChun:
  00280	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
$LN3@renderChun:

; 44   : 			{
; 45   : 				firstPass->setTranslation(i, j, k);

  00285	41 8b c4	 mov	 eax, r12d
  00288	0f 57 c0	 xorps	 xmm0, xmm0
  0028b	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 169  : 	translation = Vertex(x, y, z);

  00290	f3 0f 11 7b 20	 movss	 DWORD PTR [rbx+32], xmm7
  00295	f3 0f 11 73 24	 movss	 DWORD PTR [rbx+36], xmm6
  0029a	f3 0f 11 43 28	 movss	 DWORD PTR [rbx+40], xmm0

; 156  : 	vertex.r = r;

  0029f	c7 43 40 ff ff
	ff ff		 mov	 DWORD PTR [rbx+64], -1	; ffffffffH

; 169  : 	translation = Vertex(x, y, z);

  002a6	f3 0f 11 79 20	 movss	 DWORD PTR [rcx+32], xmm7
  002ab	f3 0f 11 71 24	 movss	 DWORD PTR [rcx+36], xmm6
  002b0	f3 0f 11 41 28	 movss	 DWORD PTR [rcx+40], xmm0

; 156  : 	vertex.r = r;

  002b5	c7 41 40 ff ff
	ff ff		 mov	 DWORD PTR [rcx+64], -1	; ffffffffH
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 53   : 				const int z = k | cz;

  002bc	45 8b fc	 mov	 r15d, r12d
  002bf	44 0b ff	 or	 r15d, edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 229  : 	std::shared_ptr<ChunkBase> chunk = getChunkFromBlockCoordinate(x, y, z);

  002c2	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  002c7	45 8b ce	 mov	 r9d, r14d
  002ca	45 8b c5	 mov	 r8d, r13d
  002cd	48 8d 55 af	 lea	 rdx, QWORD PTR chunk$3[rbp-201]
  002d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  002d8	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  002dd	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  002de	48 8b 5d af	 mov	 rbx, QWORD PTR chunk$3[rbp-201]
  002e2	48 85 db	 test	 rbx, rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 231  : 	if(chunk == nullptr || chunk->isEmpty() || !chunk->isLoaded())

  002e5	74 4e		 je	 SHORT $LN179@renderChun
  002e7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002ea	48 8b cb	 mov	 rcx, rbx
  002ed	ff 50 18	 call	 QWORD PTR [rax+24]
  002f0	84 c0		 test	 al, al
  002f2	75 41		 jne	 SHORT $LN179@renderChun
  002f4	38 43 09	 cmp	 BYTE PTR [rbx+9], al
  002f7	74 3c		 je	 SHORT $LN179@renderChun

; 236  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  002f9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002fc	45 8b cf	 mov	 r9d, r15d
  002ff	41 83 e1 0f	 and	 r9d, 15
  00303	45 8b c6	 mov	 r8d, r14d
  00306	41 83 e0 0f	 and	 r8d, 15
  0030a	41 8b d5	 mov	 edx, r13d
  0030d	83 e2 0f	 and	 edx, 15
  00310	48 8b cb	 mov	 rcx, rbx
  00313	ff 10		 call	 QWORD PTR [rax]
  00315	48 8b f8	 mov	 rdi, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00318	48 8b 55 b7	 mov	 rdx, QWORD PTR chunk$3[rbp-193]
  0031c	48 85 d2	 test	 rdx, rdx
  0031f	74 46		 je	 SHORT $LN181@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00321	f0 ff 4a 08	 lock dec DWORD PTR [rdx+8]
  00325	75 40		 jne	 SHORT $LN181@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00327	48 8b 5d b7	 mov	 rbx, QWORD PTR chunk$3[rbp-193]
  0032b	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0032e	48 8b cb	 mov	 rcx, rbx
  00331	ff 12		 call	 QWORD PTR [rdx]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 236  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  00333	eb 22		 jmp	 SHORT $LN482@renderChun
$LN179@renderChun:

; 232  : 	{
; 233  : 		return Blocks::air;

  00335	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?air@Blocks@@3PEAVBlockAir@@EA ; Blocks::air
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0033c	48 8b 4d b7	 mov	 rcx, QWORD PTR chunk$3[rbp-193]
  00340	48 85 c9	 test	 rcx, rcx
  00343	74 22		 je	 SHORT $LN181@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00345	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00349	75 1c		 jne	 SHORT $LN181@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0034b	48 8b 5d b7	 mov	 rbx, QWORD PTR chunk$3[rbp-193]
  0034f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00352	48 8b cb	 mov	 rcx, rbx
  00355	ff 10		 call	 QWORD PTR [rax]
$LN482@renderChun:

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00357	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0035b	75 0a		 jne	 SHORT $LN181@renderChun

; 128  : 			_Delete_this();

  0035d	48 8b 4d b7	 mov	 rcx, QWORD PTR chunk$3[rbp-193]
  00361	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00364	ff 50 08	 call	 QWORD PTR [rax+8]
$LN181@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 57   : 				block->firstPassRenderer(world, x, y, z, block, firstPass);

  00367	48 8b 5d bf	 mov	 rbx, QWORD PTR $T4[rbp-201]
  0036b	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00370	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00375	45 8b cf	 mov	 r9d, r15d
  00378	45 8b c6	 mov	 r8d, r14d
  0037b	41 8b d5	 mov	 edx, r13d
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00385	ff 57 10	 call	 QWORD PTR [rdi+16]

; 58   : 				block->secondPassRenderer(world, x, y, z, block, secondPass);

  00388	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  0038d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00392	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00397	45 8b cf	 mov	 r9d, r15d
  0039a	45 8b c6	 mov	 r8d, r14d
  0039d	41 8b d5	 mov	 edx, r13d
  003a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  003a7	ff 57 18	 call	 QWORD PTR [rdi+24]

; 42   : 		{
; 43   : 			for(unsigned int k = 0; k < 16; k++)

  003aa	41 ff c4	 inc	 r12d
  003ad	41 83 fc 10	 cmp	 r12d, 16
  003b1	8b 7d 6f	 mov	 edi, DWORD PTR cz$1$[rbp-201]
  003b4	0f 82 c6 fe ff
	ff		 jb	 $LL474@renderChun

; 40   : 	{
; 41   : 		for(unsigned int j = 0; j < 16; j++)

  003ba	8b 55 77	 mov	 edx, DWORD PTR j$1$[rbp-201]
  003bd	ff c2		 inc	 edx
  003bf	89 55 77	 mov	 DWORD PTR j$1$[rbp-201], edx
  003c2	83 fa 10	 cmp	 edx, 16
  003c5	44 8b 7c 24 38	 mov	 r15d, DWORD PTR cy$1$[rsp]
  003ca	0f 82 90 fe ff
	ff		 jb	 $LL475@renderChun

; 39   : 	for(unsigned int i = 0; i < 16; i++)

  003d0	44 8b 45 7f	 mov	 r8d, DWORD PTR i$1$[rbp-201]
  003d4	41 ff c0	 inc	 r8d
  003d7	44 89 45 7f	 mov	 DWORD PTR i$1$[rbp-201], r8d
  003db	41 83 f8 10	 cmp	 r8d, 16
  003df	44 8b 75 a7	 mov	 r14d, DWORD PTR cx$1$[rbp-201]
  003e3	0f 82 57 fe ff
	ff		 jb	 $LL476@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 977  : 		return (this->_Myend != this->_Mylast);

  003e9	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  003ed	49 be ab aa aa
	aa aa aa aa 2a	 mov	 r14, 3074457345618258603 ; 2aaaaaaaaaaaaaabH
  003f7	48 39 53 18	 cmp	 QWORD PTR [rbx+24], rdx

; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())

  003fb	74 47		 je	 SHORT $LN478@renderChun

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);

  003fd	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00401	48 3b c2	 cmp	 rax, rdx

; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())

  00404	75 1e		 jne	 SHORT $LN227@renderChun

; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)
; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)
; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));
; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())

  00406	48 85 c0	 test	 rax, rax
  00409	74 39		 je	 SHORT $LN478@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0040b	48 8b c8	 mov	 rcx, rax
  0040e	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00413	45 33 ff	 xor	 r15d, r15d
  00416	4c 89 7b 08	 mov	 QWORD PTR [rbx+8], r15

; 1543 : 			this->_Mylast = pointer();

  0041a	4c 89 7b 10	 mov	 QWORD PTR [rbx+16], r15

; 1544 : 			this->_Myend = pointer();

  0041e	4c 89 7b 18	 mov	 QWORD PTR [rbx+24], r15

; 1051 : 				_Tidy();
; 1052 : 			else

  00422	eb 23		 jmp	 SHORT $LN226@renderChun
$LN227@renderChun:

; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00424	48 2b d0	 sub	 rdx, rax
  00427	49 8b c6	 mov	 rax, r14
  0042a	48 f7 ea	 imul	 rdx
  0042d	48 c1 fa 02	 sar	 rdx, 2
  00431	48 8b c2	 mov	 rax, rdx
  00434	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  00438	48 03 d0	 add	 rdx, rax

; 1053 : 				_Reallocate(size());

  0043b	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  0043f	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@IEAAX_K@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::_Reallocate
$LN478@renderChun:
  00444	45 33 ff	 xor	 r15d, r15d
$LN226@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 257  : 	vertices.shrink_to_fit();

  00447	48 8b 7c 24 30	 mov	 rdi, QWORD PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 977  : 		return (this->_Myend != this->_Mylast);

  0044c	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00450	48 39 57 18	 cmp	 QWORD PTR [rdi+24], rdx

; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())

  00454	74 44		 je	 SHORT $LN250@renderChun

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);

  00456	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0045a	48 3b c2	 cmp	 rax, rdx

; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())

  0045d	75 1b		 jne	 SHORT $LN251@renderChun

; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)
; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)
; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));
; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())

  0045f	48 85 c0	 test	 rax, rax
  00462	74 36		 je	 SHORT $LN250@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00464	48 8b c8	 mov	 rcx, rax
  00467	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  0046c	4c 89 7f 08	 mov	 QWORD PTR [rdi+8], r15

; 1543 : 			this->_Mylast = pointer();

  00470	4c 89 7f 10	 mov	 QWORD PTR [rdi+16], r15

; 1544 : 			this->_Myend = pointer();

  00474	4c 89 7f 18	 mov	 QWORD PTR [rdi+24], r15

; 1051 : 				_Tidy();
; 1052 : 			else

  00478	eb 20		 jmp	 SHORT $LN250@renderChun
$LN251@renderChun:

; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0047a	48 2b d0	 sub	 rdx, rax
  0047d	49 8b c6	 mov	 rax, r14
  00480	48 f7 ea	 imul	 rdx
  00483	48 c1 fa 02	 sar	 rdx, 2
  00487	48 8b c2	 mov	 rax, rdx
  0048a	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0048e	48 03 d0	 add	 rdx, rax

; 1053 : 				_Reallocate(size());

  00491	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]
  00495	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@IEAAX_K@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::_Reallocate
$LN250@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  0049a	4c 8b 75 67	 mov	 r14, QWORD PTR chunk$[rbp-201]
  0049e	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  004a1	48 83 c1 30	 add	 rcx, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  004a5	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  004aa	85 c0		 test	 eax, eax
  004ac	74 07		 je	 SHORT $LN280@renderChun

; 33   : 		_Throw_C_error(_Res);

  004ae	8b c8		 mov	 ecx, eax
  004b0	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN280@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  004b5	4c 89 7d 87	 mov	 QWORD PTR firstPassPtr$[rbp-201], r15
  004b9	4c 89 7d 8f	 mov	 QWORD PTR firstPassPtr$[rbp-193], r15

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  004bd	48 8b d3	 mov	 rdx, rbx
  004c0	48 8d 4d 87	 lea	 rcx, QWORD PTR firstPassPtr$[rbp-201]
  004c4	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  004c9	90		 npad	 1

; 282  : 		{	// construct

  004ca	4c 89 7c 24 40	 mov	 QWORD PTR secondPassPtr$[rsp], r15
  004cf	4c 89 7c 24 48	 mov	 QWORD PTR secondPassPtr$[rsp+8], r15

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  004d4	48 8b d7	 mov	 rdx, rdi
  004d7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR secondPassPtr$[rsp]
  004dc	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  004e1	90		 npad	 1

; 335  : 		return (_Ptr);

  004e2	49 8b 16	 mov	 rdx, QWORD PTR [r14]

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  004e5	48 8b 4d 8f	 mov	 rcx, QWORD PTR firstPassPtr$[rbp-193]
  004e9	48 85 c9	 test	 rcx, rcx
  004ec	74 04		 je	 SHORT $LN314@renderChun

; 108  : 		_MT_INCR(_Ignored, _Uses);

  004ee	f0 ff 41 08	 lock inc DWORD PTR [rcx+8]
$LN314@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  004f2	48 8b 4a 40	 mov	 rcx, QWORD PTR [rdx+64]
  004f6	48 89 4d df	 mov	 QWORD PTR $T6[rbp-193], rcx

; 49   : 	_Right = _Move(_Tmp);

  004fa	48 8b 45 8f	 mov	 rax, QWORD PTR firstPassPtr$[rbp-193]
  004fe	48 89 42 40	 mov	 QWORD PTR [rdx+64], rax
  00502	48 8b 45 87	 mov	 rax, QWORD PTR firstPassPtr$[rbp-201]
  00506	48 89 42 38	 mov	 QWORD PTR [rdx+56], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0050a	48 85 c9	 test	 rcx, rcx
  0050d	74 22		 je	 SHORT $LN468@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0050f	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00513	75 1c		 jne	 SHORT $LN468@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00515	48 8b 5d df	 mov	 rbx, QWORD PTR $T6[rbp-193]
  00519	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0051c	48 8b cb	 mov	 rcx, rbx
  0051f	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00521	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00525	75 0a		 jne	 SHORT $LN468@renderChun

; 128  : 			_Delete_this();

  00527	48 8b 4d df	 mov	 rcx, QWORD PTR $T6[rbp-193]
  0052b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0052e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN468@renderChun:

; 335  : 		return (_Ptr);

  00531	49 8b 16	 mov	 rdx, QWORD PTR [r14]

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00534	48 8b 5c 24 48	 mov	 rbx, QWORD PTR secondPassPtr$[rsp+8]
  00539	48 85 db	 test	 rbx, rbx
  0053c	74 09		 je	 SHORT $LN371@renderChun

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0053e	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
  00542	48 8b 5c 24 48	 mov	 rbx, QWORD PTR secondPassPtr$[rsp+8]
$LN371@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00547	48 8b 4a 50	 mov	 rcx, QWORD PTR [rdx+80]
  0054b	48 89 4d cf	 mov	 QWORD PTR $T5[rbp-193], rcx

; 49   : 	_Right = _Move(_Tmp);

  0054f	48 89 5a 50	 mov	 QWORD PTR [rdx+80], rbx
  00553	48 8b 44 24 40	 mov	 rax, QWORD PTR secondPassPtr$[rsp]
  00558	48 89 42 48	 mov	 QWORD PTR [rdx+72], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0055c	48 85 c9	 test	 rcx, rcx
  0055f	74 27		 je	 SHORT $LN402@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00561	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00565	75 1c		 jne	 SHORT $LN469@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00567	48 8b 5d cf	 mov	 rbx, QWORD PTR $T5[rbp-193]
  0056b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0056e	48 8b cb	 mov	 rcx, rbx
  00571	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00573	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00577	75 0a		 jne	 SHORT $LN469@renderChun

; 128  : 			_Delete_this();

  00579	48 8b 4d cf	 mov	 rcx, QWORD PTR $T5[rbp-193]
  0057d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00580	ff 50 08	 call	 QWORD PTR [rax+8]
$LN469@renderChun:
  00583	48 8b 5c 24 48	 mov	 rbx, QWORD PTR secondPassPtr$[rsp+8]
$LN402@renderChun:

; 335  : 		return (_Ptr);

  00588	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  0058b	48 83 c1 30	 add	 rcx, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0058f	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00594	85 c0		 test	 eax, eax
  00596	74 08		 je	 SHORT $LN413@renderChun

; 33   : 		_Throw_C_error(_Res);

  00598	8b c8		 mov	 ecx, eax
  0059a	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0059f	90		 npad	 1
$LN413@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  005a0	48 85 db	 test	 rbx, rbx
  005a3	74 2f		 je	 SHORT $LN470@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  005a5	8b c6		 mov	 eax, esi
  005a7	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  005ac	ff c8		 dec	 eax
  005ae	75 24		 jne	 SHORT $LN470@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  005b0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR secondPassPtr$[rsp+8]
  005b5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  005b8	48 8b cb	 mov	 rcx, rbx
  005bb	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  005bd	8b c6		 mov	 eax, esi
  005bf	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  005c4	ff c8		 dec	 eax
  005c6	75 0c		 jne	 SHORT $LN470@renderChun

; 128  : 			_Delete_this();

  005c8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR secondPassPtr$[rsp+8]
  005cd	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  005d0	ff 50 08	 call	 QWORD PTR [rax+8]
  005d3	90		 npad	 1
$LN470@renderChun:

; 345  : 		if (_Rep != 0)

  005d4	48 8b 4d 8f	 mov	 rcx, QWORD PTR firstPassPtr$[rbp-193]
  005d8	48 85 c9	 test	 rcx, rcx
  005db	74 2d		 je	 SHORT $LN435@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  005dd	8b c6		 mov	 eax, esi
  005df	f0 0f c1 41 08	 lock xadd DWORD PTR [rcx+8], eax
  005e4	ff c8		 dec	 eax
  005e6	75 22		 jne	 SHORT $LN435@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  005e8	48 8b 5d 8f	 mov	 rbx, QWORD PTR firstPassPtr$[rbp-193]
  005ec	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  005ef	48 8b cb	 mov	 rcx, rbx
  005f2	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  005f4	8b c6		 mov	 eax, esi
  005f6	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  005fb	ff c8		 dec	 eax
  005fd	75 0b		 jne	 SHORT $LN435@renderChun

; 128  : 			_Delete_this();

  005ff	48 8b 4d 8f	 mov	 rcx, QWORD PTR firstPassPtr$[rbp-193]
  00603	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00606	ff 50 08	 call	 QWORD PTR [rax+8]
  00609	90		 npad	 1
$LN435@renderChun:

; 345  : 		if (_Rep != 0)

  0060a	49 8b 5e 08	 mov	 rbx, QWORD PTR [r14+8]
  0060e	48 85 db	 test	 rbx, rbx
  00611	74 4a		 je	 SHORT $LN80@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00613	8b c6		 mov	 eax, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 72   : 	return true;

  00615	eb 26		 jmp	 SHORT $LN486@renderChun
$LN20@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00617	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  0061b	48 83 c1 28	 add	 rcx, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0061f	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00624	85 c0		 test	 eax, eax
  00626	74 08		 je	 SHORT $LN69@renderChun

; 33   : 		_Throw_C_error(_Res);

  00628	8b c8		 mov	 ecx, eax
  0062a	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0062f	90		 npad	 1
$LN69@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00630	49 8b 5c 24 08	 mov	 rbx, QWORD PTR [r12+8]
  00635	48 85 db	 test	 rbx, rbx
  00638	74 23		 je	 SHORT $LN80@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0063a	83 c8 ff	 or	 eax, -1
$LN486@renderChun:
  0063d	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00642	ff c8		 dec	 eax
  00644	75 17		 jne	 SHORT $LN80@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00646	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00649	48 8b cb	 mov	 rcx, rbx
  0064c	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0064e	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00652	75 09		 jne	 SHORT $LN80@renderChun

; 128  : 			_Delete_this();

  00654	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00657	48 8b cb	 mov	 rcx, rbx
  0065a	ff 50 08	 call	 QWORD PTR [rax+8]
$LN80@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 13   : 		return true;

  0065d	b0 01		 mov	 al, 1
$LN22@renderChun:

; 73   : }

  0065f	0f 28 b4 24 d0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+208]
  00667	0f 28 bc 24 c0
	00 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+192]
  0066f	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00676	41 5f		 pop	 r15
  00678	41 5e		 pop	 r14
  0067a	41 5d		 pop	 r13
  0067c	41 5c		 pop	 r12
  0067e	5f		 pop	 rdi
  0067f	5e		 pop	 rsi
  00680	5b		 pop	 rbx
  00681	5d		 pop	 rbp
  00682	c3		 ret	 0
?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; renderChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
c$2 = 96
cx$1$ = 112
chunk$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$0@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$0
  00000	48 8b 8a 30 01
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
c$2 = 96
cx$1$ = 112
chunk$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$1@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$1
  0000c	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR c$2[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$1@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
c$2 = 96
cx$1$ = 112
chunk$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$2@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$2
  00018	48 8b 8a 40 01
	00 00		 mov	 rcx, QWORD PTR $T9[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$2@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
c$2 = 96
cx$1$ = 112
chunk$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$3@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$3
  00024	48 8b 8a 40 01
	00 00		 mov	 rcx, QWORD PTR $T8[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$3@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
c$2 = 96
cx$1$ = 112
chunk$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$6@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$6
  00030	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR chunk$3[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$6@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
c$2 = 96
cx$1$ = 112
chunk$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$4@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$4
  0003c	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR firstPassPtr$[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
?dtor$4@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
c$2 = 96
cx$1$ = 112
chunk$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$5@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$5
  00048	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR secondPassPtr$[rdx]
  0004f	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
?dtor$5@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
chunk$2 = 56
$T3 = 72
q$ = 128
?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z PROC ; renderFirstPossible, COMDAT

; 76   : {

$LN184:
  00000	48 8b c4	 mov	 rax, rsp
  00003	41 54		 push	 r12
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000d	48 c7 40 a8 fe
	ff ff ff	 mov	 QWORD PTR [rax-88], -2
  00015	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00019	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0001d	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  00021	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00025	48 8b f9	 mov	 rdi, rcx

; 77   : 	for(unsigned int i = 0; !GlobalThread::stop && (i < q.size()); i++)

  00028	45 33 e4	 xor	 r12d, r12d
  0002b	45 8b fc	 mov	 r15d, r12d
  0002e	44 38 25 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, r12b ; GlobalThread::stop
  00035	0f 85 f4 01 00
	00		 jne	 $LN3@renderFirs
  0003b	83 cd ff	 or	 ebp, -1
  0003e	66 90		 npad	 2
$LL5@renderFirs:
  00040	41 8b c7	 mov	 eax, r15d
  00043	48 3b 47 20	 cmp	 rax, QWORD PTR [rdi+32]
  00047	0f 83 e2 01 00
	00		 jae	 $LN3@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  0004d	48 8d 54 24 48	 lea	 rdx, QWORD PTR $T3[rsp]
  00052	48 8b cf	 mov	 rcx, rdi
  00055	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  0005a	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0005d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00060	48 85 c0	 test	 rax, rax
  00063	75 05		 jne	 SHORT $LN24@renderFirs
  00065	49 8b c4	 mov	 rax, r12
  00068	eb 03		 jmp	 SHORT $LN25@renderFirs
$LN24@renderFirs:
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN25@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0006d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00071	48 ff c9	 dec	 rcx
  00074	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00080	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00084	4c 8b 31	 mov	 r14, QWORD PTR [rcx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00087	48 85 db	 test	 rbx, rbx
  0008a	74 04		 je	 SHORT $LN45@renderFirs

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0008c	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN45@renderFirs:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00090	48 89 5c 24 40	 mov	 QWORD PTR chunk$2[rsp+8], rbx

; 427  : 		_Ptr = _Other_ptr;

  00095	4c 89 74 24 38	 mov	 QWORD PTR chunk$2[rsp], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  0009a	48 83 7f 20 00	 cmp	 QWORD PTR [rdi+32], 0

; 1427 : 		}
; 1428 : 
; 1429 : 	const_reference front() const
; 1430 : 		{	// return first element of nonmutable sequence
; 1431 : 		return (*begin());
; 1432 : 		}
; 1433 : 
; 1434 : 	reference back()
; 1435 : 		{	// return last element of mutable sequence
; 1436 : 		return (*(end() - 1));
; 1437 : 		}
; 1438 : 
; 1439 : 	const_reference back() const
; 1440 : 		{	// return last element of nonmutable sequence
; 1441 : 		return (*(end() - 1));
; 1442 : 		}
; 1443 : 
; 1444 : 	void push_front(const value_type& _Val)
; 1445 : 		{	// insert element at beginning
; 1446 : 		this->_Orphan_all();
; 1447 : 		_PUSH_FRONT_BEGIN;
; 1448 : 		this->_Getal().construct(
; 1449 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1450 : 		_PUSH_FRONT_END;
; 1451 : 		}
; 1452 : 
; 1453 : 	void pop_front()
; 1454 : 		{	// erase element at beginning
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())

  0009f	74 49		 je	 SHORT $LN50@renderFirs

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  000a1	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  000a5	48 ff c9	 dec	 rcx
  000a8	48 23 4f 18	 and	 rcx, QWORD PTR [rdi+24]

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  000ac	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000b0	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000b4	48 8b 71 08	 mov	 rsi, QWORD PTR [rcx+8]
  000b8	48 85 f6	 test	 rsi, rsi
  000bb	74 1d		 je	 SHORT $LN78@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000bd	f0 ff 4e 08	 lock dec DWORD PTR [rsi+8]
  000c1	75 17		 jne	 SHORT $LN78@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000c3	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000c6	48 8b ce	 mov	 rcx, rsi
  000c9	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000cb	f0 ff 4e 0c	 lock dec DWORD PTR [rsi+12]
  000cf	75 09		 jne	 SHORT $LN78@renderFirs

; 128  : 			_Delete_this();

  000d1	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000d4	48 8b ce	 mov	 rcx, rsi
  000d7	ff 50 08	 call	 QWORD PTR [rax+8]
$LN78@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1476 : 			if (--this->_Mysize == 0)

  000da	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  000de	75 06		 jne	 SHORT $LN51@renderFirs

; 1477 : 				this->_Myoff = 0;

  000e0	4c 89 67 18	 mov	 QWORD PTR [rdi+24], r12

; 1478 : 			else

  000e4	eb 04		 jmp	 SHORT $LN50@renderFirs
$LN51@renderFirs:

; 1479 : 				++this->_Myoff;

  000e6	48 ff 47 18	 inc	 QWORD PTR [rdi+24]
$LN50@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  000ea	4c 89 64 24 28	 mov	 QWORD PTR $T1[rsp], r12
  000ef	4c 89 64 24 30	 mov	 QWORD PTR $T1[rsp+8], r12

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  000f4	48 85 db	 test	 rbx, rbx
  000f7	74 2b		 je	 SHORT $LN98@renderFirs

; 108  : 		_MT_INCR(_Ignored, _Uses);

  000f9	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  000fd	48 8b 74 24 30	 mov	 rsi, QWORD PTR $T1[rsp+8]
  00102	48 85 f6	 test	 rsi, rsi
  00105	74 1d		 je	 SHORT $LN98@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00107	f0 ff 4e 08	 lock dec DWORD PTR [rsi+8]
  0010b	75 17		 jne	 SHORT $LN98@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0010d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00110	48 8b ce	 mov	 rcx, rsi
  00113	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00115	f0 ff 4e 0c	 lock dec DWORD PTR [rsi+12]
  00119	75 09		 jne	 SHORT $LN98@renderFirs

; 128  : 			_Delete_this();

  0011b	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0011e	48 8b ce	 mov	 rcx, rsi
  00121	ff 50 08	 call	 QWORD PTR [rax+8]
$LN98@renderFirs:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00124	48 89 5c 24 30	 mov	 QWORD PTR $T1[rsp+8], rbx

; 427  : 		_Ptr = _Other_ptr;

  00129	4c 89 74 24 28	 mov	 QWORD PTR $T1[rsp], r14
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 81   : 		if(renderChunk(chunk))

  0012e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  00133	e8 00 00 00 00	 call	 ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; renderChunk
  00138	84 c0		 test	 al, al
  0013a	0f 85 c4 00 00
	00		 jne	 $LN178@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00140	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00144	48 ff c0	 inc	 rax
  00147	48 39 47 10	 cmp	 QWORD PTR [rdi+16], rax
  0014b	77 08		 ja	 SHORT $LN115@renderFirs
  0014d	48 8b cf	 mov	 rcx, rdi
  00150	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
$LN115@renderFirs:
  00155	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00159	49 ff c8	 dec	 r8
  0015c	4c 21 47 18	 and	 QWORD PTR [rdi+24], r8
  00160	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00164	48 03 57 20	 add	 rdx, QWORD PTR [rdi+32]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00168	4c 23 c2	 and	 r8, rdx

; 1487 : 		_PUSH_BACK_BEGIN;

  0016b	4a 8d 34 c5 00
	00 00 00	 lea	 rsi, QWORD PTR [r8*8]
  00173	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00177	48 83 3c 06 00	 cmp	 QWORD PTR [rsi+rax], 0
  0017c	75 17		 jne	 SHORT $LN114@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0017e	b9 10 00 00 00	 mov	 ecx, 16
  00183	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00188	48 85 c0	 test	 rax, rax
  0018b	74 71		 je	 SHORT $LN179@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  0018d	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00191	48 89 04 0e	 mov	 QWORD PTR [rsi+rcx], rax
$LN114@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00195	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00199	48 8b 0c 06	 mov	 rcx, QWORD PTR [rsi+rax]
  0019d	48 85 c9	 test	 rcx, rcx
  001a0	74 1b		 je	 SHORT $LN149@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  001a2	4c 89 21	 mov	 QWORD PTR [rcx], r12
  001a5	4c 89 61 08	 mov	 QWORD PTR [rcx+8], r12

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  001a9	48 85 db	 test	 rbx, rbx
  001ac	74 04		 je	 SHORT $LN162@renderFirs

; 108  : 		_MT_INCR(_Ignored, _Uses);

  001ae	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN162@renderFirs:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  001b2	4c 8b c3	 mov	 r8, rbx
  001b5	49 8b d6	 mov	 rdx, r14
  001b8	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN149@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  001bd	48 ff 47 20	 inc	 QWORD PTR [rdi+32]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001c1	48 85 db	 test	 rbx, rbx
  001c4	74 27		 je	 SHORT $LN4@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  001c6	8b c5		 mov	 eax, ebp
  001c8	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  001cd	ff c8		 dec	 eax
  001cf	75 1c		 jne	 SHORT $LN4@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  001d1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001d4	48 8b cb	 mov	 rcx, rbx
  001d7	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  001d9	8b c5		 mov	 eax, ebp
  001db	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  001e0	ff c8		 dec	 eax
  001e2	75 09		 jne	 SHORT $LN4@renderFirs

; 128  : 			_Delete_this();

  001e4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001e7	48 8b cb	 mov	 rcx, rbx
  001ea	ff 50 08	 call	 QWORD PTR [rax+8]
$LN4@renderFirs:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 77   : 	for(unsigned int i = 0; !GlobalThread::stop && (i < q.size()); i++)

  001ed	41 ff c7	 inc	 r15d
  001f0	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
  001f7	75 36		 jne	 SHORT $LN3@renderFirs
  001f9	e9 42 fe ff ff	 jmp	 $LL5@renderFirs
$LN179@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  001fe	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00203	90		 npad	 1
$LN178@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00204	48 85 db	 test	 rbx, rbx
  00207	74 22		 je	 SHORT $LN109@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00209	8b c5		 mov	 eax, ebp
  0020b	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00210	ff c8		 dec	 eax
  00212	75 17		 jne	 SHORT $LN109@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00214	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00217	48 8b cb	 mov	 rcx, rbx
  0021a	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0021c	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00220	75 09		 jne	 SHORT $LN109@renderFirs

; 128  : 			_Delete_this();

  00222	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00225	48 8b cb	 mov	 rcx, rbx
  00228	ff 50 08	 call	 QWORD PTR [rax+8]
$LN109@renderFirs:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 83   : 			return true;

  0022b	b0 01		 mov	 al, 1
  0022d	eb 02		 jmp	 SHORT $LN6@renderFirs
$LN3@renderFirs:

; 84   : 		}
; 85   : 		else
; 86   : 		{
; 87   : 			q.push(chunk);
; 88   : 		}
; 89   : 	}
; 90   : 	return false;

  0022f	32 c0		 xor	 al, al
$LN6@renderFirs:

; 91   : }

  00231	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  00236	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0023a	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  0023e	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  00242	49 8b 7b 38	 mov	 rdi, QWORD PTR [r11+56]
  00246	49 8b e3	 mov	 rsp, r11
  00249	41 5f		 pop	 r15
  0024b	41 5e		 pop	 r14
  0024d	41 5c		 pop	 r12
  0024f	c3		 ret	 0
$LN183@renderFirs:
?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ENDP ; renderFirstPossible
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
chunk$2 = 56
$T3 = 72
q$ = 128
?dtor$0@?0??renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z@4HA PROC ; `renderFirstPossible'::`1'::dtor$0
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR chunk$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z@4HA ENDP ; `renderFirstPossible'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?tick@ChunkDrawThread@@MEAA_NXZ
_TEXT	SEGMENT
this$ = 48
?tick@ChunkDrawThread@@MEAA_NXZ PROC			; ChunkDrawThread::tick, COMDAT

; 94   : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0000d	48 81 c1 b0 08
	00 00		 add	 rcx, 2224		; 000008b0H
  00014	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN9@tick

; 33   : 		_Throw_C_error(_Res);

  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN9@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 96   : 	bool rendered = renderFirstPossible(ChunkDrawThread::drawFirstQueue) || renderFirstPossible(ChunkDrawThread::drawQueue) || renderFirstPossible(ChunkDrawThread::drawLaterQueue);

  00024	48 8d 8b 38 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2104]
  0002b	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
  00030	84 c0		 test	 al, al
  00032	75 1c		 jne	 SHORT $LN3@tick
  00034	48 8d 8b 60 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2144]
  0003b	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
  00040	84 c0		 test	 al, al
  00042	75 0c		 jne	 SHORT $LN3@tick
  00044	48 8d 8b 88 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2184]
  0004b	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
$LN3@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00050	48 8d 8b b0 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2224]
  00057	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN19@tick

; 33   : 		_Throw_C_error(_Res);

  00060	8b c8		 mov	 ecx, eax
  00062	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN19@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 99   : 	return true;

  00067	b0 01		 mov	 al, 1

; 100  : }

  00069	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
?tick@ChunkDrawThread@@MEAA_NXZ ENDP			; ChunkDrawThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestQuickChunkDraw, COMDAT

; 103  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 104  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?drawerThread@@3HA ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestQui

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestQui:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 38 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2104
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestQui

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestQui:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestQui

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestQui

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestQui

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestQui:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 109  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestQuickChunkDraw
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestQuickChunkDraw'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestQuickChunkDraw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestChunkDraw, COMDAT

; 112  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 113  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?drawerThread@@3HA ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestChu

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 60 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2144
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestChu

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestChu

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestChu

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestChu

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestChu:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 118  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestChunkDraw
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestChunkDraw'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestChunkDraw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestLateChunkDraw, COMDAT

; 121  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 122  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?drawerThread@@3HA ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestLat

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestLat:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2184
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestLat

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestLat:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestLat

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestLat

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestLat

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestLat:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 127  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestLateChunkDraw
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestLateChunkDraw'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestLateChunkDraw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 791  : 		{	// construct from [_Ptr, <null>)

$LN47:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00006	45 33 c0	 xor	 r8d, r8d

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00009	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15

; 791  : 		{	// construct from [_Ptr, <null>)

  00011	48 8b d9	 mov	 rbx, rcx

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00014	4c 89 41 10	 mov	 QWORD PTR [rcx+16], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00018	44 88 01	 mov	 BYTE PTR [rcx], r8b

; 523  : 			: _CSTD strlen(_First));

  0001b	44 38 02	 cmp	 BYTE PTR [rdx], r8b
  0001e	74 0e		 je	 SHORT $LN44@basic_stri
  00020	49 83 c8 ff	 or	 r8, -1
$LL45@basic_stri:
  00024	49 ff c0	 inc	 r8
  00027	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  0002c	75 f6		 jne	 SHORT $LL45@basic_stri
$LN44@basic_stri:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}

  00033	48 8b c3	 mov	 rax, rbx
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 963  : 		{	// destroy the string

$LN34:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00006	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 963  : 		{	// destroy the string

  0000b	48 8b d9	 mov	 rbx, rcx

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0000e	72 08		 jb	 SHORT $LN21@basic_stri
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00010	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00013	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN21@basic_stri:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00018	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00020	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00028	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 965  : 		}

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ PROC	; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>, COMDAT

; 622  : 		{	// release resource

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN9@shared_ptr

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN12@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN12@shared_ptr

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN12@shared_ptr:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN9@shared_ptr:

; 623  : 		this->_Decref();
; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ENDP	; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::operator=, COMDAT

; 627  : 		{	// assign shared ownership of resource owned by _Right

$LN59:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 627  : 		{	// assign shared ownership of resource owned by _Right

  0000d	48 8b f9	 mov	 rdi, rcx

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00010	48 85 c0	 test	 rax, rax
  00013	74 04		 je	 SHORT $LN20@operator

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00015	f0 ff 40 08	 lock inc DWORD PTR [rax+8]
$LN20@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00019	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]

; 49   : 	_Right = _Move(_Tmp);

  0001d	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  00021	4c 89 07	 mov	 QWORD PTR [rdi], r8

; 48   : 	_Left = _Move(_Right);

  00024	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp+8], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00029	48 85 c9	 test	 rcx, rcx
  0002c	74 41		 je	 SHORT $LN56@operator

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0002e	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00032	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00037	75 28		 jne	 SHORT $LN55@operator
  00039	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003e	48 8b 5c 24 28	 mov	 rbx, QWORD PTR $T1[rsp+8]
  00043	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0004b	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00054	75 0b		 jne	 SHORT $LN55@operator

; 128  : 			_Delete_this();

  00056	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp+8]
  0005b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0005e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN55@operator:

; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);

  00061	48 8b c7	 mov	 rax, rdi
  00064	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 630  : 		}

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN56@operator:

; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);

  0006f	48 8b c7	 mov	 rax, rdi

; 630  : 		}

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_KXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size, COMDAT

; 130  : 		return (c.size());

  00000	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]

; 131  : 		}

  00004	c3		 ret	 0
?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_KXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 80
?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front, COMDAT

; 134  : 		{	// return first element of mutable queue

$LN16:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  00004	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  0000e	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00011	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00014	48 85 c0	 test	 rax, rax
  00017	74 03		 je	 SHORT $LN12@front
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN12@front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 135  : 		return (c.front());

  00020	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00024	48 ff c9	 dec	 rcx
  00027	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 135  : 		return (c.front());

  0002b	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 136  : 		}

  0002f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00033	c3		 ret	 0
?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push, COMDAT

; 155  : 		c.push_back(_Val);

  00000	e9 00 00 00 00	 jmp	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop, COMDAT

; 160  : 		c.pop_front();

  00000	e9 00 00 00 00	 jmp	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z PROC	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00008	48 8b d9	 mov	 rbx, rcx

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00012	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00016	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00019	4d 85 c0	 test	 r8, r8
  0001c	74 05		 je	 SHORT $LN10@shared_ptr

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0001e	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN10@shared_ptr:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00023	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0

; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}

  00028	48 8b c3	 mov	 rax, rbx
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z ENDP	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ PROC		; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>, COMDAT

; 622  : 		{	// release resource

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN9@shared_ptr

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN12@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN12@shared_ptr

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN12@shared_ptr:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN9@shared_ptr:

; 623  : 		this->_Decref();
; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ENDP		; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??C?$shared_ptr@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$shared_ptr@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ PROC ; std::shared_ptr<ChunkBase>::operator->, COMDAT

; 691  : 		return (this->_Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 692  : 		}

  00003	c3		 ret	 0
??C?$shared_ptr@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ ENDP ; std::shared_ptr<ChunkBase>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  00000	80 3a 00	 cmp	 BYTE PTR [rdx], 0
  00003	75 08		 jne	 SHORT $LN5@assign
  00005	45 33 c0	 xor	 r8d, r8d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00008	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 523  : 			: _CSTD strlen(_First));

  0000d	49 83 c8 ff	 or	 r8, -1
$LL7@assign:
  00011	49 ff c0	 inc	 r8
  00014	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  00019	75 f6		 jne	 SHORT $LL7@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0001b	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 1733 : 		return (this->_Mysize);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 1734 : 		}

  00004	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Built$ = 56
_Newsize$ = 64
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT

; 2253 : 		{	// initialize buffer, deallocating any storage

$LN33:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b d9	 mov	 rbx, rcx

; 2254 : 		if (!_Built)

  00010	84 d2		 test	 dl, dl
  00012	74 2a		 je	 SHORT $LN19@Tidy

; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00014	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16
  00019	72 23		 jb	 SHORT $LN19@Tidy

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

  0001b	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00020	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
  00023	49 83 f8 01	 cmp	 r8, 1
  00027	72 08		 jb	 SHORT $LN14@Tidy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00029	48 8b d6	 mov	 rdx, rsi
  0002c	e8 00 00 00 00	 call	 memcpy
$LN14@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00031	48 8b ce	 mov	 rcx, rsi
  00034	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00039	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN19@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0003e	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00046	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0004a	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2267 : 		}

  0004e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >, COMDAT

; 498  : 		_Mysize = 0;

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 499  : 		_Myres = 0;

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 636  : 		{	// construct allocator from _Al
; 637  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT

; 689  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 690  : 		}

  00003	c3		 ret	 0
?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16
  00005	72 04		 jb	 SHORT $LN3@Myptr
  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 525  : 		}

  0000a	c3		 ret	 0
$LN3@Myptr:

; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

  0000b	48 8b c1	 mov	 rax, rcx

; 525  : 		}

  0000e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>, COMDAT

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00008	48 8b d9	 mov	 rbx, rcx

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00012	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00016	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00019	4d 85 c0	 test	 r8, r8
  0001c	74 05		 je	 SHORT $LN10@shared_ptr

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0001e	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN10@shared_ptr:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00023	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0

; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}

  00028	48 8b c3	 mov	 rax, rbx
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 677  : 		}

  0001c	c3		 ret	 0
?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ PROC ; std::_Ptr_base<gfxu::VertexStream>::_Decref, COMDAT

; 344  : 		{	// decrement reference count

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN7@Decref

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN10@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN10@Decref

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Decref:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN7@Decref:

; 346  : 			_Rep->_Decref();
; 347  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size, COMDAT

; 1372 : 		return (this->_Mysize);

  00000	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]

; 1373 : 		}

  00004	c3		 ret	 0
?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 80
?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front, COMDAT

; 1425 : 		{	// return first element of mutable sequence

$LN14:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1426 : 		return (*begin());

  00004	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  0000e	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00011	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00014	48 85 c0	 test	 rax, rax
  00017	74 03		 je	 SHORT $LN10@front
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN10@front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 1426 : 		return (*begin());

  00020	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00024	48 ff c9	 dec	 rcx
  00027	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  0002b	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 1427 : 		}

  0002f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00033	c3		 ret	 0
?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front, COMDAT

; 1454 : 		{	// erase element at beginning

$LN34:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 788  : 		}
; 789  : 
; 790  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 791  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 792  : 	size_type _Myoff;	// offset of initial element
; 793  : 	size_type _Mysize;	// current length of sequence
; 794  : 	};
; 795  : 
; 796  : 		// TEMPLATE CLASS _Deque_alloc
; 797  : template<bool _Al_has_storage,
; 798  : 	class _Alloc_types>
; 799  : 	class _Deque_alloc
; 800  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 801  : 	{	// base class for deque to hold allocator with storage
; 802  : public:
; 803  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 804  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 805  : 	typedef typename _Alloc_types::_Alty _Alty;
; 806  : 
; 807  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 808  : 
; 809  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 810  : 		: _Alval(_Al)
; 811  : 		{	// construct allocators from _Al
; 812  : 		_Alloc_proxy();
; 813  : 		}
; 814  : 
; 815  : 	~_Deque_alloc() _NOEXCEPT
; 816  : 		{	// destroy proxy
; 817  : 		_Free_proxy();
; 818  : 		}
; 819  : 
; 820  : 	void _Change_alloc(const _Alty& _Al)
; 821  : 		{	// replace old allocator
; 822  : 		_Free_proxy();
; 823  : 		_Alval = _Al;
; 824  : 		_Alloc_proxy();
; 825  : 		}
; 826  : 
; 827  : 	void _Swap_alloc(_Myt& _Right)
; 828  : 		{	// swap allocators
; 829  : 		_Swap_adl(_Alval, _Right._Alval);
; 830  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 831  : 		}
; 832  : 
; 833  : 	void _Alloc_proxy()
; 834  : 		{	// construct proxy from _Alval
; 835  : 		typename _Alty::template rebind<_Container_proxy>::other
; 836  : 			_Alproxy(_Alval);
; 837  : 		this->_Myproxy = _Alproxy.allocate(1);
; 838  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 839  : 		this->_Myproxy->_Mycont = this;
; 840  : 		}
; 841  : 
; 842  : 	void _Free_proxy()
; 843  : 		{	// destroy proxy
; 844  : 		typename _Alty::template rebind<_Container_proxy>::other
; 845  : 			_Alproxy(_Alval);
; 846  : 		this->_Orphan_all();
; 847  : 		_Alproxy.destroy(this->_Myproxy);
; 848  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 849  : 		this->_Myproxy = 0;
; 850  : 		}
; 851  : 
; 852  : 	_Alty& _Getal()
; 853  : 		{	// get reference to allocator
; 854  : 		return (_Alval);
; 855  : 		}
; 856  : 
; 857  : 	const _Alty& _Getal() const
; 858  : 		{	// get reference to allocator
; 859  : 		return (_Alval);
; 860  : 		}
; 861  : 
; 862  : 	_Alty _Alval;	// allocator object for stored elements
; 863  : 	};
; 864  : 
; 865  : template<class _Alloc_types>
; 866  : 	class _Deque_alloc<false, _Alloc_types>
; 867  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 868  : 	{	// base class for deque to hold allocator with no storage
; 869  : public:
; 870  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 871  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 872  : 
; 873  : 	typedef typename _Alloc_types::_Alty _Alty;
; 874  : 
; 875  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 876  : 
; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 878  : 		{	// construct allocators from _Al
; 879  : 		_Alloc_proxy();
; 880  : 		}
; 881  : 
; 882  : 	~_Deque_alloc() _NOEXCEPT
; 883  : 		{	// destroy proxy
; 884  : 		_Free_proxy();
; 885  : 		}
; 886  : 
; 887  : 	void _Change_alloc(const _Alty&)
; 888  : 		{	// replace old allocator
; 889  : 		}
; 890  : 
; 891  : 	void _Swap_alloc(_Myt& _Right)
; 892  : 		{	// swap allocators
; 893  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 894  : 		}
; 895  : 
; 896  : 	void _Alloc_proxy()
; 897  : 		{	// construct proxy from _Alval
; 898  : 		typename _Alty::template rebind<_Container_proxy>::other
; 899  : 			_Alproxy;
; 900  : 		this->_Myproxy = _Alproxy.allocate(1);
; 901  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 902  : 		this->_Myproxy->_Mycont = this;
; 903  : 		}
; 904  : 
; 905  : 	void _Free_proxy()
; 906  : 		{	// destroy proxy
; 907  : 		typename _Alty::template rebind<_Container_proxy>::other
; 908  : 			_Alproxy;
; 909  : 		this->_Orphan_all();
; 910  : 		_Alproxy.destroy(this->_Myproxy);
; 911  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 912  : 		this->_Myproxy = 0;
; 913  : 		}
; 914  : 
; 915  : 	_Alty _Getal() const
; 916  : 		{	// get reference to allocator
; 917  : 		return (_Alty());
; 918  : 		}
; 919  : 	};
; 920  : 
; 921  : 		// TEMPLATE CLASS deque
; 922  : template<class _Ty,
; 923  : 	class _Alloc = allocator<_Ty> >
; 924  : 	class deque
; 925  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 			_Deque_base_types<_Ty, _Alloc> >
; 927  : 	{	// circular queue of pointers to blocks
; 928  : public:
; 929  : 	typedef deque<_Ty, _Alloc> _Myt;
; 930  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 931  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 932  : 	typedef _Alloc allocator_type;
; 933  : 
; 934  : 	typedef typename _Mybase::_Alty _Alty;
; 935  : 	typedef typename _Mybase::_Alpty _Alpty;
; 936  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 937  : 
; 938  : 	typedef typename _Mybase::value_type value_type;
; 939  : 	typedef typename _Mybase::size_type size_type;
; 940  : 	typedef typename _Mybase::difference_type difference_type;
; 941  : 	typedef typename _Mybase::pointer pointer;
; 942  : 	typedef typename _Mybase::const_pointer const_pointer;
; 943  : 	typedef typename _Mybase::reference reference;
; 944  : 	typedef typename _Mybase::const_reference const_reference;
; 945  : 
; 946  : 	typedef typename _Mybase::iterator iterator;
; 947  : 	typedef typename _Mybase::const_iterator const_iterator;
; 948  : 
; 949  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 950  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 951  : 
; 952  : 	static const int _EEM_DS = _DEQUESIZ;
; 953  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 954  : 	deque()
; 955  : 		: _Mybase()
; 956  : 		{	// construct empty deque
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(const _Alloc& _Al)
; 960  : 		: _Mybase(_Al)
; 961  : 		{	// construct empty deque with allocator
; 962  : 		}
; 963  : 
; 964  : 	explicit deque(size_type _Count)
; 965  : 		: _Mybase()
; 966  : 		{	// construct from _Count * value_type()
; 967  : 		resize(_Count);
; 968  : 		}
; 969  : 
; 970  : 	deque(size_type _Count, const value_type& _Val)
; 971  : 		: _Mybase()
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_Construct_n(_Count, _Val);
; 974  : 		}
; 975  : 
; 976  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 977  : 		: _Mybase(_Al)
; 978  : 		{	// construct from _Count * _Val with allocator
; 979  : 		_Construct_n(_Count, _Val);
; 980  : 		}
; 981  : 
; 982  : 	deque(const _Myt& _Right)
; 983  : 
; 984  :  #if _HAS_CPP0X
; 985  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 986  : 
; 987  :  #else /* _HAS_CPP0X */
; 988  : 		: _Mybase(_Right._Getal())
; 989  :  #endif /* _HAS_CPP0X */
; 990  : 
; 991  : 		{	// construct by copying _Right
; 992  : 		_TRY_BEGIN
; 993  : 		insert(begin(), _Right.begin(), _Right.end());
; 994  : 		_CATCH_ALL
; 995  : 		_Tidy();
; 996  : 		_RERAISE;
; 997  : 		_CATCH_END
; 998  : 		}
; 999  : 
; 1000 : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct by copying _Right
; 1003 : 		_TRY_BEGIN
; 1004 : 		insert(begin(), _Right.begin(), _Right.end());
; 1005 : 		_CATCH_ALL
; 1006 : 		_Tidy();
; 1007 : 		_RERAISE;
; 1008 : 		_CATCH_END
; 1009 : 		}
; 1010 : 
; 1011 : 	template<class _Iter>
; 1012 : 		deque(_Iter _First, _Iter _Last,
; 1013 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1014 : 				void>::type ** = 0)
; 1015 : 		: _Mybase()
; 1016 : 		{	// construct from [_First, _Last)
; 1017 : 		_Construct(_First, _Last);
; 1018 : 		}
; 1019 : 
; 1020 : 	template<class _Iter>
; 1021 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 1022 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1023 : 				void>::type ** = 0)
; 1024 : 		: _Mybase(_Al)
; 1025 : 		{	// construct from [_First, _Last) with allocator
; 1026 : 		_Construct(_First, _Last);
; 1027 : 		}
; 1028 : 
; 1029 : 	template<class _Iter>
; 1030 : 		void _Construct(_Iter _First, _Iter _Last)
; 1031 : 		{	// initialize from [_First, _Last), input iterators
; 1032 : 		_TRY_BEGIN
; 1033 : 		insert(begin(), _First, _Last);
; 1034 : 		_CATCH_ALL
; 1035 : 		_Tidy();
; 1036 : 		_RERAISE;
; 1037 : 		_CATCH_END
; 1038 : 		}
; 1039 : 
; 1040 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1041 : 		{	// construct from _Count * _Val
; 1042 : 		_TRY_BEGIN
; 1043 : 		_Insert_n(begin(), _Count, _Val);
; 1044 : 		_CATCH_ALL
; 1045 : 		_Tidy();
; 1046 : 		_RERAISE;
; 1047 : 		_CATCH_END
; 1048 : 		}
; 1049 : 
; 1050 : #define _PUSH_FRONT_BEGIN \
; 1051 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1056 : 		: this->_Mapsize * _DEQUESIZ; \
; 1057 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1058 : 	if (this->_Map[_Block] == pointer()) \
; 1059 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1060 : 
; 1061 : #define _PUSH_FRONT_END \
; 1062 : 	this->_Myoff = _Newoff; \
; 1063 : 	++this->_Mysize
; 1064 : 
; 1065 : #define _PUSH_BACK_BEGIN \
; 1066 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1067 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1068 : 		_Growmap(1); \
; 1069 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1070 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1071 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1072 : 	if (this->_Map[_Block] == pointer()) \
; 1073 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1074 : 
; 1075 : #define _PUSH_BACK_END \
; 1076 : 	++this->_Mysize
; 1077 : 
; 1078 : 	deque(_Myt&& _Right)
; 1079 : 		: _Mybase(_Right._Getal())
; 1080 : 		{	// construct by moving _Right
; 1081 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1082 : 		}
; 1083 : 
; 1084 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1085 : 		: _Mybase(_Al)
; 1086 : 		{	// construct by moving _Right
; 1087 : 		if (this->_Getal() != _Right._Getal())
; 1088 : 			assign(_STD make_move_iterator(_Right.begin()),
; 1089 : 				_STD make_move_iterator(_Right.end()));
; 1090 : 		else
; 1091 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1092 : 		}
; 1093 : 
; 1094 : 	_Myt& operator=(_Myt&& _Right)
; 1095 : 		{	// assign by moving _Right
; 1096 : 		if (this != &_Right)
; 1097 : 			{	// different, assign it
; 1098 : 			_Tidy();
; 1099 : 
; 1100 :  #if _HAS_CPP0X
; 1101 : 			if (this->_Getal() != _Right._Getal()
; 1102 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1103 : 				this->_Change_alloc(_Right._Getal());
; 1104 :  #endif /* _HAS_CPP0X */
; 1105 : 
; 1106 : 			if (this->_Getal() != _Right._Getal())
; 1107 : 				assign(_STD make_move_iterator(_Right.begin()),
; 1108 : 					_STD make_move_iterator(_Right.end()));
; 1109 : 			else
; 1110 : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	void _Assign_rv(_Myt&& _Right)
; 1116 : 		{	// assign by moving _Right
; 1117 : 		if (this == &_Right)
; 1118 : 			;
; 1119 : 		else if (get_allocator() != _Right.get_allocator())
; 1120 : 			{	// move construct a copy
; 1121 : 			clear();
; 1122 : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();
; 1123 : 				++_Next)
; 1124 : 				push_back(_STD forward<value_type>(*_Next));
; 1125 : 			}
; 1126 : 		else
; 1127 : 			{	// clear this and steal from _Right
; 1128 : 			this->_Swap_all((_Myt&)_Right);
; 1129 : 			this->_Map = _Right._Map;
; 1130 : 			this->_Mapsize = _Right._Mapsize;
; 1131 : 			this->_Myoff = _Right._Myoff;
; 1132 : 			this->_Mysize = _Right._Mysize;
; 1133 : 
; 1134 : 			_Right._Map = _Mapptr();
; 1135 : 			_Right._Mapsize = 0;
; 1136 : 			_Right._Myoff = 0;
; 1137 : 			_Right._Mysize = 0;
; 1138 : 			}
; 1139 : 		}
; 1140 : 
; 1141 : 	void push_front(value_type&& _Val)
; 1142 : 		{	// insert element at beginning
; 1143 : 		this->_Orphan_all();
; 1144 : 		_PUSH_FRONT_BEGIN;
; 1145 : 		this->_Getal().construct(
; 1146 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1147 : 			_STD forward<value_type>(_Val));
; 1148 : 		_PUSH_FRONT_END;
; 1149 : 		}
; 1150 : 
; 1151 : 	void push_back(value_type&& _Val)
; 1152 : 		{	// insert element at end
; 1153 : 		this->_Orphan_all();
; 1154 : 		_PUSH_BACK_BEGIN;
; 1155 : 		this->_Getal().construct(
; 1156 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1157 : 			_STD forward<value_type>(_Val));
; 1158 : 		_PUSH_BACK_END;
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1162 : 		{	// insert _Val at _Where
; 1163 : 		return (emplace(_Where, _STD move(_Val)));
; 1164 : 		}
; 1165 : 
; 1166 : #define _DEQUE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* insert element at beginning */ \
; 1171 : 		this->_Orphan_all(); \
; 1172 : 		_PUSH_FRONT_BEGIN; \
; 1173 : 		this->_Getal().construct( \
; 1174 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1175 : 				COMMA LIST(_FORWARD_ARG)); \
; 1176 : 		_PUSH_FRONT_END; \
; 1177 : 	} \
; 1178 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1179 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1180 : 		{	/* insert element at end */ \
; 1181 : 		this->_Orphan_all(); \
; 1182 : 		_PUSH_BACK_BEGIN; \
; 1183 : 		this->_Getal().construct( \
; 1184 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1185 : 				COMMA LIST(_FORWARD_ARG)); \
; 1186 : 		_PUSH_BACK_END; \
; 1187 : 		} \
; 1188 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1189 : 		iterator emplace(const_iterator _Where \
; 1190 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1191 : 		{	/* insert element at _Where */ \
; 1192 : 		size_type _Off = _Where - begin(); \
; 1193 : 		_DEQUE_EMPLACE_CHECK \
; 1194 : 		if (_Off <= this->_Mysize / 2) \
; 1195 : 			{	/* closer to front, push to front then rotate */ \
; 1196 : 			emplace_front(LIST(_FORWARD_ARG)); \
; 1197 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off); \
; 1198 : 			} \
; 1199 : 		else \
; 1200 : 			{	/* closer to back, push to back then rotate */ \
; 1201 : 			emplace_back(LIST(_FORWARD_ARG)); \
; 1202 : 			_STD rotate(begin() + _Off, end() - 1, end()); \
; 1203 : 			} \
; 1204 : 		return (begin() + _Off); \
; 1205 : 			}
; 1206 : 
; 1207 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1208 : #define _DEQUE_EMPLACE_CHECK \
; 1209 : 		if (this->_Mysize < _Off) \
; 1210 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1211 : 
; 1212 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1213 : #define _DEQUE_EMPLACE_CHECK
; 1214 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1215 : 
; 1216 : _VARIADIC_EXPAND_0X(_DEQUE_EMPLACE, , , , )
; 1217 : #undef _DEQUE_EMPLACE_CHECK
; 1218 : #undef _DEQUE_EMPLACE
; 1219 : 
; 1220 : 	~deque() _NOEXCEPT
; 1221 : 		{	// destroy the deque
; 1222 : 		_Tidy();
; 1223 : 		}
; 1224 : 
; 1225 : 	_Myt& operator=(const _Myt& _Right)
; 1226 : 		{	// assign _Right
; 1227 : 		if (this != &_Right)
; 1228 : 			{	// different, assign it
; 1229 :  #if _HAS_CPP0X
; 1230 : 			if (this->_Getal() != _Right._Getal()
; 1231 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1232 : 				{	// change allocator before copying
; 1233 : 				_Tidy();
; 1234 : 				this->_Change_alloc(_Right._Getal());
; 1235 : 				}
; 1236 :  #endif /* _HAS_CPP0X */
; 1237 : 
; 1238 : 			this->_Orphan_all();
; 1239 : 
; 1240 : 			if (_Right._Mysize == 0)
; 1241 : 				clear();
; 1242 : 			else if (_Right._Mysize <= this->_Mysize)
; 1243 : 				{	// enough elements, copy new and destroy old
; 1244 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1245 : 					begin());
; 1246 : 				erase(_Mid, end());
; 1247 : 				}
; 1248 : 			else
; 1249 : 				{	// new sequence longer, copy and construct new
; 1250 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1251 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1252 : 				insert(end(), _Mid, _Right.end());
; 1253 : 				}
; 1254 : 			}
; 1255 : 		return (*this);
; 1256 : 		}
; 1257 : 
; 1258 : 	iterator begin() _NOEXCEPT
; 1259 : 		{	// return iterator for beginning of mutable sequence
; 1260 : 		return (iterator(this->_Myoff, this));
; 1261 : 		}
; 1262 : 
; 1263 : 	const_iterator begin() const _NOEXCEPT
; 1264 : 		{	// return iterator for beginning of nonmutable sequence
; 1265 : 		return (const_iterator(this->_Myoff, this));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator end() _NOEXCEPT
; 1269 : 		{	// return iterator for end of mutable sequence
; 1270 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1271 : 		}
; 1272 : 
; 1273 : 	const_iterator end() const _NOEXCEPT
; 1274 : 		{	// return iterator for end of nonmutable sequence
; 1275 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1276 : 		}
; 1277 : 
; 1278 : 	iterator _Make_iter(const_iterator _Where) const
; 1279 : 		{	// make iterator from const_iterator
; 1280 : 		return (iterator(_Where._Myoff, this));
; 1281 : 		}
; 1282 : 
; 1283 : 	reverse_iterator rbegin() _NOEXCEPT
; 1284 : 		{	// return iterator for beginning of reversed mutable sequence
; 1285 : 		return (reverse_iterator(end()));
; 1286 : 		}
; 1287 : 
; 1288 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1289 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1290 : 		return (const_reverse_iterator(end()));
; 1291 : 		}
; 1292 : 
; 1293 : 	reverse_iterator rend() _NOEXCEPT
; 1294 : 		{	// return iterator for end of reversed mutable sequence
; 1295 : 		return (reverse_iterator(begin()));
; 1296 : 		}
; 1297 : 
; 1298 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1299 : 		{	// return iterator for end of reversed nonmutable sequence
; 1300 : 		return (const_reverse_iterator(begin()));
; 1301 : 		}
; 1302 : 
; 1303 :  #if _HAS_CPP0X
; 1304 : 	const_iterator cbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->begin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_iterator cend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->end());
; 1312 : 		}
; 1313 : 
; 1314 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1315 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1316 : 		return (((const _Myt *)this)->rbegin());
; 1317 : 		}
; 1318 : 
; 1319 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1320 : 		{	// return iterator for end of reversed nonmutable sequence
; 1321 : 		return (((const _Myt *)this)->rend());
; 1322 : 		}
; 1323 : 
; 1324 : 	void shrink_to_fit()
; 1325 : 		{	// reduce capacity
; 1326 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1327 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1328 : 
; 1329 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1330 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1331 : 
; 1332 : 		if ((empty() && 0 < this->_Mapsize)
; 1333 : 			|| (!empty()
; 1334 : 				&& size() <= _Newcapacity
; 1335 : 				&& _Newcapacity < _Oldcapacity))
; 1336 : 			{	// worth shrinking, do it
; 1337 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1338 : 				_STD make_move_iterator(end()));
; 1339 : 			swap(_Tmp);
; 1340 : 			}
; 1341 : 		}
; 1342 :  #endif /* _HAS_CPP0X */
; 1343 : 
; 1344 : 	void resize(size_type _Newsize)
; 1345 : 		{	// determine new length, padding as needed
; 1346 : 		if (_Newsize < this->_Mysize)
; 1347 : 			erase(begin() + _Newsize, end());
; 1348 : 		else if (this->_Mysize < _Newsize)
; 1349 : 			{	// append default-constructed elements
; 1350 : 			_Alty _Alval(this->_Getal());
; 1351 : 			this->_Orphan_all();
; 1352 : 			while (this->_Mysize < _Newsize)
; 1353 : 				{	// push_back default-constructed element
; 1354 : 				_PUSH_BACK_BEGIN;
; 1355 : 				_Uninitialized_default_fill_n(
; 1356 : 					this->_Map[_Block] + _Newoff % _DEQUESIZ, 1, _Alval);
; 1357 : 				_PUSH_BACK_END;
; 1358 : 				}
; 1359 : 			}
; 1360 : 		}
; 1361 : 
; 1362 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1363 : 		{	// determine new length, padding with _Val elements as needed
; 1364 : 		if (this->_Mysize < _Newsize)
; 1365 : 			_Insert_n(end(), _Newsize - this->_Mysize, _Val);
; 1366 : 		else if (_Newsize < this->_Mysize)
; 1367 : 			erase(begin() + _Newsize, end());
; 1368 : 		}
; 1369 : 
; 1370 : 	size_type size() const _NOEXCEPT
; 1371 : 		{	// return length of sequence
; 1372 : 		return (this->_Mysize);
; 1373 : 		}
; 1374 : 
; 1375 : 	size_type max_size() const _NOEXCEPT
; 1376 : 		{	// return maximum possible length of sequence
; 1377 : 		return (this->_Getal().max_size());
; 1378 : 		}
; 1379 : 
; 1380 : 	bool empty() const _NOEXCEPT
; 1381 : 		{	// test if sequence is empty
; 1382 : 		return (this->_Mysize == 0);

  00006	48 83 79 20 00	 cmp	 QWORD PTR [rcx+32], 0

; 1454 : 		{	// erase element at beginning

  0000b	48 8b d9	 mov	 rbx, rcx

; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())

  0000e	74 65		 je	 SHORT $LN1@pop_front

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00010	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  00014	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00018	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001d	48 ff ca	 dec	 rdx
  00020	48 23 51 18	 and	 rdx, QWORD PTR [rcx+24]

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  00024	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00028	48 8b 7a 08	 mov	 rdi, QWORD PTR [rdx+8]
  0002c	48 85 ff	 test	 rdi, rdi
  0002f	74 27		 je	 SHORT $LN29@pop_front

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00031	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  00035	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0003a	75 17		 jne	 SHORT $LN32@pop_front

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003c	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0003f	48 8b cf	 mov	 rcx, rdi
  00042	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00044	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  00048	75 09		 jne	 SHORT $LN32@pop_front

; 128  : 			_Delete_this();

  0004a	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0004d	48 8b cf	 mov	 rcx, rdi
  00050	ff 50 08	 call	 QWORD PTR [rax+8]
$LN32@pop_front:
  00053	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN29@pop_front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1476 : 			if (--this->_Mysize == 0)

  00058	48 ff 4b 20	 dec	 QWORD PTR [rbx+32]
  0005c	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00061	75 0e		 jne	 SHORT $LN2@pop_front

; 1477 : 				this->_Myoff = 0;

  00063	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0

; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}

  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5b		 pop	 rbx
  00070	c3		 ret	 0
$LN2@pop_front:

; 1478 : 			else
; 1479 : 				++this->_Myoff;

  00071	48 ff 43 18	 inc	 QWORD PTR [rbx+24]
$LN1@pop_front:

; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back, COMDAT

; 1485 : 		{	// insert element at end

$LN54:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1487 : 		_PUSH_BACK_BEGIN;

  0000f	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	48 ff c0	 inc	 rax
  0001c	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00020	77 05		 ja	 SHORT $LN2@push_back
  00022	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
$LN2@push_back:
  00027	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  0002b	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0002f	49 ff c8	 dec	 r8
  00032	4c 21 43 18	 and	 QWORD PTR [rbx+24], r8
  00036	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  0003a	48 03 53 20	 add	 rdx, QWORD PTR [rbx+32]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0003e	4c 23 c2	 and	 r8, rdx

; 1487 : 		_PUSH_BACK_BEGIN;

  00041	4a 8d 34 c5 00
	00 00 00	 lea	 rsi, QWORD PTR [r8*8]
  00049	48 83 3c 06 00	 cmp	 QWORD PTR [rsi+rax], 0
  0004e	75 1a		 jne	 SHORT $LN1@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00050	b9 10 00 00 00	 mov	 ecx, 16
  00055	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	48 85 c0	 test	 rax, rax
  00060	74 48		 je	 SHORT $LN52@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00062	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00066	48 89 0c 06	 mov	 QWORD PTR [rsi+rax], rcx
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  0006a	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0006e	48 8b 0c 06	 mov	 rcx, QWORD PTR [rsi+rax]
  00072	48 85 c9	 test	 rcx, rcx
  00075	74 1f		 je	 SHORT $LN36@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00077	33 c0		 xor	 eax, eax
  00079	48 89 01	 mov	 QWORD PTR [rcx], rax
  0007c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00080	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  00084	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00087	4d 85 c0	 test	 r8, r8
  0008a	74 05		 je	 SHORT $LN49@push_back

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0008c	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN49@push_back:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00091	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN36@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00096	48 ff 43 20	 inc	 QWORD PTR [rbx+32]

; 1491 : 		}

  0009a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
$LN52@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  000aa	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000af	cc		 int	 3
$LN51@push_back:
?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VChunkBase@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@XZ PROC		; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>, COMDAT

; 282  : 		{	// construct

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@XZ ENDP		; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get@?$_Ptr_base@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Ptr_base@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ PROC ; std::_Ptr_base<ChunkBase>::_Get, COMDAT

; 335  : 		return (_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 336  : 		}

  00003	c3		 ret	 0
?_Get@?$_Ptr_base@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ ENDP ; std::_Ptr_base<ChunkBase>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ PROC	; std::_Ptr_base<ChunkBase>::_Decref, COMDAT

; 344  : 		{	// decrement reference count

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN7@Decref

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN10@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN10@Decref

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Decref:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN7@Decref:

; 346  : 			_Rep->_Decref();
; 347  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ ENDP	; std::_Ptr_base<ChunkBase>::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)

$LN118:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b f8	 mov	 rdi, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b d9	 mov	 rbx, rcx

; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00018	48 85 d2	 test	 rdx, rdx
  0001b	74 5a		 je	 SHORT $LN2@assign

; 517  : 			: this->_Bx._Buf);

  0001d	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  00021	48 83 fa 10	 cmp	 rdx, 16
  00025	72 05		 jb	 SHORT $LN12@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00027	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  0002a	eb 03		 jmp	 SHORT $LN13@assign
$LN12@assign:
  0002c	48 8b c1	 mov	 rax, rcx
$LN13@assign:

; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  0002f	48 3b f0	 cmp	 rsi, rax
  00032	72 43		 jb	 SHORT $LN2@assign

; 517  : 			: this->_Bx._Buf);

  00034	48 83 fa 10	 cmp	 rdx, 16
  00038	72 03		 jb	 SHORT $LN19@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN19@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  0003d	48 03 4b 10	 add	 rcx, QWORD PTR [rbx+16]
  00041	48 3b ce	 cmp	 rcx, rsi
  00044	76 31		 jbe	 SHORT $LN2@assign

; 517  : 			: this->_Bx._Buf);

  00046	48 83 fa 10	 cmp	 rdx, 16
  0004a	72 05		 jb	 SHORT $LN24@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0004c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  0004f	eb 03		 jmp	 SHORT $LN25@assign
$LN24@assign:
  00051	48 8b c3	 mov	 rax, rbx
$LN25@assign:

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

  00054	48 2b f0	 sub	 rsi, rax
  00057	4d 8b c8	 mov	 r9, r8
  0005a	48 8b d3	 mov	 rdx, rbx
  0005d	4c 8b c6	 mov	 r8, rsi
  00060	48 8b cb	 mov	 rcx, rbx

; 1139 : 		}

  00063	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00068	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5f		 pop	 rdi

; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring

  00072	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@assign:

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)

  00077	49 83 f8 fe	 cmp	 r8, -2
  0007b	0f 87 a4 00 00
	00		 ja	 $LN116@assign

; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)

  00081	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00085	49 3b c0	 cmp	 rax, r8
  00088	73 20		 jae	 SHORT $LN32@assign

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  0008a	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  0008e	48 8b d7	 mov	 rdx, rdi
  00091	48 8b cb	 mov	 rcx, rbx
  00094	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN91@assign:

; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  00099	48 85 ff	 test	 rdi, rdi

; 1132 : 
; 1133 : 		if (_Grow(_Count))

  0009c	74 74		 je	 SHORT $LN112@assign

; 517  : 			: this->_Bx._Buf);

  0009e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
  000a3	72 43		 jb	 SHORT $LN96@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000a5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000a8	eb 41		 jmp	 SHORT $LN97@assign
$LN32@assign:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)

  000aa	4d 85 c0	 test	 r8, r8
  000ad	75 ea		 jne	 SHORT $LN91@assign

; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000af	4c 89 43 10	 mov	 QWORD PTR [rbx+16], r8

; 517  : 			: this->_Bx._Buf);

  000b3	48 83 f8 10	 cmp	 rax, 16
  000b7	72 19		 jb	 SHORT $LN87@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000b9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000bc	44 88 00	 mov	 BYTE PTR [rax], r8b
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1138 : 		return (*this);

  000bf	48 8b c3	 mov	 rax, rbx

; 1139 : 		}

  000c2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000c7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
$LN87@assign:

; 517  : 			: this->_Bx._Buf);

  000d2	48 8b c3	 mov	 rax, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000d5	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1139 : 		}

  000d8	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000dd	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000e2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e6	5f		 pop	 rdi
  000e7	c3		 ret	 0
$LN96@assign:

; 517  : 			: this->_Bx._Buf);

  000e8	48 8b cb	 mov	 rcx, rbx
$LN97@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000eb	48 85 ff	 test	 rdi, rdi
  000ee	74 0b		 je	 SHORT $LN103@assign
  000f0	4c 8b c7	 mov	 r8, rdi
  000f3	48 8b d6	 mov	 rdx, rsi
  000f6	e8 00 00 00 00	 call	 memcpy
$LN103@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000fb	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00100	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 517  : 			: this->_Bx._Buf);

  00104	72 05		 jb	 SHORT $LN108@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00106	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00109	eb 03		 jmp	 SHORT $LN109@assign
$LN108@assign:
  0010b	48 8b c3	 mov	 rax, rbx
$LN109@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0010e	c6 04 38 00	 mov	 BYTE PTR [rax+rdi], 0
$LN112@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1139 : 		}

  00112	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00117	48 8b c3	 mov	 rax, rbx
  0011a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0011f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
$LN116@assign:

; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");

  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0012c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00131	cc		 int	 3
$LN115@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 517  : 			: this->_Bx._Buf);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00005	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 517  : 			: this->_Bx._Buf);

  00009	72 08		 jb	 SHORT $LN5@Eos
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0000b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0000e	c6 04 10 00	 mov	 BYTE PTR [rax+rdx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2219 : 		}

  00012	c3		 ret	 0
$LN5@Eos:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00013	c6 04 11 00	 mov	 BYTE PTR [rcx+rdx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2219 : 		}

  00017	c3		 ret	 0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 2275 : 		{	// report an out_of_range error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2276 : 		_Xout_of_range("invalid string position");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  00010	cc		 int	 3
$LN3@Xran:
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAA@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAA@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 497  : 		{	// initialize values
; 498  : 		_Mysize = 0;

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 499  : 		_Myres = 0;

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 500  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAA@XZ PROC	; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>, COMDAT

; 282  : 		{	// construct

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAA@XZ ENDP	; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 320  : 		}

  0001c	c3		 ret	 0
?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1260 : 		return (iterator(this->_Myoff, this));

  00003	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00007	48 c7 42 08 00
	00 00 00	 mov	 QWORD PTR [rdx+8], 0

; 166  : 			_Myproxy = _Parent_proxy;

  0000f	48 89 02	 mov	 QWORD PTR [rdx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  00012	4c 89 42 10	 mov	 QWORD PTR [rdx+16], r8

; 1260 : 		return (iterator(this->_Myoff, this));

  00016	48 8b c2	 mov	 rax, rdx

; 1261 : 		}

  00019	c3		 ret	 0
?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_NXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty, COMDAT

; 1382 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00006	0f 94 c0	 sete	 al

; 1383 : 		}

  00009	c3		 ret	 0
?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_NXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$dead$ = 72
?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap, COMDAT

; 1802 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

$LN134:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1803 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1804 : 			"The _Xlen() test should always be performed.");
; 1805 : 
; 1806 : 		typedef typename _Alpty::pointer _Blockptr;
; 1807 : 		_Alpty _Almap(this->_Getal());
; 1808 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

  00007	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0000b	bb 01 00 00 00	 mov	 ebx, 1
  00010	48 8b f1	 mov	 rsi, rcx
  00013	48 85 d2	 test	 rdx, rdx
  00016	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00020	48 0f 45 da	 cmovne	 rbx, rdx
$LL7@Growmap:

; 1809 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

  00024	48 8b c3	 mov	 rax, rbx
  00027	48 2b c2	 sub	 rax, rdx
  0002a	48 83 f8 01	 cmp	 rax, 1
  0002e	72 06		 jb	 SHORT $LN5@Growmap
  00030	48 83 fb 08	 cmp	 rbx, 8
  00034	73 14		 jae	 SHORT $LN6@Growmap
$LN5@Growmap:

; 1810 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1811 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

  00036	48 8b c1	 mov	 rax, rcx
  00039	48 2b c3	 sub	 rax, rbx
  0003c	48 3b c3	 cmp	 rax, rbx
  0003f	0f 82 5a 01 00
	00		 jb	 $LN111@Growmap

; 1812 : 				_Xlen();	// result too long
; 1813 : 			_Newsize *= 2;

  00045	48 03 db	 add	 rbx, rbx

; 1814 : 			}

  00048	eb da		 jmp	 SHORT $LL7@Growmap
$LN6@Growmap:

; 1815 : 		_Count = _Newsize - this->_Mapsize;

  0004a	48 2b da	 sub	 rbx, rdx
  0004d	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  00052	33 ed		 xor	 ebp, ebp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1818 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

  00054	48 8d 0c 1a	 lea	 rcx, QWORD PTR [rdx+rbx]
  00058	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0005d	4c 8b 7e 18	 mov	 r15, QWORD PTR [rsi+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00061	48 85 c9	 test	 rcx, rcx
  00064	74 2c		 je	 SHORT $LN32@Growmap

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00066	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00070	48 3b c8	 cmp	 rcx, rax
  00073	0f 87 20 01 00
	00		 ja	 $LN132@Growmap
  00079	48 8d 0c cd 00
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8]
  00081	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00086	48 8b e8	 mov	 rbp, rax
  00089	48 85 c0	 test	 rax, rax
  0008c	0f 84 07 01 00
	00		 je	 $LN132@Growmap
$LN32@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1823 : 			_Myptr, _Almap);	// copy initial to end

  00092	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00096	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0009b	48 8b 7e 10	 mov	 rdi, QWORD PTR [rsi+16]
  0009f	48 c1 e7 03	 shl	 rdi, 3
  000a3	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  000a8	4e 8d 34 fd 00
	00 00 00	 lea	 r14, QWORD PTR [r15*8]
  000b0	49 8d 14 06	 lea	 rdx, QWORD PTR [r14+rax]
  000b4	49 8d 0c 2e	 lea	 rcx, QWORD PTR [r14+rbp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000b8	48 2b fa	 sub	 rdi, rdx
  000bb	48 03 f8	 add	 rdi, rax
  000be	48 c1 ff 03	 sar	 rdi, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000c2	48 8d 3c fd 00
	00 00 00	 lea	 rdi, QWORD PTR [rdi*8]
  000ca	4c 8b c7	 mov	 r8, rdi
  000cd	e8 00 00 00 00	 call	 memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1828 : 				_Myptr, _Almap);	// copy rest of old

  000d2	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000d6	48 03 c7	 add	 rax, rdi
  000d9	48 8b c8	 mov	 rcx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1824 : 		if (_Myboff <= _Count)

  000dc	4c 3b fb	 cmp	 r15, rbx
  000df	77 3e		 ja	 SHORT $LN3@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000e1	49 c1 fe 03	 sar	 r14, 3
  000e5	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1830 : 				_Almap);	// clear suffix of new

  000ea	4c 8b e3	 mov	 r12, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000ed	4a 8d 3c f5 00
	00 00 00	 lea	 rdi, QWORD PTR [r14*8]
  000f5	4c 8b c7	 mov	 r8, rdi
  000f8	e8 00 00 00 00	 call	 memmove
  000fd	48 03 f8	 add	 rdi, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1830 : 				_Almap);	// clear suffix of new

  00100	4d 2b e7	 sub	 r12, r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00103	74 08		 je	 SHORT $LN61@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1828 : 				_Myptr, _Almap);	// copy rest of old

  00105	33 c0		 xor	 eax, eax
  00107	49 8b cc	 mov	 rcx, r12
  0010a	f3 48 ab	 rep stosq
$LN61@Growmap:
  0010d	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00112	4d 85 ff	 test	 r15, r15
  00115	74 51		 je	 SHORT $LN99@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  00117	48 8b fd	 mov	 rdi, rbp
  0011a	49 8b cf	 mov	 rcx, r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1834 : 		else

  0011d	eb 44		 jmp	 SHORT $LN131@Growmap
$LN3@Growmap:

; 1838 : 				_Myptr, _Almap);	// copy more old

  0011f	48 8d 3c dd 00
	00 00 00	 lea	 rdi, QWORD PTR [rbx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00127	4c 8b c7	 mov	 r8, rdi
  0012a	49 83 e0 f8	 and	 r8, -8
  0012e	e8 00 00 00 00	 call	 memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1841 : 				_Newmap, _Almap);	// copy rest of old

  00133	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00137	48 8b cd	 mov	 rcx, rbp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1841 : 				_Newmap, _Almap);	// copy rest of old

  0013a	48 8d 14 07	 lea	 rdx, QWORD PTR [rdi+rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  0013e	4c 2b f2	 sub	 r14, rdx
  00141	4c 03 f0	 add	 r14, rax
  00144	49 c1 fe 03	 sar	 r14, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00148	4a 8d 3c f5 00
	00 00 00	 lea	 rdi, QWORD PTR [r14*8]
  00150	4c 8b c7	 mov	 r8, rdi
  00153	e8 00 00 00 00	 call	 memmove
  00158	48 03 f8	 add	 rdi, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  0015b	48 85 db	 test	 rbx, rbx
  0015e	74 08		 je	 SHORT $LN99@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1838 : 				_Myptr, _Almap);	// copy more old

  00160	48 8b cb	 mov	 rcx, rbx
$LN131@Growmap:
  00163	33 c0		 xor	 eax, eax
  00165	f3 48 ab	 rep stosq
$LN99@Growmap:

; 1842 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1843 : 				_Almap);	// clear rest to initial block
; 1844 : 			}
; 1845 : 
; 1846 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1847 : 			_Almap);
; 1848 : 		if (this->_Map != _Mapptr())

  00168	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  0016c	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00171	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00176	48 85 c9	 test	 rcx, rcx
  00179	74 05		 je	 SHORT $LN104@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0017b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN104@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1853 : 		this->_Mapsize += _Count;

  00180	48 01 5e 10	 add	 QWORD PTR [rsi+16], rbx
  00184	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00189	48 89 6e 08	 mov	 QWORD PTR [rsi+8], rbp
  0018d	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 1854 : 		}

  00192	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00196	5e		 pop	 rsi
  00197	5b		 pop	 rbx
  00198	c3		 ret	 0
$LN132@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00199	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0019e	cc		 int	 3
$LN111@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1793 : 		_Xlength_error("deque<T> too long");

  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  001a6	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  001ab	cc		 int	 3
$LN130@Growmap:
?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal, COMDAT

; 917  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 918  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 20		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 16		 ja	 SHORT $LN14@allocate
  0001a	48 c1 e2 04	 shl	 rdx, 4
  0001e	48 8b ca	 mov	 rcx, rdx
  00021	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00026	48 85 c0	 test	 rax, rax
  00029	74 05		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00035	cc		 int	 3
$LN13@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_K_K@Z PROC ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock, COMDAT

; 786  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 ff c8	 dec	 rax
  00007	48 23 c2	 and	 rax, rdx

; 788  : 		}

  0000a	c3		 ret	 0
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_K_K@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEAV?$shared_ptr@VChunkBase@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEAV?$shared_ptr@VChunkBase@@@1@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 603  : 		{	// return designated object

  00003	48 8b d1	 mov	 rdx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00006	48 85 c0	 test	 rax, rax
  00009	75 14		 jne	 SHORT $LN7@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 604  : 		return ((reference)**(_Mybase *)this);

  0000f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00013	48 ff c9	 dec	 rcx
  00016	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 604  : 		return ((reference)**(_Mybase *)this);

  0001a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 605  : 		}

  0001e	c3		 ret	 0
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00022	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 604  : 		return ((reference)**(_Mybase *)this);

  00026	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0002a	48 ff c9	 dec	 rcx
  0002d	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 604  : 		return ((reference)**(_Mybase *)this);

  00031	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 605  : 		}

  00035	c3		 ret	 0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEAV?$shared_ptr@VChunkBase@@@1@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
_Roff$ = 64
_Count$ = 72
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)

$LN129:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1105 : 		if (_Right.size() < _Roff)

  00014	48 8b 7a 10	 mov	 rdi, QWORD PTR [rdx+16]
  00018	49 8b e8	 mov	 rbp, r8
  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	49 3b f8	 cmp	 rdi, r8
  00024	0f 82 da 00 00
	00		 jb	 $LN125@assign

; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;

  0002a	49 2b f8	 sub	 rdi, r8

; 1108 : 		if (_Count < _Num)

  0002d	4c 3b cf	 cmp	 r9, rdi
  00030	49 0f 42 f9	 cmovb	 rdi, r9

; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)

  00034	48 3b ca	 cmp	 rcx, rdx
  00037	75 2f		 jne	 SHORT $LN3@assign

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00039	4a 8d 04 07	 lea	 rax, QWORD PTR [rdi+r8]

; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)

  0003d	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00041	0f 82 ca 00 00
	00		 jb	 $LN127@assign

; 517  : 			: this->_Bx._Buf);

  00047	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0004c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 517  : 			: this->_Bx._Buf);

  00050	72 03		 jb	 SHORT $LN26@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00052	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN26@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00055	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

  00059	33 d2		 xor	 edx, edx
  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1113 : 		else if (_Grow(_Num))

  00063	e9 84 00 00 00	 jmp	 $LN120@assign
$LN3@assign:

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)

  00068	48 83 ff fe	 cmp	 rdi, -2
  0006c	0f 87 ac 00 00
	00		 ja	 $LN128@assign

; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)

  00072	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00076	48 3b c7	 cmp	 rax, rdi
  00079	73 27		 jae	 SHORT $LN35@assign

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  0007b	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  0007f	48 8b d7	 mov	 rdx, rdi
  00082	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  00087	48 85 ff	 test	 rdi, rdi

; 1113 : 		else if (_Grow(_Num))

  0008a	74 60		 je	 SHORT $LN120@assign
$LN124@assign:

; 518  : 		}
; 519  : 
; 520  : 	const value_type *_Myptr() const
; 521  : 		{	// determine current pointer to buffer for nonmutable string
; 522  : 		return (this->_BUF_SIZE <= this->_Myres
; 523  : 			? _STD addressof(*this->_Bx._Ptr)
; 524  : 			: this->_Bx._Buf);

  0008c	48 83 7e 18 10	 cmp	 QWORD PTR [rsi+24], 16
  00091	72 03		 jb	 SHORT $LN98@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00093	48 8b 36	 mov	 rsi, QWORD PTR [rsi]
$LN98@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00096	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
  0009b	72 24		 jb	 SHORT $LN104@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0009d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000a0	eb 22		 jmp	 SHORT $LN105@assign
$LN35@assign:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)

  000a2	48 85 ff	 test	 rdi, rdi
  000a5	75 e5		 jne	 SHORT $LN124@assign

; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000a7	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi

; 517  : 			: this->_Bx._Buf);

  000ab	48 83 f8 10	 cmp	 rax, 16
  000af	72 08		 jb	 SHORT $LN90@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000b1	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000b4	40 88 38	 mov	 BYTE PTR [rax], dil
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  000b7	eb 33		 jmp	 SHORT $LN120@assign
$LN90@assign:

; 517  : 			: this->_Bx._Buf);

  000b9	48 8b c1	 mov	 rax, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000bc	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2233 : 		return (0 < _Newsize);	// return true only if more work to do

  000bf	eb 2b		 jmp	 SHORT $LN120@assign
$LN104@assign:

; 517  : 			: this->_Bx._Buf);

  000c1	48 8b cb	 mov	 rcx, rbx
$LN105@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000c4	48 85 ff	 test	 rdi, rdi
  000c7	74 0c		 je	 SHORT $LN111@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1116 : 				_Right._Myptr() + _Roff, _Num);

  000c9	48 8d 14 2e	 lea	 rdx, QWORD PTR [rsi+rbp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000cd	4c 8b c7	 mov	 r8, rdi
  000d0	e8 00 00 00 00	 call	 memcpy
$LN111@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000d5	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000da	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 517  : 			: this->_Bx._Buf);

  000de	72 05		 jb	 SHORT $LN116@assign
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000e0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000e3	eb 03		 jmp	 SHORT $LN117@assign
$LN116@assign:
  000e5	48 8b c3	 mov	 rax, rbx
$LN117@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000e8	c6 04 38 00	 mov	 BYTE PTR [rax+rdi], 0
$LN120@assign:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1120 : 		}

  000ec	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000f1	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000f6	48 8b c3	 mov	 rax, rbx
  000f9	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000fe	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00102	5f		 pop	 rdi
  00103	c3		 ret	 0
$LN125@assign:

; 2272 : 		}
; 2273 : 
; 2274 : 	__declspec(noreturn) void _Xran() const
; 2275 : 		{	// report an out_of_range error
; 2276 : 		_Xout_of_range("invalid string position");

  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0010b	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  00110	cc		 int	 3
$LN127@assign:
  00111	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00118	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  0011d	cc		 int	 3
$LN128@assign:

; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");

  0011e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00125	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0012a	cc		 int	 3
$LN122@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Trim$ = 64
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT

; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

$LN70:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2224 : 		if (max_size() < _Newsize)

  00010	48 83 fa fe	 cmp	 rdx, -2
  00014	0f 87 a4 00 00
	00		 ja	 $LN68@Grow

; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)

  0001a	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0001e	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00023	33 ed		 xor	 ebp, ebp
  00025	48 3b c2	 cmp	 rax, rdx
  00028	73 0b		 jae	 SHORT $LN5@Grow

; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow

  0002a	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  0002e	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00033	eb 73		 jmp	 SHORT $LN64@Grow
$LN5@Grow:

; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00035	45 84 c0	 test	 r8b, r8b
  00038	74 59		 je	 SHORT $LN3@Grow
  0003a	48 83 fa 10	 cmp	 rdx, 16
  0003e	73 53		 jae	 SHORT $LN3@Grow

; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);

  00040	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00045	48 8b 71 10	 mov	 rsi, QWORD PTR [rcx+16]
  00049	48 3b d6	 cmp	 rdx, rsi
  0004c	48 0f 42 f2	 cmovb	 rsi, rdx

; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00050	48 83 f8 10	 cmp	 rax, 16
  00054	72 26		 jb	 SHORT $LN44@Grow
  00056	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;

  0005b	4c 8b 31	 mov	 r14, QWORD PTR [rcx]
  0005e	48 83 fe 01	 cmp	 rsi, 1
  00062	72 0b		 jb	 SHORT $LN39@Grow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00064	4c 8b c6	 mov	 r8, rsi
  00067	49 8b d6	 mov	 rdx, r14
  0006a	e8 00 00 00 00	 call	 memcpy
$LN39@Grow:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0006f	49 8b ce	 mov	 rcx, r14
  00072	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00077	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$LN44@Grow:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0007c	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00080	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00088	40 88 2c 1e	 mov	 BYTE PTR [rsi+rbx], bpl
  0008c	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2267 : 		}

  00091	eb 15		 jmp	 SHORT $LN64@Grow
$LN3@Grow:

; 2231 : 		else if (_Newsize == 0)

  00093	48 85 d2	 test	 rdx, rdx
  00096	75 10		 jne	 SHORT $LN64@Grow

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00098	48 89 69 10	 mov	 QWORD PTR [rcx+16], rbp

; 517  : 			: this->_Bx._Buf);

  0009c	48 83 f8 10	 cmp	 rax, 16
  000a0	72 03		 jb	 SHORT $LN60@Grow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000a2	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
$LN60@Grow:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000a5	40 88 2b	 mov	 BYTE PTR [rbx], bpl
$LN64@Grow:
  000a8	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2234 : 		}

  000ad	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000b2	48 85 ff	 test	 rdi, rdi
  000b5	0f 95 c0	 setne	 al
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN68@Grow:

; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");

  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  000c5	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  000ca	cc		 int	 3
$LN67@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_NPEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_NPEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 35		 je	 SHORT $LN2@Inside

; 517  : 			: this->_Bx._Buf);

  00005	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00009	48 83 f8 10	 cmp	 rax, 16
  0000d	72 05		 jb	 SHORT $LN8@Inside
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0000f	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00012	eb 03		 jmp	 SHORT $LN9@Inside
$LN8@Inside:
  00014	4c 8b c1	 mov	 r8, rcx
$LN9@Inside:

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  00017	49 3b d0	 cmp	 rdx, r8
  0001a	72 1e		 jb	 SHORT $LN2@Inside

; 517  : 			: this->_Bx._Buf);

  0001c	48 83 f8 10	 cmp	 rax, 16
  00020	72 05		 jb	 SHORT $LN14@Inside
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00022	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00025	eb 03		 jmp	 SHORT $LN15@Inside
$LN14@Inside:
  00027	4c 8b c1	 mov	 r8, rcx
$LN15@Inside:

; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)

  0002a	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0002e	49 8d 0c 00	 lea	 rcx, QWORD PTR [r8+rax]
  00032	48 3b ca	 cmp	 rcx, rdx
  00035	76 03		 jbe	 SHORT $LN2@Inside

; 2241 : 		else
; 2242 : 			return (true);

  00037	b0 01		 mov	 al, 1

; 2243 : 		}

  00039	c3		 ret	 0
$LN2@Inside:

; 2240 : 			return (false);	// don't ask

  0003a	32 c0		 xor	 al, al

; 2243 : 		}

  0003c	c3		 ret	 0
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_NPEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
__formal$ = 24
?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16
  00005	72 04		 jb	 SHORT $LN3@Myptr
  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 518  : 		}

  0000a	c3		 ret	 0
$LN3@Myptr:

; 515  : 		return (this->_BUF_SIZE <= this->_Myres
; 516  : 			? _STD addressof(*this->_Bx._Ptr)
; 517  : 			: this->_Bx._Buf);

  0000b	48 8b c1	 mov	 rax, rcx

; 518  : 		}

  0000e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 1377 : 		return (this->_Getal().max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 1378 : 		}

  0000a	c3		 ret	 0
?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen, COMDAT

; 1792 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1793 : 		_Xlength_error("deque<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 20		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 16		 ja	 SHORT $LN11@allocate
  0001a	48 c1 e2 04	 shl	 rdx, 4
  0001e	48 8b ca	 mov	 rcx, rdx
  00021	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00026	48 85 c0	 test	 rax, rax
  00029	74 05		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00035	cc		 int	 3
$LN10@allocate:
?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 21		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 17		 ja	 SHORT $LN14@allocate
  0001a	48 8d 0c d5 00
	00 00 00	 lea	 rcx, QWORD PTR [rdx*8]
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00027	48 85 c0	 test	 rax, rax
  0002a	74 05		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00036	cc		 int	 3
$LN13@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
_Lock$1 = 48
this$ = 48
_Off$ = 56
_Pdeque$ = 64
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT

; 586  : 		{	// construct with offset _Off in *_Pdeque

$LN18:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  0000a	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 586  : 		{	// construct with offset _Off in *_Pdeque

  0000c	48 8b fa	 mov	 rdi, rdx
  0000f	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00012	48 89 01	 mov	 QWORD PTR [rcx], rax
  00015	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 114  : 		}
; 115  : 
; 116  : 	_Iterator_base12(const _Iterator_base12& _Right)
; 117  : 		: _Myproxy(0), _Mynextiter(0)
; 118  : 		{	// copy an iterator
; 119  : 		*this = _Right;
; 120  : 		}
; 121  : 
; 122  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 123  : 		{	// assign an iterator
; 124  : 		if (_Myproxy == _Right._Myproxy)
; 125  : 			;
; 126  : 		else if (_Right._Myproxy != 0)
; 127  : 			_Adopt(_Right._Myproxy->_Mycont);
; 128  : 		else
; 129  : 			{	// becoming invalid, disown current parent
; 130  : 			_Lockit _Lock(_LOCK_DEBUG);
; 131  : 			_Orphan_me();
; 132  : 			}
; 133  : 		return (*this);
; 134  : 		}
; 135  : 
; 136  : 	~_Iterator_base12() _NOEXCEPT
; 137  : 		{	// destroy the iterator
; 138  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 139  : 		_Lockit _Lock(_LOCK_DEBUG);
; 140  : 		_Orphan_me();
; 141  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 142  : 		}
; 143  : 
; 144  : 	void _Adopt(const _Container_base12 *_Parent)
; 145  : 		{	// adopt this iterator by parent
; 146  : 		if (_Parent == 0)

  00019	4d 85 c0	 test	 r8, r8
  0001c	75 29		 jne	 SHORT $LN10@Deque_iter

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  0001e	8d 50 03	 lea	 edx, QWORD PTR [rax+3]
  00021	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00026	e8 00 00 00 00	 call	 ??0_Lockit@std@@QEAA@H@Z ; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  0002b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QEAA@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  00035	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 587  : 		}

  00039	48 8b c3	 mov	 rax, rbx
  0003c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
$LN10@Deque_iter:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00047	49 8b 00	 mov	 rax, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  0004a	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  0004e	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 587  : 		}

  00051	48 8b c3	 mov	 rax, rbx
  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEBV?$shared_ptr@VChunkBase@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEBV?$shared_ptr@VChunkBase@@@1@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 323  : 		{	// return designated object

  00003	48 8b d1	 mov	 rdx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00006	48 85 c0	 test	 rax, rax
  00009	75 14		 jne	 SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  0000f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00013	48 ff c9	 dec	 rcx
  00016	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  0001a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 346  : 		}

  0001e	c3		 ret	 0
$LN5@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00022	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  00026	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0002a	48 ff c9	 dec	 rcx
  0002d	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  00031	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 346  : 		}

  00035	c3		 ret	 0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEBV?$shared_ptr@VChunkBase@@@1@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 1309 : 		{	// erase elements [_Off, ...)

$LN20:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1310 : 		if (this->_Mysize < _Off)

  00004	48 39 51 10	 cmp	 QWORD PTR [rcx+16], rdx
  00008	72 26		 jb	 SHORT $LN18@erase

; 517  : 			: this->_Bx._Buf);

  0000a	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0000f	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 517  : 			: this->_Bx._Buf);

  00013	72 0f		 jb	 SHORT $LN11@erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00015	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00018	c6 04 10 00	 mov	 BYTE PTR [rax+rdx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1313 : 		return (*this);

  0001c	48 8b c1	 mov	 rax, rcx

; 1314 : 		}

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
$LN11@erase:

; 517  : 			: this->_Bx._Buf);

  00024	48 8b c1	 mov	 rax, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00027	c6 04 11 00	 mov	 BYTE PTR [rcx+rdx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1314 : 		}

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN18@erase:

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");
; 2272 : 		}
; 2273 : 
; 2274 : 	__declspec(noreturn) void _Xran() const
; 2275 : 		{	// report an out_of_range error
; 2276 : 		_Xout_of_range("invalid string position");

  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00037	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  0003c	cc		 int	 3
$LN17@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
_Count$ = 64
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 1317 : 		{	// erase elements [_Off, _Off + _Count)

$LN43:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1318 : 		if (this->_Mysize < _Off)

  0000a	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 3b fa	 cmp	 rdi, rdx
  00014	0f 82 a4 00 00
	00		 jb	 $LN41@erase

; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)

  0001a	48 8b c7	 mov	 rax, rdi
  0001d	48 2b c2	 sub	 rax, rdx
  00020	49 3b c0	 cmp	 rax, r8
  00023	77 35		 ja	 SHORT $LN3@erase

; 517  : 			: this->_Bx._Buf);

  00025	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0002a	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx

; 517  : 			: this->_Bx._Buf);

  0002e	72 15		 jb	 SHORT $LN14@erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00030	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00033	c6 04 10 00	 mov	 BYTE PTR [rax+rdx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1329 : 		return (*this);

  00037	48 8b c1	 mov	 rax, rcx

; 1330 : 		}

  0003a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
$LN14@erase:

; 517  : 			: this->_Bx._Buf);

  00045	48 8b c1	 mov	 rax, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00048	c6 04 11 00	 mov	 BYTE PTR [rcx+rdx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1329 : 		return (*this);

  0004c	48 8b c3	 mov	 rax, rbx

; 1330 : 		}

  0004f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00054	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
$LN3@erase:

; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)

  0005a	4d 85 c0	 test	 r8, r8
  0005d	74 51		 je	 SHORT $LN38@erase

; 517  : 			: this->_Bx._Buf);

  0005f	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16
  00064	72 05		 jb	 SHORT $LN22@erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00066	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00069	eb 03		 jmp	 SHORT $LN23@erase
$LN22@erase:
  0006b	48 8b c1	 mov	 rax, rcx
$LN23@erase:

; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;

  0006e	49 2b f8	 sub	 rdi, r8
  00071	48 8d 0c 10	 lea	 rcx, QWORD PTR [rax+rdx]

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00075	48 8b c7	 mov	 rax, rdi
  00078	48 2b c2	 sub	 rax, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0007b	74 0c		 je	 SHORT $LN29@erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0007d	4a 8d 14 01	 lea	 rdx, QWORD PTR [rcx+r8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 553  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00081	4c 8b c0	 mov	 r8, rax
  00084	e8 00 00 00 00	 call	 memmove
$LN29@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00089	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0008e	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 517  : 			: this->_Bx._Buf);

  00092	72 15		 jb	 SHORT $LN34@erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00094	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00097	c6 04 38 00	 mov	 BYTE PTR [rax+rdi], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1329 : 		return (*this);

  0009b	48 8b c3	 mov	 rax, rbx

; 1330 : 		}

  0009e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
$LN34@erase:

; 517  : 			: this->_Bx._Buf);

  000a9	48 8b c3	 mov	 rax, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000ac	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0
$LN38@erase:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1329 : 		return (*this);

  000b0	48 8b c3	 mov	 rax, rbx

; 1330 : 		}

  000b3	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	5f		 pop	 rdi
  000bd	c3		 ret	 0
$LN41@erase:

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;
; 2266 : 		_Eos(_Newsize);
; 2267 : 		}
; 2268 : 
; 2269 : 	__declspec(noreturn) void _Xlen() const
; 2270 : 		{	// report a length_error
; 2271 : 		_Xlength_error("string too long");
; 2272 : 		}
; 2273 : 
; 2274 : 	__declspec(noreturn) void _Xran() const
; 2275 : 		{	// report an out_of_range error
; 2276 : 		_Xout_of_range("invalid string position");

  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  000c5	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPEBD@Z ; std::_Xout_of_range
  000ca	cc		 int	 3
$LN40@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2

; 1740 : 		}

  00007	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 96
_Newres$ = 104
_Newsize$ = 104
_Oldlen$ = 112
_Ptr$ = 120
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

$LN185:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 56		 push	 r14
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00018	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00021	49 8b f0	 mov	 rsi, r8
  00024	48 8b d9	 mov	 rbx, rcx

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00027	48 8b fa	 mov	 rdi, rdx
  0002a	48 83 cf 0f	 or	 rdi, 15

; 2184 : 		if (max_size() < _Newres)

  0002e	48 83 ff fe	 cmp	 rdi, -2
  00032	76 05		 jbe	 SHORT $LN9@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

  00034	48 8b fa	 mov	 rdi, rdx
  00037	eb 35		 jmp	 SHORT $LN47@Copy
$LN9@Copy:

; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)

  00039	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  0003d	49 8b c8	 mov	 rcx, r8
  00040	48 d1 e9	 shr	 rcx, 1
  00043	48 b8 ab aa aa
	aa aa aa aa aa	 mov	 rax, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  0004d	48 f7 e7	 mul	 rdi
  00050	48 d1 ea	 shr	 rdx, 1
  00053	48 3b ca	 cmp	 rcx, rdx
  00056	76 16		 jbe	 SHORT $LN47@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)

  00058	48 c7 c7 fe ff
	ff ff		 mov	 rdi, -2
  0005f	48 8b c7	 mov	 rax, rdi
  00062	48 2b c1	 sub	 rax, rcx
  00065	4c 3b c0	 cmp	 r8, rax
  00068	77 04		 ja	 SHORT $LN47@Copy

; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible

  0006a	4a 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+r8]
$LN47@Copy:

; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  0006e	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  00072	45 33 f6	 xor	 r14d, r14d

; 24   : 
; 25   : 	if (_Count == 0)

  00075	48 85 c9	 test	 rcx, rcx
  00078	74 19		 je	 SHORT $LN63@Copy

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0007a	48 83 f9 ff	 cmp	 rcx, -1
  0007e	77 0d		 ja	 SHORT $LN62@Copy
  00080	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00085	4c 8b f0	 mov	 r14, rax
  00088	48 85 c0	 test	 rax, rax
  0008b	75 06		 jne	 SHORT $LN63@Copy
$LN62@Copy:

; 29   : 		_Xbad_alloc();	// report no memory

  0008d	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00092	90		 npad	 1
$LN63@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
  00093	eb 14		 jmp	 SHORT $LN18@Copy
$LN19@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
  00095	48 8b 5c 24 60	 mov	 rbx, QWORD PTR this$[rsp]
  0009a	48 8b 74 24 70	 mov	 rsi, QWORD PTR _Oldlen$[rsp]
  0009f	48 8b 7c 24 68	 mov	 rdi, QWORD PTR _Newres$[rsp]
  000a4	4c 8b 74 24 78	 mov	 r14, QWORD PTR _Ptr$[rsp]
$LN18@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2207 : 		if (0 < _Oldlen)

  000a9	48 85 f6	 test	 rsi, rsi
  000ac	74 1f		 je	 SHORT $LN124@Copy

; 517  : 			: this->_Bx._Buf);

  000ae	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
  000b3	72 05		 jb	 SHORT $LN117@Copy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000b5	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  000b8	eb 03		 jmp	 SHORT $LN118@Copy
$LN117@Copy:
  000ba	48 8b d3	 mov	 rdx, rbx
$LN118@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 530  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000bd	48 85 f6	 test	 rsi, rsi
  000c0	74 0b		 je	 SHORT $LN124@Copy
  000c2	4c 8b c6	 mov	 r8, rsi
  000c5	49 8b ce	 mov	 rcx, r14
  000c8	e8 00 00 00 00	 call	 memcpy
$LN124@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  000cd	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
  000d2	72 08		 jb	 SHORT $LN143@Copy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  000d4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000d7	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN143@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000dc	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  000df	4c 89 33	 mov	 QWORD PTR [rbx], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2212 : 		this->_Myres = _Newres;

  000e2	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi

; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000e6	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 517  : 			: this->_Bx._Buf);

  000ea	48 83 ff 10	 cmp	 rdi, 16
  000ee	72 03		 jb	 SHORT $LN178@Copy
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000f0	49 8b de	 mov	 rbx, r14
$LN178@Copy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  000f3	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2214 : 		}

  000f7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fb	41 5e		 pop	 r14
  000fd	5f		 pop	 rdi
  000fe	5e		 pop	 rsi
  000ff	5b		 pop	 rbx
  00100	c3		 ret	 0
$LN183@Copy:
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 96
_Newres$ = 104
_Newsize$ = 104
_Oldlen$ = 112
_Ptr$ = 120
?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$1

; 2197 : 		_CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z$0:

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0000d	48 8b 4d 68	 mov	 rcx, QWORD PTR _Newsize$[rbp]
  00011	48 89 4d 68	 mov	 QWORD PTR _Newres$[rbp], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  00015	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00017	48 ff c1	 inc	 rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  0001a	74 15		 je	 SHORT $LN78@catch$1

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0001c	48 83 f9 ff	 cmp	 rcx, -1
  00020	77 0a		 ja	 SHORT $LN77@catch$1
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00027	48 85 c0	 test	 rax, rax
  0002a	75 05		 jne	 SHORT $LN78@catch$1
$LN77@catch$1:

; 29   : 		_Xbad_alloc();	// report no memory

  0002c	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN78@catch$1:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00031	48 89 45 78	 mov	 QWORD PTR _Ptr$[rbp], rax

; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

  00035	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$1
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5d		 pop	 rbp
  00041	c3		 ret	 0
  00042	cc		 int	 3
?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 96
_Newres$ = 104
_Newsize$ = 104
_Oldlen$ = 112
_Ptr$ = 120
?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$0

; 2201 : 			_CATCH_ALL

  00043	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00048	53		 push	 rbx
  00049	55		 push	 rbp
  0004a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0004e	48 8b ea	 mov	 rbp, rdx
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z$1:

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00051	48 8b 5d 60	 mov	 rbx, QWORD PTR this$[rbp]
  00055	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16
  0005a	72 08		 jb	 SHORT $LN103@catch$0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0005c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0005f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN103@catch$0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00064	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0006c	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00074	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2203 : 			_RERAISE;

  00077	33 d2		 xor	 edx, edx
  00079	33 c9		 xor	 ecx, ecx
  0007b	e8 00 00 00 00	 call	 _CxxThrowException
  00080	90		 npad	 1
?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 2270 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2271 : 		_Xlength_error("string too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 914  : 		return (_Mytraits::max_size(*this));

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 915  : 		}

  0000a	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 21		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 17		 ja	 SHORT $LN11@allocate
  0001a	48 8d 0c d5 00
	00 00 00	 lea	 rcx, QWORD PTR [rdx*8]
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00027	48 85 c0	 test	 rax, rax
  0002a	74 05		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00036	cc		 int	 3
$LN10@allocate:
?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
_Lock$1 = 48
this$ = 48
_Off$ = 56
_Pdeque$ = 64
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT

; 303  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

$LN16:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  0000a	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 303  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  0000c	48 8b fa	 mov	 rdi, rdx
  0000f	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00012	48 89 01	 mov	 QWORD PTR [rcx], rax
  00015	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 114  : 		}
; 115  : 
; 116  : 	_Iterator_base12(const _Iterator_base12& _Right)
; 117  : 		: _Myproxy(0), _Mynextiter(0)
; 118  : 		{	// copy an iterator
; 119  : 		*this = _Right;
; 120  : 		}
; 121  : 
; 122  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 123  : 		{	// assign an iterator
; 124  : 		if (_Myproxy == _Right._Myproxy)
; 125  : 			;
; 126  : 		else if (_Right._Myproxy != 0)
; 127  : 			_Adopt(_Right._Myproxy->_Mycont);
; 128  : 		else
; 129  : 			{	// becoming invalid, disown current parent
; 130  : 			_Lockit _Lock(_LOCK_DEBUG);
; 131  : 			_Orphan_me();
; 132  : 			}
; 133  : 		return (*this);
; 134  : 		}
; 135  : 
; 136  : 	~_Iterator_base12() _NOEXCEPT
; 137  : 		{	// destroy the iterator
; 138  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 139  : 		_Lockit _Lock(_LOCK_DEBUG);
; 140  : 		_Orphan_me();
; 141  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 142  : 		}
; 143  : 
; 144  : 	void _Adopt(const _Container_base12 *_Parent)
; 145  : 		{	// adopt this iterator by parent
; 146  : 		if (_Parent == 0)

  00019	4d 85 c0	 test	 r8, r8
  0001c	75 29		 jne	 SHORT $LN8@Deque_cons

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  0001e	8d 50 03	 lea	 edx, QWORD PTR [rax+3]
  00021	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00026	e8 00 00 00 00	 call	 ??0_Lockit@std@@QEAA@H@Z ; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  0002b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QEAA@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  00035	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 307  : 		}

  00039	48 8b c3	 mov	 rax, rbx
  0003c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
$LN8@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00047	49 8b 00	 mov	 rax, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  0004a	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  0004e	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 307  : 		}

  00051	48 8b c3	 mov	 rax, rbx
  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 13		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 83 fa ff	 cmp	 rdx, -1
  0000f	77 12		 ja	 SHORT $LN14@allocate
  00011	48 8b ca	 mov	 rcx, rdx
  00014	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00019	48 85 c0	 test	 rax, rax
  0001c	74 05		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00023	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00028	cc		 int	 3
$LN13@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT

; 914  : 		return (_Mytraits::max_size(*this));

  00000	48 83 c8 ff	 or	 rax, -1

; 915  : 		}

  00004	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 762  : 		return (_Al.max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 763  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Lock$1 = 56
_Pdeque$ = 56
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont, COMDAT

; 531  : 		{	// set container pointer

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 146  : 		if (_Parent == 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	75 1e		 jne	 SHORT $LN4@Setcont

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  00009	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0000e	ba 03 00 00 00	 mov	 edx, 3
  00013	e8 00 00 00 00	 call	 ??0_Lockit@std@@QEAA@H@Z ; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  00018	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0001d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QEAA@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 533  : 		}

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN4@Setcont:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00027	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002a	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 533  : 		}

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 13		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 83 fa ff	 cmp	 rdx, -1
  0000f	77 12		 ja	 SHORT $LN11@allocate
  00011	48 8b ca	 mov	 rcx, rdx
  00014	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00019	48 85 c0	 test	 rax, rax
  0001c	74 05		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00023	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00028	cc		 int	 3
$LN10@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
_Al$ = 8
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 762  : 		return (_Al.max_size());

  00000	48 83 c8 ff	 or	 rax, -1

; 763  : 		}

  00004	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEBA_KXZ PROC ; std::allocator<std::shared_ptr<ChunkBase> >::max_size, COMDAT

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 629  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEBA_KXZ ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$allocator@D@std@@QEBA_KXZ PROC		; std::allocator<char>::max_size, COMDAT

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	48 83 c8 ff	 or	 rax, -1

; 629  : 		}

  00004	c3		 ret	 0
?max_size@?$allocator@D@std@@QEBA_KXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 627  : 		{	// estimate maximum array size

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
  00007	e9 00 00 00 00	 jmp	 atexit
??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Generic_object''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 627  : 		{	// estimate maximum array size

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
  00007	e9 00 00 00 00	 jmp	 atexit
??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_Iostream_object''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yc	SEGMENT
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::_Error_objects<int>::_System_object'', COMDAT

; 627  : 		{	// estimate maximum array size

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
  00007	e9 00 00 00 00	 jmp	 atexit
??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::_Error_objects<int>::_System_object''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
this$ = 48
_Px$ = 56
??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>, COMDAT

; 485  : 		explicit shared_ptr(_Ux *_Px)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00008	48 8b d9	 mov	 rbx, rcx

; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00012	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>

; 488  : 		}

  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEBV01@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>, COMDAT

; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00007	4d 85 c0	 test	 r8, r8
  0000a	74 05		 je	 SHORT $LN6@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0000c	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN6@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00011	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEBV01@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEADAEAPEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEADAEAPEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEADAEAPEAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN11@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN11@construct:

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@PEADAEAPEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEADAEAPEAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$destroy@PEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char * __ptr64>, COMDAT

; 908  : 		{	// destroy object at _Ptr
; 909  : 		_Mytraits::destroy(*this, _Ptr);
; 910  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEBV01@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>, COMDAT

; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00007	4d 85 c0	 test	 r8, r8
  0000a	74 05		 je	 SHORT $LN6@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0000c	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN6@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00011	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEBV01@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >, COMDAT

; 907  : 		void destroy(_Ty *_Ptr)

$LN23:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN18@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN21@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN21@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN21@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN18@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 910  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEBV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEBV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>, COMDAT

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN24@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN24@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEBV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PEAV_Ref_count_base@std@@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAV_Ref_count_base@std@@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z PROC ; std::swap<std::_Ref_count_base * __ptr64>, COMDAT

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00009	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 50   : 	}

  0000c	c3		 ret	 0
??$swap@PEAV_Ref_count_base@std@@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z ENDP ; std::swap<std::_Ref_count_base * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PEAVVertexStream@gfxu@@@std@@YAXAEAPEAVVertexStream@gfxu@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAVVertexStream@gfxu@@@std@@YAXAEAPEAVVertexStream@gfxu@@0@Z PROC ; std::swap<gfxu::VertexStream * __ptr64>, COMDAT

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00009	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 50   : 	}

  0000c	c3		 ret	 0
??$swap@PEAVVertexStream@gfxu@@@std@@YAXAEAPEAVVertexStream@gfxu@@0@Z ENDP ; std::swap<gfxu::VertexStream * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$dead$ = 16
??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 847  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00006	48 2b d1	 sub	 rdx, rcx

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00009	49 8b c0	 mov	 rax, r8

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  0000c	48 c1 fa 03	 sar	 rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00010	48 8d 1c d5 00
	00 00 00	 lea	 rbx, QWORD PTR [rdx*8]
  00018	48 8b d1	 mov	 rdx, rcx
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	4c 8b c3	 mov	 r8, rbx
  00021	e8 00 00 00 00	 call	 memmove
  00026	48 03 c3	 add	 rax, rbx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
_Al$dead$ = 32
??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >, COMDAT

; 668  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

$LN18:
  00000	48 83 ec 08	 sub	 rsp, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00004	48 85 d2	 test	 rdx, rdx
  00007	74 13		 je	 SHORT $LN11@Uninitiali
  00009	48 89 3c 24	 mov	 QWORD PTR [rsp], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000d	48 8b f9	 mov	 rdi, rcx
  00010	33 c0		 xor	 eax, eax
  00012	48 8b ca	 mov	 rcx, rdx
  00015	f3 48 ab	 rep stosq
  00018	48 8b 3c 24	 mov	 rdi, QWORD PTR [rsp]
$LN11@Uninitiali:

; 669  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 670  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 671  : 	}

  0001c	48 83 c4 08	 add	 rsp, 8
  00020	c3		 ret	 0
??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >, COMDAT

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 81   : 	}

  00000	c2 00 00	 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z PROC ; std::_Allocate<std::shared_ptr<ChunkBase> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 13		 ja	 SHORT $LN12@Allocate
  00013	48 c1 e1 04	 shl	 rcx, 4
  00017	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00026	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002b	cc		 int	 3
$LN11@Allocate:
??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z ENDP ; std::_Allocate<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z PROC ; std::_Allocate<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 17		 ja	 SHORT $LN12@Allocate
  00013	48 8d 0c cd 00
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8]
  0001b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00020	48 85 c0	 test	 rax, rax
  00023	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002a	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002f	cc		 int	 3
$LN11@Allocate:
??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z ENDP ; std::_Allocate<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@D@std@@YAPEAD_KPEAD@Z
_TEXT	SEGMENT
_Count$ = 48
__formal$ = 56
??$_Allocate@D@std@@YAPEAD_KPEAD@Z PROC			; std::_Allocate<char>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 c9	 test	 rcx, rcx
  00009	74 10		 je	 SHORT $LN2@Allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 83 f9 ff	 cmp	 rcx, -1
  0000f	77 0f		 ja	 SHORT $LN8@Allocate
  00011	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00016	48 85 c0	 test	 rax, rax
  00019	74 05		 je	 SHORT $LN8@Allocate
$LN2@Allocate:

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
$LN8@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00020	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00025	cc		 int	 3
$LN7@Allocate:
??$_Allocate@D@std@@YAPEAD_KPEAD@Z ENDP			; std::_Allocate<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object'', COMDAT

; 167  : 		{	// destroy the object

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  00007	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A, rax ; std::_Error_objects<int>::_System_object
  0000e	c3		 ret	 0
??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_System_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object'', COMDAT

; 167  : 		{	// destroy the object

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  00007	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A, rax ; std::_Error_objects<int>::_Iostream_object
  0000e	c3		 ret	 0
??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Iostream_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\system_error
;	COMDAT ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ
text$yd	SEGMENT
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ PROC ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object'', COMDAT

; 167  : 		{	// destroy the object

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7error_category@std@@6B@
  00007	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A, rax ; std::_Error_objects<int>::_Generic_object
  0000e	c3		 ret	 0
??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'std::_Error_objects<int>::_Generic_object''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 8
_Other_ptr$ = 16
_Other_rep$ = 24
?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset, COMDAT

; 407  : 		if (_Other_rep)

  00000	4d 85 c0	 test	 r8, r8
  00003	74 05		 je	 SHORT $LN4@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00005	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN4@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0000a	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 8
_Other_ptr$ = 16
_Other_rep$ = 24
?_Reset@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset, COMDAT

; 407  : 		if (_Other_rep)

  00000	4d 85 c0	 test	 r8, r8
  00003	74 05		 je	 SHORT $LN4@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00005	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN4@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0000a	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
?_Reset@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 48
_Other_ptr$ = 56
_Other_rep$ = 64
?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset0, COMDAT

; 423  : 		{	// release resource and take new resource

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 424  : 		if (_Rep != 0)

  00014	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00018	49 8b f0	 mov	 rsi, r8
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	48 85 ff	 test	 rdi, rdi
  00024	74 4c		 je	 SHORT $LN12@Reset0

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00026	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  0002a	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0002f	75 38		 jne	 SHORT $LN11@Reset0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00031	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00034	48 8b cf	 mov	 rcx, rdi
  00037	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00039	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0003d	75 09		 jne	 SHORT $LN10@Reset0

; 128  : 			_Delete_this();

  0003f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00042	48 8b cf	 mov	 rcx, rdi
  00045	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00048	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi

; 427  : 		_Ptr = _Other_ptr;

  0004c	48 89 2b	 mov	 QWORD PTR [rbx], rbp
$LN13@Reset0:
  0004f	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
$LN7@Reset0:

; 428  : 		}

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0005e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN11@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00069	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  0006d	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00070	eb dd		 jmp	 SHORT $LN13@Reset0
$LN12@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00072	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  00076	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00079	eb d9		 jmp	 SHORT $LN7@Reset0
?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 48
_Other_ptr$ = 56
_Other_rep$ = 64
?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset0, COMDAT

; 423  : 		{	// release resource and take new resource

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 424  : 		if (_Rep != 0)

  00014	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00018	49 8b f0	 mov	 rsi, r8
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	48 85 ff	 test	 rdi, rdi
  00024	74 4c		 je	 SHORT $LN12@Reset0

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00026	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  0002a	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0002f	75 38		 jne	 SHORT $LN11@Reset0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00031	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00034	48 8b cf	 mov	 rcx, rdi
  00037	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00039	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0003d	75 09		 jne	 SHORT $LN10@Reset0

; 128  : 			_Delete_this();

  0003f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00042	48 8b cf	 mov	 rcx, rdi
  00045	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00048	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi

; 427  : 		_Ptr = _Other_ptr;

  0004c	48 89 2b	 mov	 QWORD PTR [rbx], rbp
$LN13@Reset0:
  0004f	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
$LN7@Reset0:

; 428  : 		}

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0005e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN11@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00069	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  0006d	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00070	eb dd		 jmp	 SHORT $LN13@Reset0
$LN12@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00072	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  00076	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00079	eb d9		 jmp	 SHORT $LN7@Reset0
?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>, COMDAT

; 708  : 		void _Resetp(_Ux *_Px)

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  0001e	b9 18 00 00 00	 mov	 ecx, 24
  00023	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00028	48 85 c0	 test	 rax, rax
  0002b	74 1c		 je	 SHORT $LN5@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0002d	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1
  00034	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
  00042	48 89 08	 mov	 QWORD PTR [rax], rcx
  00045	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
$LN5@Resetp:

; 717  : 
; 718  : 	template<class _Ux,
; 719  : 		class _Dx>
; 720  : 		void _Resetp(_Ux *_Px, _Dx _Dt)
; 721  : 		{	// release, take ownership of _Px, deleter _Dt
; 722  : 		_TRY_BEGIN	// allocate control block and reset
; 723  : 		_Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
; 724  : 		_CATCH_ALL	// allocation failed, delete resource
; 725  : 		_Dt(_Px);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : //#if _HAS_CPP0X
; 731  : 	template<class _Ux,
; 732  : 		class _Dx,
; 733  : 		class _Alloc>
; 734  : 		void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 735  : 		{	// release, take ownership of _Px, deleter _Dt, allocator _Ax
; 736  : 		typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
; 737  : 		typename _Alloc::template rebind<_Refd>::other _Al = _Ax;
; 738  : 
; 739  : 		_TRY_BEGIN	// allocate control block and reset
; 740  : 		_Refd *_Ptr = _Al.allocate(1);
; 741  : 		::new (_Ptr) _Refd(_Px, _Dt, _Al);
; 742  : 		_Resetp0(_Px, _Ptr);
; 743  : 		_CATCH_ALL	// allocation failed, delete resource
; 744  : 		_Dt(_Px);
; 745  : 		_RERAISE;
; 746  : 		_CATCH_END
; 747  : 		}
; 748  : //#endif /* _HAS_CPP0X */
; 749  : 
; 750  : public:
; 751  : 	template<class _Ux>
; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00049	4c 8b c0	 mov	 r8, rax
  0004c	48 8b d3	 mov	 rdx, rbx
  0004f	48 8b cf	 mov	 rcx, rdi
  00052	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
  00057	90		 npad	 1

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;
; 714  : 		_RERAISE;
; 715  : 		_CATCH_END
; 716  : 		}

  00058	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN25@Resetp:
??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA PROC ; `std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>'::`1'::catch$0

; 712  : 		_CATCH_ALL	// allocation failed, delete resource

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z$0:

; 713  : 		delete _Px;

  0000d	48 8b 4d 48	 mov	 rcx, QWORD PTR _Px$[rbp]
  00011	48 85 c9	 test	 rcx, rcx
  00014	74 0a		 je	 SHORT $LN6@catch$0
  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	ba 01 00 00 00	 mov	 edx, 1
  0001e	ff 10		 call	 QWORD PTR [rax]
$LN6@catch$0:

; 714  : 		_RERAISE;

  00020	33 d2		 xor	 edx, edx
  00022	33 c9		 xor	 ecx, ecx
  00024	e8 00 00 00 00	 call	 _CxxThrowException
  00029	90		 npad	 1
?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA ENDP ; `std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * __ptr64 & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEADAEAPEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEADAEAPEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEADAEAPEAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN7@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN7@construct:

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0000b	f3 c3		 fatret	 0
??$construct@PEADAEAPEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEADAEAPEAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEAD@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
??$destroy@PEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char * __ptr64>, COMDAT

; 756  : 		{	// destroy object at _Ptr
; 757  : 		_Al.destroy(_Ptr);
; 758  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN16@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN19@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN19@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN19@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 758  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEBV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> const & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEBV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEBV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEBV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN20@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN20@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEBV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z PROC ; std::_Move<std::_Ref_count_base * __ptr64 & __ptr64>, COMDAT

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1800 : 	}

  00003	c3		 ret	 0
??$_Move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z ENDP ; std::_Move<std::_Ref_count_base * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAVVertexStream@gfxu@@@std@@YA$$QEAPEAVVertexStream@gfxu@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAVVertexStream@gfxu@@@std@@YA$$QEAPEAVVertexStream@gfxu@@AEAPEAV12@@Z PROC ; std::_Move<gfxu::VertexStream * __ptr64 & __ptr64>, COMDAT

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1800 : 	}

  00003	c3		 ret	 0
??$_Move@AEAPEAVVertexStream@gfxu@@@std@@YA$$QEAPEAVVertexStream@gfxu@@AEAPEAV12@@Z ENDP ; std::_Move<gfxu::VertexStream * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocator<std::shared_ptr<ChunkBase> * __ptr64><std::shared_ptr<ChunkBase> >, COMDAT

; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocator<std::shared_ptr<ChunkBase> * __ptr64><std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAV?$shared_ptr@VChunkBase@@@0@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAV?$shared_ptr@VChunkBase@@@0@0@Z PROC ; std::_Ptr_cat<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00005	0f b6 44 24 10	 movzx	 eax, BYTE PTR _Cat$[rsp]

; 440  : 	}

  0000a	c3		 ret	 0
??$_Ptr_cat@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAV?$shared_ptr@VChunkBase@@@0@0@Z ENDP ; std::_Ptr_cat<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00006	48 2b d1	 sub	 rdx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	48 c1 fa 03	 sar	 rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00010	48 8d 1c d5 00
	00 00 00	 lea	 rbx, QWORD PTR [rdx*8]
  00018	48 8b d1	 mov	 rdx, rcx
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	4c 8b c3	 mov	 r8, rbx
  00021	e8 00 00 00 00	 call	 memmove
  00026	48 03 c3	 add	 rax, rbx

; 407  : 	}

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@@Z PROC ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64>, COMDAT

; 711  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 712  : 	}

  00002	c3		 ret	 0
??$_Val_type@PEAPEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@@Z ENDP ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
__formal$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 659  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

$LN12:
  00000	48 83 ec 08	 sub	 rsp, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00004	48 85 d2	 test	 rdx, rdx
  00007	74 13		 je	 SHORT $LN5@Uninit_def
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  00009	48 89 3c 24	 mov	 QWORD PTR [rsp], rdi
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	33 c0		 xor	 eax, eax
  00012	48 8b ca	 mov	 rcx, rdx
  00015	f3 48 ab	 rep stosq
  00018	48 8b 3c 24	 mov	 rdi, QWORD PTR [rsp]
$LN5@Uninit_def:

; 661  : 	}

  0001c	48 83 c4 08	 add	 rsp, 8
  00020	c3		 ret	 0
??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >, COMDAT

; 97   : 	}

  00000	c2 00 00	 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@AEBV32@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Val$ = 24
?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@AEBV32@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct, COMDAT

; 605  : 		{	// construct object at _Ptr with value _Val

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN16@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN16@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 607  : 		}

  0002d	f3 c3		 fatret	 0
?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@AEBV32@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
??0?$_Ref_count@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z PROC ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>, COMDAT

; 155  : 		{	// construct

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00007	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [rcx+8], 1
  0000e	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 156  : 		}

  00018	48 8b c1	 mov	 rax, rcx
  0001b	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  0001f	c3		 ret	 0
??0?$_Ref_count@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z ENDP ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ PROC ; std::_Ref_count<gfxu::VertexStream>::_Destroy, COMDAT

; 161  : 		delete _Ptr;

  00000	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 0b		 je	 SHORT $LN3@Destroy
  00009	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000c	ba 01 00 00 00	 mov	 edx, 1
  00011	48 ff 20	 rex_jmp QWORD PTR [rax]
$LN3@Destroy:

; 162  : 		}

  00014	f3 c3		 fatret	 0
?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ ENDP ; std::_Ref_count<gfxu::VertexStream>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ PROC ; std::_Ref_count<gfxu::VertexStream>::_Delete_this, COMDAT

; 166  : 		delete this;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 0c		 je	 SHORT $LN3@Delete_thi
  00005	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00008	ba 01 00 00 00	 mov	 edx, 1
  0000d	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
$LN3@Delete_thi:

; 167  : 		}

  00011	f3 c3		 fatret	 0
?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ ENDP ; std::_Ref_count<gfxu::VertexStream>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z PROC ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor', COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN8@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN8@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z ENDP ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VVertexStream@gfxu@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Ref_count@VVertexStream@gfxu@@@std@@UEAA@XZ PROC	; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>, COMDAT

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1?$_Ref_count@VVertexStream@gfxu@@@std@@UEAA@XZ ENDP	; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
_Rx$ = 24
??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>, COMDAT

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00000	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@PEADAEAPEAD@?$allocator@D@std@@QEAAXPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@PEADAEAPEAD@?$allocator@D@std@@QEAAXPEAPEADAEAPEAD@Z PROC ; std::allocator<char>::construct<char * __ptr64,char * __ptr64 & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN3@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN3@construct:
  0000b	f3 c3		 fatret	 0
??$construct@PEADAEAPEAD@?$allocator@D@std@@QEAAXPEAPEADAEAPEAD@Z ENDP ; std::allocator<char>::construct<char * __ptr64,char * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAD@?$allocator@D@std@@QEAAXPEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$destroy@PEAD@?$allocator@D@std@@QEAAXPEAPEAD@Z PROC	; std::allocator<char>::destroy<char * __ptr64>, COMDAT

; 622  : 		{	// destroy object at _Ptr
; 623  : 		_Ptr->~_Uty();
; 624  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAD@?$allocator@D@std@@QEAAXPEAPEAD@Z ENDP	; std::allocator<char>::destroy<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >, COMDAT

; 621  : 		void destroy(_Uty *_Ptr)

$LN19:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN14@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN17@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN17@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN17@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN14@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@_KAEBQEAV10@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Count$ = 16
_Val$ = 24
??$_Fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@_KAEBQEAV10@@Z PROC ; std::_Fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 1b		 je	 SHORT $LN9@Fill_n
  00005	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@Fill_n:

; 2679 : 		*_Dest = _Val;

  00010	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00013	48 83 c1 08	 add	 rcx, 8
  00017	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax
  0001b	48 ff ca	 dec	 rdx
  0001e	75 f0		 jne	 SHORT $LL3@Fill_n
$LN9@Fill_n:

; 2680 : 	return (_Dest);

  00020	48 8b c1	 mov	 rax, rcx

; 2681 : 	}

  00023	c3		 ret	 0
??$_Fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@_KAEBQEAV10@@Z ENDP ; std::_Fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z PROC	; std::shared_ptr<ChunkBase>::`scalar deleting destructor', COMDAT
$LN20:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  0000a	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 35		 je	 SHORT $LN17@scalar

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00016	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0001a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001f	75 17		 jne	 SHORT $LN16@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00021	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00024	48 8b cb	 mov	 rcx, rbx
  00027	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00029	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0002d	75 09		 jne	 SHORT $LN16@scalar

; 128  : 			_Delete_this();

  0002f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00032	48 8b cb	 mov	 rcx, rbx
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
$LN16@scalar:
  00038	48 8b c7	 mov	 rax, rdi
  0003b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00040	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN17@scalar:
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z ENDP	; std::shared_ptr<ChunkBase>::`scalar deleting destructor'
_TEXT	ENDS
END
