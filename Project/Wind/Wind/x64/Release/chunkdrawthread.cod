; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	?drawerThread@@3HA				; drawerThread
PUBLIC	??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@	; std::_Ref_count<gfxu::VertexStream>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 ; std::_Ref_count<gfxu::VertexStream> `RTTI Type Descriptor'
PUBLIC	??_R0?AV_Ref_count_base@std@@@8			; std::_Ref_count_base `RTTI Type Descriptor'
PUBLIC	??_R4_Ref_count_base@std@@6B@			; std::_Ref_count_base::`RTTI Complete Object Locator'
PUBLIC	??_7_Ref_count_base@std@@6B@			; std::_Ref_count_base::`vftable'
PUBLIC	??_R2_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Base Class Array'
PUBLIC	??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8	; std::_Ref_count<gfxu::VertexStream>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8	; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Array'
PUBLIC	??_R3_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@_Ref_count_base@std@@8		; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@	; std::_Ref_count<gfxu::VertexStream>::`vftable'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	_Mtx_lock:PROC
EXTRN	_Mtx_unlock:PROC
EXTRN	??0_Lockit@std@@QEAA@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QEAA@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?_Throw_C_error@std@@YAXH@Z:PROC		; std::_Throw_C_error
?drawerThread@@3HA DD 01H DUP (?)			; drawerThread
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD imagerel ??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ DQ FLAT:??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ ; std::_Ref_count<gfxu::VertexStream>::`vftable'
	DQ	FLAT:?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ
	DQ	FLAT:?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ
	DQ	FLAT:??_E?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Ref_count_base@std@@8 DD imagerel ??_R0?AV_Ref_count_base@std@@@8 ; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R3_Ref_count_base@std@@8 DD 00H			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Ref_count@VVertexStream@gfxu@@@std@@8 ; std::_Ref_count<gfxu::VertexStream>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8 DD 00H	; std::_Ref_count<gfxu::VertexStream>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Ref_count@VVertexStream@gfxu@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R2_Ref_count_base@std@@8 DD imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8 ; std::_Ref_count_base::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7_Ref_count_base@std@@6B@
CONST	SEGMENT
??_7_Ref_count_base@std@@6B@ DQ FLAT:??_R4_Ref_count_base@std@@6B@ ; std::_Ref_count_base::`vftable'
	DQ	FLAT:_purecall
	DQ	FLAT:_purecall
	DQ	FLAT:??_E_Ref_count_base@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
CONST	ENDS
;	COMDAT ??_R4_Ref_count_base@std@@6B@
rdata$r	SEGMENT
??_R4_Ref_count_base@std@@6B@ DD 01H			; std::_Ref_count_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Ref_count_base@std@@@8
	DD	imagerel ??_R3_Ref_count_base@std@@8
	DD	imagerel ??_R4_Ref_count_base@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV_Ref_count_base@std@@@8
_DATA	SEGMENT
??_R0?AV_Ref_count_base@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Ref_count_base@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count<gfxu::VertexStream> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Ref_count@VVertexStream@gfxu@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@ DD 01H	; std::_Ref_count<gfxu::VertexStream>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Ref_count@VVertexStream@gfxu@@@std@@@8
	DD	imagerel ??_R3?$_Ref_count@VVertexStream@gfxu@@@std@@8
	DD	imagerel ??_R4?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
PUBLIC	??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z	; std::shared_ptr<ChunkBase>::`scalar deleting destructor'
PUBLIC	??$_Fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@_KAEBQEAV10@@Z ; std::_Fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@1@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>
PUBLIC	??1?$_Ref_count@VVertexStream@gfxu@@@std@@UEAA@XZ ; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>
PUBLIC	??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ ; std::_Ref_count<gfxu::VertexStream>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ ; std::_Ref_count<gfxu::VertexStream>::_Destroy
PUBLIC	??0?$_Ref_count@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>
PUBLIC	?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@AEBV32@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
PUBLIC	??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Val_type@PEAPEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@@Z ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64>
PUBLIC	??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Ptr_cat@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAV?$shared_ptr@VChunkBase@@@0@0@Z ; std::_Ptr_cat<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocator<std::shared_ptr<ChunkBase> * __ptr64><std::shared_ptr<ChunkBase> >
PUBLIC	??$_Move@AEAPEAVVertexStream@gfxu@@@std@@YA$$QEAPEAVVertexStream@gfxu@@AEAPEAV12@@Z ; std::_Move<gfxu::VertexStream * __ptr64 & __ptr64>
PUBLIC	??$_Move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z ; std::_Move<std::_Ref_count_base * __ptr64 & __ptr64>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEBV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>
PUBLIC	??$forward@AEBV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ; std::forward<std::shared_ptr<ChunkBase> const & __ptr64>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
PUBLIC	?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
PUBLIC	?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
PUBLIC	?_Reset@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset
PUBLIC	?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset
PUBLIC	??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z ; std::_Allocate<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z ; std::_Allocate<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
PUBLIC	??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
PUBLIC	??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$swap@PEAVVertexStream@gfxu@@@std@@YAXAEAPEAVVertexStream@gfxu@@0@Z ; std::swap<gfxu::VertexStream * __ptr64>
PUBLIC	??$swap@PEAV_Ref_count_base@std@@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base * __ptr64>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEBV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>
PUBLIC	??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
PUBLIC	??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEBV01@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>
PUBLIC	??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEBV01@@Z ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>
PUBLIC	??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>
PUBLIC	?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEBA_KXZ ; std::allocator<std::shared_ptr<ChunkBase> >::max_size
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont
PUBLIC	?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocate
PUBLIC	?deallocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_KXZ ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEBV?$shared_ptr@VChunkBase@@@1@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::deallocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::allocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> >::allocate
PUBLIC	?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
PUBLIC	?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEAV?$shared_ptr@VChunkBase@@@1@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_K_K@Z ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate
PUBLIC	?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
PUBLIC	?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
PUBLIC	?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_NXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty
PUBLIC	?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
PUBLIC	?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Swap
PUBLIC	??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ	; std::_Ptr_base<ChunkBase>::_Decref
PUBLIC	?_Get@?$_Ptr_base@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ ; std::_Ptr_base<ChunkBase>::_Get
PUBLIC	??0?$_Ptr_base@VChunkBase@@@std@@QEAA@XZ	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
PUBLIC	?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
PUBLIC	?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
PUBLIC	?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front
PUBLIC	?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
PUBLIC	?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ ; std::_Ptr_base<gfxu::VertexStream>::_Decref
PUBLIC	?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z ; std::shared_ptr<gfxu::VertexStream>::swap
PUBLIC	??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
PUBLIC	??B?$shared_ptr@VChunkBase@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VChunkBase@@@std@@@1@HXZ ; std::shared_ptr<ChunkBase>::operator int std::_Bool_struct<std::shared_ptr<ChunkBase> >::* __ptr64
PUBLIC	??C?$shared_ptr@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ ; std::shared_ptr<ChunkBase>::operator->
PUBLIC	??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ	; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop
PUBLIC	?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push
PUBLIC	?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front
PUBLIC	?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_KXZ ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size
PUBLIC	??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z ; std::shared_ptr<gfxu::VertexStream>::operator=
PUBLIC	??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
PUBLIC	?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestLateChunkDraw
PUBLIC	?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestChunkDraw
PUBLIC	?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ; requestQuickChunkDraw
PUBLIC	?tick@ChunkDrawThread@@MEAA_NXZ			; ChunkDrawThread::tick
PUBLIC	?staticInit@ChunkDrawThread@@SAXXZ		; ChunkDrawThread::staticInit
PUBLIC	?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
PUBLIC	?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; renderChunk
PUBLIC	?_Enable_shared@std@@YAXPEDX0@Z			; std::_Enable_shared
PUBLIC	??_G_Ref_count_base@std@@UEAAPEAXI@Z		; std::_Ref_count_base::`scalar deleting destructor'
PUBLIC	?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z ; std::_Ref_count_base::_Get_deleter
PUBLIC	?_Decwref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	?_Decref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Incref@_Ref_count_base@std@@QEAAXXZ		; std::_Ref_count_base::_Incref
PUBLIC	??1_Ref_count_base@std@@UEAA@XZ			; std::_Ref_count_base::~_Ref_count_base
PUBLIC	??0_Ref_count_base@std@@IEAA@XZ			; std::_Ref_count_base::_Ref_count_base
PUBLIC	?unlock@_Mutex_base@std@@QEAAXXZ		; std::_Mutex_base::unlock
PUBLIC	?lock@_Mutex_base@std@@QEAAXXZ			; std::_Mutex_base::lock
PUBLIC	?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z ; std::_Mtx_unlockX
PUBLIC	?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z ; std::_Mtx_lockX
PUBLIC	?_Check_C_return@std@@YAHH@Z			; std::_Check_C_return
PUBLIC	?_Init_atomic_counter@std@@YAXAEAKK@Z		; std::_Init_atomic_counter
PUBLIC	?_Orphan_all@_Container_base12@std@@QEAAXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QEAAXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	??1_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::~_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QEAA@XZ		; std::_Iterator_base12::_Iterator_base12
EXTRN	??_E?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z:PROC ; std::_Ref_count<gfxu::VertexStream>::`vector deleting destructor'
EXTRN	??_E_Ref_count_base@std@@UEAAPEAXI@Z:PROC	; std::_Ref_count_base::`vector deleting destructor'
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD imagerel $LN20+26
	DD	imagerel $LN20+75
	DD	imagerel $chain$0$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD imagerel $LN20+75
	DD	imagerel $LN20+89
	DD	imagerel $chain$1$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN19+19
	DD	imagerel $LN19+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN19+54
	DD	imagerel $LN19+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN12
	DD	imagerel $LN12+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN12+9
	DD	imagerel $LN12+28
	DD	imagerel $chain$0$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN12+28
	DD	imagerel $LN12+33
	DD	imagerel $chain$1$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD imagerel $LN4
	DD	imagerel $LN4+47
	DD	imagerel $unwind$??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN21+19
	DD	imagerel $LN21+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN21+54
	DD	imagerel $LN21+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD imagerel $LN26
	DD	imagerel $LN26+99
	DD	imagerel $unwind$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA DD imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA+42
	DD	imagerel $unwind$?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+42
	DD	imagerel $LN15+84
	DD	imagerel $chain$0$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+84
	DD	imagerel $LN15+105
	DD	imagerel $chain$1$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+105
	DD	imagerel $LN15+114
	DD	imagerel $chain$2$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+114
	DD	imagerel $LN15+123
	DD	imagerel $chain$3$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+42
	DD	imagerel $LN15+84
	DD	imagerel $chain$0$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+84
	DD	imagerel $LN15+105
	DD	imagerel $chain$1$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+105
	DD	imagerel $LN15+114
	DD	imagerel $chain$2$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD imagerel $LN15+114
	DD	imagerel $LN15+123
	DD	imagerel $chain$3$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z DD imagerel $LN14
	DD	imagerel $LN14+48
	DD	imagerel $unwind$??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z DD imagerel $LN14
	DD	imagerel $LN14+44
	DD	imagerel $unwind$??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN18
	DD	imagerel $LN18+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN18+9
	DD	imagerel $LN18+28
	DD	imagerel $chain$0$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN18+28
	DD	imagerel $LN18+33
	DD	imagerel $chain$1$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+47
	DD	imagerel $unwind$??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN23+19
	DD	imagerel $LN23+54
	DD	imagerel $chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD imagerel $LN23+54
	DD	imagerel $LN23+60
	DD	imagerel $chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z DD imagerel $LN11
	DD	imagerel $LN11+50
	DD	imagerel $unwind$?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD imagerel $LN16
	DD	imagerel $LN16+95
	DD	imagerel $unwind$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+55
	DD	imagerel $unwind$?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD imagerel $LN18
	DD	imagerel $LN18+95
	DD	imagerel $unwind$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+55
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD imagerel $LN13
	DD	imagerel $LN13+54
	DD	imagerel $unwind$?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD imagerel $LN16
	DD	imagerel $LN16+54
	DD	imagerel $unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134
	DD	imagerel $LN134+77
	DD	imagerel $unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+77
	DD	imagerel $LN134+150
	DD	imagerel $chain$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+150
	DD	imagerel $LN134+229
	DD	imagerel $chain$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+229
	DD	imagerel $LN134+279
	DD	imagerel $chain$4$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+279
	DD	imagerel $LN134+379
	DD	imagerel $chain$5$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+379
	DD	imagerel $LN134+409
	DD	imagerel $chain$6$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+409
	DD	imagerel $LN134+415
	DD	imagerel $chain$8$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN134+415
	DD	imagerel $LN134+428
	DD	imagerel $chain$9$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD imagerel $LN12+19
	DD	imagerel $LN12+54
	DD	imagerel $chain$0$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD imagerel $LN12+54
	DD	imagerel $LN12+60
	DD	imagerel $chain$1$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD imagerel $LN54
	DD	imagerel $LN54+176
	DD	imagerel $unwind$?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34
	DD	imagerel $LN34+24
	DD	imagerel $unwind$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34+24
	DD	imagerel $LN34+53
	DD	imagerel $chain$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34+53
	DD	imagerel $LN34+88
	DD	imagerel $chain$1$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34+88
	DD	imagerel $LN34+99
	DD	imagerel $chain$2$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD imagerel $LN34+99
	DD	imagerel $LN34+123
	DD	imagerel $chain$3$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ DD imagerel $LN14
	DD	imagerel $LN14+52
	DD	imagerel $unwind$?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD imagerel $LN12+19
	DD	imagerel $LN12+54
	DD	imagerel $chain$0$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD imagerel $LN12+54
	DD	imagerel $LN12+60
	DD	imagerel $chain$1$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z DD imagerel $LN13
	DD	imagerel $LN13+49
	DD	imagerel $unwind$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD imagerel $LN14+19
	DD	imagerel $LN14+54
	DD	imagerel $chain$0$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD imagerel $LN14+54
	DD	imagerel $LN14+60
	DD	imagerel $chain$1$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z DD imagerel $LN13
	DD	imagerel $LN13+49
	DD	imagerel $unwind$??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ DD imagerel $LN16
	DD	imagerel $LN16+52
	DD	imagerel $unwind$?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+57
	DD	imagerel $LN59+86
	DD	imagerel $chain$1$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+86
	DD	imagerel $LN59+111
	DD	imagerel $chain$2$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59+111
	DD	imagerel $LN59+120
	DD	imagerel $chain$3$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD imagerel $LN14+19
	DD	imagerel $LN14+54
	DD	imagerel $chain$0$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD imagerel $LN14+54
	DD	imagerel $LN14+60
	DD	imagerel $chain$1$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN31
	DD	imagerel $LN31+144
	DD	imagerel $unwind$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@ChunkDrawThread@@MEAA_NXZ DD imagerel $LN21
	DD	imagerel $LN21+116
	DD	imagerel $unwind$?tick@ChunkDrawThread@@MEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD imagerel $LN184
	DD	imagerel $LN184+592
	DD	imagerel $unwind$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel $LN497
	DD	imagerel $LN497+1710
	DD	imagerel $unwind$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Ref_count_base@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+38
	DD	imagerel $unwind$??_G_Ref_count_base@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Decref@_Ref_count_base@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+50
	DD	imagerel $unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?unlock@_Mutex_base@std@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+29
	DD	imagerel $unwind$?unlock@_Mutex_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?lock@_Mutex_base@std@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+29
	DD	imagerel $unwind$?lock@_Mutex_base@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z DD imagerel $LN8
	DD	imagerel $LN8+32
	DD	imagerel $unwind$?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z DD imagerel $LN8
	DD	imagerel $LN8+32
	DD	imagerel $unwind$?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_C_return@std@@YAHH@Z DD imagerel $LN6
	DD	imagerel $LN6+25
	DD	imagerel $unwind$?_Check_C_return@std@@YAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD imagerel $LN9
	DD	imagerel $LN9+50
	DD	imagerel $unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_C_return@std@@YAHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?lock@_Mutex_base@std@@QEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?unlock@_Mutex_base@std@@QEAAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@_Ref_count_base@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Ref_count_base@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+49
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+236
	DD	01H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+271
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+403
	DD	02H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+431
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+445
	DD	03H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+477
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+662
	DD	04H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+720
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+749
	DD	04H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+756
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1160
	DD	05H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1184
	DD	06H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1374
	DD	05H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1426
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1480
	DD	0ffffffffH
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1500
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1554
	DD	0ffffffffH
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1602
	DD	00H
	DD	imagerel ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z+1627
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$2@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$3@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$6@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
	DD	05H
	DD	imagerel ?dtor$5@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	07H
	DD	imagerel $stateUnwindMap$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	015H
	DD	imagerel $ip2state$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0b0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z DD 0e2e11H
	DD	0c782eH
	DD	0d682aH
	DD	01d011eH
	DD	0e011f013H
	DD	0c00dd00fH
	DD	0600a700bH
	DD	050083009H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z+154
	DD	00H
	DD	imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z+449
	DD	0ffffffffH
	DD	imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z+510
	DD	00H
	DD	imagerel ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z+516
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z DD 0c2511H
	DD	0137425H
	DD	0126421H
	DD	011541dH
	DD	0103419H
	DD	0f009b20dH
	DD	0c005e007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@ChunkDrawThread@@MEAA_NXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD imagerel ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+27
	DD	00H
	DD	imagerel ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z+95
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN59+50
	DD	imagerel $LN59+57
	DD	imagerel $chain$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 020521H
	DD	096405H
	DD	imagerel $LN59
	DD	imagerel $LN59+50
	DD	imagerel $unwind$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD 020521H
	DD	067405H
	DD	imagerel $LN14
	DD	imagerel $LN14+19
	DD	imagerel $unwind$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+24
	DD	imagerel $unwind$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN34+24
	DD	imagerel $LN34+53
	DD	imagerel $chain$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	066405H
	DD	imagerel $LN34+24
	DD	imagerel $LN34+53
	DD	imagerel $chain$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020521H
	DD	077405H
	DD	imagerel $LN34
	DD	imagerel $LN34+24
	DD	imagerel $unwind$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD 020521H
	DD	067405H
	DD	imagerel $LN12
	DD	imagerel $LN12+19
	DD	imagerel $unwind$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN134
	DD	imagerel $LN134+77
	DD	imagerel $unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 040021H
	DD	04f400H
	DD	085400H
	DD	imagerel $LN134
	DD	imagerel $LN134+77
	DD	imagerel $unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN134+77
	DD	imagerel $LN134+150
	DD	imagerel $chain$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN134+150
	DD	imagerel $LN134+229
	DD	imagerel $chain$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 020521H
	DD	0ac405H
	DD	imagerel $LN134+150
	DD	imagerel $LN134+229
	DD	imagerel $chain$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 041221H
	DD	0be412H
	DD	097405H
	DD	imagerel $LN134+77
	DD	imagerel $LN134+150
	DD	imagerel $chain$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 041021H
	DD	04f410H
	DD	085405H
	DD	imagerel $LN134
	DD	imagerel $LN134+77
	DD	imagerel $unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 030701H
	DD	060034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN23
	DD	imagerel $LN23+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN18
	DD	imagerel $LN18+9
	DD	imagerel $unwind$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 020021H
	DD	06e400H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 020521H
	DD	06e405H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 020021H
	DD	06e400H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 020521H
	DD	06e405H
	DD	imagerel $LN15
	DD	imagerel $LN15+42
	DD	imagerel $unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD imagerel ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z+30
	DD	00H
	DD	imagerel ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z+88
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA+13
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z DD 041819H
	DD	083418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN21
	DD	imagerel $LN21+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 020421H
	DD	07404H
	DD	imagerel $LN12
	DD	imagerel $LN12+9
	DD	imagerel $unwind$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020521H
	DD	067405H
	DD	imagerel $LN19
	DD	imagerel $LN19+19
	DD	imagerel $unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD 020521H
	DD	066405H
	DD	imagerel $LN20
	DD	imagerel $LN20+26
	DD	imagerel $unwind$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT

; 113  : 		{	// construct orphaned iterator

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 114  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT

; 138  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 139  : 		_Lockit _Lock(_LOCK_DEBUG);
; 140  : 		_Orphan_me();
; 141  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 142  : 		}

  00000	c2 00 00	 ret	 0
??1_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
this$ = 48
_Lock$1 = 56
_Parent$ = 56
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT

; 145  : 		{	// adopt this iterator by parent

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 146  : 		if (_Parent == 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	75 1e		 jne	 SHORT $LN2@Adopt

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  00009	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0000e	ba 03 00 00 00	 mov	 edx, 3
  00013	e8 00 00 00 00	 call	 ??0_Lockit@std@@QEAA@H@Z ; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  00018	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0001d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QEAA@XZ	; std::_Lockit::~_Lockit

; 167  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 168  : 			}
; 169  : 		}

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN2@Adopt:

; 151  : 		else
; 152  : 			{	// have a parent, do adoption
; 153  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 154  : 
; 155  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 156  : 			if (_Myproxy != _Parent_proxy)
; 157  : 				{	// change parentage
; 158  : 				_Lockit _Lock(_LOCK_DEBUG);
; 159  : 				_Orphan_me();
; 160  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 161  : 				_Parent_proxy->_Myfirstiter = this;
; 162  : 				_Myproxy = _Parent_proxy;
; 163  : 				}
; 164  : 
; 165  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 166  : 			_Myproxy = _Parent_proxy;

  00027	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 167  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 168  : 			}
; 169  : 		}

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 85 c0	 test	 rax, rax
  00006	75 02		 jne	 SHORT $LN3@Getcont

; 179  : 		}

  00008	f3 c3		 fatret	 0
$LN3@Getcont:

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0000a	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 179  : 		}

  0000d	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_me@_Iterator_base12@std@@QEAAXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT

; 188  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 189  : 		if (_Myproxy != 0)
; 190  : 			{	// adopted, remove self from list
; 191  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 192  : 			while (*_Pnext != 0 && *_Pnext != this)
; 193  : 				_Pnext = &(*_Pnext)->_Mynextiter;
; 194  : 
; 195  : 			if (*_Pnext == 0)
; 196  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");
; 197  : 			*_Pnext = _Mynextiter;
; 198  : 			_Myproxy = 0;
; 199  : 			}
; 200  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 201  : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 210  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 211  : 	if (_Myproxy != 0)
; 212  : 		{	// proxy allocated, drain it
; 213  : 		_Lockit _Lock(_LOCK_DEBUG);
; 214  : 
; 215  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 216  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 217  : 			(*_Pnext)->_Myproxy = 0;
; 218  : 		_Myproxy->_Myfirstiter = 0;
; 219  : 		}
; 220  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 221  : 	}

  00000	c2 00 00	 ret	 0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
;	COMDAT ?_Init_atomic_counter@std@@YAXAEAKK@Z
_TEXT	SEGMENT
_Counter$ = 8
_Value$ = 16
?_Init_atomic_counter@std@@YAXAEAKK@Z PROC		; std::_Init_atomic_counter, COMDAT

; 219  : 	_Counter = _Value;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 220  : 	}

  00002	c3		 ret	 0
?_Init_atomic_counter@std@@YAXAEAKK@Z ENDP		; std::_Init_atomic_counter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Check_C_return@std@@YAHH@Z
_TEXT	SEGMENT
_Res$ = 48
?_Check_C_return@std@@YAHH@Z PROC			; std::_Check_C_return, COMDAT

; 31   : 	{	// throw exception on failure

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 32   : 	if (_Res != _Thrd_success)

  00008	85 c9		 test	 ecx, ecx
  0000a	74 05		 je	 SHORT $LN4@Check_C_re

; 33   : 		_Throw_C_error(_Res);

  0000c	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN4@Check_C_re:

; 34   : 	return (_Res);

  00011	8b c3		 mov	 eax, ebx

; 35   : 	}

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5b		 pop	 rbx
  00018	c3		 ret	 0
?_Check_C_return@std@@YAHH@Z ENDP			; std::_Check_C_return
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z
_TEXT	SEGMENT
_Mtx$ = 48
?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z PROC	; std::_Mtx_lockX, COMDAT

; 67   : 	{	// throw exception on failure

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00006	e8 00 00 00 00	 call	 _Mtx_lock
  0000b	8b d8		 mov	 ebx, eax

; 32   : 	if (_Res != _Thrd_success)

  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN3@Mtx_lockX

; 33   : 		_Throw_C_error(_Res);

  00011	8b c8		 mov	 ecx, eax
  00013	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00018	8b c3		 mov	 eax, ebx
$LN3@Mtx_lockX:

; 69   : 	}

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
?_Mtx_lockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z ENDP	; std::_Mtx_lockX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
;	COMDAT ?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z
_TEXT	SEGMENT
_Mtx$ = 48
?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z PROC ; std::_Mtx_unlockX, COMDAT

; 82   : 	{	// throw exception on failure

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00006	e8 00 00 00 00	 call	 _Mtx_unlock
  0000b	8b d8		 mov	 ebx, eax

; 32   : 	if (_Res != _Thrd_success)

  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN3@Mtx_unlock

; 33   : 		_Throw_C_error(_Res);

  00011	8b c8		 mov	 ecx, eax
  00013	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00018	8b c3		 mov	 eax, ebx
$LN3@Mtx_unlock:

; 84   : 	}

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
?_Mtx_unlockX@std@@YAHPEAPEAU_Mtx_internal_imp_t@@@Z ENDP ; std::_Mtx_unlockX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ?lock@_Mutex_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?lock@_Mutex_base@std@@QEAAXXZ PROC			; std::_Mutex_base::lock, COMDAT

; 42   : 		{	// lock the mutex

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00004	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00009	85 c0		 test	 eax, eax
  0000b	74 0b		 je	 SHORT $LN5@lock

; 33   : 		_Throw_C_error(_Res);

  0000d	8b c8		 mov	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 44   : 		}

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 33   : 		_Throw_C_error(_Res);

  00013	e9 00 00 00 00	 jmp	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN5@lock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 44   : 		}

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
?lock@_Mutex_base@std@@QEAAXXZ ENDP			; std::_Mutex_base::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ?unlock@_Mutex_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?unlock@_Mutex_base@std@@QEAAXXZ PROC			; std::_Mutex_base::unlock, COMDAT

; 52   : 		{	// unlock the mutex

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00004	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00009	85 c0		 test	 eax, eax
  0000b	74 0b		 je	 SHORT $LN5@unlock

; 33   : 		_Throw_C_error(_Res);

  0000d	8b c8		 mov	 ecx, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 54   : 		}

  0000f	48 83 c4 28	 add	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 33   : 		_Throw_C_error(_Res);

  00013	e9 00 00 00 00	 jmp	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN5@unlock:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 54   : 		}

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
?unlock@_Mutex_base@std@@QEAAXXZ ENDP			; std::_Mutex_base::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0_Ref_count_base@std@@IEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Ref_count_base@std@@IEAA@XZ PROC			; std::_Ref_count_base::_Ref_count_base, COMDAT

; 61   : 	_Ref_count_base()

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00007	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [rcx+8], 1
  0000e	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 61   : 	_Ref_count_base()

  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 62   : 		{	// construct
; 63   : 		_Init_atomic_counter(_Uses, 1);
; 64   : 		_Init_atomic_counter(_Weaks, 1);
; 65   : 		}

  00018	48 8b c1	 mov	 rax, rcx
  0001b	c3		 ret	 0
??0_Ref_count_base@std@@IEAA@XZ ENDP			; std::_Ref_count_base::_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1_Ref_count_base@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_Ref_count_base@std@@UEAA@XZ PROC			; std::_Ref_count_base::~_Ref_count_base, COMDAT

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 70   : 		}

  0000a	c3		 ret	 0
??1_Ref_count_base@std@@UEAA@XZ ENDP			; std::_Ref_count_base::~_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Incref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Incref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Incref, COMDAT

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00000	f0 ff 41 08	 lock inc DWORD PTR [rcx+8]

; 109  : 		}

  00004	c3		 ret	 0
?_Incref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Incref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT

; 117  : 		{	// decrement use count

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000a	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	75 14		 jne	 SHORT $LN4@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00013	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00016	ff 10		 call	 QWORD PTR [rax]

; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00018	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0001c	75 09		 jne	 SHORT $LN4@Decref

; 128  : 			_Delete_this();

  0001e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00021	48 8b cb	 mov	 rcx, rbx
  00024	ff 50 08	 call	 QWORD PTR [rax+8]
$LN4@Decref:

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}

  00027	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5f		 pop	 rdi
  00031	c3		 ret	 0
?_Decref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Decwref@_Ref_count_base@std@@QEAAXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT

; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00000	f0 ff 49 0c	 lock dec DWORD PTR [rcx+12]
  00004	75 07		 jne	 SHORT $LN1@Decwref

; 128  : 			_Delete_this();

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 ff 60 08	 rex_jmp QWORD PTR [rax+8]
$LN1@Decwref:

; 129  : 		}

  0000d	f3 c3		 fatret	 0
?_Decwref@_Ref_count_base@std@@QEAAXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z PROC ; std::_Ref_count_base::_Get_deleter, COMDAT

; 143  : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 144  : 		}

  00002	c3		 ret	 0
?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z ENDP ; std::_Ref_count_base::_Get_deleter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G_Ref_count_base@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Ref_count_base@std@@UEAAPEAXI@Z PROC		; std::_Ref_count_base::`scalar deleting destructor', COMDAT
$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN6@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN6@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G_Ref_count_base@std@@UEAAPEAXI@Z ENDP		; std::_Ref_count_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Enable_shared@std@@YAXPEDX0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?_Enable_shared@std@@YAXPEDX0@Z PROC			; std::_Enable_shared, COMDAT

; 269  : 	}

  00000	c2 00 00	 ret	 0
?_Enable_shared@std@@YAXPEDX0@Z ENDP			; std::_Enable_shared
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
chunk$2 = 96
cx$1$ = 112
c$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; renderChunk, COMDAT

; 6    : {

$LN497:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00007	55		 push	 rbp
  00008	53		 push	 rbx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	41 54		 push	 r12
  0000d	41 55		 push	 r13
  0000f	41 56		 push	 r14
  00011	41 57		 push	 r15
  00013	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  00017	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001e	48 c7 45 e7 fe
	ff ff ff	 mov	 QWORD PTR $T7[rbp-201], -2
  00026	0f 29 70 a8	 movaps	 XMMWORD PTR [rax-88], xmm6
  0002a	0f 29 78 98	 movaps	 XMMWORD PTR [rax-104], xmm7
  0002e	4c 8b e1	 mov	 r12, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00031	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  00034	48 83 c1 28	 add	 rcx, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00038	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0003d	85 c0		 test	 eax, eax
  0003f	74 07		 je	 SHORT $LN43@renderChun

; 33   : 		_Throw_C_error(_Res);

  00041	8b c8		 mov	 ecx, eax
  00043	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN43@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00048	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 10   : 	if(!chunk->shouldRender() || !chunk->isRenderUpdateNeeded() || chunk->isUnloaded())

  0004c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0004f	ff 50 28	 call	 QWORD PTR [rax+40]
  00052	84 c0		 test	 al, al
  00054	0f 84 e8 05 00
	00		 je	 $LN21@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  0005a	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 10   : 	if(!chunk->shouldRender() || !chunk->isRenderUpdateNeeded() || chunk->isUnloaded())

  0005e	80 78 08 00	 cmp	 BYTE PTR [rax+8], 0
  00062	0f 84 da 05 00
	00		 je	 $LN21@renderChun
  00068	80 78 0a 00	 cmp	 BYTE PTR [rax+10], 0
  0006c	0f 85 d0 05 00
	00		 jne	 $LN21@renderChun
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 95   : 	renderUpdateNeeded = flag;

  00072	c6 40 08 00	 mov	 BYTE PTR [rax+8], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00076	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  0007a	48 83 c1 28	 add	 rcx, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0007e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00083	85 c0		 test	 eax, eax
  00085	74 07		 je	 SHORT $LN98@renderChun

; 33   : 		_Throw_C_error(_Res);

  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN98@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 18   : 	for(int i = -1; i < 2; i++)

  0008e	83 ce ff	 or	 esi, -1
  00091	44 8b fe	 mov	 r15d, esi
  00094	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL20@renderChun:

; 19   : 	{
; 20   : 		for(int j = -1; j < 2; j++)

  000a0	44 8b f6	 mov	 r14d, esi
  000a3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL17@renderChun:

; 22   : 			for(int k = -1; k < 2; k++)

  000b0	8b fe		 mov	 edi, esi
  000b2	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL14@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  000c0	49 8b 14 24	 mov	 rdx, QWORD PTR [r12]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 24   : 				std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(chunk->pos.x + i, chunk->pos.y + j, chunk->pos.z + k);

  000c4	8b 4a 20	 mov	 ecx, DWORD PTR [rdx+32]
  000c7	03 cf		 add	 ecx, edi
  000c9	44 8b 4a 1c	 mov	 r9d, DWORD PTR [rdx+28]
  000cd	45 03 ce	 add	 r9d, r14d
  000d0	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  000d3	45 8d 04 07	 lea	 r8d, DWORD PTR [r15+rax]
  000d7	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000db	48 8d 55 af	 lea	 rdx, QWORD PTR c$3[rbp-201]
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  000e6	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  000eb	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  000ec	48 8b 5d af	 mov	 rbx, QWORD PTR c$3[rbp-201]
  000f0	48 85 db	 test	 rbx, rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 25   : 				if(c == nullptr || (!c->isEmpty() && !c->isLoaded()))

  000f3	0f 84 e3 04 00
	00		 je	 $LN468@renderChun
  000f9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000fc	48 8b cb	 mov	 rcx, rbx
  000ff	ff 50 18	 call	 QWORD PTR [rax+24]
  00102	84 c0		 test	 al, al
  00104	75 09		 jne	 SHORT $LN11@renderChun
  00106	38 43 09	 cmp	 BYTE PTR [rbx+9], al
  00109	0f 84 cd 04 00
	00		 je	 $LN468@renderChun
$LN11@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0010f	48 8b 4d b7	 mov	 rcx, QWORD PTR c$3[rbp-193]
  00113	48 85 c9	 test	 rcx, rcx
  00116	74 22		 je	 SHORT $LN13@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00118	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  0011c	75 1c		 jne	 SHORT $LN13@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0011e	48 8b 5d b7	 mov	 rbx, QWORD PTR c$3[rbp-193]
  00122	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00125	48 8b cb	 mov	 rcx, rbx
  00128	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0012a	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0012e	75 0a		 jne	 SHORT $LN13@renderChun

; 128  : 			_Delete_this();

  00130	48 8b 4d b7	 mov	 rcx, QWORD PTR c$3[rbp-193]
  00134	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00137	ff 50 08	 call	 QWORD PTR [rax+8]
$LN13@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 22   : 			for(int k = -1; k < 2; k++)

  0013a	ff c7		 inc	 edi
  0013c	83 ff 02	 cmp	 edi, 2
  0013f	0f 8c 7b ff ff
	ff		 jl	 $LL14@renderChun

; 19   : 	{
; 20   : 		for(int j = -1; j < 2; j++)

  00145	41 ff c6	 inc	 r14d
  00148	41 83 fe 02	 cmp	 r14d, 2
  0014c	0f 8c 5e ff ff
	ff		 jl	 $LL17@renderChun

; 18   : 	for(int i = -1; i < 2; i++)

  00152	41 ff c7	 inc	 r15d
  00155	41 83 ff 02	 cmp	 r15d, 2
  00159	0f 8c 41 ff ff
	ff		 jl	 $LL20@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  0015f	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 33   : 	const int cx = chunk->pos.x * 16;

  00163	44 8b 70 18	 mov	 r14d, DWORD PTR [rax+24]
  00167	41 c1 e6 04	 shl	 r14d, 4
  0016b	44 89 75 a7	 mov	 DWORD PTR cx$1$[rbp-201], r14d

; 34   : 	const int cy = chunk->pos.y * 16;

  0016f	44 8b 78 1c	 mov	 r15d, DWORD PTR [rax+28]
  00173	41 c1 e7 04	 shl	 r15d, 4
  00177	44 89 7c 24 38	 mov	 DWORD PTR cy$1$[rsp], r15d

; 35   : 	const int cz = chunk->pos.z * 16;

  0017c	8b 78 20	 mov	 edi, DWORD PTR [rax+32]
  0017f	c1 e7 04	 shl	 edi, 4
  00182	89 7d 6f	 mov	 DWORD PTR cz$1$[rbp-201], edi

; 36   : 
; 37   : 	gfxu::VertexStream* firstPass = new gfxu::VertexStream(8192);

  00185	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0018a	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0018f	48 89 45 77	 mov	 QWORD PTR $T9[rbp-201], rax
  00193	45 33 e4	 xor	 r12d, r12d
  00196	48 85 c0	 test	 rax, rax
  00199	74 0d		 je	 SHORT $LN25@renderChun
  0019b	48 8b c8	 mov	 rcx, rax
  0019e	e8 00 00 00 00	 call	 ??0VertexStream@gfxu@@QEAA@H@Z ; gfxu::VertexStream::VertexStream
  001a3	48 8b d8	 mov	 rbx, rax
  001a6	eb 03		 jmp	 SHORT $LN489@renderChun
$LN25@renderChun:
  001a8	49 8b dc	 mov	 rbx, r12
$LN489@renderChun:
  001ab	48 89 5d bf	 mov	 QWORD PTR $T4[rbp-201], rbx

; 38   : 	gfxu::VertexStream* secondPass = new gfxu::VertexStream(8192);

  001af	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  001b4	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  001b9	48 89 45 77	 mov	 QWORD PTR $T8[rbp-201], rax
  001bd	48 85 c0	 test	 rax, rax
  001c0	74 10		 je	 SHORT $LN27@renderChun
  001c2	48 8b c8	 mov	 rcx, rax
  001c5	e8 00 00 00 00	 call	 ??0VertexStream@gfxu@@QEAA@H@Z ; gfxu::VertexStream::VertexStream
  001ca	48 8b c8	 mov	 rcx, rax
  001cd	45 33 c9	 xor	 r9d, r9d
  001d0	eb 06		 jmp	 SHORT $LN490@renderChun
$LN27@renderChun:
  001d2	45 33 c9	 xor	 r9d, r9d
  001d5	41 8b c9	 mov	 ecx, r9d
$LN490@renderChun:
  001d8	48 89 4c 24 30	 mov	 QWORD PTR $T1[rsp], rcx

; 39   : 	for(unsigned int i = 0; i < 16; i++)

  001dd	45 8b c1	 mov	 r8d, r9d
  001e0	44 89 4d 7f	 mov	 DWORD PTR i$1$[rbp-201], r9d
  001e4	eb 0f		 jmp	 SHORT $LN9@renderChun
  001e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL486@renderChun:
  001f0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
$LN9@renderChun:

; 40   : 	{
; 41   : 		for(unsigned int j = 0; j < 16; j++)

  001f5	41 8b d1	 mov	 edx, r9d
  001f8	89 55 77	 mov	 DWORD PTR j$1$[rbp-201], edx
  001fb	41 8b c0	 mov	 eax, r8d
  001fe	0f 57 ff	 xorps	 xmm7, xmm7
  00201	f3 48 0f 2a f8	 cvtsi2ss xmm7, rax
  00206	45 8b e8	 mov	 r13d, r8d
  00209	45 0b ee	 or	 r13d, r14d
  0020c	eb 07		 jmp	 SHORT $LN6@renderChun
  0020e	66 90		 npad	 2
$LL485@renderChun:
  00210	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
$LN6@renderChun:

; 42   : 		{
; 43   : 			for(unsigned int k = 0; k < 16; k++)

  00215	45 8b e1	 mov	 r12d, r9d
  00218	8b c2		 mov	 eax, edx
  0021a	0f 57 f6	 xorps	 xmm6, xmm6
  0021d	f3 48 0f 2a f0	 cvtsi2ss xmm6, rax
  00222	44 8b f2	 mov	 r14d, edx
  00225	45 0b f7	 or	 r14d, r15d
  00228	eb 0b		 jmp	 SHORT $LN3@renderChun
  0022a	66 0f 1f 44 00
	00		 npad	 6
$LL484@renderChun:
  00230	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
$LN3@renderChun:

; 44   : 			{
; 45   : 				firstPass->setTranslation(i, j, k);

  00235	41 8b c4	 mov	 eax, r12d
  00238	0f 57 c0	 xorps	 xmm0, xmm0
  0023b	f3 48 0f 2a c0	 cvtsi2ss xmm0, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 177  : 	translation = Vertex(x, y, z);

  00240	f3 0f 11 7b 20	 movss	 DWORD PTR [rbx+32], xmm7
  00245	f3 0f 11 73 24	 movss	 DWORD PTR [rbx+36], xmm6
  0024a	f3 0f 11 43 28	 movss	 DWORD PTR [rbx+40], xmm0

; 156  : 	vertex.r = r;

  0024f	c7 43 4c ff ff
	ff ff		 mov	 DWORD PTR [rbx+76], -1	; ffffffffH

; 178  : }
; 179  : void VertexStream::setTranslation(Vertex vertex)
; 180  : {
; 181  : 	translation = vertex;
; 182  : }
; 183  : 
; 184  : void VertexStream::setIcon(TiledTexture::Icon* icon)
; 185  : {
; 186  : 	this->icon = icon;

  00256	4c 89 4b 30	 mov	 QWORD PTR [rbx+48], r9

; 177  : 	translation = Vertex(x, y, z);

  0025a	f3 0f 11 79 20	 movss	 DWORD PTR [rcx+32], xmm7
  0025f	f3 0f 11 71 24	 movss	 DWORD PTR [rcx+36], xmm6
  00264	f3 0f 11 41 28	 movss	 DWORD PTR [rcx+40], xmm0

; 156  : 	vertex.r = r;

  00269	c7 41 4c ff ff
	ff ff		 mov	 DWORD PTR [rcx+76], -1	; ffffffffH

; 178  : }
; 179  : void VertexStream::setTranslation(Vertex vertex)
; 180  : {
; 181  : 	translation = vertex;
; 182  : }
; 183  : 
; 184  : void VertexStream::setIcon(TiledTexture::Icon* icon)
; 185  : {
; 186  : 	this->icon = icon;

  00270	4c 89 49 30	 mov	 QWORD PTR [rcx+48], r9
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 55   : 				const int z = k | cz;

  00274	45 8b fc	 mov	 r15d, r12d
  00277	44 0b ff	 or	 r15d, edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 244  : 	std::shared_ptr<ChunkBase> chunk = getChunkFromBlockCoordinate(x, y, z);

  0027a	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  0027f	45 8b ce	 mov	 r9d, r14d
  00282	45 8b c5	 mov	 r8d, r13d
  00285	48 8d 55 97	 lea	 rdx, QWORD PTR chunk$2[rbp-201]
  00289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00290	e8 00 00 00 00	 call	 ?getChunkFromBlockCoordinate@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunkFromBlockCoordinate
  00295	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  00296	48 8b 5d 97	 mov	 rbx, QWORD PTR chunk$2[rbp-201]
  0029a	48 85 db	 test	 rbx, rbx
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 246  : 	if(chunk == nullptr || chunk->isEmpty() || !chunk->isLoaded())

  0029d	74 4e		 je	 SHORT $LN192@renderChun
  0029f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002a2	48 8b cb	 mov	 rcx, rbx
  002a5	ff 50 18	 call	 QWORD PTR [rax+24]
  002a8	84 c0		 test	 al, al
  002aa	75 41		 jne	 SHORT $LN192@renderChun
  002ac	38 43 09	 cmp	 BYTE PTR [rbx+9], al
  002af	74 3c		 je	 SHORT $LN192@renderChun

; 251  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  002b1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002b4	45 8b cf	 mov	 r9d, r15d
  002b7	41 83 e1 0f	 and	 r9d, 15
  002bb	45 8b c6	 mov	 r8d, r14d
  002be	41 83 e0 0f	 and	 r8d, 15
  002c2	41 8b d5	 mov	 edx, r13d
  002c5	83 e2 0f	 and	 edx, 15
  002c8	48 8b cb	 mov	 rcx, rbx
  002cb	ff 10		 call	 QWORD PTR [rax]
  002cd	48 8b f8	 mov	 rdi, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  002d0	48 8b 55 9f	 mov	 rdx, QWORD PTR chunk$2[rbp-193]
  002d4	48 85 d2	 test	 rdx, rdx
  002d7	74 46		 je	 SHORT $LN194@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002d9	f0 ff 4a 08	 lock dec DWORD PTR [rdx+8]
  002dd	75 40		 jne	 SHORT $LN194@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002df	48 8b 5d 9f	 mov	 rbx, QWORD PTR chunk$2[rbp-193]
  002e3	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  002e6	48 8b cb	 mov	 rcx, rbx
  002e9	ff 12		 call	 QWORD PTR [rdx]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 251  : 	return chunk->getBlock(x & 0xf, y & 0xf, z & 0xf);

  002eb	eb 22		 jmp	 SHORT $LN492@renderChun
$LN192@renderChun:

; 247  : 	{
; 248  : 		return Blocks::air;

  002ed	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?air@Blocks@@3PEAVBlockAir@@EA ; Blocks::air
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  002f4	48 8b 4d 9f	 mov	 rcx, QWORD PTR chunk$2[rbp-193]
  002f8	48 85 c9	 test	 rcx, rcx
  002fb	74 22		 je	 SHORT $LN194@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002fd	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00301	75 1c		 jne	 SHORT $LN194@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00303	48 8b 5d 9f	 mov	 rbx, QWORD PTR chunk$2[rbp-193]
  00307	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0030a	48 8b cb	 mov	 rcx, rbx
  0030d	ff 10		 call	 QWORD PTR [rax]
$LN492@renderChun:

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0030f	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00313	75 0a		 jne	 SHORT $LN194@renderChun

; 128  : 			_Delete_this();

  00315	48 8b 4d 9f	 mov	 rcx, QWORD PTR chunk$2[rbp-193]
  00319	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0031c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN194@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 59   : 				block->firstPassRenderer(world, x, y, z, block, firstPass);

  0031f	48 8b 5d bf	 mov	 rbx, QWORD PTR $T4[rbp-201]
  00323	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00328	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0032d	45 8b cf	 mov	 r9d, r15d
  00330	45 8b c6	 mov	 r8d, r14d
  00333	41 8b d5	 mov	 edx, r13d
  00336	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  0033d	ff 57 38	 call	 QWORD PTR [rdi+56]

; 60   : 				block->secondPassRenderer(world, x, y, z, block, secondPass);

  00340	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  00345	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0034a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0034f	45 8b cf	 mov	 r9d, r15d
  00352	45 8b c6	 mov	 r8d, r14d
  00355	41 8b d5	 mov	 edx, r13d
  00358	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  0035f	ff 57 40	 call	 QWORD PTR [rdi+64]

; 42   : 		{
; 43   : 			for(unsigned int k = 0; k < 16; k++)

  00362	41 ff c4	 inc	 r12d
  00365	41 83 fc 10	 cmp	 r12d, 16
  00369	8b 7d 6f	 mov	 edi, DWORD PTR cz$1$[rbp-201]
  0036c	41 b9 00 00 00
	00		 mov	 r9d, 0
  00372	0f 82 b8 fe ff
	ff		 jb	 $LL484@renderChun

; 40   : 	{
; 41   : 		for(unsigned int j = 0; j < 16; j++)

  00378	8b 55 77	 mov	 edx, DWORD PTR j$1$[rbp-201]
  0037b	ff c2		 inc	 edx
  0037d	89 55 77	 mov	 DWORD PTR j$1$[rbp-201], edx
  00380	83 fa 10	 cmp	 edx, 16
  00383	44 8b 7c 24 38	 mov	 r15d, DWORD PTR cy$1$[rsp]
  00388	0f 82 82 fe ff
	ff		 jb	 $LL485@renderChun

; 39   : 	for(unsigned int i = 0; i < 16; i++)

  0038e	44 8b 45 7f	 mov	 r8d, DWORD PTR i$1$[rbp-201]
  00392	41 ff c0	 inc	 r8d
  00395	44 89 45 7f	 mov	 DWORD PTR i$1$[rbp-201], r8d
  00399	41 83 f8 10	 cmp	 r8d, 16
  0039d	44 8b 75 a7	 mov	 r14d, DWORD PTR cx$1$[rbp-201]
  003a1	0f 82 49 fe ff
	ff		 jb	 $LL486@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 977  : 		return (this->_Myend != this->_Mylast);

  003a7	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]
  003ab	49 be ab aa aa
	aa aa aa aa 2a	 mov	 r14, 3074457345618258603 ; 2aaaaaaaaaaaaaabH
  003b5	48 39 53 18	 cmp	 QWORD PTR [rbx+24], rdx

; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())

  003b9	74 47		 je	 SHORT $LN488@renderChun

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);

  003bb	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  003bf	48 3b c2	 cmp	 rax, rdx

; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())

  003c2	75 1e		 jne	 SHORT $LN240@renderChun

; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)
; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)
; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));
; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())

  003c4	48 85 c0	 test	 rax, rax
  003c7	74 39		 je	 SHORT $LN488@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  003c9	48 8b c8	 mov	 rcx, rax
  003cc	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  003d1	45 33 e4	 xor	 r12d, r12d
  003d4	4c 89 63 08	 mov	 QWORD PTR [rbx+8], r12

; 1543 : 			this->_Mylast = pointer();

  003d8	4c 89 63 10	 mov	 QWORD PTR [rbx+16], r12

; 1544 : 			this->_Myend = pointer();

  003dc	4c 89 63 18	 mov	 QWORD PTR [rbx+24], r12

; 1051 : 				_Tidy();
; 1052 : 			else

  003e0	eb 23		 jmp	 SHORT $LN239@renderChun
$LN240@renderChun:

; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  003e2	48 2b d0	 sub	 rdx, rax
  003e5	49 8b c6	 mov	 rax, r14
  003e8	48 f7 ea	 imul	 rdx
  003eb	48 c1 fa 02	 sar	 rdx, 2
  003ef	48 8b c2	 mov	 rax, rdx
  003f2	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  003f6	48 03 d0	 add	 rdx, rax

; 1053 : 				_Reallocate(size());

  003f9	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  003fd	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@IEAAX_K@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::_Reallocate
$LN488@renderChun:
  00402	45 33 e4	 xor	 r12d, r12d
$LN239@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 275  : 	vertices.shrink_to_fit();

  00405	48 8b 7c 24 30	 mov	 rdi, QWORD PTR $T1[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 977  : 		return (this->_Myend != this->_Mylast);

  0040a	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0040e	48 39 57 18	 cmp	 QWORD PTR [rdi+24], rdx

; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())

  00412	74 44		 je	 SHORT $LN263@renderChun

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);

  00414	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00418	48 3b c2	 cmp	 rax, rdx

; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())

  0041b	75 1b		 jne	 SHORT $LN264@renderChun

; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)
; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)
; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));
; 1531 : 			}
; 1532 : 		}
; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())

  0041d	48 85 c0	 test	 rax, rax
  00420	74 36		 je	 SHORT $LN263@renderChun
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00422	48 8b c8	 mov	 rcx, rax
  00425	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  0042a	4c 89 67 08	 mov	 QWORD PTR [rdi+8], r12

; 1543 : 			this->_Mylast = pointer();

  0042e	4c 89 67 10	 mov	 QWORD PTR [rdi+16], r12

; 1544 : 			this->_Myend = pointer();

  00432	4c 89 67 18	 mov	 QWORD PTR [rdi+24], r12

; 1051 : 				_Tidy();
; 1052 : 			else

  00436	eb 20		 jmp	 SHORT $LN263@renderChun
$LN264@renderChun:

; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00438	48 2b d0	 sub	 rdx, rax
  0043b	49 8b c6	 mov	 rax, r14
  0043e	48 f7 ea	 imul	 rdx
  00441	48 c1 fa 02	 sar	 rdx, 2
  00445	48 8b c2	 mov	 rax, rdx
  00448	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0044c	48 03 d0	 add	 rdx, rax

; 1053 : 				_Reallocate(size());

  0044f	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]
  00453	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@IEAAX_K@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::_Reallocate
$LN263@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00458	4c 8b 75 67	 mov	 r14, QWORD PTR chunk$[rbp-201]
  0045c	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 43   : 		_Mtx_lockX(&_Mtx);

  0045f	48 83 c1 30	 add	 rcx, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00463	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00468	85 c0		 test	 eax, eax
  0046a	74 07		 je	 SHORT $LN293@renderChun

; 33   : 		_Throw_C_error(_Res);

  0046c	8b c8		 mov	 ecx, eax
  0046e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN293@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00473	4c 89 65 87	 mov	 QWORD PTR firstPassPtr$[rbp-201], r12
  00477	4c 89 65 8f	 mov	 QWORD PTR firstPassPtr$[rbp-193], r12

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  0047b	48 8b d3	 mov	 rdx, rbx
  0047e	48 8d 4d 87	 lea	 rcx, QWORD PTR firstPassPtr$[rbp-201]
  00482	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  00487	90		 npad	 1

; 282  : 		{	// construct

  00488	4c 89 64 24 40	 mov	 QWORD PTR secondPassPtr$[rsp], r12
  0048d	4c 89 64 24 48	 mov	 QWORD PTR secondPassPtr$[rsp+8], r12

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;
; 427  : 		_Ptr = _Other_ptr;
; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00492	48 8b d7	 mov	 rdx, rdi
  00495	48 8d 4c 24 40	 lea	 rcx, QWORD PTR secondPassPtr$[rsp]
  0049a	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  0049f	90		 npad	 1

; 335  : 		return (_Ptr);

  004a0	49 8b 16	 mov	 rdx, QWORD PTR [r14]

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  004a3	48 8b 4d 8f	 mov	 rcx, QWORD PTR firstPassPtr$[rbp-193]
  004a7	48 85 c9	 test	 rcx, rcx
  004aa	74 04		 je	 SHORT $LN327@renderChun

; 108  : 		_MT_INCR(_Ignored, _Uses);

  004ac	f0 ff 41 08	 lock inc DWORD PTR [rcx+8]
$LN327@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  004b0	48 8b 4a 40	 mov	 rcx, QWORD PTR [rdx+64]
  004b4	48 89 4d df	 mov	 QWORD PTR $T6[rbp-193], rcx

; 49   : 	_Right = _Move(_Tmp);

  004b8	48 8b 45 8f	 mov	 rax, QWORD PTR firstPassPtr$[rbp-193]
  004bc	48 89 42 40	 mov	 QWORD PTR [rdx+64], rax
  004c0	48 8b 45 87	 mov	 rax, QWORD PTR firstPassPtr$[rbp-201]
  004c4	48 89 42 38	 mov	 QWORD PTR [rdx+56], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  004c8	48 85 c9	 test	 rcx, rcx
  004cb	74 22		 je	 SHORT $LN481@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  004cd	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  004d1	75 1c		 jne	 SHORT $LN481@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  004d3	48 8b 5d df	 mov	 rbx, QWORD PTR $T6[rbp-193]
  004d7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004da	48 8b cb	 mov	 rcx, rbx
  004dd	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  004df	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  004e3	75 0a		 jne	 SHORT $LN481@renderChun

; 128  : 			_Delete_this();

  004e5	48 8b 4d df	 mov	 rcx, QWORD PTR $T6[rbp-193]
  004e9	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  004ec	ff 50 08	 call	 QWORD PTR [rax+8]
$LN481@renderChun:

; 335  : 		return (_Ptr);

  004ef	49 8b 16	 mov	 rdx, QWORD PTR [r14]

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  004f2	48 8b 5c 24 48	 mov	 rbx, QWORD PTR secondPassPtr$[rsp+8]
  004f7	48 85 db	 test	 rbx, rbx
  004fa	74 09		 je	 SHORT $LN384@renderChun

; 108  : 		_MT_INCR(_Ignored, _Uses);

  004fc	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
  00500	48 8b 5c 24 48	 mov	 rbx, QWORD PTR secondPassPtr$[rsp+8]
$LN384@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00505	48 8b 4a 50	 mov	 rcx, QWORD PTR [rdx+80]
  00509	48 89 4d cf	 mov	 QWORD PTR $T5[rbp-193], rcx

; 49   : 	_Right = _Move(_Tmp);

  0050d	48 89 5a 50	 mov	 QWORD PTR [rdx+80], rbx
  00511	48 8b 44 24 40	 mov	 rax, QWORD PTR secondPassPtr$[rsp]
  00516	48 89 42 48	 mov	 QWORD PTR [rdx+72], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0051a	48 85 c9	 test	 rcx, rcx
  0051d	74 27		 je	 SHORT $LN415@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0051f	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00523	75 1c		 jne	 SHORT $LN482@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00525	48 8b 5d cf	 mov	 rbx, QWORD PTR $T5[rbp-193]
  00529	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0052c	48 8b cb	 mov	 rcx, rbx
  0052f	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00531	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00535	75 0a		 jne	 SHORT $LN482@renderChun

; 128  : 			_Delete_this();

  00537	48 8b 4d cf	 mov	 rcx, QWORD PTR $T5[rbp-193]
  0053b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0053e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN482@renderChun:
  00541	48 8b 5c 24 48	 mov	 rbx, QWORD PTR secondPassPtr$[rsp+8]
$LN415@renderChun:

; 335  : 		return (_Ptr);

  00546	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  00549	48 83 c1 30	 add	 rcx, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0054d	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00552	85 c0		 test	 eax, eax
  00554	74 08		 je	 SHORT $LN426@renderChun

; 33   : 		_Throw_C_error(_Res);

  00556	8b c8		 mov	 ecx, eax
  00558	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0055d	90		 npad	 1
$LN426@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0055e	48 85 db	 test	 rbx, rbx
  00561	74 2f		 je	 SHORT $LN483@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00563	8b c6		 mov	 eax, esi
  00565	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  0056a	ff c8		 dec	 eax
  0056c	75 24		 jne	 SHORT $LN483@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0056e	48 8b 5c 24 48	 mov	 rbx, QWORD PTR secondPassPtr$[rsp+8]
  00573	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00576	48 8b cb	 mov	 rcx, rbx
  00579	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0057b	8b c6		 mov	 eax, esi
  0057d	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  00582	ff c8		 dec	 eax
  00584	75 0c		 jne	 SHORT $LN483@renderChun

; 128  : 			_Delete_this();

  00586	48 8b 4c 24 48	 mov	 rcx, QWORD PTR secondPassPtr$[rsp+8]
  0058b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0058e	ff 50 08	 call	 QWORD PTR [rax+8]
  00591	90		 npad	 1
$LN483@renderChun:

; 345  : 		if (_Rep != 0)

  00592	48 8b 4d 8f	 mov	 rcx, QWORD PTR firstPassPtr$[rbp-193]
  00596	48 85 c9	 test	 rcx, rcx
  00599	74 2d		 je	 SHORT $LN448@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0059b	8b c6		 mov	 eax, esi
  0059d	f0 0f c1 41 08	 lock xadd DWORD PTR [rcx+8], eax
  005a2	ff c8		 dec	 eax
  005a4	75 22		 jne	 SHORT $LN448@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  005a6	48 8b 5d 8f	 mov	 rbx, QWORD PTR firstPassPtr$[rbp-193]
  005aa	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  005ad	48 8b cb	 mov	 rcx, rbx
  005b0	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  005b2	8b c6		 mov	 eax, esi
  005b4	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  005b9	ff c8		 dec	 eax
  005bb	75 0b		 jne	 SHORT $LN448@renderChun

; 128  : 			_Delete_this();

  005bd	48 8b 4d 8f	 mov	 rcx, QWORD PTR firstPassPtr$[rbp-193]
  005c1	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  005c4	ff 50 08	 call	 QWORD PTR [rax+8]
  005c7	90		 npad	 1
$LN448@renderChun:

; 345  : 		if (_Rep != 0)

  005c8	49 8b 5e 08	 mov	 rbx, QWORD PTR [r14+8]
  005cc	48 85 db	 test	 rbx, rbx
  005cf	0f 84 b3 00 00
	00		 je	 $LN81@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  005d5	8b c6		 mov	 eax, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 74   : 	return true;

  005d7	e9 8c 00 00 00	 jmp	 $LN496@renderChun
$LN468@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  005dc	48 8b 4d b7	 mov	 rcx, QWORD PTR c$3[rbp-193]
  005e0	48 85 c9	 test	 rcx, rcx
  005e3	74 2d		 je	 SHORT $LN135@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  005e5	8b c6		 mov	 eax, esi
  005e7	f0 0f c1 41 08	 lock xadd DWORD PTR [rcx+8], eax
  005ec	ff c8		 dec	 eax
  005ee	75 22		 jne	 SHORT $LN135@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  005f0	48 8b 5d b7	 mov	 rbx, QWORD PTR c$3[rbp-193]
  005f4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  005f7	48 8b cb	 mov	 rcx, rbx
  005fa	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  005fc	8b c6		 mov	 eax, esi
  005fe	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  00603	ff c8		 dec	 eax
  00605	75 0b		 jne	 SHORT $LN135@renderChun

; 128  : 			_Delete_this();

  00607	48 8b 4d b7	 mov	 rcx, QWORD PTR c$3[rbp-193]
  0060b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0060e	ff 50 08	 call	 QWORD PTR [rax+8]
  00611	90		 npad	 1
$LN135@renderChun:

; 345  : 		if (_Rep != 0)

  00612	49 8b 5c 24 08	 mov	 rbx, QWORD PTR [r12+8]
  00617	48 85 db	 test	 rbx, rbx
  0061a	74 22		 je	 SHORT $LN146@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0061c	8b c6		 mov	 eax, esi
  0061e	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00623	ff c8		 dec	 eax
  00625	75 17		 jne	 SHORT $LN146@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00627	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0062a	48 8b cb	 mov	 rcx, rbx
  0062d	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0062f	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00633	75 09		 jne	 SHORT $LN146@renderChun

; 128  : 			_Delete_this();

  00635	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00638	48 8b cb	 mov	 rcx, rbx
  0063b	ff 50 08	 call	 QWORD PTR [rax+8]
$LN146@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 27   : 					return false;

  0063e	32 c0		 xor	 al, al
  00640	eb 48		 jmp	 SHORT $LN23@renderChun
$LN21@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  00642	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 53   : 		_Mtx_unlockX(&_Mtx);

  00646	48 83 c1 28	 add	 rcx, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0064a	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0064f	85 c0		 test	 eax, eax
  00651	74 08		 je	 SHORT $LN70@renderChun

; 33   : 		_Throw_C_error(_Res);

  00653	8b c8		 mov	 ecx, eax
  00655	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0065a	90		 npad	 1
$LN70@renderChun:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0065b	49 8b 5c 24 08	 mov	 rbx, QWORD PTR [r12+8]
  00660	48 85 db	 test	 rbx, rbx
  00663	74 23		 je	 SHORT $LN81@renderChun

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00665	83 c8 ff	 or	 eax, -1
$LN496@renderChun:
  00668	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  0066d	ff c8		 dec	 eax
  0066f	75 17		 jne	 SHORT $LN81@renderChun

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00671	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00674	48 8b cb	 mov	 rcx, rbx
  00677	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00679	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0067d	75 09		 jne	 SHORT $LN81@renderChun

; 128  : 			_Delete_this();

  0067f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00682	48 8b cb	 mov	 rcx, rbx
  00685	ff 50 08	 call	 QWORD PTR [rax+8]
$LN81@renderChun:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 13   : 		return true;

  00688	b0 01		 mov	 al, 1
$LN23@renderChun:

; 75   : }

  0068a	0f 28 b4 24 d0
	00 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+208]
  00692	0f 28 bc 24 c0
	00 00 00	 movaps	 xmm7, XMMWORD PTR [rsp+192]
  0069a	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  006a1	41 5f		 pop	 r15
  006a3	41 5e		 pop	 r14
  006a5	41 5d		 pop	 r13
  006a7	41 5c		 pop	 r12
  006a9	5f		 pop	 rdi
  006aa	5e		 pop	 rsi
  006ab	5b		 pop	 rbx
  006ac	5d		 pop	 rbp
  006ad	c3		 ret	 0
?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; renderChunk
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
chunk$2 = 96
cx$1$ = 112
c$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$0@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$0
  00000	48 8b 8a 30 01
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
chunk$2 = 96
cx$1$ = 112
c$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$1@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$1
  0000c	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR c$3[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$1@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
chunk$2 = 96
cx$1$ = 112
c$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$2@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$2
  00018	48 8b 8a 40 01
	00 00		 mov	 rcx, QWORD PTR $T9[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$2@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
chunk$2 = 96
cx$1$ = 112
c$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$3@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$3
  00024	48 8b 8a 40 01
	00 00		 mov	 rcx, QWORD PTR $T8[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$3@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
chunk$2 = 96
cx$1$ = 112
c$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$6@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$6
  00030	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR chunk$2[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$6@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
chunk$2 = 96
cx$1$ = 112
c$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$4@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$4
  0003c	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR firstPassPtr$[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
?dtor$4@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
cy$1$ = 56
secondPassPtr$ = 64
firstPassPtr$ = 80
chunk$2 = 96
cx$1$ = 112
c$3 = 120
$T4 = 136
$T5 = 144
$T6 = 160
$T7 = 176
chunk$ = 304
cz$1$ = 312
j$1$ = 320
$T8 = 320
$T9 = 320
i$1$ = 328
?dtor$5@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `renderChunk'::`1'::dtor$5
  00048	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR secondPassPtr$[rdx]
  0004f	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
?dtor$5@?0??renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `renderChunk'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 40
chunk$2 = 56
$T3 = 72
q$ = 128
?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z PROC ; renderFirstPossible, COMDAT

; 78   : {

$LN184:
  00000	48 8b c4	 mov	 rax, rsp
  00003	41 54		 push	 r12
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  0000d	48 c7 40 a8 fe
	ff ff ff	 mov	 QWORD PTR [rax-88], -2
  00015	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00019	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0001d	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  00021	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00025	48 8b f9	 mov	 rdi, rcx

; 79   : 	for(unsigned int i = 0; !GlobalThread::stop && (i < q.size()); i++)

  00028	45 33 e4	 xor	 r12d, r12d
  0002b	45 8b fc	 mov	 r15d, r12d
  0002e	44 38 25 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, r12b ; GlobalThread::stop
  00035	0f 85 f4 01 00
	00		 jne	 $LN3@renderFirs
  0003b	83 cd ff	 or	 ebp, -1
  0003e	66 90		 npad	 2
$LL5@renderFirs:
  00040	41 8b c7	 mov	 eax, r15d
  00043	48 3b 47 20	 cmp	 rax, QWORD PTR [rdi+32]
  00047	0f 83 e2 01 00
	00		 jae	 $LN3@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  0004d	48 8d 54 24 48	 lea	 rdx, QWORD PTR $T3[rsp]
  00052	48 8b cf	 mov	 rcx, rdi
  00055	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  0005a	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0005d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00060	48 85 c0	 test	 rax, rax
  00063	75 05		 jne	 SHORT $LN24@renderFirs
  00065	49 8b c4	 mov	 rax, r12
  00068	eb 03		 jmp	 SHORT $LN25@renderFirs
$LN24@renderFirs:
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN25@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0006d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00071	48 ff c9	 dec	 rcx
  00074	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  00078	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007c	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00080	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00084	4c 8b 31	 mov	 r14, QWORD PTR [rcx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00087	48 85 db	 test	 rbx, rbx
  0008a	74 04		 je	 SHORT $LN45@renderFirs

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0008c	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN45@renderFirs:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00090	48 89 5c 24 40	 mov	 QWORD PTR chunk$2[rsp+8], rbx

; 427  : 		_Ptr = _Other_ptr;

  00095	4c 89 74 24 38	 mov	 QWORD PTR chunk$2[rsp], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  0009a	48 83 7f 20 00	 cmp	 QWORD PTR [rdi+32], 0

; 1427 : 		}
; 1428 : 
; 1429 : 	const_reference front() const
; 1430 : 		{	// return first element of nonmutable sequence
; 1431 : 		return (*begin());
; 1432 : 		}
; 1433 : 
; 1434 : 	reference back()
; 1435 : 		{	// return last element of mutable sequence
; 1436 : 		return (*(end() - 1));
; 1437 : 		}
; 1438 : 
; 1439 : 	const_reference back() const
; 1440 : 		{	// return last element of nonmutable sequence
; 1441 : 		return (*(end() - 1));
; 1442 : 		}
; 1443 : 
; 1444 : 	void push_front(const value_type& _Val)
; 1445 : 		{	// insert element at beginning
; 1446 : 		this->_Orphan_all();
; 1447 : 		_PUSH_FRONT_BEGIN;
; 1448 : 		this->_Getal().construct(
; 1449 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ, _Val);
; 1450 : 		_PUSH_FRONT_END;
; 1451 : 		}
; 1452 : 
; 1453 : 	void pop_front()
; 1454 : 		{	// erase element at beginning
; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())

  0009f	74 49		 je	 SHORT $LN50@renderFirs

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  000a1	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  000a5	48 ff c9	 dec	 rcx
  000a8	48 23 4f 18	 and	 rcx, QWORD PTR [rdi+24]

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  000ac	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  000b0	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000b4	48 8b 71 08	 mov	 rsi, QWORD PTR [rcx+8]
  000b8	48 85 f6	 test	 rsi, rsi
  000bb	74 1d		 je	 SHORT $LN78@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000bd	f0 ff 4e 08	 lock dec DWORD PTR [rsi+8]
  000c1	75 17		 jne	 SHORT $LN78@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000c3	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000c6	48 8b ce	 mov	 rcx, rsi
  000c9	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000cb	f0 ff 4e 0c	 lock dec DWORD PTR [rsi+12]
  000cf	75 09		 jne	 SHORT $LN78@renderFirs

; 128  : 			_Delete_this();

  000d1	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000d4	48 8b ce	 mov	 rcx, rsi
  000d7	ff 50 08	 call	 QWORD PTR [rax+8]
$LN78@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1476 : 			if (--this->_Mysize == 0)

  000da	48 ff 4f 20	 dec	 QWORD PTR [rdi+32]
  000de	75 06		 jne	 SHORT $LN51@renderFirs

; 1477 : 				this->_Myoff = 0;

  000e0	4c 89 67 18	 mov	 QWORD PTR [rdi+24], r12

; 1478 : 			else

  000e4	eb 04		 jmp	 SHORT $LN50@renderFirs
$LN51@renderFirs:

; 1479 : 				++this->_Myoff;

  000e6	48 ff 47 18	 inc	 QWORD PTR [rdi+24]
$LN50@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  000ea	4c 89 64 24 28	 mov	 QWORD PTR $T1[rsp], r12
  000ef	4c 89 64 24 30	 mov	 QWORD PTR $T1[rsp+8], r12

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  000f4	48 85 db	 test	 rbx, rbx
  000f7	74 2b		 je	 SHORT $LN98@renderFirs

; 108  : 		_MT_INCR(_Ignored, _Uses);

  000f9	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  000fd	48 8b 74 24 30	 mov	 rsi, QWORD PTR $T1[rsp+8]
  00102	48 85 f6	 test	 rsi, rsi
  00105	74 1d		 je	 SHORT $LN98@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00107	f0 ff 4e 08	 lock dec DWORD PTR [rsi+8]
  0010b	75 17		 jne	 SHORT $LN98@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0010d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00110	48 8b ce	 mov	 rcx, rsi
  00113	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00115	f0 ff 4e 0c	 lock dec DWORD PTR [rsi+12]
  00119	75 09		 jne	 SHORT $LN98@renderFirs

; 128  : 			_Delete_this();

  0011b	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0011e	48 8b ce	 mov	 rcx, rsi
  00121	ff 50 08	 call	 QWORD PTR [rax+8]
$LN98@renderFirs:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00124	48 89 5c 24 30	 mov	 QWORD PTR $T1[rsp+8], rbx

; 427  : 		_Ptr = _Other_ptr;

  00129	4c 89 74 24 28	 mov	 QWORD PTR $T1[rsp], r14
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 83   : 		if(renderChunk(chunk))

  0012e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  00133	e8 00 00 00 00	 call	 ?renderChunk@@YA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; renderChunk
  00138	84 c0		 test	 al, al
  0013a	0f 85 c4 00 00
	00		 jne	 $LN178@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00140	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]
  00144	48 ff c0	 inc	 rax
  00147	48 39 47 10	 cmp	 QWORD PTR [rdi+16], rax
  0014b	77 08		 ja	 SHORT $LN115@renderFirs
  0014d	48 8b cf	 mov	 rcx, rdi
  00150	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
$LN115@renderFirs:
  00155	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00159	49 ff c8	 dec	 r8
  0015c	4c 21 47 18	 and	 QWORD PTR [rdi+24], r8
  00160	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00164	48 03 57 20	 add	 rdx, QWORD PTR [rdi+32]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00168	4c 23 c2	 and	 r8, rdx

; 1487 : 		_PUSH_BACK_BEGIN;

  0016b	4a 8d 34 c5 00
	00 00 00	 lea	 rsi, QWORD PTR [r8*8]
  00173	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00177	48 83 3c 06 00	 cmp	 QWORD PTR [rsi+rax], 0
  0017c	75 17		 jne	 SHORT $LN114@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0017e	b9 10 00 00 00	 mov	 ecx, 16
  00183	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00188	48 85 c0	 test	 rax, rax
  0018b	74 71		 je	 SHORT $LN179@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  0018d	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  00191	48 89 04 0e	 mov	 QWORD PTR [rsi+rcx], rax
$LN114@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00195	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00199	48 8b 0c 06	 mov	 rcx, QWORD PTR [rsi+rax]
  0019d	48 85 c9	 test	 rcx, rcx
  001a0	74 1b		 je	 SHORT $LN149@renderFirs
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  001a2	4c 89 21	 mov	 QWORD PTR [rcx], r12
  001a5	4c 89 61 08	 mov	 QWORD PTR [rcx+8], r12

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  001a9	48 85 db	 test	 rbx, rbx
  001ac	74 04		 je	 SHORT $LN162@renderFirs

; 108  : 		_MT_INCR(_Ignored, _Uses);

  001ae	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN162@renderFirs:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  001b2	4c 8b c3	 mov	 r8, rbx
  001b5	49 8b d6	 mov	 rdx, r14
  001b8	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN149@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  001bd	48 ff 47 20	 inc	 QWORD PTR [rdi+32]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  001c1	48 85 db	 test	 rbx, rbx
  001c4	74 27		 je	 SHORT $LN4@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  001c6	8b c5		 mov	 eax, ebp
  001c8	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  001cd	ff c8		 dec	 eax
  001cf	75 1c		 jne	 SHORT $LN4@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  001d1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001d4	48 8b cb	 mov	 rcx, rbx
  001d7	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  001d9	8b c5		 mov	 eax, ebp
  001db	f0 0f c1 43 0c	 lock xadd DWORD PTR [rbx+12], eax
  001e0	ff c8		 dec	 eax
  001e2	75 09		 jne	 SHORT $LN4@renderFirs

; 128  : 			_Delete_this();

  001e4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  001e7	48 8b cb	 mov	 rcx, rbx
  001ea	ff 50 08	 call	 QWORD PTR [rax+8]
$LN4@renderFirs:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 79   : 	for(unsigned int i = 0; !GlobalThread::stop && (i < q.size()); i++)

  001ed	41 ff c7	 inc	 r15d
  001f0	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
  001f7	75 36		 jne	 SHORT $LN3@renderFirs
  001f9	e9 42 fe ff ff	 jmp	 $LL5@renderFirs
$LN179@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  001fe	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00203	90		 npad	 1
$LN178@renderFirs:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00204	48 85 db	 test	 rbx, rbx
  00207	74 22		 je	 SHORT $LN109@renderFirs

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00209	8b c5		 mov	 eax, ebp
  0020b	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00210	ff c8		 dec	 eax
  00212	75 17		 jne	 SHORT $LN109@renderFirs

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00214	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00217	48 8b cb	 mov	 rcx, rbx
  0021a	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0021c	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00220	75 09		 jne	 SHORT $LN109@renderFirs

; 128  : 			_Delete_this();

  00222	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00225	48 8b cb	 mov	 rcx, rbx
  00228	ff 50 08	 call	 QWORD PTR [rax+8]
$LN109@renderFirs:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 85   : 			return true;

  0022b	b0 01		 mov	 al, 1
  0022d	eb 02		 jmp	 SHORT $LN6@renderFirs
$LN3@renderFirs:

; 86   : 		}
; 87   : 		else
; 88   : 		{
; 89   : 			q.push(chunk);
; 90   : 		}
; 91   : 	}
; 92   : 	return false;

  0022f	32 c0		 xor	 al, al
$LN6@renderFirs:

; 93   : }

  00231	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  00236	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  0023a	49 8b 6b 28	 mov	 rbp, QWORD PTR [r11+40]
  0023e	49 8b 73 30	 mov	 rsi, QWORD PTR [r11+48]
  00242	49 8b 7b 38	 mov	 rdi, QWORD PTR [r11+56]
  00246	49 8b e3	 mov	 rsp, r11
  00249	41 5f		 pop	 r15
  0024b	41 5e		 pop	 r14
  0024d	41 5c		 pop	 r12
  0024f	c3		 ret	 0
$LN183@renderFirs:
?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ENDP ; renderFirstPossible
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
chunk$2 = 56
$T3 = 72
q$ = 128
?dtor$0@?0??renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z@4HA PROC ; `renderFirstPossible'::`1'::dtor$0
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR chunk$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z@4HA ENDP ; `renderFirstPossible'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?staticInit@ChunkDrawThread@@SAXXZ
_TEXT	SEGMENT
?staticInit@ChunkDrawThread@@SAXXZ PROC			; ChunkDrawThread::staticInit, COMDAT

; 97   : 
; 98   : }

  00000	c2 00 00	 ret	 0
?staticInit@ChunkDrawThread@@SAXXZ ENDP			; ChunkDrawThread::staticInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?tick@ChunkDrawThread@@MEAA_NXZ
_TEXT	SEGMENT
this$ = 48
?tick@ChunkDrawThread@@MEAA_NXZ PROC			; ChunkDrawThread::tick, COMDAT

; 101  : {

$LN21:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0000d	48 81 c1 b0 08
	00 00		 add	 rcx, 2224		; 000008b0H
  00014	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00019	85 c0		 test	 eax, eax
  0001b	74 07		 je	 SHORT $LN9@tick

; 33   : 		_Throw_C_error(_Res);

  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN9@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 103  : 	bool rendered = renderFirstPossible(ChunkDrawThread::drawFirstQueue) || renderFirstPossible(ChunkDrawThread::drawQueue) || renderFirstPossible(ChunkDrawThread::drawLaterQueue);

  00024	48 8d 8b 38 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2104]
  0002b	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
  00030	84 c0		 test	 al, al
  00032	75 1c		 jne	 SHORT $LN3@tick
  00034	48 8d 8b 60 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2144]
  0003b	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
  00040	84 c0		 test	 al, al
  00042	75 0c		 jne	 SHORT $LN3@tick
  00044	48 8d 8b 88 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2184]
  0004b	e8 00 00 00 00	 call	 ?renderFirstPossible@@YA_NAEAV?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@@Z ; renderFirstPossible
$LN3@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00050	48 8d 8b b0 08
	00 00		 lea	 rcx, QWORD PTR [rbx+2224]
  00057	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN19@tick

; 33   : 		_Throw_C_error(_Res);

  00060	8b c8		 mov	 ecx, eax
  00062	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN19@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 106  : 	return true;

  00067	b0 01		 mov	 al, 1

; 107  : }

  00069	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
?tick@ChunkDrawThread@@MEAA_NXZ ENDP			; ChunkDrawThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestQuickChunkDraw, COMDAT

; 110  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 111  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?drawerThread@@3HA ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestQui

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestQui:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 38 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2104
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestQui

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestQui:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestQui

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestQui

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestQui

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestQui:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 116  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestQuickChunkDraw
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestQuickChunkDraw'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestQuickChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestQuickChunkDraw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestChunkDraw, COMDAT

; 119  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 120  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?drawerThread@@3HA ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestChu

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 60 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2144
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestChu

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestChu:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestChu

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestChu

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestChu

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestChu:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 125  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestChunkDraw
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestChunkDraw'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestChunkDraw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp
;	COMDAT ?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
chunk$ = 64
?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z PROC ; requestLateChunkDraw, COMDAT

; 128  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b d9	 mov	 rbx, rcx

; 129  : 	ChunkDrawThread* thread = &chunkDrawThreads[(drawerThread++) % DRAW_THREAD_AMOUNT];

  0001b	ff 05 00 00 00
	00		 inc	 DWORD PTR ?drawerThread@@3HA ; drawerThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00021	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  00028	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0002d	85 c0		 test	 eax, eax
  0002f	74 07		 je	 SHORT $LN8@requestLat

; 33   : 		_Throw_C_error(_Res);

  00031	8b c8		 mov	 ecx, eax
  00033	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN8@requestLat:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00038	48 8b d3	 mov	 rdx, rbx
  0003b	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2184
  00042	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00047	48 8d 0d b0 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2224
  0004e	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN17@requestLat

; 33   : 		_Throw_C_error(_Res);

  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0005e	90		 npad	 1
$LN17@requestLat:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0005f	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
  00063	48 85 db	 test	 rbx, rbx
  00066	74 1d		 je	 SHORT $LN28@requestLat

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00068	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0006c	75 17		 jne	 SHORT $LN28@requestLat

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00071	48 8b cb	 mov	 rcx, rbx
  00074	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00076	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0007a	75 09		 jne	 SHORT $LN28@requestLat

; 128  : 			_Delete_this();

  0007c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007f	48 8b cb	 mov	 rcx, rbx
  00082	ff 50 08	 call	 QWORD PTR [rax+8]
$LN28@requestLat:
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkdrawthread.cpp

; 134  : }

  00085	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0008a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
?requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z ENDP ; requestLateChunkDraw
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
chunk$ = 64
?dtor$0@?0??requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA PROC ; `requestLateChunkDraw'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR chunk$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??requestLateChunkDraw@@YAXV?$shared_ptr@VChunkBase@@@std@@@Z@4HA ENDP ; `requestLateChunkDraw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ PROC	; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>, COMDAT

; 622  : 		{	// release resource

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN9@shared_ptr

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN12@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN12@shared_ptr

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN12@shared_ptr:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN9@shared_ptr:

; 623  : 		this->_Decref();
; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ENDP	; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::operator=, COMDAT

; 627  : 		{	// assign shared ownership of resource owned by _Right

$LN59:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00006	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0000a	4c 8b 02	 mov	 r8, QWORD PTR [rdx]

; 627  : 		{	// assign shared ownership of resource owned by _Right

  0000d	48 8b f9	 mov	 rdi, rcx

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00010	48 85 c0	 test	 rax, rax
  00013	74 04		 je	 SHORT $LN20@operator

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00015	f0 ff 40 08	 lock inc DWORD PTR [rax+8]
$LN20@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00019	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]

; 49   : 	_Right = _Move(_Tmp);

  0001d	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
  00021	4c 89 07	 mov	 QWORD PTR [rdi], r8

; 48   : 	_Left = _Move(_Right);

  00024	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp+8], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00029	48 85 c9	 test	 rcx, rcx
  0002c	74 41		 je	 SHORT $LN56@operator

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0002e	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00032	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00037	75 28		 jne	 SHORT $LN55@operator
  00039	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003e	48 8b 5c 24 28	 mov	 rbx, QWORD PTR $T1[rsp+8]
  00043	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0004b	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004f	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00054	75 0b		 jne	 SHORT $LN55@operator

; 128  : 			_Delete_this();

  00056	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp+8]
  0005b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0005e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN55@operator:

; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);

  00061	48 8b c7	 mov	 rax, rdi
  00064	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 630  : 		}

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN56@operator:

; 628  : 		shared_ptr(_Right).swap(*this);
; 629  : 		return (*this);

  0006f	48 8b c7	 mov	 rax, rdi

; 630  : 		}

  00072	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
??4?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_KXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size, COMDAT

; 130  : 		return (c.size());

  00000	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]

; 131  : 		}

  00004	c3		 ret	 0
?size@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEBA_KXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 80
?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front, COMDAT

; 134  : 		{	// return first element of mutable queue

$LN16:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  00004	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  0000e	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00011	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00014	48 85 c0	 test	 rax, rax
  00017	74 03		 je	 SHORT $LN12@front
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN12@front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 135  : 		return (c.front());

  00020	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00024	48 ff c9	 dec	 rcx
  00027	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 135  : 		return (c.front());

  0002b	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 136  : 		}

  0002f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00033	c3		 ret	 0
?front@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push, COMDAT

; 155  : 		c.push_back(_Val);

  00000	e9 00 00 00 00	 jmp	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
?push@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
;	COMDAT ?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXXZ PROC ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop, COMDAT

; 160  : 		c.pop_front();

  00000	e9 00 00 00 00	 jmp	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
?pop@?$queue@V?$shared_ptr@VChunkBase@@@std@@V?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@2@@std@@QEAAXXZ ENDP ; std::queue<std::shared_ptr<ChunkBase>,std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z PROC	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00008	48 8b d9	 mov	 rbx, rcx

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00012	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00016	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00019	4d 85 c0	 test	 r8, r8
  0001c	74 05		 je	 SHORT $LN10@shared_ptr

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0001e	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN10@shared_ptr:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00023	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0

; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}

  00028	48 8b c3	 mov	 rax, rbx
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
??0?$shared_ptr@VChunkBase@@@std@@QEAA@AEBV01@@Z ENDP	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ PROC		; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>, COMDAT

; 622  : 		{	// release resource

$LN14:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN9@shared_ptr

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN12@shared_ptr

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN12@shared_ptr

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN12@shared_ptr:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN9@shared_ptr:

; 623  : 		this->_Decref();
; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ENDP		; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??C?$shared_ptr@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$shared_ptr@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ PROC ; std::shared_ptr<ChunkBase>::operator->, COMDAT

; 691  : 		return (this->_Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 692  : 		}

  00003	c3		 ret	 0
??C?$shared_ptr@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ ENDP ; std::shared_ptr<ChunkBase>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??B?$shared_ptr@VChunkBase@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VChunkBase@@@std@@@1@HXZ
_TEXT	SEGMENT
this$ = 8
??B?$shared_ptr@VChunkBase@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VChunkBase@@@std@@@1@HXZ PROC ; std::shared_ptr<ChunkBase>::operator int std::_Bool_struct<std::shared_ptr<ChunkBase> >::* __ptr64, COMDAT

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 f7 d8	 neg	 rax
  00006	1b c0		 sbb	 eax, eax
  00008	f7 d8		 neg	 eax
  0000a	ff c8		 dec	 eax

; 704  : 		}

  0000c	c3		 ret	 0
??B?$shared_ptr@VChunkBase@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VChunkBase@@@std@@@1@HXZ ENDP ; std::shared_ptr<ChunkBase>::operator int std::_Bool_struct<std::shared_ptr<ChunkBase> >::* __ptr64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>, COMDAT

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 534  : 	shared_ptr(const _Myt& _Other) _NOEXCEPT

  00008	48 8b d9	 mov	 rbx, rcx

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)
; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();
; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)
; 128  : 			_Delete_this();
; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00012	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00016	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00019	4d 85 c0	 test	 r8, r8
  0001c	74 05		 je	 SHORT $LN10@shared_ptr

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0001e	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN10@shared_ptr:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00023	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0

; 535  : 		{	// construct shared_ptr object that owns same resource as _Other
; 536  : 		this->_Reset(_Other);
; 537  : 		}

  00028	48 8b c3	 mov	 rax, rbx
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5b		 pop	 rbx
  00030	c3		 ret	 0
??0?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@AEBV01@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 677  : 		}

  0001c	c3		 ret	 0
?swap@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ PROC ; std::_Ptr_base<gfxu::VertexStream>::_Decref, COMDAT

; 344  : 		{	// decrement reference count

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN7@Decref

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN10@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN10@Decref

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Decref:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN7@Decref:

; 346  : 			_Rep->_Decref();
; 347  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
?_Decref@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXXZ ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size, COMDAT

; 1372 : 		return (this->_Mysize);

  00000	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]

; 1373 : 		}

  00004	c3		 ret	 0
?size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 80
?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front, COMDAT

; 1425 : 		{	// return first element of mutable sequence

$LN14:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1426 : 		return (*begin());

  00004	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T1[rsp]
  00009	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  0000e	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00011	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00014	48 85 c0	 test	 rax, rax
  00017	74 03		 je	 SHORT $LN10@front
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN10@front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001c	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 1426 : 		return (*begin());

  00020	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00024	48 ff c9	 dec	 rcx
  00027	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  0002b	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 1427 : 		}

  0002f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00033	c3		 ret	 0
?front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@2@XZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front, COMDAT

; 1454 : 		{	// erase element at beginning

$LN34:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 788  : 		}
; 789  : 
; 790  : 	_Mapptr _Map;		// pointer to array of pointers to blocks
; 791  : 	size_type _Mapsize;	// size of map array, zero or 2^N
; 792  : 	size_type _Myoff;	// offset of initial element
; 793  : 	size_type _Mysize;	// current length of sequence
; 794  : 	};
; 795  : 
; 796  : 		// TEMPLATE CLASS _Deque_alloc
; 797  : template<bool _Al_has_storage,
; 798  : 	class _Alloc_types>
; 799  : 	class _Deque_alloc
; 800  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 801  : 	{	// base class for deque to hold allocator with storage
; 802  : public:
; 803  : 	typedef _Deque_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 804  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 805  : 	typedef typename _Alloc_types::_Alty _Alty;
; 806  : 
; 807  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 808  : 
; 809  : 	_Deque_alloc(const _Alloc& _Al = _Alloc())
; 810  : 		: _Alval(_Al)
; 811  : 		{	// construct allocators from _Al
; 812  : 		_Alloc_proxy();
; 813  : 		}
; 814  : 
; 815  : 	~_Deque_alloc() _NOEXCEPT
; 816  : 		{	// destroy proxy
; 817  : 		_Free_proxy();
; 818  : 		}
; 819  : 
; 820  : 	void _Change_alloc(const _Alty& _Al)
; 821  : 		{	// replace old allocator
; 822  : 		_Free_proxy();
; 823  : 		_Alval = _Al;
; 824  : 		_Alloc_proxy();
; 825  : 		}
; 826  : 
; 827  : 	void _Swap_alloc(_Myt& _Right)
; 828  : 		{	// swap allocators
; 829  : 		_Swap_adl(_Alval, _Right._Alval);
; 830  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 831  : 		}
; 832  : 
; 833  : 	void _Alloc_proxy()
; 834  : 		{	// construct proxy from _Alval
; 835  : 		typename _Alty::template rebind<_Container_proxy>::other
; 836  : 			_Alproxy(_Alval);
; 837  : 		this->_Myproxy = _Alproxy.allocate(1);
; 838  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 839  : 		this->_Myproxy->_Mycont = this;
; 840  : 		}
; 841  : 
; 842  : 	void _Free_proxy()
; 843  : 		{	// destroy proxy
; 844  : 		typename _Alty::template rebind<_Container_proxy>::other
; 845  : 			_Alproxy(_Alval);
; 846  : 		this->_Orphan_all();
; 847  : 		_Alproxy.destroy(this->_Myproxy);
; 848  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 849  : 		this->_Myproxy = 0;
; 850  : 		}
; 851  : 
; 852  : 	_Alty& _Getal()
; 853  : 		{	// get reference to allocator
; 854  : 		return (_Alval);
; 855  : 		}
; 856  : 
; 857  : 	const _Alty& _Getal() const
; 858  : 		{	// get reference to allocator
; 859  : 		return (_Alval);
; 860  : 		}
; 861  : 
; 862  : 	_Alty _Alval;	// allocator object for stored elements
; 863  : 	};
; 864  : 
; 865  : template<class _Alloc_types>
; 866  : 	class _Deque_alloc<false, _Alloc_types>
; 867  : 		: public _Deque_val<typename _Alloc_types::_Val_types>
; 868  : 	{	// base class for deque to hold allocator with no storage
; 869  : public:
; 870  : 	typedef _Deque_alloc<false, _Alloc_types> _Myt;
; 871  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 872  : 
; 873  : 	typedef typename _Alloc_types::_Alty _Alty;
; 874  : 
; 875  : 	typedef typename _Alloc_types::_Alpty _Alpty;
; 876  : 
; 877  : 	_Deque_alloc(const _Alloc& = _Alloc())
; 878  : 		{	// construct allocators from _Al
; 879  : 		_Alloc_proxy();
; 880  : 		}
; 881  : 
; 882  : 	~_Deque_alloc() _NOEXCEPT
; 883  : 		{	// destroy proxy
; 884  : 		_Free_proxy();
; 885  : 		}
; 886  : 
; 887  : 	void _Change_alloc(const _Alty&)
; 888  : 		{	// replace old allocator
; 889  : 		}
; 890  : 
; 891  : 	void _Swap_alloc(_Myt& _Right)
; 892  : 		{	// swap allocators
; 893  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 894  : 		}
; 895  : 
; 896  : 	void _Alloc_proxy()
; 897  : 		{	// construct proxy from _Alval
; 898  : 		typename _Alty::template rebind<_Container_proxy>::other
; 899  : 			_Alproxy;
; 900  : 		this->_Myproxy = _Alproxy.allocate(1);
; 901  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 902  : 		this->_Myproxy->_Mycont = this;
; 903  : 		}
; 904  : 
; 905  : 	void _Free_proxy()
; 906  : 		{	// destroy proxy
; 907  : 		typename _Alty::template rebind<_Container_proxy>::other
; 908  : 			_Alproxy;
; 909  : 		this->_Orphan_all();
; 910  : 		_Alproxy.destroy(this->_Myproxy);
; 911  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 912  : 		this->_Myproxy = 0;
; 913  : 		}
; 914  : 
; 915  : 	_Alty _Getal() const
; 916  : 		{	// get reference to allocator
; 917  : 		return (_Alty());
; 918  : 		}
; 919  : 	};
; 920  : 
; 921  : 		// TEMPLATE CLASS deque
; 922  : template<class _Ty,
; 923  : 	class _Alloc = allocator<_Ty> >
; 924  : 	class deque
; 925  : 		: public _Deque_alloc<!is_empty<_Alloc>::value,
; 926  : 			_Deque_base_types<_Ty, _Alloc> >
; 927  : 	{	// circular queue of pointers to blocks
; 928  : public:
; 929  : 	typedef deque<_Ty, _Alloc> _Myt;
; 930  : 	typedef _Deque_alloc<!is_empty<_Alloc>::value,
; 931  : 		_Deque_base_types<_Ty, _Alloc> > _Mybase;
; 932  : 	typedef _Alloc allocator_type;
; 933  : 
; 934  : 	typedef typename _Mybase::_Alty _Alty;
; 935  : 	typedef typename _Mybase::_Alpty _Alpty;
; 936  : 	typedef typename _Mybase::_Mapptr _Mapptr;
; 937  : 
; 938  : 	typedef typename _Mybase::value_type value_type;
; 939  : 	typedef typename _Mybase::size_type size_type;
; 940  : 	typedef typename _Mybase::difference_type difference_type;
; 941  : 	typedef typename _Mybase::pointer pointer;
; 942  : 	typedef typename _Mybase::const_pointer const_pointer;
; 943  : 	typedef typename _Mybase::reference reference;
; 944  : 	typedef typename _Mybase::const_reference const_reference;
; 945  : 
; 946  : 	typedef typename _Mybase::iterator iterator;
; 947  : 	typedef typename _Mybase::const_iterator const_iterator;
; 948  : 
; 949  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 950  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 951  : 
; 952  : 	static const int _EEM_DS = _DEQUESIZ;
; 953  : 	enum {_EEN_DS = _DEQUESIZ};	// helper for expression evaluator
; 954  : 	deque()
; 955  : 		: _Mybase()
; 956  : 		{	// construct empty deque
; 957  : 		}
; 958  : 
; 959  : 	explicit deque(const _Alloc& _Al)
; 960  : 		: _Mybase(_Al)
; 961  : 		{	// construct empty deque with allocator
; 962  : 		}
; 963  : 
; 964  : 	explicit deque(size_type _Count)
; 965  : 		: _Mybase()
; 966  : 		{	// construct from _Count * value_type()
; 967  : 		resize(_Count);
; 968  : 		}
; 969  : 
; 970  : 	deque(size_type _Count, const value_type& _Val)
; 971  : 		: _Mybase()
; 972  : 		{	// construct from _Count * _Val
; 973  : 		_Construct_n(_Count, _Val);
; 974  : 		}
; 975  : 
; 976  : 	deque(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 977  : 		: _Mybase(_Al)
; 978  : 		{	// construct from _Count * _Val with allocator
; 979  : 		_Construct_n(_Count, _Val);
; 980  : 		}
; 981  : 
; 982  : 	deque(const _Myt& _Right)
; 983  : 
; 984  :  #if _HAS_CPP0X
; 985  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 986  : 
; 987  :  #else /* _HAS_CPP0X */
; 988  : 		: _Mybase(_Right._Getal())
; 989  :  #endif /* _HAS_CPP0X */
; 990  : 
; 991  : 		{	// construct by copying _Right
; 992  : 		_TRY_BEGIN
; 993  : 		insert(begin(), _Right.begin(), _Right.end());
; 994  : 		_CATCH_ALL
; 995  : 		_Tidy();
; 996  : 		_RERAISE;
; 997  : 		_CATCH_END
; 998  : 		}
; 999  : 
; 1000 : 	deque(const _Myt& _Right, const _Alloc& _Al)
; 1001 : 		: _Mybase(_Al)
; 1002 : 		{	// construct by copying _Right
; 1003 : 		_TRY_BEGIN
; 1004 : 		insert(begin(), _Right.begin(), _Right.end());
; 1005 : 		_CATCH_ALL
; 1006 : 		_Tidy();
; 1007 : 		_RERAISE;
; 1008 : 		_CATCH_END
; 1009 : 		}
; 1010 : 
; 1011 : 	template<class _Iter>
; 1012 : 		deque(_Iter _First, _Iter _Last,
; 1013 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1014 : 				void>::type ** = 0)
; 1015 : 		: _Mybase()
; 1016 : 		{	// construct from [_First, _Last)
; 1017 : 		_Construct(_First, _Last);
; 1018 : 		}
; 1019 : 
; 1020 : 	template<class _Iter>
; 1021 : 		deque(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 1022 : 			typename enable_if<_Is_iterator<_Iter>::value,
; 1023 : 				void>::type ** = 0)
; 1024 : 		: _Mybase(_Al)
; 1025 : 		{	// construct from [_First, _Last) with allocator
; 1026 : 		_Construct(_First, _Last);
; 1027 : 		}
; 1028 : 
; 1029 : 	template<class _Iter>
; 1030 : 		void _Construct(_Iter _First, _Iter _Last)
; 1031 : 		{	// initialize from [_First, _Last), input iterators
; 1032 : 		_TRY_BEGIN
; 1033 : 		insert(begin(), _First, _Last);
; 1034 : 		_CATCH_ALL
; 1035 : 		_Tidy();
; 1036 : 		_RERAISE;
; 1037 : 		_CATCH_END
; 1038 : 		}
; 1039 : 
; 1040 : 	void _Construct_n(size_type _Count, const value_type& _Val)
; 1041 : 		{	// construct from _Count * _Val
; 1042 : 		_TRY_BEGIN
; 1043 : 		_Insert_n(begin(), _Count, _Val);
; 1044 : 		_CATCH_ALL
; 1045 : 		_Tidy();
; 1046 : 		_RERAISE;
; 1047 : 		_CATCH_END
; 1048 : 		}
; 1049 : 
; 1050 : #define _PUSH_FRONT_BEGIN \
; 1051 : 	if (this->_Myoff % _DEQUESIZ == 0 \
; 1052 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1053 : 		_Growmap(1); \
; 1054 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1055 : 	size_type _Newoff = this->_Myoff != 0 ? this->_Myoff \
; 1056 : 		: this->_Mapsize * _DEQUESIZ; \
; 1057 : 	size_type _Block = this->_Getblock(--_Newoff); \
; 1058 : 	if (this->_Map[_Block] == pointer()) \
; 1059 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1060 : 
; 1061 : #define _PUSH_FRONT_END \
; 1062 : 	this->_Myoff = _Newoff; \
; 1063 : 	++this->_Mysize
; 1064 : 
; 1065 : #define _PUSH_BACK_BEGIN \
; 1066 : 	if ((this->_Myoff + this->_Mysize) % _DEQUESIZ == 0 \
; 1067 : 		&& this->_Mapsize <= (this->_Mysize + _DEQUESIZ) / _DEQUESIZ) \
; 1068 : 		_Growmap(1); \
; 1069 : 	this->_Myoff &= this->_Mapsize * _DEQUESIZ - 1; \
; 1070 : 	size_type _Newoff = this->_Myoff + this->_Mysize; \
; 1071 : 	size_type _Block = this->_Getblock(_Newoff); \
; 1072 : 	if (this->_Map[_Block] == pointer()) \
; 1073 : 		this->_Map[_Block] = this->_Getal().allocate(_DEQUESIZ)
; 1074 : 
; 1075 : #define _PUSH_BACK_END \
; 1076 : 	++this->_Mysize
; 1077 : 
; 1078 : 	deque(_Myt&& _Right)
; 1079 : 		: _Mybase(_Right._Getal())
; 1080 : 		{	// construct by moving _Right
; 1081 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1082 : 		}
; 1083 : 
; 1084 : 	deque(_Myt&& _Right, const _Alloc& _Al)
; 1085 : 		: _Mybase(_Al)
; 1086 : 		{	// construct by moving _Right
; 1087 : 		if (this->_Getal() != _Right._Getal())
; 1088 : 			assign(_STD make_move_iterator(_Right.begin()),
; 1089 : 				_STD make_move_iterator(_Right.end()));
; 1090 : 		else
; 1091 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1092 : 		}
; 1093 : 
; 1094 : 	_Myt& operator=(_Myt&& _Right)
; 1095 : 		{	// assign by moving _Right
; 1096 : 		if (this != &_Right)
; 1097 : 			{	// different, assign it
; 1098 : 			_Tidy();
; 1099 : 
; 1100 :  #if _HAS_CPP0X
; 1101 : 			if (this->_Getal() != _Right._Getal()
; 1102 : 				&& _Alty::propagate_on_container_move_assignment::value)
; 1103 : 				this->_Change_alloc(_Right._Getal());
; 1104 :  #endif /* _HAS_CPP0X */
; 1105 : 
; 1106 : 			if (this->_Getal() != _Right._Getal())
; 1107 : 				assign(_STD make_move_iterator(_Right.begin()),
; 1108 : 					_STD make_move_iterator(_Right.end()));
; 1109 : 			else
; 1110 : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 1111 : 			}
; 1112 : 		return (*this);
; 1113 : 		}
; 1114 : 
; 1115 : 	void _Assign_rv(_Myt&& _Right)
; 1116 : 		{	// assign by moving _Right
; 1117 : 		if (this == &_Right)
; 1118 : 			;
; 1119 : 		else if (get_allocator() != _Right.get_allocator())
; 1120 : 			{	// move construct a copy
; 1121 : 			clear();
; 1122 : 			for (iterator _Next = _Right.begin(); _Next != _Right.end();
; 1123 : 				++_Next)
; 1124 : 				push_back(_STD forward<value_type>(*_Next));
; 1125 : 			}
; 1126 : 		else
; 1127 : 			{	// clear this and steal from _Right
; 1128 : 			this->_Swap_all((_Myt&)_Right);
; 1129 : 			this->_Map = _Right._Map;
; 1130 : 			this->_Mapsize = _Right._Mapsize;
; 1131 : 			this->_Myoff = _Right._Myoff;
; 1132 : 			this->_Mysize = _Right._Mysize;
; 1133 : 
; 1134 : 			_Right._Map = _Mapptr();
; 1135 : 			_Right._Mapsize = 0;
; 1136 : 			_Right._Myoff = 0;
; 1137 : 			_Right._Mysize = 0;
; 1138 : 			}
; 1139 : 		}
; 1140 : 
; 1141 : 	void push_front(value_type&& _Val)
; 1142 : 		{	// insert element at beginning
; 1143 : 		this->_Orphan_all();
; 1144 : 		_PUSH_FRONT_BEGIN;
; 1145 : 		this->_Getal().construct(
; 1146 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1147 : 			_STD forward<value_type>(_Val));
; 1148 : 		_PUSH_FRONT_END;
; 1149 : 		}
; 1150 : 
; 1151 : 	void push_back(value_type&& _Val)
; 1152 : 		{	// insert element at end
; 1153 : 		this->_Orphan_all();
; 1154 : 		_PUSH_BACK_BEGIN;
; 1155 : 		this->_Getal().construct(
; 1156 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ,
; 1157 : 			_STD forward<value_type>(_Val));
; 1158 : 		_PUSH_BACK_END;
; 1159 : 		}
; 1160 : 
; 1161 : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 1162 : 		{	// insert _Val at _Where
; 1163 : 		return (emplace(_Where, _STD move(_Val)));
; 1164 : 		}
; 1165 : 
; 1166 : #define _DEQUE_EMPLACE( \
; 1167 : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 1168 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1169 : 		void emplace_front(LIST(_TYPE_REFREF_ARG)) \
; 1170 : 		{	/* insert element at beginning */ \
; 1171 : 		this->_Orphan_all(); \
; 1172 : 		_PUSH_FRONT_BEGIN; \
; 1173 : 		this->_Getal().construct( \
; 1174 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1175 : 				COMMA LIST(_FORWARD_ARG)); \
; 1176 : 		_PUSH_FRONT_END; \
; 1177 : 	} \
; 1178 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1179 : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 1180 : 		{	/* insert element at end */ \
; 1181 : 		this->_Orphan_all(); \
; 1182 : 		_PUSH_BACK_BEGIN; \
; 1183 : 		this->_Getal().construct( \
; 1184 : 			this->_Map[_Block] + _Newoff % _DEQUESIZ \
; 1185 : 				COMMA LIST(_FORWARD_ARG)); \
; 1186 : 		_PUSH_BACK_END; \
; 1187 : 		} \
; 1188 : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 1189 : 		iterator emplace(const_iterator _Where \
; 1190 : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 1191 : 		{	/* insert element at _Where */ \
; 1192 : 		size_type _Off = _Where - begin(); \
; 1193 : 		_DEQUE_EMPLACE_CHECK \
; 1194 : 		if (_Off <= this->_Mysize / 2) \
; 1195 : 			{	/* closer to front, push to front then rotate */ \
; 1196 : 			emplace_front(LIST(_FORWARD_ARG)); \
; 1197 : 			_STD rotate(begin(), begin() + 1, begin() + 1 + _Off); \
; 1198 : 			} \
; 1199 : 		else \
; 1200 : 			{	/* closer to back, push to back then rotate */ \
; 1201 : 			emplace_back(LIST(_FORWARD_ARG)); \
; 1202 : 			_STD rotate(begin() + _Off, end() - 1, end()); \
; 1203 : 			} \
; 1204 : 		return (begin() + _Off); \
; 1205 : 			}
; 1206 : 
; 1207 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1208 : #define _DEQUE_EMPLACE_CHECK \
; 1209 : 		if (this->_Mysize < _Off) \
; 1210 : 			_DEBUG_ERROR("deque emplace iterator outside range");
; 1211 : 
; 1212 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1213 : #define _DEQUE_EMPLACE_CHECK
; 1214 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1215 : 
; 1216 : _VARIADIC_EXPAND_0X(_DEQUE_EMPLACE, , , , )
; 1217 : #undef _DEQUE_EMPLACE_CHECK
; 1218 : #undef _DEQUE_EMPLACE
; 1219 : 
; 1220 : 	~deque() _NOEXCEPT
; 1221 : 		{	// destroy the deque
; 1222 : 		_Tidy();
; 1223 : 		}
; 1224 : 
; 1225 : 	_Myt& operator=(const _Myt& _Right)
; 1226 : 		{	// assign _Right
; 1227 : 		if (this != &_Right)
; 1228 : 			{	// different, assign it
; 1229 :  #if _HAS_CPP0X
; 1230 : 			if (this->_Getal() != _Right._Getal()
; 1231 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1232 : 				{	// change allocator before copying
; 1233 : 				_Tidy();
; 1234 : 				this->_Change_alloc(_Right._Getal());
; 1235 : 				}
; 1236 :  #endif /* _HAS_CPP0X */
; 1237 : 
; 1238 : 			this->_Orphan_all();
; 1239 : 
; 1240 : 			if (_Right._Mysize == 0)
; 1241 : 				clear();
; 1242 : 			else if (_Right._Mysize <= this->_Mysize)
; 1243 : 				{	// enough elements, copy new and destroy old
; 1244 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),
; 1245 : 					begin());
; 1246 : 				erase(_Mid, end());
; 1247 : 				}
; 1248 : 			else
; 1249 : 				{	// new sequence longer, copy and construct new
; 1250 : 				const_iterator _Mid = _Right.begin() + this->_Mysize;
; 1251 : 				_STD copy(_Right.begin(), _Mid, begin());
; 1252 : 				insert(end(), _Mid, _Right.end());
; 1253 : 				}
; 1254 : 			}
; 1255 : 		return (*this);
; 1256 : 		}
; 1257 : 
; 1258 : 	iterator begin() _NOEXCEPT
; 1259 : 		{	// return iterator for beginning of mutable sequence
; 1260 : 		return (iterator(this->_Myoff, this));
; 1261 : 		}
; 1262 : 
; 1263 : 	const_iterator begin() const _NOEXCEPT
; 1264 : 		{	// return iterator for beginning of nonmutable sequence
; 1265 : 		return (const_iterator(this->_Myoff, this));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator end() _NOEXCEPT
; 1269 : 		{	// return iterator for end of mutable sequence
; 1270 : 		return (iterator(this->_Myoff + this->_Mysize, this));
; 1271 : 		}
; 1272 : 
; 1273 : 	const_iterator end() const _NOEXCEPT
; 1274 : 		{	// return iterator for end of nonmutable sequence
; 1275 : 		return (const_iterator(this->_Myoff + this->_Mysize, this));
; 1276 : 		}
; 1277 : 
; 1278 : 	iterator _Make_iter(const_iterator _Where) const
; 1279 : 		{	// make iterator from const_iterator
; 1280 : 		return (iterator(_Where._Myoff, this));
; 1281 : 		}
; 1282 : 
; 1283 : 	reverse_iterator rbegin() _NOEXCEPT
; 1284 : 		{	// return iterator for beginning of reversed mutable sequence
; 1285 : 		return (reverse_iterator(end()));
; 1286 : 		}
; 1287 : 
; 1288 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1289 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1290 : 		return (const_reverse_iterator(end()));
; 1291 : 		}
; 1292 : 
; 1293 : 	reverse_iterator rend() _NOEXCEPT
; 1294 : 		{	// return iterator for end of reversed mutable sequence
; 1295 : 		return (reverse_iterator(begin()));
; 1296 : 		}
; 1297 : 
; 1298 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1299 : 		{	// return iterator for end of reversed nonmutable sequence
; 1300 : 		return (const_reverse_iterator(begin()));
; 1301 : 		}
; 1302 : 
; 1303 :  #if _HAS_CPP0X
; 1304 : 	const_iterator cbegin() const _NOEXCEPT
; 1305 : 		{	// return iterator for beginning of nonmutable sequence
; 1306 : 		return (((const _Myt *)this)->begin());
; 1307 : 		}
; 1308 : 
; 1309 : 	const_iterator cend() const _NOEXCEPT
; 1310 : 		{	// return iterator for end of nonmutable sequence
; 1311 : 		return (((const _Myt *)this)->end());
; 1312 : 		}
; 1313 : 
; 1314 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1315 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1316 : 		return (((const _Myt *)this)->rbegin());
; 1317 : 		}
; 1318 : 
; 1319 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1320 : 		{	// return iterator for end of reversed nonmutable sequence
; 1321 : 		return (((const _Myt *)this)->rend());
; 1322 : 		}
; 1323 : 
; 1324 : 	void shrink_to_fit()
; 1325 : 		{	// reduce capacity
; 1326 : 		size_type _Oldcapacity = _DEQUESIZ * this->_Mapsize;
; 1327 : 		size_type _Newcapacity = _Oldcapacity / 2;
; 1328 : 
; 1329 : 		if (_Newcapacity < _DEQUESIZ * _DEQUEMAPSIZ)
; 1330 : 			_Newcapacity = _DEQUESIZ * _DEQUEMAPSIZ;
; 1331 : 
; 1332 : 		if ((empty() && 0 < this->_Mapsize)
; 1333 : 			|| (!empty()
; 1334 : 				&& size() <= _Newcapacity
; 1335 : 				&& _Newcapacity < _Oldcapacity))
; 1336 : 			{	// worth shrinking, do it
; 1337 : 			_Myt _Tmp(_STD make_move_iterator(begin()),
; 1338 : 				_STD make_move_iterator(end()));
; 1339 : 			swap(_Tmp);
; 1340 : 			}
; 1341 : 		}
; 1342 :  #endif /* _HAS_CPP0X */
; 1343 : 
; 1344 : 	void resize(size_type _Newsize)
; 1345 : 		{	// determine new length, padding as needed
; 1346 : 		if (_Newsize < this->_Mysize)
; 1347 : 			erase(begin() + _Newsize, end());
; 1348 : 		else if (this->_Mysize < _Newsize)
; 1349 : 			{	// append default-constructed elements
; 1350 : 			_Alty _Alval(this->_Getal());
; 1351 : 			this->_Orphan_all();
; 1352 : 			while (this->_Mysize < _Newsize)
; 1353 : 				{	// push_back default-constructed element
; 1354 : 				_PUSH_BACK_BEGIN;
; 1355 : 				_Uninitialized_default_fill_n(
; 1356 : 					this->_Map[_Block] + _Newoff % _DEQUESIZ, 1, _Alval);
; 1357 : 				_PUSH_BACK_END;
; 1358 : 				}
; 1359 : 			}
; 1360 : 		}
; 1361 : 
; 1362 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1363 : 		{	// determine new length, padding with _Val elements as needed
; 1364 : 		if (this->_Mysize < _Newsize)
; 1365 : 			_Insert_n(end(), _Newsize - this->_Mysize, _Val);
; 1366 : 		else if (_Newsize < this->_Mysize)
; 1367 : 			erase(begin() + _Newsize, end());
; 1368 : 		}
; 1369 : 
; 1370 : 	size_type size() const _NOEXCEPT
; 1371 : 		{	// return length of sequence
; 1372 : 		return (this->_Mysize);
; 1373 : 		}
; 1374 : 
; 1375 : 	size_type max_size() const _NOEXCEPT
; 1376 : 		{	// return maximum possible length of sequence
; 1377 : 		return (this->_Getal().max_size());
; 1378 : 		}
; 1379 : 
; 1380 : 	bool empty() const _NOEXCEPT
; 1381 : 		{	// test if sequence is empty
; 1382 : 		return (this->_Mysize == 0);

  00006	48 83 79 20 00	 cmp	 QWORD PTR [rcx+32], 0

; 1454 : 		{	// erase element at beginning

  0000b	48 8b d9	 mov	 rbx, rcx

; 1455 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1456 : 		if (empty())
; 1457 : 			_DEBUG_ERROR("deque empty before pop");
; 1458 : 		else
; 1459 : 			{	// something to erase, do it
; 1460 : 			_Orphan_off(this->_Myoff);
; 1461 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1462 : 			this->_Getal().destroy(
; 1463 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);
; 1464 : 			if (--this->_Mysize == 0)
; 1465 : 				this->_Myoff = 0;
; 1466 : 			else
; 1467 : 				++this->_Myoff;
; 1468 : 			}
; 1469 : 
; 1470 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 		if (!empty())

  0000e	74 65		 je	 SHORT $LN1@pop_front

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00010	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  00014	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00018	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0001d	48 ff ca	 dec	 rdx
  00020	48 23 51 18	 and	 rdx, QWORD PTR [rcx+24]

; 1472 : 			{	// something to erase, do it
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff);
; 1474 : 			this->_Getal().destroy(
; 1475 : 				this->_Map[_Block] + this->_Myoff % _DEQUESIZ);

  00024	48 8b 14 d0	 mov	 rdx, QWORD PTR [rax+rdx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00028	48 8b 7a 08	 mov	 rdi, QWORD PTR [rdx+8]
  0002c	48 85 ff	 test	 rdi, rdi
  0002f	74 27		 je	 SHORT $LN29@pop_front

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00031	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  00035	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0003a	75 17		 jne	 SHORT $LN32@pop_front

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003c	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0003f	48 8b cf	 mov	 rcx, rdi
  00042	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00044	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  00048	75 09		 jne	 SHORT $LN32@pop_front

; 128  : 			_Delete_this();

  0004a	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0004d	48 8b cf	 mov	 rcx, rdi
  00050	ff 50 08	 call	 QWORD PTR [rax+8]
$LN32@pop_front:
  00053	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN29@pop_front:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1476 : 			if (--this->_Mysize == 0)

  00058	48 ff 4b 20	 dec	 QWORD PTR [rbx+32]
  0005c	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00061	75 0e		 jne	 SHORT $LN2@pop_front

; 1477 : 				this->_Myoff = 0;

  00063	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0

; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}

  0006b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006f	5b		 pop	 rbx
  00070	c3		 ret	 0
$LN2@pop_front:

; 1478 : 			else
; 1479 : 				++this->_Myoff;

  00071	48 ff 43 18	 inc	 QWORD PTR [rbx+24]
$LN1@pop_front:

; 1480 : 			}
; 1481 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1482 : 		}

  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5b		 pop	 rbx
  0007a	c3		 ret	 0
?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back, COMDAT

; 1485 : 		{	// insert element at end

$LN54:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1487 : 		_PUSH_BACK_BEGIN;

  0000f	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	48 ff c0	 inc	 rax
  0001c	48 39 41 10	 cmp	 QWORD PTR [rcx+16], rax
  00020	77 05		 ja	 SHORT $LN2@push_back
  00022	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
$LN2@push_back:
  00027	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]
  0002b	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0002f	49 ff c8	 dec	 r8
  00032	4c 21 43 18	 and	 QWORD PTR [rbx+24], r8
  00036	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  0003a	48 03 53 20	 add	 rdx, QWORD PTR [rbx+32]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0003e	4c 23 c2	 and	 r8, rdx

; 1487 : 		_PUSH_BACK_BEGIN;

  00041	4a 8d 34 c5 00
	00 00 00	 lea	 rsi, QWORD PTR [r8*8]
  00049	48 83 3c 06 00	 cmp	 QWORD PTR [rsi+rax], 0
  0004e	75 1a		 jne	 SHORT $LN1@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00050	b9 10 00 00 00	 mov	 ecx, 16
  00055	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	48 85 c0	 test	 rax, rax
  00060	74 48		 je	 SHORT $LN52@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00062	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00066	48 89 0c 06	 mov	 QWORD PTR [rsi+rax], rcx
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  0006a	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0006e	48 8b 0c 06	 mov	 rcx, QWORD PTR [rsi+rax]
  00072	48 85 c9	 test	 rcx, rcx
  00075	74 1f		 je	 SHORT $LN36@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00077	33 c0		 xor	 eax, eax
  00079	48 89 01	 mov	 QWORD PTR [rcx], rax
  0007c	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00080	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  00084	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00087	4d 85 c0	 test	 r8, r8
  0008a	74 05		 je	 SHORT $LN49@push_back

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0008c	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN49@push_back:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00091	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN36@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00096	48 ff 43 20	 inc	 QWORD PTR [rbx+32]

; 1491 : 		}

  0009a	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0009f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a8	5f		 pop	 rdi
  000a9	c3		 ret	 0
$LN52@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  000aa	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000af	cc		 int	 3
$LN51@push_back:
?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VChunkBase@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@XZ PROC		; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>, COMDAT

; 282  : 		{	// construct

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@XZ ENDP		; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get@?$_Ptr_base@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Ptr_base@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ PROC ; std::_Ptr_base<ChunkBase>::_Get, COMDAT

; 335  : 		return (_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 336  : 		}

  00003	c3		 ret	 0
?_Get@?$_Ptr_base@VChunkBase@@@std@@QEBAPEAVChunkBase@@XZ ENDP ; std::_Ptr_base<ChunkBase>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ PROC	; std::_Ptr_base<ChunkBase>::_Decref, COMDAT

; 344  : 		{	// decrement reference count

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  00006	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN7@Decref

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN10@Decref

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN10@Decref

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Decref:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN7@Decref:

; 346  : 			_Rep->_Decref();
; 347  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
?_Decref@?$_Ptr_base@VChunkBase@@@std@@QEAAXXZ ENDP	; std::_Ptr_base<ChunkBase>::_Decref
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAA@XZ PROC	; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>, COMDAT

; 282  : 		{	// construct

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAA@XZ ENDP	; std::_Ptr_base<gfxu::VertexStream>::_Ptr_base<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 320  : 		}

  0001c	c3		 ret	 0
?_Swap@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1260 : 		return (iterator(this->_Myoff, this));

  00003	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00007	48 c7 42 08 00
	00 00 00	 mov	 QWORD PTR [rdx+8], 0

; 166  : 			_Myproxy = _Parent_proxy;

  0000f	48 89 02	 mov	 QWORD PTR [rdx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  00012	4c 89 42 10	 mov	 QWORD PTR [rdx+16], r8

; 1260 : 		return (iterator(this->_Myoff, this));

  00016	48 8b c2	 mov	 rax, rdx

; 1261 : 		}

  00019	c3		 ret	 0
?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_NXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty, COMDAT

; 1382 : 		return (this->_Mysize == 0);

  00000	33 c0		 xor	 eax, eax
  00002	48 39 41 20	 cmp	 QWORD PTR [rcx+32], rax
  00006	0f 94 c0	 sete	 al

; 1383 : 		}

  00009	c3		 ret	 0
?empty@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_NXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 64
_Count$dead$ = 72
?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap, COMDAT

; 1802 : 		{	// grow map by at least _Count pointers, _Mapsize a power of 2

$LN134:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1803 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1804 : 			"The _Xlen() test should always be performed.");
; 1805 : 
; 1806 : 		typedef typename _Alpty::pointer _Blockptr;
; 1807 : 		_Alpty _Almap(this->_Getal());
; 1808 : 		size_type _Newsize = 0 < this->_Mapsize ? this->_Mapsize : 1;

  00007	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0000b	bb 01 00 00 00	 mov	 ebx, 1
  00010	48 8b f1	 mov	 rsi, rcx
  00013	48 85 d2	 test	 rdx, rdx
  00016	48 b9 ff ff ff
	ff ff ff ff 0f	 mov	 rcx, 1152921504606846975 ; 0fffffffffffffffH
  00020	48 0f 45 da	 cmovne	 rbx, rdx
$LL7@Growmap:

; 1809 : 		while (_Newsize - this->_Mapsize < _Count || _Newsize < _DEQUEMAPSIZ)

  00024	48 8b c3	 mov	 rax, rbx
  00027	48 2b c2	 sub	 rax, rdx
  0002a	48 83 f8 01	 cmp	 rax, 1
  0002e	72 06		 jb	 SHORT $LN5@Growmap
  00030	48 83 fb 08	 cmp	 rbx, 8
  00034	73 14		 jae	 SHORT $LN6@Growmap
$LN5@Growmap:

; 1810 : 			{	// scale _Newsize to 2^N >= _Mapsize + _Count
; 1811 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

  00036	48 8b c1	 mov	 rax, rcx
  00039	48 2b c3	 sub	 rax, rbx
  0003c	48 3b c3	 cmp	 rax, rbx
  0003f	0f 82 5a 01 00
	00		 jb	 $LN111@Growmap

; 1812 : 				_Xlen();	// result too long
; 1813 : 			_Newsize *= 2;

  00045	48 03 db	 add	 rbx, rbx

; 1814 : 			}

  00048	eb da		 jmp	 SHORT $LL7@Growmap
$LN6@Growmap:

; 1815 : 		_Count = _Newsize - this->_Mapsize;

  0004a	48 2b da	 sub	 rbx, rdx
  0004d	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  00052	33 ed		 xor	 ebp, ebp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1818 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize + _Count);

  00054	48 8d 0c 1a	 lea	 rcx, QWORD PTR [rdx+rbx]
  00058	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  0005d	4c 8b 7e 18	 mov	 r15, QWORD PTR [rsi+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00061	48 85 c9	 test	 rcx, rcx
  00064	74 2c		 je	 SHORT $LN32@Growmap

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00066	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00070	48 3b c8	 cmp	 rcx, rax
  00073	0f 87 20 01 00
	00		 ja	 $LN132@Growmap
  00079	48 8d 0c cd 00
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8]
  00081	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00086	48 8b e8	 mov	 rbp, rax
  00089	48 85 c0	 test	 rax, rax
  0008c	0f 84 07 01 00
	00		 je	 $LN132@Growmap
$LN32@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1823 : 			_Myptr, _Almap);	// copy initial to end

  00092	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00096	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0009b	48 8b 7e 10	 mov	 rdi, QWORD PTR [rsi+16]
  0009f	48 c1 e7 03	 shl	 rdi, 3
  000a3	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  000a8	4e 8d 34 fd 00
	00 00 00	 lea	 r14, QWORD PTR [r15*8]
  000b0	49 8d 14 06	 lea	 rdx, QWORD PTR [r14+rax]
  000b4	49 8d 0c 2e	 lea	 rcx, QWORD PTR [r14+rbp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000b8	48 2b fa	 sub	 rdi, rdx
  000bb	48 03 f8	 add	 rdi, rax
  000be	48 c1 ff 03	 sar	 rdi, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000c2	48 8d 3c fd 00
	00 00 00	 lea	 rdi, QWORD PTR [rdi*8]
  000ca	4c 8b c7	 mov	 r8, rdi
  000cd	e8 00 00 00 00	 call	 memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1828 : 				_Myptr, _Almap);	// copy rest of old

  000d2	48 8b 56 08	 mov	 rdx, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000d6	48 03 c7	 add	 rax, rdi
  000d9	48 8b c8	 mov	 rcx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1824 : 		if (_Myboff <= _Count)

  000dc	4c 3b fb	 cmp	 r15, rbx
  000df	77 3e		 ja	 SHORT $LN3@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  000e1	49 c1 fe 03	 sar	 r14, 3
  000e5	4c 89 64 24 50	 mov	 QWORD PTR [rsp+80], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1830 : 				_Almap);	// clear suffix of new

  000ea	4c 8b e3	 mov	 r12, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  000ed	4a 8d 3c f5 00
	00 00 00	 lea	 rdi, QWORD PTR [r14*8]
  000f5	4c 8b c7	 mov	 r8, rdi
  000f8	e8 00 00 00 00	 call	 memmove
  000fd	48 03 f8	 add	 rdi, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1830 : 				_Almap);	// clear suffix of new

  00100	4d 2b e7	 sub	 r12, r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00103	74 08		 je	 SHORT $LN61@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1828 : 				_Myptr, _Almap);	// copy rest of old

  00105	33 c0		 xor	 eax, eax
  00107	49 8b cc	 mov	 rcx, r12
  0010a	f3 48 ab	 rep stosq
$LN61@Growmap:
  0010d	4c 8b 64 24 50	 mov	 r12, QWORD PTR [rsp+80]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00112	4d 85 ff	 test	 r15, r15
  00115	74 51		 je	 SHORT $LN99@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  00117	48 8b fd	 mov	 rdi, rbp
  0011a	49 8b cf	 mov	 rcx, r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1834 : 		else

  0011d	eb 44		 jmp	 SHORT $LN131@Growmap
$LN3@Growmap:

; 1838 : 				_Myptr, _Almap);	// copy more old

  0011f	48 8d 3c dd 00
	00 00 00	 lea	 rdi, QWORD PTR [rbx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00127	4c 8b c7	 mov	 r8, rdi
  0012a	49 83 e0 f8	 and	 r8, -8
  0012e	e8 00 00 00 00	 call	 memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1841 : 				_Newmap, _Almap);	// copy rest of old

  00133	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00137	48 8b cd	 mov	 rcx, rbp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1841 : 				_Newmap, _Almap);	// copy rest of old

  0013a	48 8d 14 07	 lea	 rdx, QWORD PTR [rdi+rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  0013e	4c 2b f2	 sub	 r14, rdx
  00141	4c 03 f0	 add	 r14, rax
  00144	49 c1 fe 03	 sar	 r14, 3

; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00148	4a 8d 3c f5 00
	00 00 00	 lea	 rdi, QWORD PTR [r14*8]
  00150	4c 8b c7	 mov	 r8, rdi
  00153	e8 00 00 00 00	 call	 memmove
  00158	48 03 f8	 add	 rdi, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  0015b	48 85 db	 test	 rbx, rbx
  0015e	74 08		 je	 SHORT $LN99@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1838 : 				_Myptr, _Almap);	// copy more old

  00160	48 8b cb	 mov	 rcx, rbx
$LN131@Growmap:
  00163	33 c0		 xor	 eax, eax
  00165	f3 48 ab	 rep stosq
$LN99@Growmap:

; 1842 : 			_Uninitialized_default_fill_n(_Myptr, _Count,
; 1843 : 				_Almap);	// clear rest to initial block
; 1844 : 			}
; 1845 : 
; 1846 : 		_Destroy_range(this->_Map + _Myboff, this->_Map + this->_Mapsize,
; 1847 : 			_Almap);
; 1848 : 		if (this->_Map != _Mapptr())

  00168	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  0016c	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00171	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00176	48 85 c9	 test	 rcx, rcx
  00179	74 05		 je	 SHORT $LN104@Growmap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0017b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN104@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1853 : 		this->_Mapsize += _Count;

  00180	48 01 5e 10	 add	 QWORD PTR [rsi+16], rbx
  00184	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  00189	48 89 6e 08	 mov	 QWORD PTR [rsi+8], rbp
  0018d	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 1854 : 		}

  00192	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00196	5e		 pop	 rsi
  00197	5b		 pop	 rbx
  00198	c3		 ret	 0
$LN132@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00199	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0019e	cc		 int	 3
$LN111@Growmap:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1793 : 		_Xlength_error("deque<T> too long");

  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  001a6	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  001ab	cc		 int	 3
$LN130@Growmap:
?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ PROC ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal, COMDAT

; 917  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 918  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Deque_alloc@$0A@U?$_Deque_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ENDP ; std::_Deque_alloc<0,std::_Deque_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 20		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 16		 ja	 SHORT $LN14@allocate
  0001a	48 c1 e2 04	 shl	 rdx, 4
  0001e	48 8b ca	 mov	 rcx, rdx
  00021	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00026	48 85 c0	 test	 rax, rax
  00029	74 05		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00035	cc		 int	 3
$LN13@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_K_K@Z PROC ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock, COMDAT

; 786  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 ff c8	 dec	 rax
  00007	48 23 c2	 and	 rax, rdx

; 788  : 		}

  0000a	c3		 ret	 0
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_K_K@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEAV?$shared_ptr@VChunkBase@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEAV?$shared_ptr@VChunkBase@@@1@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 603  : 		{	// return designated object

  00003	48 8b d1	 mov	 rdx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00006	48 85 c0	 test	 rax, rax
  00009	75 14		 jne	 SHORT $LN7@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 604  : 		return ((reference)**(_Mybase *)this);

  0000f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00013	48 ff c9	 dec	 rcx
  00016	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 604  : 		return ((reference)**(_Mybase *)this);

  0001a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 605  : 		}

  0001e	c3		 ret	 0
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00022	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 604  : 		return ((reference)**(_Mybase *)this);

  00026	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0002a	48 ff c9	 dec	 rcx
  0002d	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 604  : 		return ((reference)**(_Mybase *)this);

  00031	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 605  : 		}

  00035	c3		 ret	 0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEAV?$shared_ptr@VChunkBase@@@1@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 1377 : 		return (this->_Getal().max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 1378 : 		}

  0000a	c3		 ret	 0
?max_size@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ PROC ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen, COMDAT

; 1792 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1793 : 		_Xlength_error("deque<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ENDP ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 20		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 16		 ja	 SHORT $LN11@allocate
  0001a	48 c1 e2 04	 shl	 rdx, 4
  0001e	48 8b ca	 mov	 rcx, rdx
  00021	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00026	48 85 c0	 test	 rax, rax
  00029	74 05		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002f	c3		 ret	 0
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00030	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00035	cc		 int	 3
$LN10@allocate:
?allocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 831  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::allocate, COMDAT

; 875  : 		{	// allocate array of _Count elements

$LN16:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 21		 je	 SHORT $LN6@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 17		 ja	 SHORT $LN14@allocate
  0001a	48 8d 0c d5 00
	00 00 00	 lea	 rcx, QWORD PTR [rdx*8]
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00027	48 85 c0	 test	 rax, rax
  0002a	74 05		 je	 SHORT $LN14@allocate
$LN6@allocate:

; 876  : 		return (_Mybase::allocate(_Count));
; 877  : 		}

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN14@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00036	cc		 int	 3
$LN13@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
_Lock$1 = 48
this$ = 48
_Off$ = 56
_Pdeque$ = 64
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT

; 586  : 		{	// construct with offset _Off in *_Pdeque

$LN18:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  0000a	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 586  : 		{	// construct with offset _Off in *_Pdeque

  0000c	48 8b fa	 mov	 rdi, rdx
  0000f	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00012	48 89 01	 mov	 QWORD PTR [rcx], rax
  00015	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 114  : 		}
; 115  : 
; 116  : 	_Iterator_base12(const _Iterator_base12& _Right)
; 117  : 		: _Myproxy(0), _Mynextiter(0)
; 118  : 		{	// copy an iterator
; 119  : 		*this = _Right;
; 120  : 		}
; 121  : 
; 122  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 123  : 		{	// assign an iterator
; 124  : 		if (_Myproxy == _Right._Myproxy)
; 125  : 			;
; 126  : 		else if (_Right._Myproxy != 0)
; 127  : 			_Adopt(_Right._Myproxy->_Mycont);
; 128  : 		else
; 129  : 			{	// becoming invalid, disown current parent
; 130  : 			_Lockit _Lock(_LOCK_DEBUG);
; 131  : 			_Orphan_me();
; 132  : 			}
; 133  : 		return (*this);
; 134  : 		}
; 135  : 
; 136  : 	~_Iterator_base12() _NOEXCEPT
; 137  : 		{	// destroy the iterator
; 138  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 139  : 		_Lockit _Lock(_LOCK_DEBUG);
; 140  : 		_Orphan_me();
; 141  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 142  : 		}
; 143  : 
; 144  : 	void _Adopt(const _Container_base12 *_Parent)
; 145  : 		{	// adopt this iterator by parent
; 146  : 		if (_Parent == 0)

  00019	4d 85 c0	 test	 r8, r8
  0001c	75 29		 jne	 SHORT $LN10@Deque_iter

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  0001e	8d 50 03	 lea	 edx, QWORD PTR [rax+3]
  00021	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00026	e8 00 00 00 00	 call	 ??0_Lockit@std@@QEAA@H@Z ; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  0002b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QEAA@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  00035	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 587  : 		}

  00039	48 8b c3	 mov	 rax, rbx
  0003c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
$LN10@Deque_iter:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00047	49 8b 00	 mov	 rax, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  0004a	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  0004e	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 587  : 		}

  00051	48 8b c3	 mov	 rax, rbx
  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEBV?$shared_ptr@VChunkBase@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEBV?$shared_ptr@VChunkBase@@@1@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 323  : 		{	// return designated object

  00003	48 8b d1	 mov	 rdx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00006	48 85 c0	 test	 rax, rax
  00009	75 14		 jne	 SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0000b	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  0000f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00013	48 ff c9	 dec	 rcx
  00016	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  0001a	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 346  : 		}

  0001e	c3		 ret	 0
$LN5@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0001f	48 8b 00	 mov	 rax, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00022	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  00026	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  0002a	48 ff c9	 dec	 rcx
  0002d	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 324  : 		_Mydeque *_Mycont = ((_Mydeque *)this->_Getcont());
; 325  : 
; 326  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 327  : 		if (_Mycont == 0
; 328  : 			|| this->_Myoff < _Mycont->_Myoff
; 329  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 330  : 		{	// report error
; 331  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 332  : 		_SCL_SECURE_OUT_OF_RANGE;
; 333  : 		}
; 334  : 
; 335  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 336  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 337  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 338  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 339  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 340  : 
; 341  : 		_Analysis_assume_(_Mycont != 0);
; 342  : 
; 343  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 344  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 345  : 		return (_Mycont->_Map[_Block][_Off]);

  00031	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]

; 346  : 		}

  00035	c3		 ret	 0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEBAAEBV?$shared_ptr@VChunkBase@@@1@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ PROC ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >, COMDAT

; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@XZ ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::allocator<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_KXZ PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 914  : 		return (_Mytraits::max_size(*this));

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 915  : 		}

  0000a	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEBA_KXZ ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocate, COMDAT

; 590  : 		{	// allocate array of _Count elements

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;

  00004	33 c0		 xor	 eax, eax

; 24   : 
; 25   : 	if (_Count == 0)

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 21		 je	 SHORT $LN4@allocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  0000b	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  00015	48 3b d0	 cmp	 rdx, rax
  00018	77 17		 ja	 SHORT $LN11@allocate
  0001a	48 8d 0c d5 00
	00 00 00	 lea	 rcx, QWORD PTR [rdx*8]
  00022	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00027	48 85 c0	 test	 rax, rax
  0002a	74 05		 je	 SHORT $LN11@allocate
$LN4@allocate:

; 591  : 		return (_Allocate(_Count, (pointer)0));
; 592  : 		}

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
$LN11@allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00031	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00036	cc		 int	 3
$LN10@allocate:
?allocate@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAAPEAPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
_Lock$1 = 48
this$ = 48
_Off$ = 56
_Pdeque$ = 64
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >, COMDAT

; 303  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

$LN16:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  0000a	33 c0		 xor	 eax, eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 303  : 	_Deque_const_iterator(size_type _Off, const _Container_base12 *_Pdeque)

  0000c	48 8b fa	 mov	 rdi, rdx
  0000f	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 113  : 		{	// construct orphaned iterator

  00012	48 89 01	 mov	 QWORD PTR [rcx], rax
  00015	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 114  : 		}
; 115  : 
; 116  : 	_Iterator_base12(const _Iterator_base12& _Right)
; 117  : 		: _Myproxy(0), _Mynextiter(0)
; 118  : 		{	// copy an iterator
; 119  : 		*this = _Right;
; 120  : 		}
; 121  : 
; 122  : 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
; 123  : 		{	// assign an iterator
; 124  : 		if (_Myproxy == _Right._Myproxy)
; 125  : 			;
; 126  : 		else if (_Right._Myproxy != 0)
; 127  : 			_Adopt(_Right._Myproxy->_Mycont);
; 128  : 		else
; 129  : 			{	// becoming invalid, disown current parent
; 130  : 			_Lockit _Lock(_LOCK_DEBUG);
; 131  : 			_Orphan_me();
; 132  : 			}
; 133  : 		return (*this);
; 134  : 		}
; 135  : 
; 136  : 	~_Iterator_base12() _NOEXCEPT
; 137  : 		{	// destroy the iterator
; 138  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 139  : 		_Lockit _Lock(_LOCK_DEBUG);
; 140  : 		_Orphan_me();
; 141  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 142  : 		}
; 143  : 
; 144  : 	void _Adopt(const _Container_base12 *_Parent)
; 145  : 		{	// adopt this iterator by parent
; 146  : 		if (_Parent == 0)

  00019	4d 85 c0	 test	 r8, r8
  0001c	75 29		 jne	 SHORT $LN8@Deque_cons

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  0001e	8d 50 03	 lea	 edx, QWORD PTR [rax+3]
  00021	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00026	e8 00 00 00 00	 call	 ??0_Lockit@std@@QEAA@H@Z ; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  0002b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00030	e8 00 00 00 00	 call	 ??1_Lockit@std@@QEAA@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  00035	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 307  : 		}

  00039	48 8b c3	 mov	 rax, rbx
  0003c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
$LN8@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00047	49 8b 00	 mov	 rax, QWORD PTR [r8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 306  : 		_Myoff = _Off;

  0004a	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  0004e	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 307  : 		}

  00051	48 8b c3	 mov	 rax, rbx
  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi
  0005e	c3		 ret	 0
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAA@_KPEBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 762  : 		return (_Al.max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 763  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SA_KAEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Lock$1 = 56
_Pdeque$ = 56
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont, COMDAT

; 531  : 		{	// set container pointer

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 146  : 		if (_Parent == 0)

  00004	48 85 d2	 test	 rdx, rdx
  00007	75 1e		 jne	 SHORT $LN4@Setcont

; 147  : 			{	// no future parent, just disown current parent
; 148  : 			_Lockit _Lock(_LOCK_DEBUG);

  00009	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0000e	ba 03 00 00 00	 mov	 edx, 3
  00013	e8 00 00 00 00	 call	 ??0_Lockit@std@@QEAA@H@Z ; std::_Lockit::_Lockit

; 149  : 			_Orphan_me();
; 150  : 			}

  00018	48 8d 4c 24 38	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0001d	e8 00 00 00 00	 call	 ??1_Lockit@std@@QEAA@XZ	; std::_Lockit::~_Lockit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 533  : 		}

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
$LN4@Setcont:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 166  : 			_Myproxy = _Parent_proxy;

  00027	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002a	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 533  : 		}

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@QEAAXPEBV?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<std::shared_ptr<ChunkBase> > > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEBA_KXZ PROC ; std::allocator<std::shared_ptr<ChunkBase> >::max_size, COMDAT

; 628  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 629  : 		}

  0000a	c3		 ret	 0
?max_size@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEBA_KXZ ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
this$ = 48
_Px$ = 56
??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>, COMDAT

; 485  : 		explicit shared_ptr(_Ux *_Px)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00008	48 8b d9	 mov	 rbx, rcx

; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00012	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>

; 488  : 		}

  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
??$?0VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::shared_ptr<gfxu::VertexStream><gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEBV01@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>, COMDAT

; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00007	4d 85 c0	 test	 r8, r8
  0000a	74 05		 je	 SHORT $LN6@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0000c	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN6@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00011	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
??$_Reset@VChunkBase@@@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEBV01@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Other$ = 16
??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEBV01@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>, COMDAT

; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00000	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]
  00004	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00007	4d 85 c0	 test	 r8, r8
  0000a	74 05		 je	 SHORT $LN6@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0000c	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN6@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00011	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
??$_Reset@VVertexStream@gfxu@@@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXAEBV01@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >, COMDAT

; 907  : 		void destroy(_Ty *_Ptr)

$LN23:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN18@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN21@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN21@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN21@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN18@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 910  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEBV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEBV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>, COMDAT

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN24@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN24@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEBV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PEAV_Ref_count_base@std@@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAV_Ref_count_base@std@@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z PROC ; std::swap<std::_Ref_count_base * __ptr64>, COMDAT

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00009	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 50   : 	}

  0000c	c3		 ret	 0
??$swap@PEAV_Ref_count_base@std@@@std@@YAXAEAPEAV_Ref_count_base@0@0@Z ENDP ; std::swap<std::_Ref_count_base * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PEAVVertexStream@gfxu@@@std@@YAXAEAPEAVVertexStream@gfxu@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAVVertexStream@gfxu@@@std@@YAXAEAPEAVVertexStream@gfxu@@0@Z PROC ; std::swap<gfxu::VertexStream * __ptr64>, COMDAT

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00009	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 50   : 	}

  0000c	c3		 ret	 0
??$swap@PEAVVertexStream@gfxu@@@std@@YAXAEAPEAVVertexStream@gfxu@@0@Z ENDP ; std::swap<gfxu::VertexStream * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$dead$ = 16
??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 847  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$?0U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@AEBU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> >::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> ><std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >, COMDAT

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00006	48 2b d1	 sub	 rdx, rcx

; 414  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

  00009	49 8b c0	 mov	 rax, r8

; 404  : 	size_t _Count = (size_t)(_Last - _First);

  0000c	48 c1 fa 03	 sar	 rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00010	48 8d 1c d5 00
	00 00 00	 lea	 rbx, QWORD PTR [rdx*8]
  00018	48 8b d1	 mov	 rdx, rcx
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	4c 8b c3	 mov	 r8, rbx
  00021	e8 00 00 00 00	 call	 memmove
  00026	48 03 c3	 add	 rax, rbx

; 415  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 416  : 		_Ptr_cat(_First, _Dest)));
; 417  : 	}

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
??$_Uninitialized_copy@PEAPEAV?$shared_ptr@VChunkBase@@@std@@PEAPEAV12@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
_Al$dead$ = 32
??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >, COMDAT

; 668  : 	{	// copy _Count * _Val_type(_First)() to raw _First, using _Al

$LN18:
  00000	48 83 ec 08	 sub	 rsp, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00004	48 85 d2	 test	 rdx, rdx
  00007	74 13		 je	 SHORT $LN11@Uninitiali
  00009	48 89 3c 24	 mov	 QWORD PTR [rsp], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  0000d	48 8b f9	 mov	 rdi, rcx
  00010	33 c0		 xor	 eax, eax
  00012	48 8b ca	 mov	 rcx, rdx
  00015	f3 48 ab	 rep stosq
  00018	48 8b 3c 24	 mov	 rdi, QWORD PTR [rsp]
$LN11@Uninitiali:

; 669  : 	_Uninit_def_fill_n(_First, _Count, _Al,
; 670  : 		_Val_type(_First), _Ptr_cat(_First, _First));
; 671  : 	}

  0001c	48 83 c4 08	 add	 rsp, 8
  00020	c3		 ret	 0
??$_Uninitialized_default_fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >, COMDAT

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 81   : 	}

  00000	c2 00 00	 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z PROC ; std::_Allocate<std::shared_ptr<ChunkBase> >, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 13		 ja	 SHORT $LN12@Allocate
  00013	48 c1 e1 04	 shl	 rcx, 4
  00017	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0001c	48 85 c0	 test	 rax, rax
  0001f	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00021	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00025	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  00026	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002b	cc		 int	 3
$LN11@Allocate:
??$_Allocate@V?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAV10@@Z ENDP ; std::_Allocate<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z
_TEXT	SEGMENT
_Count$ = 48
??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z PROC ; std::_Allocate<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 22   : 	{	// allocate storage for _Count elements of type _Ty

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 23   : 	void *_Ptr = 0;
; 24   : 
; 25   : 	if (_Count == 0)
; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00004	48 b8 ff ff ff
	ff ff ff ff 1f	 mov	 rax, 2305843009213693951 ; 1fffffffffffffffH
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	77 17		 ja	 SHORT $LN12@Allocate
  00013	48 8d 0c cd 00
	00 00 00	 lea	 rcx, QWORD PTR [rcx*8]
  0001b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00020	48 85 c0	 test	 rax, rax
  00023	74 05		 je	 SHORT $LN12@Allocate

; 30   : 
; 31   : 	return ((_Ty *)_Ptr);
; 32   : 	}

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
$LN12@Allocate:

; 29   : 		_Xbad_alloc();	// report no memory

  0002a	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  0002f	cc		 int	 3
$LN11@Allocate:
??$_Allocate@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@_KPEAPEAV10@@Z ENDP ; std::_Allocate<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 8
_Other_ptr$ = 16
_Other_rep$ = 24
?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset, COMDAT

; 407  : 		if (_Other_rep)

  00000	4d 85 c0	 test	 r8, r8
  00003	74 05		 je	 SHORT $LN4@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00005	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN4@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0000a	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
?_Reset@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 8
_Other_ptr$ = 16
_Other_rep$ = 24
?_Reset@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset, COMDAT

; 407  : 		if (_Other_rep)

  00000	4d 85 c0	 test	 r8, r8
  00003	74 05		 je	 SHORT $LN4@Reset

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00005	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN4@Reset:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0000a	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
?_Reset@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 48
_Other_ptr$ = 56
_Other_rep$ = 64
?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<gfxu::VertexStream>::_Reset0, COMDAT

; 423  : 		{	// release resource and take new resource

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 424  : 		if (_Rep != 0)

  00014	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00018	49 8b f0	 mov	 rsi, r8
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	48 85 ff	 test	 rdi, rdi
  00024	74 4c		 je	 SHORT $LN12@Reset0

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00026	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  0002a	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0002f	75 38		 jne	 SHORT $LN11@Reset0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00031	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00034	48 8b cf	 mov	 rcx, rdi
  00037	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00039	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0003d	75 09		 jne	 SHORT $LN10@Reset0

; 128  : 			_Delete_this();

  0003f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00042	48 8b cf	 mov	 rcx, rdi
  00045	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00048	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi

; 427  : 		_Ptr = _Other_ptr;

  0004c	48 89 2b	 mov	 QWORD PTR [rbx], rbp
$LN13@Reset0:
  0004f	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
$LN7@Reset0:

; 428  : 		}

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0005e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN11@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00069	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  0006d	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00070	eb dd		 jmp	 SHORT $LN13@Reset0
$LN12@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00072	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  00076	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00079	eb d9		 jmp	 SHORT $LN7@Reset0
?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z
_TEXT	SEGMENT
this$ = 48
_Other_ptr$ = 56
_Other_rep$ = 64
?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z PROC ; std::_Ptr_base<ChunkBase>::_Reset0, COMDAT

; 423  : 		{	// release resource and take new resource

$LN15:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 424  : 		if (_Rep != 0)

  00014	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
  00018	49 8b f0	 mov	 rsi, r8
  0001b	48 8b ea	 mov	 rbp, rdx
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	48 85 ff	 test	 rdi, rdi
  00024	74 4c		 je	 SHORT $LN12@Reset0

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00026	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  0002a	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0002f	75 38		 jne	 SHORT $LN11@Reset0

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00031	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00034	48 8b cf	 mov	 rcx, rdi
  00037	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00039	f0 ff 4f 0c	 lock dec DWORD PTR [rdi+12]
  0003d	75 09		 jne	 SHORT $LN10@Reset0

; 128  : 			_Delete_this();

  0003f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00042	48 8b cf	 mov	 rcx, rdi
  00045	ff 50 08	 call	 QWORD PTR [rax+8]
$LN10@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00048	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi

; 427  : 		_Ptr = _Other_ptr;

  0004c	48 89 2b	 mov	 QWORD PTR [rbx], rbp
$LN13@Reset0:
  0004f	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
$LN7@Reset0:

; 428  : 		}

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0005e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00063	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00067	5f		 pop	 rdi
  00068	c3		 ret	 0
$LN11@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00069	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  0006d	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00070	eb dd		 jmp	 SHORT $LN13@Reset0
$LN12@Reset0:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00072	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 427  : 		_Ptr = _Other_ptr;

  00076	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00079	eb d9		 jmp	 SHORT $LN7@Reset0
?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Reset0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>, COMDAT

; 708  : 		void _Resetp(_Ux *_Px)

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  0001e	b9 18 00 00 00	 mov	 ecx, 24
  00023	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00028	48 85 c0	 test	 rax, rax
  0002b	74 1c		 je	 SHORT $LN5@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0002d	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1
  00034	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
  00042	48 89 08	 mov	 QWORD PTR [rax], rcx
  00045	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
$LN5@Resetp:

; 717  : 
; 718  : 	template<class _Ux,
; 719  : 		class _Dx>
; 720  : 		void _Resetp(_Ux *_Px, _Dx _Dt)
; 721  : 		{	// release, take ownership of _Px, deleter _Dt
; 722  : 		_TRY_BEGIN	// allocate control block and reset
; 723  : 		_Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
; 724  : 		_CATCH_ALL	// allocation failed, delete resource
; 725  : 		_Dt(_Px);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : //#if _HAS_CPP0X
; 731  : 	template<class _Ux,
; 732  : 		class _Dx,
; 733  : 		class _Alloc>
; 734  : 		void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 735  : 		{	// release, take ownership of _Px, deleter _Dt, allocator _Ax
; 736  : 		typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
; 737  : 		typename _Alloc::template rebind<_Refd>::other _Al = _Ax;
; 738  : 
; 739  : 		_TRY_BEGIN	// allocate control block and reset
; 740  : 		_Refd *_Ptr = _Al.allocate(1);
; 741  : 		::new (_Ptr) _Refd(_Px, _Dt, _Al);
; 742  : 		_Resetp0(_Px, _Ptr);
; 743  : 		_CATCH_ALL	// allocation failed, delete resource
; 744  : 		_Dt(_Px);
; 745  : 		_RERAISE;
; 746  : 		_CATCH_END
; 747  : 		}
; 748  : //#endif /* _HAS_CPP0X */
; 749  : 
; 750  : public:
; 751  : 	template<class _Ux>
; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00049	4c 8b c0	 mov	 r8, rax
  0004c	48 8b d3	 mov	 rdx, rbx
  0004f	48 8b cf	 mov	 rcx, rdi
  00052	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
  00057	90		 npad	 1

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;
; 714  : 		_RERAISE;
; 715  : 		_CATCH_END
; 716  : 		}

  00058	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN25@Resetp:
??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA PROC ; `std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>'::`1'::catch$0

; 712  : 		_CATCH_ALL	// allocation failed, delete resource

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z$0:

; 713  : 		delete _Px;

  0000d	48 8b 4d 48	 mov	 rcx, QWORD PTR _Px$[rbp]
  00011	48 85 c9	 test	 rcx, rcx
  00014	74 0a		 je	 SHORT $LN6@catch$0
  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	ba 01 00 00 00	 mov	 edx, 1
  0001e	ff 10		 call	 QWORD PTR [rax]
$LN6@catch$0:

; 714  : 		_RERAISE;

  00020	33 d2		 xor	 edx, edx
  00022	33 c9		 xor	 ecx, ecx
  00024	e8 00 00 00 00	 call	 _CxxThrowException
  00029	90		 npad	 1
?catch$0@?0???$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z@4HA ENDP ; `std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
_Al$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >, COMDAT

; 755  : 		static void destroy(_Alloc& _Al, _Uty *_Ptr)

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN16@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN19@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN19@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN19@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 758  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEBV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> const & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEBV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEBV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEBV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN20@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN20@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEBV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEBV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z PROC ; std::_Move<std::_Ref_count_base * __ptr64 & __ptr64>, COMDAT

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1800 : 	}

  00003	c3		 ret	 0
??$_Move@AEAPEAV_Ref_count_base@std@@@std@@YA$$QEAPEAV_Ref_count_base@0@AEAPEAV10@@Z ENDP ; std::_Move<std::_Ref_count_base * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAVVertexStream@gfxu@@@std@@YA$$QEAPEAVVertexStream@gfxu@@AEAPEAV12@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAVVertexStream@gfxu@@@std@@YA$$QEAPEAVVertexStream@gfxu@@AEAPEAV12@@Z PROC ; std::_Move<gfxu::VertexStream * __ptr64 & __ptr64>, COMDAT

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1800 : 	}

  00003	c3		 ret	 0
??$_Move@AEAPEAVVertexStream@gfxu@@@std@@YA$$QEAPEAVVertexStream@gfxu@@AEAPEAV12@@Z ENDP ; std::_Move<gfxu::VertexStream * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocator<std::shared_ptr<ChunkBase> * __ptr64><std::shared_ptr<ChunkBase> >, COMDAT

; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$?0V?$shared_ptr@VChunkBase@@@std@@@?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> * __ptr64>::allocator<std::shared_ptr<ChunkBase> * __ptr64><std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAV?$shared_ptr@VChunkBase@@@0@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAV?$shared_ptr@VChunkBase@@@0@0@Z PROC ; std::_Ptr_cat<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00005	0f b6 44 24 10	 movzx	 eax, BYTE PTR _Cat$[rsp]

; 440  : 	}

  0000a	c3		 ret	 0
??$_Ptr_cat@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PEAPEAV?$shared_ptr@VChunkBase@@@0@0@Z ENDP ; std::_Ptr_cat<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
__formal$dead$ = 72
__formal$dead$ = 80
??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_copy<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 401  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 402  : 	_DEBUG_RANGE(_First, _Last);
; 403  : 	_DEBUG_POINTER(_Dest);
; 404  : 	size_t _Count = (size_t)(_Last - _First);

  00006	48 2b d1	 sub	 rdx, rcx
  00009	49 8b c0	 mov	 rax, r8
  0000c	48 c1 fa 03	 sar	 rdx, 3

; 405  : 	return ((_Ty2 *)_CSTD memmove(&*_Dest, &*_First,
; 406  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

  00010	48 8d 1c d5 00
	00 00 00	 lea	 rbx, QWORD PTR [rdx*8]
  00018	48 8b d1	 mov	 rdx, rcx
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	4c 8b c3	 mov	 r8, rbx
  00021	e8 00 00 00 00	 call	 memmove
  00026	48 03 c3	 add	 rax, rbx

; 407  : 	}

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
??$_Uninit_copy@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@00AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAPEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAPEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@@Z PROC ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64>, COMDAT

; 711  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 712  : 	}

  00002	c3		 ret	 0
??$_Val_type@PEAPEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@@Z ENDP ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
__formal$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 659  : 	{	// copy _Count * _Valty() to raw _First, using _Al, scalar type

$LN12:
  00000	48 83 ec 08	 sub	 rsp, 8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00004	48 85 d2	 test	 rdx, rdx
  00007	74 13		 je	 SHORT $LN5@Uninit_def
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 660  : 	_Fill_n(_First, _Count, (_Valty)0);

  00009	48 89 3c 24	 mov	 QWORD PTR [rsp], rdi
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	33 c0		 xor	 eax, eax
  00012	48 8b ca	 mov	 rcx, rdx
  00015	f3 48 ab	 rep stosq
  00018	48 8b 3c 24	 mov	 rdi, QWORD PTR [rsp]
$LN5@Uninit_def:

; 661  : 	}

  0001c	48 83 c4 08	 add	 rsp, 8
  00020	c3		 ret	 0
??$_Uninit_def_fill_n@PEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@_KAEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_def_fill_n<std::shared_ptr<ChunkBase> * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
__formal$dead$ = 32
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >, COMDAT

; 97   : 	}

  00000	c2 00 00	 ret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> * __ptr64> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@AEBV32@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Val$ = 24
?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@AEBV32@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct, COMDAT

; 605  : 		{	// construct object at _Ptr with value _Val

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN16@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN16@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 607  : 		}

  0002d	f3 c3		 fatret	 0
?construct@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@AEBV32@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
??0?$_Ref_count@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z PROC ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>, COMDAT

; 155  : 		{	// construct

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_Ref_count@VVertexStream@gfxu@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00007	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [rcx+8], 1
  0000e	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 156  : 		}

  00018	48 8b c1	 mov	 rax, rcx
  0001b	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  0001f	c3		 ret	 0
??0?$_Ref_count@VVertexStream@gfxu@@@std@@QEAA@PEAVVertexStream@gfxu@@@Z ENDP ; std::_Ref_count<gfxu::VertexStream>::_Ref_count<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ PROC ; std::_Ref_count<gfxu::VertexStream>::_Destroy, COMDAT

; 161  : 		delete _Ptr;

  00000	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00004	48 85 c9	 test	 rcx, rcx
  00007	74 0b		 je	 SHORT $LN3@Destroy
  00009	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000c	ba 01 00 00 00	 mov	 edx, 1
  00011	48 ff 20	 rex_jmp QWORD PTR [rax]
$LN3@Destroy:

; 162  : 		}

  00014	f3 c3		 fatret	 0
?_Destroy@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ ENDP ; std::_Ref_count<gfxu::VertexStream>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ PROC ; std::_Ref_count<gfxu::VertexStream>::_Delete_this, COMDAT

; 166  : 		delete this;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 0c		 je	 SHORT $LN3@Delete_thi
  00005	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00008	ba 01 00 00 00	 mov	 edx, 1
  0000d	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
$LN3@Delete_thi:

; 167  : 		}

  00011	f3 c3		 fatret	 0
?_Delete_this@?$_Ref_count@VVertexStream@gfxu@@@std@@EEAAXXZ ENDP ; std::_Ref_count<gfxu::VertexStream>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z PROC ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor', COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN8@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN8@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G?$_Ref_count@VVertexStream@gfxu@@@std@@UEAAPEAXI@Z ENDP ; std::_Ref_count<gfxu::VertexStream>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VVertexStream@gfxu@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Ref_count@VVertexStream@gfxu@@@std@@UEAA@XZ PROC	; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>, COMDAT

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1?$_Ref_count@VVertexStream@gfxu@@@std@@UEAA@XZ ENDP	; std::_Ref_count<gfxu::VertexStream>::~_Ref_count<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
_Rx$ = 24
??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>, COMDAT

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00000	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<gfxu::VertexStream>::_Reset0
??$_Resetp0@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@QEAAXPEAVVertexStream@gfxu@@PEAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<gfxu::VertexStream>::_Resetp0<gfxu::VertexStream>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >, COMDAT

; 621  : 		void destroy(_Uty *_Ptr)

$LN19:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00006	48 8b 5a 08	 mov	 rbx, QWORD PTR [rdx+8]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 27		 je	 SHORT $LN14@destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0000f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00013	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00018	75 17		 jne	 SHORT $LN17@destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0001a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001d	48 8b cb	 mov	 rcx, rbx
  00020	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00022	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00026	75 09		 jne	 SHORT $LN17@destroy

; 128  : 			_Delete_this();

  00028	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0002b	48 8b cb	 mov	 rcx, rbx
  0002e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN17@destroy:
  00031	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN14@destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 624  : 		}

  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
??$destroy@V?$shared_ptr@VChunkBase@@@std@@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::destroy<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@_KAEBQEAV10@@Z
_TEXT	SEGMENT
_Dest$ = 8
_Count$ = 16
_Val$ = 24
??$_Fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@_KAEBQEAV10@@Z PROC ; std::_Fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 2678 : 	for (; 0 < _Count; --_Count, ++_Dest)

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 1b		 je	 SHORT $LN9@Fill_n
  00005	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL3@Fill_n:

; 2679 : 		*_Dest = _Val;

  00010	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00013	48 83 c1 08	 add	 rcx, 8
  00017	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax
  0001b	48 ff ca	 dec	 rdx
  0001e	75 f0		 jne	 SHORT $LL3@Fill_n
$LN9@Fill_n:

; 2680 : 	return (_Dest);

  00020	48 8b c1	 mov	 rax, rcx

; 2681 : 	}

  00023	c3		 ret	 0
??$_Fill_n@PEAPEAV?$shared_ptr@VChunkBase@@@std@@_KPEAV12@@std@@YAPEAPEAV?$shared_ptr@VChunkBase@@@0@PEAPEAV10@_KAEBQEAV10@@Z ENDP ; std::_Fill_n<std::shared_ptr<ChunkBase> * __ptr64 * __ptr64,unsigned __int64,std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z PROC	; std::shared_ptr<ChunkBase>::`scalar deleting destructor', COMDAT
$LN20:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 345  : 		if (_Rep != 0)

  0000a	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 85 db	 test	 rbx, rbx
  00014	74 35		 je	 SHORT $LN17@scalar

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00016	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0001a	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001f	75 17		 jne	 SHORT $LN16@scalar

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00021	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00024	48 8b cb	 mov	 rcx, rbx
  00027	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00029	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0002d	75 09		 jne	 SHORT $LN16@scalar

; 128  : 			_Delete_this();

  0002f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00032	48 8b cb	 mov	 rcx, rbx
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
$LN16@scalar:
  00038	48 8b c7	 mov	 rax, rdi
  0003b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00040	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5f		 pop	 rdi
  0004a	c3		 ret	 0
$LN17@scalar:
  0004b	48 8b c1	 mov	 rax, rcx
  0004e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
??_G?$shared_ptr@VChunkBase@@@std@@QEAAPEAXI@Z ENDP	; std::shared_ptr<ChunkBase>::`scalar deleting destructor'
_TEXT	ENDS
END
