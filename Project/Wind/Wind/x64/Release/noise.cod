; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

	ORG $+6
$SG4294895144 DB 'fillNoiseBuffer1d', 00H
	ORG $+6
$SG4294895145 DB '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'i'
	DB	00H, 's', 00H, 'e', 00H, '.', 00H, 'c', 00H, 'l', 00H, 00H, 00H
	ORG $+2
$SG4294895142 DB 'fillNoiseBuffer2d', 00H
	ORG $+6
$SG4294895143 DB 'fillNoiseBufferWithSmoothness1d', 00H
$SG4294895140 DB 'fillNoiseBuffer3d', 00H
	ORG $+6
$SG4294895141 DB 'fillNoiseBufferWithSmoothness2d', 00H
$SG4294895139 DB 'fillNoiseBufferWithSmoothness3d', 00H
PUBLIC	?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z ; Noise::NoiseGenerator3D::initNoise
PUBLIC	?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z ; Noise::NoiseGenerator2D::initNoise
PUBLIC	?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z	; Noise::NoiseGenerator1D::getNoise
PUBLIC	?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z ; Noise::NoiseGenerator1D::initNoise
PUBLIC	?noiseAt@NoiseGenerator1D@Noise@@AEAAEAEAH@Z	; Noise::NoiseGenerator1D::noiseAt
PUBLIC	?interpolate@@YAMM@Z				; interpolate
PUBLIC	?staticInit@Noise@@YAXXZ			; Noise::staticInit
PUBLIC	?getNoise@NoiseGenerator1D@Noise@@QEAAMM@Z	; Noise::NoiseGenerator1D::getNoise
PUBLIC	??1NoiseGenerator1D@Noise@@QEAA@XZ		; Noise::NoiseGenerator1D::~NoiseGenerator1D
PUBLIC	??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z ; Noise::NoiseGenerator1D::NoiseGenerator1D
PUBLIC	?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ; Noise::NoiseGenerator2D::fillNoiseBuffer
PUBLIC	?prepareForCL@NoiseGenerator2D@Noise@@QEAAXXZ	; Noise::NoiseGenerator2D::prepareForCL
PUBLIC	??1NoiseGenerator2D@Noise@@QEAA@XZ		; Noise::NoiseGenerator2D::~NoiseGenerator2D
PUBLIC	??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z		; Noise::NoiseGenerator2D::NoiseGenerator2D
PUBLIC	?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBufferWithSmoothness
PUBLIC	?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBuffer
PUBLIC	?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBuffer
PUBLIC	?prepareForCL@NoiseGenerator3D@Noise@@QEAAXXZ	; Noise::NoiseGenerator3D::prepareForCL
PUBLIC	??1NoiseGenerator3D@Noise@@QEAA@XZ		; Noise::NoiseGenerator3D::~NoiseGenerator3D
PUBLIC	??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z		; Noise::NoiseGenerator3D::NoiseGenerator3D
PUBLIC	?noiseProgram@Noise@@3VProgram@cl@@A		; Noise::noiseProgram
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

?noiseProgram@Noise@@3VProgram@cl@@A DB 038H DUP (?)	; Noise::noiseProgram
ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19+41
	DD	imagerel $LN19+145
	DD	imagerel $chain$0$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19+145
	DD	imagerel $LN19+161
	DD	imagerel $chain$1$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19
	DD	imagerel $LN19+32
	DD	imagerel $unwind$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19+32
	DD	imagerel $LN19+140
	DD	imagerel $chain$0$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19+140
	DD	imagerel $LN19+156
	DD	imagerel $chain$1$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z DD imagerel $LN16
	DD	imagerel $LN16+76
	DD	imagerel $unwind$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z DD imagerel $LN16+76
	DD	imagerel $LN16+338
	DD	imagerel $chain$5$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z DD imagerel $LN16+338
	DD	imagerel $LN16+387
	DD	imagerel $chain$6$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19
	DD	imagerel $LN19+27
	DD	imagerel $unwind$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19+27
	DD	imagerel $LN19+120
	DD	imagerel $chain$0$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z DD imagerel $LN19+120
	DD	imagerel $LN19+136
	DD	imagerel $chain$1$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__EnoiseProgram@Noise@@YAXXZ DD imagerel ??__EnoiseProgram@Noise@@YAXXZ
	DD	imagerel ??__EnoiseProgram@Noise@@YAXXZ+76
	DD	imagerel $unwind$??__EnoiseProgram@Noise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?staticInit@Noise@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+41
	DD	imagerel $unwind$?staticInit@Noise@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1NoiseGenerator1D@Noise@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+32
	DD	imagerel $unwind$??1NoiseGenerator1D@Noise@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z DD imagerel $LN6
	DD	imagerel $LN6+97
	DD	imagerel $unwind$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z DD imagerel $LN53
	DD	imagerel $LN53+446
	DD	imagerel $unwind$?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1NoiseGenerator2D@Noise@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+32
	DD	imagerel $unwind$??1NoiseGenerator2D@Noise@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z DD imagerel $LN48
	DD	imagerel $LN48+414
	DD	imagerel $unwind$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z DD imagerel $LN55
	DD	imagerel $LN55+542
	DD	imagerel $unwind$?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMM@Z DD imagerel $LN4
	DD	imagerel $LN4+121
	DD	imagerel $unwind$?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z DD imagerel $LN53
	DD	imagerel $LN53+531
	DD	imagerel $unwind$?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1NoiseGenerator3D@Noise@@QEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+32
	DD	imagerel $unwind$??1NoiseGenerator3D@Noise@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z DD imagerel $LN48
	DD	imagerel $LN48+419
	DD	imagerel $unwind$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z DD imagerel ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z
	DD	0ffffffffH
	DD	imagerel ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z+95
	DD	00H
	DD	imagerel ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z+379
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0NoiseGenerator3D@Noise@@QEAA@HHMI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z DD 073a19H
	DD	027e6428H
	DD	027d3420H
	DD	027a010fH
	DD	07002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z
	DD	013c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1NoiseGenerator3D@Noise@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z DD 072219H
	DD	01b3414H
	DD	0140114H
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	098H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMM@Z DD 010701H
	DD	0e207H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z DD 072219H
	DD	0183414H
	DD	0140114H
	DD	060077008H
	DD	05006H
	DD	imagerel __GSHandlerCheck
	DD	098H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z DD imagerel ??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z
	DD	0ffffffffH
	DD	imagerel ??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z+95
	DD	00H
	DD	imagerel ??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z+374
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0NoiseGenerator2D@Noise@@QEAA@HHMI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z DD 073a19H
	DD	027e6428H
	DD	027d3420H
	DD	027a010fH
	DD	07002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z
	DD	013c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1NoiseGenerator2D@Noise@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z DD 061401H
	DD	0116414H
	DD	0103414H
	DD	07010d214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z DD imagerel ??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z
	DD	0ffffffffH
	DD	imagerel ??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z+51
	DD	00H
	DD	imagerel ??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z+88
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1NoiseGenerator1D@Noise@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?staticInit@Noise@@YAXXZ DD 010401H
	DD	08204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__EnoiseProgram@Noise@@YAXXZ DD imagerel ??__EnoiseProgram@Noise@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__EnoiseProgram@Noise@@YAXXZ+25
	DD	00H
	DD	imagerel ??__EnoiseProgram@Noise@@YAXXZ+60
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__EnoiseProgram@Noise@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__EnoiseProgram@Noise@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__EnoiseProgram@Noise@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__EnoiseProgram@Noise@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__EnoiseProgram@Noise@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__EnoiseProgram@Noise@@YAXXZ DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__EnoiseProgram@Noise@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+27
	DD	imagerel $unwind$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z DD 020521H
	DD	065405H
	DD	imagerel $LN19
	DD	imagerel $LN19+27
	DD	imagerel $unwind$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+76
	DD	imagerel $unwind$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z DD 0c3821H
	DD	02e838H
	DD	03d820H
	DD	04c811H
	DD	016740cH
	DD	0196408H
	DD	0183404H
	DD	imagerel $LN16
	DD	imagerel $LN16+76
	DD	imagerel $unwind$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z DD 0e3501H
	DD	05b835H
	DD	06a827H
	DD	079822H
	DD	08881dH
	DD	097815H
	DD	0a6811H
	DD	017010aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+32
	DD	imagerel $unwind$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z DD 020521H
	DD	065405H
	DD	imagerel $LN19
	DD	imagerel $LN19+32
	DD	imagerel $unwind$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z DD 021H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z DD 020521H
	DD	065405H
	DD	imagerel $LN19
	DD	imagerel $LN19+41
	DD	imagerel $unwind$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
noiseProgram$initializer$ DQ FLAT:??__EnoiseProgram@Noise@@YAXXZ
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\random
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
$T1 = 40
rand$ = 48
__$ArrayPad$ = 5056
this$ = 5088
sizeExponent$dead$ = 5096
octaves$dead$ = 5104
smoothness$ = 5112
seed$ = 5120
??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z PROC		; Noise::NoiseGenerator3D::NoiseGenerator3D, COMDAT

; 300  : {

$LN48:
  00000	40 57		 push	 rdi
  00002	b8 d0 13 00 00	 mov	 eax, 5072		; 000013d0H
  00007	e8 00 00 00 00	 call	 __chkstk
  0000c	48 2b e0	 sub	 rsp, rax
  0000f	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00018	48 89 9c 24 e8
	13 00 00	 mov	 QWORD PTR [rsp+5096], rbx
  00020	48 89 b4 24 f0
	13 00 00	 mov	 QWORD PTR [rsp+5104], rsi
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002f	48 33 c4	 xor	 rax, rsp
  00032	48 89 84 24 c0
	13 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0003a	48 8b f9	 mov	 rdi, rcx
  0003d	48 89 4c 24 20	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  00042	c7 01 08 00 00
	00		 mov	 DWORD PTR [rcx], 8
  00048	c7 41 04 00 01
	00 00		 mov	 DWORD PTR [rcx+4], 256	; 00000100H
  0004f	c7 41 08 0c 00
	00 00		 mov	 DWORD PTR [rcx+8], 12
  00056	f3 0f 11 59 0c	 movss	 DWORD PTR [rcx+12], xmm3
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 261  : {

  0005b	c6 41 10 00	 mov	 BYTE PTR [rcx+16], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 300  : {

  0005f	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00062	8b c8		 mov	 ecx, eax
  00064	0f af c8	 imul	 ecx, eax
  00067	0f af c8	 imul	 ecx, eax
  0006a	48 63 c9	 movsxd	 rcx, ecx
  0006d	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00072	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp

; 5    : {

  00076	8b 8c 24 00 14
	00 00		 mov	 ecx, DWORD PTR seed$[rsp]
  0007d	89 4c 24 30	 mov	 DWORD PTR rand$[rsp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\random

; 1312 : 		{	// construct with specified seed

  00081	c7 84 24 b8 13
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rand$[rsp+5000], -1 ; ffffffffH

; 1313 : 		seed(_X0, _Fxarg);
; 1314 : 		}
; 1315 : 
; 1316 : 	mersenne_twister(const mersenne_twister& _Right)
; 1317 : 		{	// construct by copying
; 1318 : 		*this = _Right;
; 1319 : 		}
; 1320 : 
; 1321 : 	mersenne_twister(mersenne_twister& _Right)
; 1322 : 		{	// construct by copying
; 1323 : 		*this = _Right;
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Gen>
; 1327 : 		explicit mersenne_twister(_Gen& _Gx)
; 1328 : 		: _Dxval(_WMSK)
; 1329 : 		{	// construct with seed values from generator
; 1330 : 		seed(_Gx);
; 1331 : 		}
; 1332 : 
; 1333 : 	void seed(unsigned long _X0 = default_seed,
; 1334 : 		_Ty _Fx = (_Ty)1812433253)
; 1335 : 		{	// set initial values from specified value
; 1336 : 		_RNG_ASSERT(0 < _X0,
; 1337 : 			"invalid argument for mersenne_twister::seed");
; 1338 : 
; 1339 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  0008c	ba 71 15 00 00	 mov	 edx, 5489		; 00001571H

; 1340 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)

  00091	41 b8 01 00 00
	00		 mov	 r8d, 1
  00097	45 8b c8	 mov	 r9d, r8d
  0009a	4c 8d 54 24 3c	 lea	 r10, QWORD PTR rand$[rsp+12]
  0009f	41 bb 6f 02 00
	00		 mov	 r11d, 623		; 0000026fH
  000a5	41 8b db	 mov	 ebx, r11d
  000a8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL14@NoiseGener:

; 1341 : 			_Prev = this->_Ax[_Ix] =
; 1342 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

  000b0	8b c2		 mov	 eax, edx
  000b2	c1 e8 1e	 shr	 eax, 30
  000b5	33 d0		 xor	 edx, eax
  000b7	69 d2 65 89 07
	6c		 imul	 edx, 1812433253		; 6c078965H
  000bd	41 03 d1	 add	 edx, r9d
  000c0	41 89 12	 mov	 DWORD PTR [r10], edx

; 1340 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)

  000c3	41 ff c1	 inc	 r9d
  000c6	4d 8d 52 04	 lea	 r10, QWORD PTR [r10+4]
  000ca	48 ff cb	 dec	 rbx
  000cd	75 e1		 jne	 SHORT $LL14@NoiseGener

; 1313 : 		seed(_X0, _Fxarg);
; 1314 : 		}
; 1315 : 
; 1316 : 	mersenne_twister(const mersenne_twister& _Right)
; 1317 : 		{	// construct by copying
; 1318 : 		*this = _Right;
; 1319 : 		}
; 1320 : 
; 1321 : 	mersenne_twister(mersenne_twister& _Right)
; 1322 : 		{	// construct by copying
; 1323 : 		*this = _Right;
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Gen>
; 1327 : 		explicit mersenne_twister(_Gen& _Gx)
; 1328 : 		: _Dxval(_WMSK)
; 1329 : 		{	// construct with seed values from generator
; 1330 : 		seed(_Gx);
; 1331 : 		}
; 1332 : 
; 1333 : 	void seed(unsigned long _X0 = default_seed,
; 1334 : 		_Ty _Fx = (_Ty)1812433253)
; 1335 : 		{	// set initial values from specified value
; 1336 : 		_RNG_ASSERT(0 < _X0,
; 1337 : 			"invalid argument for mersenne_twister::seed");
; 1338 : 
; 1339 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  000cf	89 4c 24 38	 mov	 DWORD PTR rand$[rsp+8], ecx
  000d3	48 8d 54 24 3c	 lea	 rdx, QWORD PTR rand$[rsp+12]
  000d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL21@NoiseGener:

; 1341 : 			_Prev = this->_Ax[_Ix] =
; 1342 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

  000e0	8b c1		 mov	 eax, ecx
  000e2	c1 e8 1e	 shr	 eax, 30
  000e5	33 c8		 xor	 ecx, eax
  000e7	69 c9 65 89 07
	6c		 imul	 ecx, 1812433253		; 6c078965H
  000ed	41 03 c8	 add	 ecx, r8d
  000f0	89 0a		 mov	 DWORD PTR [rdx], ecx

; 1340 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)

  000f2	41 ff c0	 inc	 r8d
  000f5	48 8d 52 04	 lea	 rdx, QWORD PTR [rdx+4]
  000f9	49 ff cb	 dec	 r11
  000fc	75 e2		 jne	 SHORT $LL21@NoiseGener

; 1343 : 		this->_Idx = _Nx;

  000fe	c7 44 24 34 70
	02 00 00	 mov	 DWORD PTR rand$[rsp+4], 624 ; 00000270H
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 314  : 	for(int i = 0; i < size * size * size; i += chunk_size)

  00106	33 f6		 xor	 esi, esi
  00108	33 db		 xor	 ebx, ebx
  0010a	8b 47 04	 mov	 eax, DWORD PTR [rdi+4]
  0010d	8b c8		 mov	 ecx, eax
  0010f	0f af c8	 imul	 ecx, eax
  00112	0f af c8	 imul	 ecx, eax
  00115	85 c9		 test	 ecx, ecx
  00117	7e 62		 jle	 SHORT $LN47@NoiseGener
  00119	0f 1f 80 00 00
	00 00		 npad	 7
$LL29@NoiseGener:
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp

; 17   : 	return randomEngine();

  00120	48 8d 4c 24 34	 lea	 rcx, QWORD PTR rand$[rsp+4]
  00125	e8 00 00 00 00	 call	 ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
  0012a	44 8b c0	 mov	 r8d, eax
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 317  : 		for(int j = 0; j < chunk_size; j++)

  0012d	45 33 c9	 xor	 r9d, r9d
$LL26@NoiseGener:

; 318  : 		{
; 319  : 			noiseMap[i + j] = r & 0x1;

  00130	41 0f b6 d0	 movzx	 edx, r8b
  00134	80 e2 01	 and	 dl, 1
  00137	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0013b	48 03 cb	 add	 rcx, rbx
  0013e	42 88 14 09	 mov	 BYTE PTR [rcx+r9], dl

; 320  : 			r >>= 1;

  00142	41 d1 e8	 shr	 r8d, 1

; 318  : 		{
; 319  : 			noiseMap[i + j] = r & 0x1;

  00145	41 0f b6 d0	 movzx	 edx, r8b
  00149	80 e2 01	 and	 dl, 1
  0014c	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00150	48 03 cb	 add	 rcx, rbx
  00153	42 88 54 09 01	 mov	 BYTE PTR [rcx+r9+1], dl

; 320  : 			r >>= 1;

  00158	41 d1 e8	 shr	 r8d, 1
  0015b	49 83 c1 02	 add	 r9, 2

; 317  : 		for(int j = 0; j < chunk_size; j++)

  0015f	49 83 f9 20	 cmp	 r9, 32			; 00000020H
  00163	7c cb		 jl	 SHORT $LL26@NoiseGener

; 314  : 	for(int i = 0; i < size * size * size; i += chunk_size)

  00165	83 c6 20	 add	 esi, 32			; 00000020H
  00168	48 83 c3 20	 add	 rbx, 32			; 00000020H
  0016c	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  0016f	8b d1		 mov	 edx, ecx
  00171	0f af d1	 imul	 edx, ecx
  00174	0f af d1	 imul	 edx, ecx
  00177	3b f2		 cmp	 esi, edx
  00179	7c a5		 jl	 SHORT $LL29@NoiseGener
$LN47@NoiseGener:

; 301  : 	Random rand(seed);
; 302  : 	initNoise(rand);
; 303  : }

  0017b	48 8b c7	 mov	 rax, rdi
  0017e	48 8b 8c 24 c0
	13 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00186	48 33 cc	 xor	 rcx, rsp
  00189	e8 00 00 00 00	 call	 __security_check_cookie
  0018e	4c 8d 9c 24 d0
	13 00 00	 lea	 r11, QWORD PTR [rsp+5072]
  00196	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  0019a	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  0019e	49 8b e3	 mov	 rsp, r11
  001a1	5f		 pop	 rdi
  001a2	c3		 ret	 0
??0NoiseGenerator3D@Noise@@QEAA@HHMI@Z ENDP		; Noise::NoiseGenerator3D::NoiseGenerator3D
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
$T1 = 40
rand$ = 48
__$ArrayPad$ = 5056
this$ = 5088
sizeExponent$dead$ = 5096
octaves$dead$ = 5104
smoothness$ = 5112
seed$ = 5120
?dtor$0@?0???0NoiseGenerator3D@Noise@@QEAA@HHMI@Z@4HA PROC ; `Noise::NoiseGenerator3D::NoiseGenerator3D'::`1'::dtor$0
  00000	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 83 c1 10	 add	 rcx, 16
  0000b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$0@?0???0NoiseGenerator3D@Noise@@QEAA@HHMI@Z@4HA ENDP ; `Noise::NoiseGenerator3D::NoiseGenerator3D'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??1NoiseGenerator3D@Noise@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1NoiseGenerator3D@Noise@@QEAA@XZ PROC			; Noise::NoiseGenerator3D::~NoiseGenerator3D, COMDAT

; 326  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 327  : 	delete[] noiseMap;

  00009	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0000d	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 328  : }

  00012	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??1NoiseGenerator3D@Noise@@QEAA@XZ ENDP			; Noise::NoiseGenerator3D::~NoiseGenerator3D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?prepareForCL@NoiseGenerator3D@Noise@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?prepareForCL@NoiseGenerator3D@Noise@@QEAAXXZ PROC	; Noise::NoiseGenerator3D::prepareForCL, COMDAT

; 392  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00000	48 63 41 04	 movsxd	 rax, DWORD PTR [rcx+4]
  00004	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  00008	48 83 c1 10	 add	 rcx, 16
  0000c	48 8b d0	 mov	 rdx, rax
  0000f	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  00015	48 0f af d0	 imul	 rdx, rax
  00019	48 0f af d0	 imul	 rdx, rax
  0001d	e9 00 00 00 00	 jmp	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
?prepareForCL@NoiseGenerator3D@Noise@@QEAAXXZ ENDP	; Noise::NoiseGenerator3D::prepareForCL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z
_TEXT	SEGMENT
zs$ = 48
xs$GSCopy$ = 56
ys$ = 64
$T1 = 72
local_ws$ = 104
global_ws$ = 128
__$ArrayPad$ = 152
this$ = 192
queue$ = 200
buffer$ = 208
xs$dead$ = 216
ys$dead$ = 224
zs$dead$ = 232
smoothness$ = 240
x$ = 248
y$ = 256
z$ = 264
xd$ = 272
yd$ = 280
zd$ = 288
?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z PROC ; Noise::NoiseGenerator3D::fillNoiseBuffer, COMDAT

; 401  : {

$LN53:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 8d 6c 24 f9	 lea	 rbp, QWORD PTR [rsp-7]
  0000d	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 45 ff	 mov	 QWORD PTR __$ArrayPad$[rbp-153], rax
  00022	48 8b f2	 mov	 rsi, rdx
  00025	48 8b f9	 mov	 rdi, rcx
  00028	49 8b d8	 mov	 rbx, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294895140
  00032	48 8d 4d af	 lea	 rcx, QWORD PTR $T1[rbp-153]
  00036	41 b8 11 00 00
	00		 mov	 r8d, 17
  0003c	c7 45 97 12 00
	00 00		 mov	 DWORD PTR zs$[rbp-153], 18
  00043	c7 45 a7 12 00
	00 00		 mov	 DWORD PTR ys$[rbp-153], 18
  0004a	c7 45 9f 12 00
	00 00		 mov	 DWORD PTR xs$GSCopy$[rbp-153], 18
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 402  : 	const size_t local_ws[] = {1, 1, 1};

  00051	48 c7 45 cf 01
	00 00 00	 mov	 QWORD PTR local_ws$[rbp-153], 1
  00059	48 c7 45 d7 01
	00 00 00	 mov	 QWORD PTR local_ws$[rbp-145], 1
  00061	48 c7 45 df 01
	00 00 00	 mov	 QWORD PTR local_ws$[rbp-137], 1

; 403  : 	const size_t global_ws[] = {xs, ys, zs};

  00069	48 c7 45 e7 12
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-153], 18
  00071	48 c7 45 ef 12
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-145], 18
  00079	48 c7 45 f7 12
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-137], 18
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00081	48 c7 45 c7 0f
	00 00 00	 mov	 QWORD PTR $T1[rbp-129], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00089	48 c7 45 bf 00
	00 00 00	 mov	 QWORD PTR $T1[rbp-137], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00091	c6 45 af 00	 mov	 BYTE PTR $T1[rbp-153], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00095	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 405  : 	noiseProgram.prepare("fillNoiseBuffer3d");

  0009a	48 8d 55 af	 lea	 rdx, QWORD PTR $T1[rbp-153]
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000a5	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  000aa	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000b5	ba 08 00 00 00	 mov	 edx, 8
  000ba	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  000bf	4c 8d 47 18	 lea	 r8, QWORD PTR [rdi+24]
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000ca	ba 08 00 00 00	 mov	 edx, 8
  000cf	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 408  : 	noiseProgram.setArgument(sizeof(unsigned int), &sizeExponent);

  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000db	4c 8b c7	 mov	 r8, rdi
  000de	ba 04 00 00 00	 mov	 edx, 4
  000e3	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 409  : 	noiseProgram.setArgument(sizeof(float), &smoothness);

  000e8	4c 8d 45 57	 lea	 r8, QWORD PTR smoothness$[rbp-153]
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000f3	ba 04 00 00 00	 mov	 edx, 4
  000f8	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 410  : 	noiseProgram.setArgument(sizeof(unsigned int), &octaves);

  000fd	4c 8d 47 08	 lea	 r8, QWORD PTR [rdi+8]
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00108	ba 04 00 00 00	 mov	 edx, 4
  0010d	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 411  : 	noiseProgram.setArgument(sizeof(float), &x);

  00112	4c 8d 45 5f	 lea	 r8, QWORD PTR x$[rbp-153]
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0011d	ba 04 00 00 00	 mov	 edx, 4
  00122	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 412  : 	noiseProgram.setArgument(sizeof(float), &y);

  00127	4c 8d 45 67	 lea	 r8, QWORD PTR y$[rbp-153]
  0012b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00132	ba 04 00 00 00	 mov	 edx, 4
  00137	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 413  : 	noiseProgram.setArgument(sizeof(float), &z);

  0013c	4c 8d 45 6f	 lea	 r8, QWORD PTR z$[rbp-153]
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00147	ba 04 00 00 00	 mov	 edx, 4
  0014c	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 414  : 	noiseProgram.setArgument(sizeof(float), &xd);

  00151	4c 8d 45 77	 lea	 r8, QWORD PTR xd$[rbp-153]
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0015c	ba 04 00 00 00	 mov	 edx, 4
  00161	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 415  : 	noiseProgram.setArgument(sizeof(float), &yd);

  00166	4c 8d 45 7f	 lea	 r8, QWORD PTR yd$[rbp-153]
  0016a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00171	ba 04 00 00 00	 mov	 edx, 4
  00176	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 416  : 	noiseProgram.setArgument(sizeof(float), &zd);

  0017b	4c 8d 85 87 00
	00 00		 lea	 r8, QWORD PTR zd$[rbp-153]
  00182	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00189	ba 04 00 00 00	 mov	 edx, 4
  0018e	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 417  : 	noiseProgram.setArgument(sizeof(unsigned int), &xs);

  00193	4c 8d 45 9f	 lea	 r8, QWORD PTR xs$GSCopy$[rbp-153]
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0019e	ba 04 00 00 00	 mov	 edx, 4
  001a3	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 418  : 	noiseProgram.setArgument(sizeof(unsigned int), &ys);

  001a8	4c 8d 45 a7	 lea	 r8, QWORD PTR ys$[rbp-153]
  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  001b3	ba 04 00 00 00	 mov	 edx, 4
  001b8	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 419  : 	noiseProgram.setArgument(sizeof(unsigned int), &zs);

  001bd	4c 8d 45 97	 lea	 r8, QWORD PTR zs$[rbp-153]
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  001c8	ba 04 00 00 00	 mov	 edx, 4
  001cd	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 420  : 	noiseProgram.invoke(queue, 3, global_ws, local_ws);

  001d2	48 8d 45 cf	 lea	 rax, QWORD PTR local_ws$[rbp-153]
  001d6	4c 8d 4d e7	 lea	 r9, QWORD PTR global_ws$[rbp-153]
  001da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  001e6	41 b8 03 00 00
	00		 mov	 r8d, 3
  001ec	48 8b d6	 mov	 rdx, rsi
  001ef	e8 00 00 00 00	 call	 ?invoke@Program@cl@@QEAA_NAEAVCommandQueue@2@IPEB_K1@Z ; cl::Program::invoke

; 421  : }

  001f4	48 8b 4d ff	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-153]
  001f8	48 33 cc	 xor	 rcx, rsp
  001fb	e8 00 00 00 00	 call	 __security_check_cookie
  00200	48 8b 9c 24 d8
	00 00 00	 mov	 rbx, QWORD PTR [rsp+216]
  00208	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0020f	5f		 pop	 rdi
  00210	5e		 pop	 rsi
  00211	5d		 pop	 rbp
  00212	c3		 ret	 0
?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z ENDP ; Noise::NoiseGenerator3D::fillNoiseBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMM@Z
_TEXT	SEGMENT
this$dead$ = 128
queue$ = 136
buffer$ = 144
xs$dead$ = 152
ys$dead$ = 160
zs$dead$ = 168
x$ = 176
y$ = 184
z$ = 192
xd$ = 200
yd$ = 208
zd$ = 216
?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMM@Z PROC ; Noise::NoiseGenerator3D::fillNoiseBuffer, COMDAT

; 396  : {

$LN4:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 397  : 	fillNoiseBuffer(queue, buffer, xs, ys, zs, smoothness, x, y, z, xd, yd, zd);

  00007	f3 0f 10 84 24
	d8 00 00 00	 movss	 xmm0, DWORD PTR zd$[rsp]
  00010	f3 0f 10 8c 24
	d0 00 00 00	 movss	 xmm1, DWORD PTR yd$[rsp]
  00019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::smoothnessNoise
  00020	f3 0f 11 40 e8	 movss	 DWORD PTR [rax-24], xmm0
  00025	f3 0f 10 84 24
	c8 00 00 00	 movss	 xmm0, DWORD PTR xd$[rsp]
  0002e	f3 0f 11 48 e0	 movss	 DWORD PTR [rax-32], xmm1
  00033	f3 0f 10 8c 24
	c0 00 00 00	 movss	 xmm1, DWORD PTR z$[rsp]
  0003c	f3 0f 11 40 d8	 movss	 DWORD PTR [rax-40], xmm0
  00041	f3 0f 10 84 24
	b8 00 00 00	 movss	 xmm0, DWORD PTR y$[rsp]
  0004a	f3 0f 11 48 d0	 movss	 DWORD PTR [rax-48], xmm1
  0004f	f3 0f 10 8c 24
	b0 00 00 00	 movss	 xmm1, DWORD PTR x$[rsp]
  00058	f3 0f 11 40 c8	 movss	 DWORD PTR [rax-56], xmm0
  0005d	f3 0f 10 05 0c
	00 00 00	 movss	 xmm0, DWORD PTR ?smoothnessNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+12
  00065	f3 0f 11 48 c0	 movss	 DWORD PTR [rax-64], xmm1
  0006a	f3 0f 11 40 b8	 movss	 DWORD PTR [rax-72], xmm0
  0006f	e8 00 00 00 00	 call	 ?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMMM@Z ; Noise::NoiseGenerator3D::fillNoiseBuffer

; 398  : }

  00074	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00078	c3		 ret	 0
?fillNoiseBuffer@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIIMMMMMM@Z ENDP ; Noise::NoiseGenerator3D::fillNoiseBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z
_TEXT	SEGMENT
zs$ = 48
xs$GSCopy$ = 56
ys$ = 64
$T1 = 72
local_ws$ = 104
global_ws$ = 128
__$ArrayPad$ = 152
this$dead$ = 192
queue$ = 200
buffer$ = 208
xs$dead$ = 216
ys$dead$ = 224
zs$dead$ = 232
smoothness$ = 240
x$ = 248
y$ = 256
z$ = 264
xd$ = 272
yd$ = 280
zd$ = 288
?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z PROC ; Noise::NoiseGenerator3D::fillNoiseBufferWithSmoothness, COMDAT

; 424  : {

$LN55:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 8d 6c 24 f9	 lea	 rbp, QWORD PTR [rsp-7]
  0000d	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 45 ff	 mov	 QWORD PTR __$ArrayPad$[rbp-153], rax
  00022	48 8b 7d 57	 mov	 rdi, QWORD PTR smoothness$[rbp-153]
  00026	48 8b f2	 mov	 rsi, rdx
  00029	49 8b d8	 mov	 rbx, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294895139
  00033	48 8d 4d af	 lea	 rcx, QWORD PTR $T1[rbp-153]
  00037	41 b8 1f 00 00
	00		 mov	 r8d, 31
  0003d	c7 45 97 12 00
	00 00		 mov	 DWORD PTR zs$[rbp-153], 18
  00044	c7 45 a7 12 00
	00 00		 mov	 DWORD PTR ys$[rbp-153], 18
  0004b	c7 45 9f 12 00
	00 00		 mov	 DWORD PTR xs$GSCopy$[rbp-153], 18
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 425  : 	const size_t local_ws[] = {1, 1, 1};

  00052	48 c7 45 cf 01
	00 00 00	 mov	 QWORD PTR local_ws$[rbp-153], 1
  0005a	48 c7 45 d7 01
	00 00 00	 mov	 QWORD PTR local_ws$[rbp-145], 1
  00062	48 c7 45 df 01
	00 00 00	 mov	 QWORD PTR local_ws$[rbp-137], 1

; 426  : 	const size_t global_ws[] = {xs, ys, zs};

  0006a	48 c7 45 e7 12
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-153], 18
  00072	48 c7 45 ef 12
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-145], 18
  0007a	48 c7 45 f7 12
	00 00 00	 mov	 QWORD PTR global_ws$[rbp-137], 18
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00082	48 c7 45 c7 0f
	00 00 00	 mov	 QWORD PTR $T1[rbp-129], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0008a	48 c7 45 bf 00
	00 00 00	 mov	 QWORD PTR $T1[rbp-137], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00092	c6 45 af 00	 mov	 BYTE PTR $T1[rbp-153], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00096	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 428  : 	noiseProgram.prepare("fillNoiseBufferWithSmoothness3d");

  0009b	48 8d 55 af	 lea	 rdx, QWORD PTR $T1[rbp-153]
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000a6	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  000ab	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000b6	ba 08 00 00 00	 mov	 edx, 8
  000bb	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  000c0	4c 8d 05 18 00
	00 00		 lea	 r8, OFFSET FLAT:?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000ce	ba 08 00 00 00	 mov	 edx, 8
  000d3	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 431  : 	noiseProgram.setArgument(sizeof(unsigned int), &sizeExponent);

  000d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A ; ChunkLoadThread::solidNoise
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000e6	ba 04 00 00 00	 mov	 edx, 4
  000eb	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  000f0	4c 8d 47 08	 lea	 r8, QWORD PTR [rdi+8]
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000fb	ba 08 00 00 00	 mov	 edx, 8
  00100	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 433  : 	noiseProgram.setArgument(sizeof(unsigned int), &octaves);

  00105	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:?solidNoise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+8
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00113	ba 04 00 00 00	 mov	 edx, 4
  00118	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 434  : 	noiseProgram.setArgument(sizeof(float), &x);

  0011d	4c 8d 45 5f	 lea	 r8, QWORD PTR x$[rbp-153]
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00128	ba 04 00 00 00	 mov	 edx, 4
  0012d	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 435  : 	noiseProgram.setArgument(sizeof(float), &y);

  00132	4c 8d 45 67	 lea	 r8, QWORD PTR y$[rbp-153]
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0013d	ba 04 00 00 00	 mov	 edx, 4
  00142	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 436  : 	noiseProgram.setArgument(sizeof(float), &z);

  00147	4c 8d 45 6f	 lea	 r8, QWORD PTR z$[rbp-153]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00152	ba 04 00 00 00	 mov	 edx, 4
  00157	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 437  : 	noiseProgram.setArgument(sizeof(float), &xd);

  0015c	4c 8d 45 77	 lea	 r8, QWORD PTR xd$[rbp-153]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00167	ba 04 00 00 00	 mov	 edx, 4
  0016c	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 438  : 	noiseProgram.setArgument(sizeof(float), &yd);

  00171	4c 8d 45 7f	 lea	 r8, QWORD PTR yd$[rbp-153]
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0017c	ba 04 00 00 00	 mov	 edx, 4
  00181	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 439  : 	noiseProgram.setArgument(sizeof(float), &zd);

  00186	4c 8d 85 87 00
	00 00		 lea	 r8, QWORD PTR zd$[rbp-153]
  0018d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00194	ba 04 00 00 00	 mov	 edx, 4
  00199	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 440  : 	noiseProgram.setArgument(sizeof(unsigned int), &xs);

  0019e	4c 8d 45 9f	 lea	 r8, QWORD PTR xs$GSCopy$[rbp-153]
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  001a9	ba 04 00 00 00	 mov	 edx, 4
  001ae	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 441  : 	noiseProgram.setArgument(sizeof(unsigned int), &ys);

  001b3	4c 8d 45 a7	 lea	 r8, QWORD PTR ys$[rbp-153]
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  001be	ba 04 00 00 00	 mov	 edx, 4
  001c3	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 442  : 	noiseProgram.setArgument(sizeof(unsigned int), &zs);

  001c8	4c 8d 45 97	 lea	 r8, QWORD PTR zs$[rbp-153]
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  001d3	ba 04 00 00 00	 mov	 edx, 4
  001d8	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 443  : 	noiseProgram.invoke(queue, 3, global_ws, local_ws);

  001dd	48 8d 45 cf	 lea	 rax, QWORD PTR local_ws$[rbp-153]
  001e1	4c 8d 4d e7	 lea	 r9, QWORD PTR global_ws$[rbp-153]
  001e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  001f1	41 b8 03 00 00
	00		 mov	 r8d, 3
  001f7	48 8b d6	 mov	 rdx, rsi
  001fa	e8 00 00 00 00	 call	 ?invoke@Program@cl@@QEAA_NAEAVCommandQueue@2@IPEB_K1@Z ; cl::Program::invoke

; 444  : }

  001ff	48 8b 4d ff	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-153]
  00203	48 33 cc	 xor	 rcx, rsp
  00206	e8 00 00 00 00	 call	 __security_check_cookie
  0020b	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
  00213	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  0021a	5f		 pop	 rdi
  0021b	5e		 pop	 rsi
  0021c	5d		 pop	 rbp
  0021d	c3		 ret	 0
?fillNoiseBufferWithSmoothness@NoiseGenerator3D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@III1MMMMMM@Z ENDP ; Noise::NoiseGenerator3D::fillNoiseBufferWithSmoothness
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\random
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
$T1 = 40
rand$ = 48
__$ArrayPad$ = 5056
this$ = 5088
sizeExponent$dead$ = 5096
octaves$dead$ = 5104
smoothness$ = 5112
seed$ = 5120
??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z PROC		; Noise::NoiseGenerator2D::NoiseGenerator2D, COMDAT

; 160  : {

$LN48:
  00000	40 57		 push	 rdi
  00002	b8 d0 13 00 00	 mov	 eax, 5072		; 000013d0H
  00007	e8 00 00 00 00	 call	 __chkstk
  0000c	48 2b e0	 sub	 rsp, rax
  0000f	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00018	48 89 9c 24 e8
	13 00 00	 mov	 QWORD PTR [rsp+5096], rbx
  00020	48 89 b4 24 f0
	13 00 00	 mov	 QWORD PTR [rsp+5104], rsi
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002f	48 33 c4	 xor	 rax, rsp
  00032	48 89 84 24 c0
	13 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  0003a	48 8b f9	 mov	 rdi, rcx
  0003d	48 89 4c 24 20	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  00042	c7 01 08 00 00
	00		 mov	 DWORD PTR [rcx], 8
  00048	c7 41 04 00 01
	00 00		 mov	 DWORD PTR [rcx+4], 256	; 00000100H
  0004f	c7 41 08 0c 00
	00 00		 mov	 DWORD PTR [rcx+8], 12
  00056	f3 0f 11 59 0c	 movss	 DWORD PTR [rcx+12], xmm3
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 261  : {

  0005b	c6 41 10 00	 mov	 BYTE PTR [rcx+16], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 160  : {

  0005f	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00062	0f af c0	 imul	 eax, eax
  00065	48 63 c8	 movsxd	 rcx, eax
  00068	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  0006d	48 89 47 28	 mov	 QWORD PTR [rdi+40], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp

; 5    : {

  00071	8b 8c 24 00 14
	00 00		 mov	 ecx, DWORD PTR seed$[rsp]
  00078	89 4c 24 30	 mov	 DWORD PTR rand$[rsp], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\random

; 1312 : 		{	// construct with specified seed

  0007c	c7 84 24 b8 13
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rand$[rsp+5000], -1 ; ffffffffH

; 1313 : 		seed(_X0, _Fxarg);
; 1314 : 		}
; 1315 : 
; 1316 : 	mersenne_twister(const mersenne_twister& _Right)
; 1317 : 		{	// construct by copying
; 1318 : 		*this = _Right;
; 1319 : 		}
; 1320 : 
; 1321 : 	mersenne_twister(mersenne_twister& _Right)
; 1322 : 		{	// construct by copying
; 1323 : 		*this = _Right;
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Gen>
; 1327 : 		explicit mersenne_twister(_Gen& _Gx)
; 1328 : 		: _Dxval(_WMSK)
; 1329 : 		{	// construct with seed values from generator
; 1330 : 		seed(_Gx);
; 1331 : 		}
; 1332 : 
; 1333 : 	void seed(unsigned long _X0 = default_seed,
; 1334 : 		_Ty _Fx = (_Ty)1812433253)
; 1335 : 		{	// set initial values from specified value
; 1336 : 		_RNG_ASSERT(0 < _X0,
; 1337 : 			"invalid argument for mersenne_twister::seed");
; 1338 : 
; 1339 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00087	ba 71 15 00 00	 mov	 edx, 5489		; 00001571H

; 1340 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)

  0008c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00092	45 8b c8	 mov	 r9d, r8d
  00095	4c 8d 54 24 3c	 lea	 r10, QWORD PTR rand$[rsp+12]
  0009a	41 bb 6f 02 00
	00		 mov	 r11d, 623		; 0000026fH
  000a0	41 8b db	 mov	 ebx, r11d
  000a3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL14@NoiseGener:

; 1341 : 			_Prev = this->_Ax[_Ix] =
; 1342 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

  000b0	8b c2		 mov	 eax, edx
  000b2	c1 e8 1e	 shr	 eax, 30
  000b5	33 d0		 xor	 edx, eax
  000b7	69 d2 65 89 07
	6c		 imul	 edx, 1812433253		; 6c078965H
  000bd	41 03 d1	 add	 edx, r9d
  000c0	41 89 12	 mov	 DWORD PTR [r10], edx

; 1340 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)

  000c3	41 ff c1	 inc	 r9d
  000c6	4d 8d 52 04	 lea	 r10, QWORD PTR [r10+4]
  000ca	48 ff cb	 dec	 rbx
  000cd	75 e1		 jne	 SHORT $LL14@NoiseGener

; 1313 : 		seed(_X0, _Fxarg);
; 1314 : 		}
; 1315 : 
; 1316 : 	mersenne_twister(const mersenne_twister& _Right)
; 1317 : 		{	// construct by copying
; 1318 : 		*this = _Right;
; 1319 : 		}
; 1320 : 
; 1321 : 	mersenne_twister(mersenne_twister& _Right)
; 1322 : 		{	// construct by copying
; 1323 : 		*this = _Right;
; 1324 : 		}
; 1325 : 
; 1326 : 	template<class _Gen>
; 1327 : 		explicit mersenne_twister(_Gen& _Gx)
; 1328 : 		: _Dxval(_WMSK)
; 1329 : 		{	// construct with seed values from generator
; 1330 : 		seed(_Gx);
; 1331 : 		}
; 1332 : 
; 1333 : 	void seed(unsigned long _X0 = default_seed,
; 1334 : 		_Ty _Fx = (_Ty)1812433253)
; 1335 : 		{	// set initial values from specified value
; 1336 : 		_RNG_ASSERT(0 < _X0,
; 1337 : 			"invalid argument for mersenne_twister::seed");
; 1338 : 
; 1339 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  000cf	89 4c 24 38	 mov	 DWORD PTR rand$[rsp+8], ecx
  000d3	48 8d 54 24 3c	 lea	 rdx, QWORD PTR rand$[rsp+12]
  000d8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL21@NoiseGener:

; 1341 : 			_Prev = this->_Ax[_Ix] =
; 1342 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;

  000e0	8b c1		 mov	 eax, ecx
  000e2	c1 e8 1e	 shr	 eax, 30
  000e5	33 c8		 xor	 ecx, eax
  000e7	69 c9 65 89 07
	6c		 imul	 ecx, 1812433253		; 6c078965H
  000ed	41 03 c8	 add	 ecx, r8d
  000f0	89 0a		 mov	 DWORD PTR [rdx], ecx

; 1340 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)

  000f2	41 ff c0	 inc	 r8d
  000f5	48 8d 52 04	 lea	 rdx, QWORD PTR [rdx+4]
  000f9	49 ff cb	 dec	 r11
  000fc	75 e2		 jne	 SHORT $LL21@NoiseGener

; 1343 : 		this->_Idx = _Nx;

  000fe	c7 44 24 34 70
	02 00 00	 mov	 DWORD PTR rand$[rsp+4], 624 ; 00000270H
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 174  : 	for(int i = 0; i < size * size; i += chunk_size)

  00106	33 f6		 xor	 esi, esi
  00108	33 db		 xor	 ebx, ebx
  0010a	8b 47 04	 mov	 eax, DWORD PTR [rdi+4]
  0010d	0f af c0	 imul	 eax, eax
  00110	85 c0		 test	 eax, eax
  00112	7e 62		 jle	 SHORT $LN47@NoiseGener
$LL29@NoiseGener:
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp

; 17   : 	return randomEngine();

  00114	48 8d 4c 24 34	 lea	 rcx, QWORD PTR rand$[rsp+4]
  00119	e8 00 00 00 00	 call	 ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
  0011e	44 8b c0	 mov	 r8d, eax
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 177  : 		for(int j = 0; j < chunk_size; j++)

  00121	45 33 c9	 xor	 r9d, r9d
  00124	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL26@NoiseGener:

; 178  : 		{
; 179  : 			noiseMap[i + j] = r & 0x1;

  00130	41 0f b6 d0	 movzx	 edx, r8b
  00134	80 e2 01	 and	 dl, 1
  00137	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0013b	48 03 cb	 add	 rcx, rbx
  0013e	42 88 14 09	 mov	 BYTE PTR [rcx+r9], dl

; 180  : 			r >>= 1;

  00142	41 d1 e8	 shr	 r8d, 1

; 178  : 		{
; 179  : 			noiseMap[i + j] = r & 0x1;

  00145	41 0f b6 d0	 movzx	 edx, r8b
  00149	80 e2 01	 and	 dl, 1
  0014c	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00150	48 03 cb	 add	 rcx, rbx
  00153	42 88 54 09 01	 mov	 BYTE PTR [rcx+r9+1], dl

; 180  : 			r >>= 1;

  00158	41 d1 e8	 shr	 r8d, 1
  0015b	49 83 c1 02	 add	 r9, 2

; 177  : 		for(int j = 0; j < chunk_size; j++)

  0015f	49 83 f9 20	 cmp	 r9, 32			; 00000020H
  00163	7c cb		 jl	 SHORT $LL26@NoiseGener

; 174  : 	for(int i = 0; i < size * size; i += chunk_size)

  00165	83 c6 20	 add	 esi, 32			; 00000020H
  00168	48 83 c3 20	 add	 rbx, 32			; 00000020H
  0016c	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  0016f	0f af c9	 imul	 ecx, ecx
  00172	3b f1		 cmp	 esi, ecx
  00174	7c 9e		 jl	 SHORT $LL29@NoiseGener
$LN47@NoiseGener:

; 161  : 	Random rand(seed);
; 162  : 	initNoise(rand);
; 163  : }

  00176	48 8b c7	 mov	 rax, rdi
  00179	48 8b 8c 24 c0
	13 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00181	48 33 cc	 xor	 rcx, rsp
  00184	e8 00 00 00 00	 call	 __security_check_cookie
  00189	4c 8d 9c 24 d0
	13 00 00	 lea	 r11, QWORD PTR [rsp+5072]
  00191	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  00195	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  00199	49 8b e3	 mov	 rsp, r11
  0019c	5f		 pop	 rdi
  0019d	c3		 ret	 0
??0NoiseGenerator2D@Noise@@QEAA@HHMI@Z ENDP		; Noise::NoiseGenerator2D::NoiseGenerator2D
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
$T1 = 40
rand$ = 48
__$ArrayPad$ = 5056
this$ = 5088
sizeExponent$dead$ = 5096
octaves$dead$ = 5104
smoothness$ = 5112
seed$ = 5120
?dtor$0@?0???0NoiseGenerator2D@Noise@@QEAA@HHMI@Z@4HA PROC ; `Noise::NoiseGenerator2D::NoiseGenerator2D'::`1'::dtor$0
  00000	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 83 c1 10	 add	 rcx, 16
  0000b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$0@?0???0NoiseGenerator2D@Noise@@QEAA@HHMI@Z@4HA ENDP ; `Noise::NoiseGenerator2D::NoiseGenerator2D'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??1NoiseGenerator2D@Noise@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1NoiseGenerator2D@Noise@@QEAA@XZ PROC			; Noise::NoiseGenerator2D::~NoiseGenerator2D, COMDAT

; 186  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 187  : 	delete[] noiseMap;

  00009	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0000d	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 188  : }

  00012	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??1NoiseGenerator2D@Noise@@QEAA@XZ ENDP			; Noise::NoiseGenerator2D::~NoiseGenerator2D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?prepareForCL@NoiseGenerator2D@Noise@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?prepareForCL@NoiseGenerator2D@Noise@@QEAAXXZ PROC	; Noise::NoiseGenerator2D::prepareForCL, COMDAT

; 239  : 	noiseMapBuffer.create(sizeof(unsigned char) * size * size, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, noiseMap);

  00000	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]
  00004	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  00008	48 83 c1 10	 add	 rcx, 16
  0000c	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  00012	48 0f af d2	 imul	 rdx, rdx
  00016	e9 00 00 00 00	 jmp	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
?prepareForCL@NoiseGenerator2D@Noise@@QEAAXXZ ENDP	; Noise::NoiseGenerator2D::prepareForCL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z
_TEXT	SEGMENT
local_ws$ = 48
global_ws$ = 64
$T1 = 80
this$ = 128
queue$ = 136
buffer$ = 144
xs$dead$ = 152
xs$ = 152
ys$dead$ = 160
ys$ = 160
smoothness$ = 168
x$ = 176
y$ = 184
xd$ = 192
yd$ = 200
?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z PROC ; Noise::NoiseGenerator2D::fillNoiseBuffer, COMDAT

; 248  : {

$LN53:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	44 89 48 20	 mov	 DWORD PTR [rax+32], r9d
  0000f	57		 push	 rdi
  00010	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00014	48 8b f2	 mov	 rsi, rdx
  00017	48 8b f9	 mov	 rdi, rcx
  0001a	49 8b d8	 mov	 rbx, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294895142
  00024	48 8d 48 d8	 lea	 rcx, QWORD PTR [rax-40]
  00028	41 b8 11 00 00
	00		 mov	 r8d, 17
  0002e	c7 40 28 12 00
	00 00		 mov	 DWORD PTR [rax+40], 18
  00035	c7 40 20 12 00
	00 00		 mov	 DWORD PTR [rax+32], 18
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 249  : 	const size_t local_ws[] = {1, 1};

  0003c	48 c7 40 b8 01
	00 00 00	 mov	 QWORD PTR [rax-72], 1
  00044	48 c7 40 c0 01
	00 00 00	 mov	 QWORD PTR [rax-64], 1

; 250  : 	const size_t global_ws[] = {xs, ys};

  0004c	48 c7 40 c8 12
	00 00 00	 mov	 QWORD PTR [rax-56], 18
  00054	48 c7 40 d0 12
	00 00 00	 mov	 QWORD PTR [rax-48], 18
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0005c	48 c7 40 f0 0f
	00 00 00	 mov	 QWORD PTR [rax-16], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00064	48 c7 40 e8 00
	00 00 00	 mov	 QWORD PTR [rax-24], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0006c	c6 40 d8 00	 mov	 BYTE PTR [rax-40], 0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00070	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 252  : 	noiseProgram.prepare("fillNoiseBuffer2d");

  00075	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T1[rsp]
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00081	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00086	4c 8d 43 08	 lea	 r8, QWORD PTR [rbx+8]
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00091	ba 08 00 00 00	 mov	 edx, 8
  00096	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  0009b	4c 8d 47 18	 lea	 r8, QWORD PTR [rdi+24]
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000a6	ba 08 00 00 00	 mov	 edx, 8
  000ab	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 255  : 	noiseProgram.setArgument(sizeof(unsigned int), &sizeExponent);

  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000b7	4c 8b c7	 mov	 r8, rdi
  000ba	ba 04 00 00 00	 mov	 edx, 4
  000bf	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 256  : 	noiseProgram.setArgument(sizeof(float), &smoothness);

  000c4	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR smoothness$[rsp]
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000d3	ba 04 00 00 00	 mov	 edx, 4
  000d8	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 257  : 	noiseProgram.setArgument(sizeof(unsigned int), &octaves);

  000dd	4c 8d 47 08	 lea	 r8, QWORD PTR [rdi+8]
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  000e8	ba 04 00 00 00	 mov	 edx, 4
  000ed	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 258  : 	noiseProgram.setArgument(sizeof(float), &x);

  000f2	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR x$[rsp]
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00101	ba 04 00 00 00	 mov	 edx, 4
  00106	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 259  : 	noiseProgram.setArgument(sizeof(float), &y);

  0010b	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR y$[rsp]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0011a	ba 04 00 00 00	 mov	 edx, 4
  0011f	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 260  : 	noiseProgram.setArgument(sizeof(float), &xd);

  00124	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR xd$[rsp]
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00133	ba 04 00 00 00	 mov	 edx, 4
  00138	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 261  : 	noiseProgram.setArgument(sizeof(float), &yd);

  0013d	4c 8d 84 24 c8
	00 00 00	 lea	 r8, QWORD PTR yd$[rsp]
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0014c	ba 04 00 00 00	 mov	 edx, 4
  00151	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 262  : 	noiseProgram.setArgument(sizeof(unsigned int), &xs);

  00156	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR xs$[rsp]
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00165	ba 04 00 00 00	 mov	 edx, 4
  0016a	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 263  : 	noiseProgram.setArgument(sizeof(unsigned int), &ys);

  0016f	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR ys$[rsp]
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0017e	ba 04 00 00 00	 mov	 edx, 4
  00183	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument

; 264  : 	noiseProgram.invoke(queue, 2, global_ws, local_ws);

  00188	48 8d 44 24 30	 lea	 rax, QWORD PTR local_ws$[rsp]
  0018d	4c 8d 4c 24 40	 lea	 r9, QWORD PTR global_ws$[rsp]
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00199	41 b8 02 00 00
	00		 mov	 r8d, 2
  0019f	48 8b d6	 mov	 rdx, rsi
  001a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a7	e8 00 00 00 00	 call	 ?invoke@Program@cl@@QEAA_NAEAVCommandQueue@2@IPEB_K1@Z ; cl::Program::invoke

; 265  : }

  001ac	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  001b1	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001b5	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  001b9	49 8b e3	 mov	 rsp, r11
  001bc	5f		 pop	 rdi
  001bd	c3		 ret	 0
?fillNoiseBuffer@NoiseGenerator2D@Noise@@QEAAXAEAVCommandQueue@cl@@AEAVBuffer@4@IIMMMMM@Z ENDP ; Noise::NoiseGenerator2D::fillNoiseBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
sizeExponent$dead$ = 72
octaves$dead$ = 80
smoothness$ = 88
rand$ = 96
??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z PROC	; Noise::NoiseGenerator1D::NoiseGenerator1D, COMDAT

; 44   : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
  00016	c7 01 05 00 00
	00		 mov	 DWORD PTR [rcx], 5
  0001c	c7 41 04 20 00
	00 00		 mov	 DWORD PTR [rcx+4], 32	; 00000020H
  00023	c7 41 08 08 00
	00 00		 mov	 DWORD PTR [rcx+8], 8
  0002a	f3 0f 11 59 0c	 movss	 DWORD PTR [rcx+12], xmm3
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 261  : {

  0002f	c6 41 10 00	 mov	 BYTE PTR [rcx+16], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 44   : {

  00033	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00036	8b d0		 mov	 edx, eax
  00038	0f af d0	 imul	 edx, eax
  0003b	0f af d0	 imul	 edx, eax
  0003e	48 63 ca	 movsxd	 rcx, edx
  00041	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]
  00046	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 45   : 	initNoise(rand);

  0004a	48 8b 54 24 60	 mov	 rdx, QWORD PTR rand$[rsp]
  0004f	48 8b cb	 mov	 rcx, rbx
  00052	e8 00 00 00 00	 call	 ?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z ; Noise::NoiseGenerator1D::initNoise
  00057	90		 npad	 1

; 46   : }

  00058	48 8b c3	 mov	 rax, rbx
  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5b		 pop	 rbx
  00060	c3		 ret	 0
??0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z ENDP	; Noise::NoiseGenerator1D::NoiseGenerator1D
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
sizeExponent$dead$ = 72
octaves$dead$ = 80
smoothness$ = 88
rand$ = 96
?dtor$0@?0???0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z@4HA PROC ; `Noise::NoiseGenerator1D::NoiseGenerator1D'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 10	 add	 rcx, 16
  0000b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
?dtor$0@?0???0NoiseGenerator1D@Noise@@QEAA@HHMAEAVRandom@@@Z@4HA ENDP ; `Noise::NoiseGenerator1D::NoiseGenerator1D'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??1NoiseGenerator1D@Noise@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1NoiseGenerator1D@Noise@@QEAA@XZ PROC			; Noise::NoiseGenerator1D::~NoiseGenerator1D, COMDAT

; 63   : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 64   : 	delete[] noiseMap;

  00009	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0000d	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]

; 65   : }

  00012	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??1NoiseGenerator1D@Noise@@QEAA@XZ ENDP			; Noise::NoiseGenerator1D::~NoiseGenerator1D
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?getNoise@NoiseGenerator1D@Noise@@QEAAMM@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
?getNoise@NoiseGenerator1D@Noise@@QEAAMM@Z PROC		; Noise::NoiseGenerator1D::getNoise, COMDAT

; 69   : 	return getNoise(x, smoothness);

  00000	f3 0f 10 51 0c	 movss	 xmm2, DWORD PTR [rcx+12]
  00005	e9 00 00 00 00	 jmp	 ?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z ; Noise::NoiseGenerator1D::getNoise
?getNoise@NoiseGenerator1D@Noise@@QEAAMM@Z ENDP		; Noise::NoiseGenerator1D::getNoise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?staticInit@Noise@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
?staticInit@Noise@@YAXXZ PROC				; Noise::staticInit, COMDAT

; 20   : {

$LN5:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 21   : 	Noise::noiseProgram.create(IOUtil::EXE_DIR + L"\\programs\\noise.cl");

  00004	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294895145
  0000b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]
  00010	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00015	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  0001c	48 8b d0	 mov	 rdx, rax
  0001f	e8 00 00 00 00	 call	 ?create@Program@cl@@QEAA_NV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; cl::Program::create

; 22   : }

  00024	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00028	c3		 ret	 0
?staticInit@Noise@@YAXXZ ENDP				; Noise::staticInit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ??__EnoiseProgram@Noise@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__EnoiseProgram@Noise@@YAXXZ PROC			; Noise::`dynamic initializer for 'noiseProgram'', COMDAT

; 11   : cl::Program Noise::noiseProgram;

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 778  : 		this->_Myhead = _Buyheadnode();

  0000d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64> > > >::_Buyheadnode
  00012	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?noiseProgram@Noise@@3VProgram@cl@@A+8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00019	ba 02 00 00 00	 mov	 edx, 2
  0001e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A+24
  00025	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN31@dynamic

; 33   : 		_Throw_C_error(_Res);

  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN31@dynamic:
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 97   : {

  00035	c6 05 30 00 00
	00 00		 mov	 BYTE PTR ?noiseProgram@Noise@@3VProgram@cl@@A+48, 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 11   : cl::Program Noise::noiseProgram;

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FnoiseProgram@Noise@@YAXXZ ; Noise::`dynamic atexit destructor for 'noiseProgram''
  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	e9 00 00 00 00	 jmp	 atexit
??__EnoiseProgram@Noise@@YAXXZ ENDP			; Noise::`dynamic initializer for 'noiseProgram''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__EnoiseProgram@Noise@@YAXXZ@4HA PROC	; `Noise::`dynamic initializer for 'noiseProgram'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@QEAA@XZ
?dtor$0@?0???__EnoiseProgram@Noise@@YAXXZ@4HA ENDP	; `Noise::`dynamic initializer for 'noiseProgram'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FnoiseProgram@Noise@@YAXXZ
text$yd	SEGMENT
??__FnoiseProgram@Noise@@YAXXZ PROC			; Noise::`dynamic atexit destructor for 'noiseProgram'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00007	e9 00 00 00 00	 jmp	 ??1Program@cl@@QEAA@XZ	; cl::Program::~Program
??__FnoiseProgram@Noise@@YAXXZ ENDP			; Noise::`dynamic atexit destructor for 'noiseProgram''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?interpolate@@YAMM@Z
_TEXT	SEGMENT
f$ = 8
?interpolate@@YAMM@Z PROC				; interpolate, COMDAT

; 15   : 	//return (cos(f * M_PI) + 1.0f) * 0.5f;
; 16   : 	return 1.0f - f * f * (3 - f * 2);

  00000	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@40400000
  00008	0f 28 c8	 movaps	 xmm1, xmm0
  0000b	f3 0f 59 c0	 mulss	 xmm0, xmm0
  0000f	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@40000000
  00017	f3 0f 5c d1	 subss	 xmm2, xmm1
  0001b	f3 0f 59 d0	 mulss	 xmm2, xmm0
  0001f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00027	f3 0f 5c c2	 subss	 xmm0, xmm2

; 17   : }

  0002b	c3		 ret	 0
?interpolate@@YAMM@Z ENDP				; interpolate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?noiseAt@NoiseGenerator1D@Noise@@AEAAEAEAH@Z
_TEXT	SEGMENT
this$ = 8
x$ = 16
?noiseAt@NoiseGenerator1D@Noise@@AEAAEAEAH@Z PROC	; Noise::NoiseGenerator1D::noiseAt, COMDAT

; 26   : 	const int andField = size - 1;

  00000	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]

; 27   : 	return noiseMap[x & andField];

  00003	48 63 12	 movsxd	 rdx, DWORD PTR [rdx]
  00006	ff c8		 dec	 eax
  00008	4c 63 c0	 movsxd	 r8, eax
  0000b	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  0000f	4c 23 c2	 and	 r8, rdx
  00012	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]

; 28   : }

  00017	c3		 ret	 0
?noiseAt@NoiseGenerator1D@Noise@@AEAAEAEAH@Z ENDP	; Noise::NoiseGenerator1D::noiseAt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z
_TEXT	SEGMENT
this$ = 48
rand$ = 56
?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z PROC ; Noise::NoiseGenerator1D::initNoise, COMDAT

; 49   : {

$LN19:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 50   : 	const int chunk_size = 32;
; 51   : 	for(int i = 0; i < size; i += chunk_size)

  0000f	33 db		 xor	 ebx, ebx
  00011	33 f6		 xor	 esi, esi
  00013	48 8b f9	 mov	 rdi, rcx
  00016	39 59 04	 cmp	 DWORD PTR [rcx+4], ebx
  00019	7e 5d		 jle	 SHORT $LN4@initNoise
  0001b	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00020	48 8d 6a 04	 lea	 rbp, QWORD PTR [rdx+4]
$LL6@initNoise:
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp

; 17   : 	return randomEngine();

  00024	48 8b cd	 mov	 rcx, rbp
  00027	e8 00 00 00 00	 call	 ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 54   : 		for(int j = 0; j < chunk_size; j++)

  0002c	45 33 c9	 xor	 r9d, r9d
  0002f	90		 npad	 1
$LL3@initNoise:

; 55   : 		{
; 56   : 			noiseMap[i + j] = r & 0x1;

  00030	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00034	44 0f b6 c0	 movzx	 r8d, al
  00038	4a 8d 14 0b	 lea	 rdx, QWORD PTR [rbx+r9]
  0003c	41 80 e0 01	 and	 r8b, 1

; 57   : 			r >>= 1;

  00040	d1 e8		 shr	 eax, 1
  00042	44 88 04 0a	 mov	 BYTE PTR [rdx+rcx], r8b
  00046	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  0004a	44 0f b6 c0	 movzx	 r8d, al
  0004e	4a 8d 14 0b	 lea	 rdx, QWORD PTR [rbx+r9]
  00052	41 80 e0 01	 and	 r8b, 1
  00056	49 83 c1 02	 add	 r9, 2
  0005a	d1 e8		 shr	 eax, 1
  0005c	44 88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], r8b
  00061	49 83 f9 20	 cmp	 r9, 32			; 00000020H
  00065	7c c9		 jl	 SHORT $LL3@initNoise

; 50   : 	const int chunk_size = 32;
; 51   : 	for(int i = 0; i < size; i += chunk_size)

  00067	83 c6 20	 add	 esi, 32			; 00000020H
  0006a	48 83 c3 20	 add	 rbx, 32			; 00000020H
  0006e	3b 77 04	 cmp	 esi, DWORD PTR [rdi+4]
  00071	7c b1		 jl	 SHORT $LL6@initNoise
  00073	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$LN4@initNoise:

; 58   : 		}
; 59   : 	}
; 60   : }

  00078	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5f		 pop	 rdi
  00087	c3		 ret	 0
?initNoise@NoiseGenerator1D@Noise@@AEAAXAEAVRandom@@@Z ENDP ; Noise::NoiseGenerator1D::initNoise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z
_TEXT	SEGMENT
this$ = 192
x$ = 200
smoothness$ = 208
?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z PROC	; Noise::NoiseGenerator1D::getNoise, COMDAT

; 73   : {

$LN16:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0000a	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  0000d	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  00011	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  00015	0f 57 f6	 xorps	 xmm6, xmm6
  00018	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  0001d	44 0f 29 48 b8	 movaps	 XMMWORD PTR [rax-72], xmm9
  00022	44 0f 29 50 a8	 movaps	 XMMWORD PTR [rax-88], xmm10

; 75   : 	float value = 1.0f;

  00027	f3 44 0f 10 15
	00 00 00 00	 movss	 xmm10, DWORD PTR __real@3f800000
  00030	44 0f 29 58 98	 movaps	 XMMWORD PTR [rax-104], xmm11
  00035	45 0f 28 ca	 movaps	 xmm9, xmm10
  00039	44 0f 28 c1	 movaps	 xmm8, xmm1
  0003d	44 0f 28 da	 movaps	 xmm11, xmm2

; 76   : 	float maxValue = 0.0f;

  00041	0f 28 fe	 movaps	 xmm7, xmm6

; 77   : 
; 78   : 	int ix;
; 79   : 	int ix1;
; 80   : 	float xMix;
; 81   : 	float xMixi;
; 82   : 
; 83   : 	for(int i = 0; i < octaves; i++)

  00044	85 d2		 test	 edx, edx
  00046	0f 8e 06 01 00
	00		 jle	 $LN1@getNoise

; 74   : 	float noise = 0.0f;

  0004c	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00050	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  00054	48 89 78 f8	 mov	 QWORD PTR [rax-8], rdi
  00058	44 0f 29 60 88	 movaps	 XMMWORD PTR [rax-120], xmm12
  0005d	f3 44 0f 10 25
	00 00 00 00	 movss	 xmm12, DWORD PTR __real@40000000
  00066	44 0f 29 6c 24
	30		 movaps	 XMMWORD PTR [rsp+48], xmm13
  0006c	f3 44 0f 10 2d
	00 00 00 00	 movss	 xmm13, DWORD PTR __real@40400000
  00075	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00078	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0007c	8b f2		 mov	 esi, edx
  0007e	44 0f 29 74 24
	20		 movaps	 XMMWORD PTR [rsp+32], xmm14
  00084	f3 44 0f 10 35
	00 00 00 00	 movss	 xmm14, DWORD PTR __real@3f000000
  0008d	ff c8		 dec	 eax
  0008f	48 63 d8	 movsxd	 rbx, eax
$LL3@getNoise:

; 84   : 	{
; 85   : 		maxValue += value;
; 86   : 
; 87   : 		ix = (int)floorf(x);

  00092	41 0f 28 c0	 movaps	 xmm0, xmm8
  00096	f3 41 0f 58 f9	 addss	 xmm7, xmm9
  0009b	e8 00 00 00 00	 call	 floorf

; 88   : 		ix1 = ix + 1;
; 89   : 		xMix = interpolate(x - ix);

  000a0	41 0f 28 d0	 movaps	 xmm2, xmm8

; 16   : 	return 1.0f - f * f * (3 - f * 2);

  000a4	41 0f 28 da	 movaps	 xmm3, xmm10

; 95   : 
; 96   : 		x *= 0.5f;

  000a8	f3 45 0f 59 c6	 mulss	 xmm8, xmm14
  000ad	f3 0f 2c d0	 cvttss2si edx, xmm0
  000b1	66 0f 6e ca	 movd	 xmm1, edx
  000b5	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  000b8	48 63 c8	 movsxd	 rcx, eax

; 17   : }
; 18   : 
; 19   : void Noise::staticInit()
; 20   : {
; 21   : 	Noise::noiseProgram.create(IOUtil::EXE_DIR + L"\\programs\\noise.cl");
; 22   : }
; 23   : 
; 24   : unsigned char NoiseGenerator1D::noiseAt(int &x)
; 25   : {
; 26   : 	const int andField = size - 1;
; 27   : 	return noiseMap[x & andField];

  000bb	48 23 cb	 and	 rcx, rbx

; 91   : 
; 92   : 		noise += (noiseAt(ix) * xMix
; 93   : 			+ noiseAt(ix1) * xMixi)
; 94   : 			* value;

  000be	0f b6 04 39	 movzx	 eax, BYTE PTR [rcx+rdi]
  000c2	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000c5	f3 0f 5c d1	 subss	 xmm2, xmm1

; 16   : 	return 1.0f - f * f * (3 - f * 2);

  000c9	41 0f 28 cd	 movaps	 xmm1, xmm13
  000cd	0f 28 c2	 movaps	 xmm0, xmm2
  000d0	f3 0f 59 d2	 mulss	 xmm2, xmm2
  000d4	f3 41 0f 59 c4	 mulss	 xmm0, xmm12
  000d9	f3 0f 5c c8	 subss	 xmm1, xmm0

; 90   : 		xMixi = 1.0f - xMix;

  000dd	41 0f 28 c2	 movaps	 xmm0, xmm10

; 16   : 	return 1.0f - f * f * (3 - f * 2);

  000e1	f3 0f 59 ca	 mulss	 xmm1, xmm2
  000e5	66 0f 6e d0	 movd	 xmm2, eax

; 91   : 
; 92   : 		noise += (noiseAt(ix) * xMix
; 93   : 			+ noiseAt(ix1) * xMixi)
; 94   : 			* value;

  000e9	48 63 c2	 movsxd	 rax, edx

; 17   : }
; 18   : 
; 19   : void Noise::staticInit()
; 20   : {
; 21   : 	Noise::noiseProgram.create(IOUtil::EXE_DIR + L"\\programs\\noise.cl");
; 22   : }
; 23   : 
; 24   : unsigned char NoiseGenerator1D::noiseAt(int &x)
; 25   : {
; 26   : 	const int andField = size - 1;
; 27   : 	return noiseMap[x & andField];

  000ec	48 23 c3	 and	 rax, rbx

; 91   : 
; 92   : 		noise += (noiseAt(ix) * xMix
; 93   : 			+ noiseAt(ix1) * xMixi)
; 94   : 			* value;

  000ef	0f b6 04 38	 movzx	 eax, BYTE PTR [rax+rdi]

; 16   : 	return 1.0f - f * f * (3 - f * 2);

  000f3	f3 0f 5c d9	 subss	 xmm3, xmm1

; 91   : 
; 92   : 		noise += (noiseAt(ix) * xMix
; 93   : 			+ noiseAt(ix1) * xMixi)
; 94   : 			* value;

  000f7	0f 5b d2	 cvtdq2ps xmm2, xmm2
  000fa	66 0f 6e c8	 movd	 xmm1, eax
  000fe	f3 0f 5c c3	 subss	 xmm0, xmm3
  00102	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00106	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00109	f3 0f 59 cb	 mulss	 xmm1, xmm3
  0010d	f3 0f 58 d1	 addss	 xmm2, xmm1
  00111	f3 41 0f 59 d1	 mulss	 xmm2, xmm9

; 97   : 		value *= smoothness;

  00116	f3 45 0f 59 cb	 mulss	 xmm9, xmm11
  0011b	f3 0f 58 f2	 addss	 xmm6, xmm2
  0011f	48 ff ce	 dec	 rsi
  00122	0f 85 6a ff ff
	ff		 jne	 $LL3@getNoise
  00128	44 0f 28 74 24
	20		 movaps	 xmm14, XMMWORD PTR [rsp+32]
  0012e	44 0f 28 6c 24
	30		 movaps	 xmm13, XMMWORD PTR [rsp+48]
  00134	44 0f 28 64 24
	40		 movaps	 xmm12, XMMWORD PTR [rsp+64]
  0013a	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR [rsp+176]
  00142	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+200]
  0014a	48 8b 9c 24 c0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+192]
$LN1@getNoise:

; 98   : 	}
; 99   : 
; 100  : 	return noise / maxValue;
; 101  : }

  00152	4c 8d 9c 24 b8
	00 00 00	 lea	 r11, QWORD PTR [rsp+184]
  0015a	f3 0f 5e f7	 divss	 xmm6, xmm7
  0015e	41 0f 28 7b d8	 movaps	 xmm7, XMMWORD PTR [r11-40]
  00163	45 0f 28 43 c8	 movaps	 xmm8, XMMWORD PTR [r11-56]
  00168	45 0f 28 4b b8	 movaps	 xmm9, XMMWORD PTR [r11-72]
  0016d	45 0f 28 53 a8	 movaps	 xmm10, XMMWORD PTR [r11-88]
  00172	45 0f 28 5b 98	 movaps	 xmm11, XMMWORD PTR [r11-104]
  00177	0f 28 c6	 movaps	 xmm0, xmm6
  0017a	41 0f 28 73 e8	 movaps	 xmm6, XMMWORD PTR [r11-24]
  0017f	49 8b e3	 mov	 rsp, r11
  00182	c3		 ret	 0
?getNoise@NoiseGenerator1D@Noise@@QEAAMMM@Z ENDP	; Noise::NoiseGenerator1D::getNoise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z
_TEXT	SEGMENT
this$ = 48
rand$ = 56
?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z PROC ; Noise::NoiseGenerator2D::initNoise, COMDAT

; 172  : {

$LN19:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 173  : 	const int chunk_size = 32;
; 174  : 	for(int i = 0; i < size * size; i += chunk_size)

  0000f	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00012	33 f6		 xor	 esi, esi
  00014	33 db		 xor	 ebx, ebx
  00016	48 8b f9	 mov	 rdi, rcx
  00019	0f af c0	 imul	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	7e 6c		 jle	 SHORT $LN4@initNoise
  00020	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00025	48 8d 6a 04	 lea	 rbp, QWORD PTR [rdx+4]
  00029	0f 1f 80 00 00
	00 00		 npad	 7
$LL6@initNoise:
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp

; 17   : 	return randomEngine();

  00030	48 8b cd	 mov	 rcx, rbp
  00033	e8 00 00 00 00	 call	 ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 177  : 		for(int j = 0; j < chunk_size; j++)

  00038	45 33 c9	 xor	 r9d, r9d
  0003b	0f 1f 44 00 00	 npad	 5
$LL3@initNoise:

; 178  : 		{
; 179  : 			noiseMap[i + j] = r & 0x1;

  00040	48 8b 57 28	 mov	 rdx, QWORD PTR [rdi+40]
  00044	44 0f b6 c0	 movzx	 r8d, al

; 180  : 			r >>= 1;

  00048	d1 e8		 shr	 eax, 1
  0004a	48 03 d3	 add	 rdx, rbx
  0004d	41 80 e0 01	 and	 r8b, 1
  00051	49 83 c1 02	 add	 r9, 2
  00055	46 88 44 0a fe	 mov	 BYTE PTR [rdx+r9-2], r8b
  0005a	48 8b 57 28	 mov	 rdx, QWORD PTR [rdi+40]
  0005e	44 0f b6 c0	 movzx	 r8d, al
  00062	48 03 d3	 add	 rdx, rbx
  00065	41 80 e0 01	 and	 r8b, 1
  00069	d1 e8		 shr	 eax, 1
  0006b	46 88 44 0a ff	 mov	 BYTE PTR [rdx+r9-1], r8b
  00070	49 83 f9 20	 cmp	 r9, 32			; 00000020H
  00074	7c ca		 jl	 SHORT $LL3@initNoise

; 173  : 	const int chunk_size = 32;
; 174  : 	for(int i = 0; i < size * size; i += chunk_size)

  00076	8b 47 04	 mov	 eax, DWORD PTR [rdi+4]
  00079	83 c6 20	 add	 esi, 32			; 00000020H
  0007c	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00080	0f af c0	 imul	 eax, eax
  00083	3b f0		 cmp	 esi, eax
  00085	7c a9		 jl	 SHORT $LL6@initNoise
  00087	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$LN4@initNoise:

; 181  : 		}
; 182  : 	}
; 183  : }

  0008c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00091	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00096	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009a	5f		 pop	 rdi
  0009b	c3		 ret	 0
?initNoise@NoiseGenerator2D@Noise@@AEAAXAEAVRandom@@@Z ENDP ; Noise::NoiseGenerator2D::initNoise
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
;	COMDAT ?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z
_TEXT	SEGMENT
this$ = 48
rand$ = 56
?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z PROC ; Noise::NoiseGenerator3D::initNoise, COMDAT

; 312  : {

$LN19:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 313  : 	const int chunk_size = 32;
; 314  : 	for(int i = 0; i < size * size * size; i += chunk_size)

  0000f	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00012	33 f6		 xor	 esi, esi
  00014	33 db		 xor	 ebx, ebx
  00016	44 8b c0	 mov	 r8d, eax
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	44 0f af c0	 imul	 r8d, eax
  00020	44 0f af c0	 imul	 r8d, eax
  00024	45 85 c0	 test	 r8d, r8d
  00027	7e 68		 jle	 SHORT $LN4@initNoise
  00029	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0002e	48 8d 6a 04	 lea	 rbp, QWORD PTR [rdx+4]
$LL6@initNoise:
; File c:\users\erlend\documents\github\wind\project\wind\wind\globalutil.cpp

; 17   : 	return randomEngine();

  00032	48 8b cd	 mov	 rcx, rbp
  00035	e8 00 00 00 00	 call	 ??R?$mersenne_twister@I$0CA@$0CHA@$0BIN@$0BP@$0JJAILANP@$0L@$06$0JNCMFGIA@$0P@$0OPMGAAAA@$0BC@@std@@QEAAIXZ ; std::mersenne_twister<unsigned int,32,624,397,31,2567483615,11,7,2636928640,15,4022730752,18>::operator()
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 317  : 		for(int j = 0; j < chunk_size; j++)

  0003a	45 33 c9	 xor	 r9d, r9d
  0003d	0f 1f 00	 npad	 3
$LL3@initNoise:

; 318  : 		{
; 319  : 			noiseMap[i + j] = r & 0x1;

  00040	48 8b 57 28	 mov	 rdx, QWORD PTR [rdi+40]
  00044	44 0f b6 c0	 movzx	 r8d, al

; 320  : 			r >>= 1;

  00048	d1 e8		 shr	 eax, 1
  0004a	48 03 d3	 add	 rdx, rbx
  0004d	41 80 e0 01	 and	 r8b, 1
  00051	49 83 c1 02	 add	 r9, 2
  00055	46 88 44 0a fe	 mov	 BYTE PTR [rdx+r9-2], r8b
  0005a	48 8b 57 28	 mov	 rdx, QWORD PTR [rdi+40]
  0005e	44 0f b6 c0	 movzx	 r8d, al
  00062	48 03 d3	 add	 rdx, rbx
  00065	41 80 e0 01	 and	 r8b, 1
  00069	d1 e8		 shr	 eax, 1
  0006b	46 88 44 0a ff	 mov	 BYTE PTR [rdx+r9-1], r8b
  00070	49 83 f9 20	 cmp	 r9, 32			; 00000020H
  00074	7c ca		 jl	 SHORT $LL3@initNoise

; 313  : 	const int chunk_size = 32;
; 314  : 	for(int i = 0; i < size * size * size; i += chunk_size)

  00076	8b 47 04	 mov	 eax, DWORD PTR [rdi+4]
  00079	83 c6 20	 add	 esi, 32			; 00000020H
  0007c	48 83 c3 20	 add	 rbx, 32			; 00000020H
  00080	8b c8		 mov	 ecx, eax
  00082	0f af c8	 imul	 ecx, eax
  00085	0f af c8	 imul	 ecx, eax
  00088	3b f1		 cmp	 esi, ecx
  0008a	7c a6		 jl	 SHORT $LL6@initNoise
  0008c	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
$LN4@initNoise:

; 321  : 		}
; 322  : 	}
; 323  : }

  00091	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00096	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
?initNoise@NoiseGenerator3D@Noise@@AEAAXAEAVRandom@@@Z ENDP ; Noise::NoiseGenerator3D::initNoise
_TEXT	ENDS
END
