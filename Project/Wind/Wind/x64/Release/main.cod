; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?camX@@3HA					; camX
PUBLIC	?camY@@3HA					; camY
PUBLIC	??_7?$_Ref_count@VChunk@@@std@@6B@		; std::_Ref_count<Chunk>::`vftable'
PUBLIC	??_R3?$_Ref_count@VChunk@@@std@@8		; std::_Ref_count<Chunk>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count@VChunk@@@std@@8		; std::_Ref_count<Chunk>::`RTTI Base Class Array'
PUBLIC	?prevCamX@@3HA					; prevCamX
PUBLIC	??_R0?AV?$_Ref_count@VChunk@@@std@@@8		; std::_Ref_count<Chunk> `RTTI Type Descriptor'
PUBLIC	?prevCamZ@@3HA					; prevCamZ
PUBLIC	?ticks@@3HA					; ticks
PUBLIC	??_R4?$_Ref_count@VChunk@@@std@@6B@		; std::_Ref_count<Chunk>::`RTTI Complete Object Locator'
PUBLIC	?camZ@@3HA					; camZ
PUBLIC	?prevCamY@@3HA					; prevCamY
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8	; std::_Ref_count<Chunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_PeekMessageW:PROC
EXTRN	__imp_DispatchMessageW:PROC
?camX@@3HA DD	01H DUP (?)				; camX
?camY@@3HA DD	01H DUP (?)				; camY
?prevCamX@@3HA DD 01H DUP (?)				; prevCamX
?prevCamZ@@3HA DD 01H DUP (?)				; prevCamZ
?ticks@@3HA DD	01H DUP (?)				; ticks
?camZ@@3HA DD	01H DUP (?)				; camZ
?prevCamY@@3HA DD 01H DUP (?)				; prevCamY
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8 DD imagerel ??_R0?AV?$_Ref_count@VChunk@@@std@@@8 ; std::_Ref_count<Chunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Ref_count@VChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Ref_count@VChunk@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VChunk@@@std@@6B@ DD 01H		; std::_Ref_count<Chunk>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Ref_count@VChunk@@@std@@@8
	DD	imagerel ??_R3?$_Ref_count@VChunk@@@std@@8
	DD	imagerel ??_R4?$_Ref_count@VChunk@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VChunk@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VChunk@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count<Chunk> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Ref_count@VChunk@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R2?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VChunk@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8 ; std::_Ref_count<Chunk>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VChunk@@@std@@8 DD 00H		; std::_Ref_count<Chunk>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Ref_count@VChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count@VChunk@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VChunk@@@std@@6B@ DQ FLAT:??_R4?$_Ref_count@VChunk@@@std@@6B@ ; std::_Ref_count<Chunk>::`vftable'
	DQ	FLAT:?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ
	DQ	FLAT:?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ
	DQ	FLAT:??_E?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
	ORG $+5
$SG4294898609 DB 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 00H, 00H
PUBLIC	??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVChunk@@PEAV_Ref_count_base@1@@Z ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>
PUBLIC	??1?$_Ref_count@VChunk@@@std@@UEAA@XZ		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>
PUBLIC	??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z	; std::_Ref_count<Chunk>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ ; std::_Ref_count<Chunk>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ	; std::_Ref_count<Chunk>::_Destroy
PUBLIC	??0?$_Ref_count@VChunk@@@std@@QEAA@PEAVChunk@@@Z ; std::_Ref_count<Chunk>::_Ref_count<Chunk>
PUBLIC	??_GChunk@@QEAAPEAXI@Z				; Chunk::`scalar deleting destructor'
PUBLIC	??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
PUBLIC	??$move@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ; std::move<std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>
PUBLIC	??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::shared_ptr<ChunkBase>::operator=
PUBLIC	?clear@?$List@VMouseAction@@$0BA@@@QEAAXXZ	; List<MouseAction,16>::clear
PUBLIC	?getSize@?$List@VMouseAction@@$0BA@@@QEAAHXZ	; List<MouseAction,16>::getSize
PUBLIC	??A?$List@VMouseAction@@$0BA@@@QEAAAEAVMouseAction@@H@Z ; List<MouseAction,16>::operator[]
PUBLIC	?clear@?$List@VKeyboardAction@@$0BA@@@QEAAXXZ	; List<KeyboardAction,16>::clear
PUBLIC	?getSize@?$List@VKeyboardAction@@$0BA@@@QEAAHXZ	; List<KeyboardAction,16>::getSize
PUBLIC	??A?$List@VKeyboardAction@@$0BA@@@QEAAAEAVKeyboardAction@@H@Z ; List<KeyboardAction,16>::operator[]
PUBLIC	??_GGLWindow@@QEAAPEAXI@Z			; GLWindow::`scalar deleting destructor'
PUBLIC	WinMain
PUBLIC	?mainLoop@@YA_NXZ				; mainLoop
EXTRN	??_E?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z:PROC	; std::_Ref_count<Chunk>::`vector deleting destructor'
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GChunk@@QEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$??_GChunk@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD imagerel $LN31
	DD	imagerel $LN31+99
	DD	imagerel $unwind$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA DD imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA+59
	DD	imagerel $unwind$?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70
	DD	imagerel $LN70+77
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70+77
	DD	imagerel $LN70+84
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70+84
	DD	imagerel $LN70+113
	DD	imagerel $chain$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70+113
	DD	imagerel $LN70+138
	DD	imagerel $chain$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70+138
	DD	imagerel $LN70+147
	DD	imagerel $chain$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GGLWindow@@QEAAPEAXI@Z DD imagerel $LN45
	DD	imagerel $LN45+74
	DD	imagerel $unwind$??_GGLWindow@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN995
	DD	imagerel $LN995+2485
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mainLoop@@YA_NXZ DD imagerel $LN590
	DD	imagerel $LN590+3496
	DD	imagerel $unwind$?mainLoop@@YA_NXZ
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?mainLoop@@YA_NXZ DD imagerel ?mainLoop@@YA_NXZ
	DD	0ffffffffH
	DD	imagerel ?mainLoop@@YA_NXZ+2130
	DD	00H
	DD	imagerel ?mainLoop@@YA_NXZ+2180
	DD	01H
	DD	imagerel ?mainLoop@@YA_NXZ+2258
	DD	02H
	DD	imagerel ?mainLoop@@YA_NXZ+2284
	DD	03H
	DD	imagerel ?mainLoop@@YA_NXZ+2303
	DD	04H
	DD	imagerel ?mainLoop@@YA_NXZ+2322
	DD	01H
	DD	imagerel ?mainLoop@@YA_NXZ+2345
	DD	00H
	DD	imagerel ?mainLoop@@YA_NXZ+2740
	DD	05H
	DD	imagerel ?mainLoop@@YA_NXZ+2810
	DD	00H
	DD	imagerel ?mainLoop@@YA_NXZ+3121
	DD	0ffffffffH
	DD	imagerel ?mainLoop@@YA_NXZ+3254
	DD	00H
	DD	imagerel ?mainLoop@@YA_NXZ+3266
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?mainLoop@@YA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??mainLoop@@YA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??mainLoop@@YA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$5@?0??mainLoop@@YA_NXZ@4HA
	DD	02H
	DD	imagerel ?dtor$6@?0??mainLoop@@YA_NXZ@4HA
	DD	03H
	DD	imagerel ?dtor$7@?0??mainLoop@@YA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$9@?0??mainLoop@@YA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?mainLoop@@YA_NXZ DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$?mainLoop@@YA_NXZ
	DD	00H
	DD	00H
	DD	0dH
	DD	imagerel $ip2state$?mainLoop@@YA_NXZ
	DD	090H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mainLoop@@YA_NXZ DD 0184f11H
	DD	0ac84fH
	DD	0bb847H
	DD	0ca83fH
	DD	0d9837H
	DD	0e882fH
	DD	0f782aH
	DD	0106826H
	DD	023011aH
	DD	0e00df00fH
	DD	0c009d00bH
	DD	060067007H
	DD	050043005H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?mainLoop@@YA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WinMain DD 0d2c01H
	DD	05d742cH
	DD	05c642cH
	DD	05b342cH
	DD	054012cH
	DD	0e01bf01dH
	DD	0c017d019H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GGLWindow@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN70
	DD	imagerel $LN70+77
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN70+77
	DD	imagerel $LN70+84
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN70+77
	DD	imagerel $LN70+84
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	096405H
	DD	imagerel $LN70
	DD	imagerel $LN70+77
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD imagerel ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z+30
	DD	00H
	DD	imagerel ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z+88
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA+14
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 041819H
	DD	083418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GChunk@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
;	COMDAT ?mainLoop@@YA_NXZ
_TEXT	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2278 = 360
tv2277 = 368
xDist$1$ = 376
?mainLoop@@YA_NXZ PROC					; mainLoop, COMDAT

; 22   : {

$LN590:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	53		 push	 rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 8d 68 a8	 lea	 rbp, QWORD PTR [rax-88]
  00013	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001a	48 c7 45 90 fe
	ff ff ff	 mov	 QWORD PTR $T8[rbp-256], -2
  00022	0f 29 70 a8	 movaps	 XMMWORD PTR [rax-88], xmm6
  00026	0f 29 78 98	 movaps	 XMMWORD PTR [rax-104], xmm7
  0002a	44 0f 29 40 88	 movaps	 XMMWORD PTR [rax-120], xmm8
  0002f	44 0f 29 88 78
	ff ff ff	 movaps	 XMMWORD PTR [rax-136], xmm9
  00037	44 0f 29 90 68
	ff ff ff	 movaps	 XMMWORD PTR [rax-152], xmm10
  0003f	44 0f 29 98 58
	ff ff ff	 movaps	 XMMWORD PTR [rax-168], xmm11
  00047	44 0f 29 a0 48
	ff ff ff	 movaps	 XMMWORD PTR [rax-184], xmm12

; 23   : 	Camera* cam = &GameStates::processedState->cam;

  0004f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA ; GameStates::processedState
  00056	4c 8b f2	 mov	 r14, rdx

; 24   : 
; 25   : 	for(int i = 0; i < Mouse::actions.getSize(); i++)

  00059	45 33 e4	 xor	 r12d, r12d
  0005c	41 8b fc	 mov	 edi, r12d
  0005f	44 39 25 40 01
	00 00		 cmp	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, r12d
  00066	0f 8e bc 00 00
	00		 jle	 $LN42@mainLoop

; 23   : 	Camera* cam = &GameStates::processedState->cam;

  0006c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A ; Mouse::actions
  00073	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3f000000
  0007b	0f 1f 44 00 00	 npad	 5
$LL44@mainLoop:

; 26   : 	{
; 27   : 		MouseAction ma = Mouse::actions[i];

  00080	44 8b 3b	 mov	 r15d, DWORD PTR [rbx]
  00083	44 8b 6b 04	 mov	 r13d, DWORD PTR [rbx+4]
  00087	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]
  0008a	8b 43 0c	 mov	 eax, DWORD PTR [rbx+12]
  0008d	89 44 24 7c	 mov	 DWORD PTR ma$5[rsp+12], eax
  00091	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  00094	89 45 80	 mov	 DWORD PTR ma$5[rbp-240], eax

; 28   : 		GameStates::processedState->FOV -= ma.sc * 5;

  00097	6b c9 fb	 imul	 ecx, -5
  0009a	01 4a 20	 add	 DWORD PTR [rdx+32], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  000a4	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  000a9	85 c0		 test	 eax, eax
  000ab	74 07		 je	 SHORT $LN65@mainLoop

; 33   : 		_Throw_C_error(_Res);

  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN65@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp

; 48   : 	bool value = mbs[index];

  000b4	0f b6 35 00 00
	00 00		 movzx	 esi, BYTE PTR ?mbs@Mouse@@0PA_NA
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  000c2	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  000c7	85 c0		 test	 eax, eax
  000c9	74 07		 je	 SHORT $LN72@mainLoop

; 33   : 		_Throw_C_error(_Res);

  000cb	8b c8		 mov	 ecx, eax
  000cd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN72@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 29   : 		if(Mouse::getMB(0))

  000d2	40 84 f6	 test	 sil, sil
  000d5	74 38		 je	 SHORT $LN43@mainLoop
  000d7	66 41 0f 6e cd	 movd	 xmm1, r13d

; 30   : 		{
; 31   : 			cam->rot.x -= ma.ry * 0.5f;

  000dc	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000df	f3 0f 59 ce	 mulss	 xmm1, xmm6
  000e3	f3 41 0f 10 46
	10		 movss	 xmm0, DWORD PTR [r14+16]
  000e9	f3 0f 5c c1	 subss	 xmm0, xmm1
  000ed	f3 41 0f 11 46
	10		 movss	 DWORD PTR [r14+16], xmm0
  000f3	66 41 0f 6e cf	 movd	 xmm1, r15d

; 32   : 			cam->rot.y -= ma.rx * 0.5f;

  000f8	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000fb	f3 0f 59 ce	 mulss	 xmm1, xmm6
  000ff	f3 41 0f 10 46
	14		 movss	 xmm0, DWORD PTR [r14+20]
  00105	f3 0f 5c c1	 subss	 xmm0, xmm1
  00109	f3 41 0f 11 46
	14		 movss	 DWORD PTR [r14+20], xmm0
$LN43@mainLoop:

; 24   : 
; 25   : 	for(int i = 0; i < Mouse::actions.getSize(); i++)

  0010f	ff c7		 inc	 edi
  00111	48 83 c3 14	 add	 rbx, 20

; 23   : 	Camera* cam = &GameStates::processedState->cam;

  00115	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA ; GameStates::processedState

; 24   : 
; 25   : 	for(int i = 0; i < Mouse::actions.getSize(); i++)

  0011c	3b 3d 40 01 00
	00		 cmp	 edi, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
  00122	0f 8c 58 ff ff
	ff		 jl	 $LL44@mainLoop
$LN42@mainLoop:

; 33   : 		}
; 34   : 	}
; 35   : 
; 36   : 	for(int i = 0; i < Keyboard::actions.getSize(); i++)

  00128	45 8b c4	 mov	 r8d, r12d
  0012b	44 8b 15 80 00
	00 00		 mov	 r10d, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
  00132	45 85 d2	 test	 r10d, r10d
  00135	7e 40		 jle	 SHORT $LN38@mainLoop
  00137	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A ; Keyboard::actions
  0013e	66 90		 npad	 2
$LL40@mainLoop:

; 37   : 	{
; 38   : 		KeyboardAction kba = Keyboard::actions[i];

  00140	49 8b 01	 mov	 rax, QWORD PTR [r9]

; 39   : 		
; 40   : 		if(kba.released && kba.button == 69)

  00143	48 8b c8	 mov	 rcx, rax
  00146	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  0014a	84 c9		 test	 cl, cl
  0014c	74 1d		 je	 SHORT $LN39@mainLoop
  0014e	83 f8 45	 cmp	 eax, 69			; 00000045H
  00151	75 18		 jne	 SHORT $LN39@mainLoop

; 41   : 		{
; 42   : 			GameStates::processedState->devEnabled = !GameStates::processedState->devEnabled;

  00153	44 38 62 24	 cmp	 BYTE PTR [rdx+36], r12b
  00157	0f 94 c0	 sete	 al
  0015a	88 42 24	 mov	 BYTE PTR [rdx+36], al
  0015d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA ; GameStates::processedState
  00164	44 8b 15 80 00
	00 00		 mov	 r10d, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
$LN39@mainLoop:

; 33   : 		}
; 34   : 	}
; 35   : 
; 36   : 	for(int i = 0; i < Keyboard::actions.getSize(); i++)

  0016b	41 ff c0	 inc	 r8d
  0016e	49 83 c1 08	 add	 r9, 8
  00172	45 3b c2	 cmp	 r8d, r10d
  00175	7c c9		 jl	 SHORT $LL40@mainLoop
$LN38@mainLoop:

; 43   : 		}
; 44   : 	}
; 45   : 
; 46   : 	if(GameStates::processedState->FOV < 5)

  00177	8b 42 20	 mov	 eax, DWORD PTR [rdx+32]
  0017a	83 f8 05	 cmp	 eax, 5
  0017d	7d 09		 jge	 SHORT $LN36@mainLoop

; 47   : 	{
; 48   : 		GameStates::processedState->FOV = 5;

  0017f	c7 42 20 05 00
	00 00		 mov	 DWORD PTR [rdx+32], 5
  00186	eb 0e		 jmp	 SHORT $LN34@mainLoop
$LN36@mainLoop:

; 49   : 	}
; 50   : 	else if(GameStates::processedState->FOV > 175)

  00188	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  0018d	7e 07		 jle	 SHORT $LN34@mainLoop

; 51   : 	{
; 52   : 		GameStates::processedState->FOV = 175;

  0018f	c7 42 20 af 00
	00 00		 mov	 DWORD PTR [rdx+32], 175	; 000000afH
$LN34@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0019d	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  001a2	85 c0		 test	 eax, eax
  001a4	74 07		 je	 SHORT $LN85@mainLoop

; 33   : 		_Throw_C_error(_Res);

  001a6	8b c8		 mov	 ecx, eax
  001a8	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN85@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  001ad	0f b6 1d 10 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  001bb	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  001c0	85 c0		 test	 eax, eax
  001c2	74 07		 je	 SHORT $LN92@mainLoop

; 33   : 		_Throw_C_error(_Res);

  001c4	8b c8		 mov	 ecx, eax
  001c6	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN92@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 55   : 	float b = Keyboard::getKey(16) ? 0.4f : 0.1f;

  001cb	84 db		 test	 bl, bl
  001cd	74 0b		 je	 SHORT $LN47@mainLoop
  001cf	f3 44 0f 10 15
	00 00 00 00	 movss	 xmm10, DWORD PTR __real@3ecccccd
  001d8	eb 09		 jmp	 SHORT $LN48@mainLoop
$LN47@mainLoop:
  001da	f3 44 0f 10 15
	00 00 00 00	 movss	 xmm10, DWORD PTR __real@3dcccccd
$LN48@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  001ea	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  001ef	85 c0		 test	 eax, eax
  001f1	74 07		 je	 SHORT $LN101@mainLoop

; 33   : 		_Throw_C_error(_Res);

  001f3	8b c8		 mov	 ecx, eax
  001f5	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN101@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  001fa	0f b6 1d 57 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+87
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00208	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0020d	85 c0		 test	 eax, eax
  0020f	74 07		 je	 SHORT $LN108@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00211	8b c8		 mov	 ecx, eax
  00213	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN108@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 57   : 	if(Keyboard::getKey(87)) //W

  00218	f2 44 0f 10 1d
	00 00 00 00	 movsdx	 xmm11, QWORD PTR __real@400921fb54442d18
  00221	f2 44 0f 10 25
	00 00 00 00	 movsdx	 xmm12, QWORD PTR __real@4066800000000000
  0022a	84 db		 test	 bl, bl
  0022c	0f 84 ae 00 00
	00		 je	 $LN33@mainLoop
  00232	f3 41 0f 10 7e
	10		 movss	 xmm7, DWORD PTR [r14+16]

; 58   : 	{
; 59   : 		cam->pos.x -= b * cos(cam->rot.x * M_PI / 180.0f) * sin(cam->rot.y * M_PI / 180.0f);

  00238	0f 5a ff	 cvtps2pd xmm7, xmm7
  0023b	f2 41 0f 59 fb	 mulsd	 xmm7, xmm11
  00240	f2 41 0f 5e fc	 divsd	 xmm7, xmm12
  00245	0f 28 c7	 movaps	 xmm0, xmm7
  00248	e8 00 00 00 00	 call	 cos
  0024d	44 0f 28 c8	 movaps	 xmm9, xmm0
  00251	41 0f 5a c2	 cvtps2pd xmm0, xmm10
  00255	f2 44 0f 59 c8	 mulsd	 xmm9, xmm0
  0025a	f3 45 0f 10 46
	14		 movss	 xmm8, DWORD PTR [r14+20]
  00260	45 0f 5a c0	 cvtps2pd xmm8, xmm8
  00264	f2 45 0f 59 c3	 mulsd	 xmm8, xmm11
  00269	f2 45 0f 5e c4	 divsd	 xmm8, xmm12
  0026e	f3 41 0f 10 36	 movss	 xmm6, DWORD PTR [r14]
  00273	0f 5a f6	 cvtps2pd xmm6, xmm6
  00276	41 0f 28 c0	 movaps	 xmm0, xmm8
  0027a	e8 00 00 00 00	 call	 sin
  0027f	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  00284	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00288	66 0f 5a ce	 cvtpd2ps xmm1, xmm6
  0028c	f3 41 0f 11 0e	 movss	 DWORD PTR [r14], xmm1

; 60   : 		cam->pos.y += b * sin(cam->rot.x * M_PI / 180.0f);

  00291	0f 28 c7	 movaps	 xmm0, xmm7
  00294	e8 00 00 00 00	 call	 sin
  00299	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  0029d	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  002a1	f3 41 0f 10 56
	04		 movss	 xmm2, DWORD PTR [r14+4]
  002a7	0f 5a d2	 cvtps2pd xmm2, xmm2
  002aa	f2 0f 58 c2	 addsd	 xmm0, xmm2
  002ae	0f 57 c9	 xorps	 xmm1, xmm1
  002b1	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  002b5	f3 41 0f 11 4e
	04		 movss	 DWORD PTR [r14+4], xmm1

; 61   : 		cam->pos.z += b * cos(cam->rot.x * M_PI / 180.0f) * cos(cam->rot.y * M_PI / 180.0f);

  002bb	41 0f 28 c0	 movaps	 xmm0, xmm8
  002bf	e8 00 00 00 00	 call	 cos
  002c4	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  002c9	f3 41 0f 10 4e
	08		 movss	 xmm1, DWORD PTR [r14+8]
  002cf	0f 5a c9	 cvtps2pd xmm1, xmm1
  002d2	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002d6	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002da	f3 41 0f 11 46
	08		 movss	 DWORD PTR [r14+8], xmm0
$LN33@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  002e7	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  002ec	85 c0		 test	 eax, eax
  002ee	74 07		 je	 SHORT $LN117@mainLoop

; 33   : 		_Throw_C_error(_Res);

  002f0	8b c8		 mov	 ecx, eax
  002f2	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN117@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  002f7	0f b6 1d 53 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+83
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  002fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00305	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0030a	85 c0		 test	 eax, eax
  0030c	74 07		 je	 SHORT $LN124@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0030e	8b c8		 mov	 ecx, eax
  00310	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN124@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 64   : 	if(Keyboard::getKey(83)) //S

  00315	84 db		 test	 bl, bl
  00317	0f 84 ae 00 00
	00		 je	 $LN32@mainLoop
  0031d	f3 45 0f 10 46
	10		 movss	 xmm8, DWORD PTR [r14+16]

; 65   : 	{
; 66   : 		cam->pos.x += b * cos(cam->rot.x * M_PI / 180.0f) * sin(cam->rot.y * M_PI / 180.0f);

  00323	45 0f 5a c0	 cvtps2pd xmm8, xmm8
  00327	f2 45 0f 59 c3	 mulsd	 xmm8, xmm11
  0032c	f2 45 0f 5e c4	 divsd	 xmm8, xmm12
  00331	41 0f 28 c0	 movaps	 xmm0, xmm8
  00335	e8 00 00 00 00	 call	 cos
  0033a	44 0f 28 c8	 movaps	 xmm9, xmm0
  0033e	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  00342	f2 44 0f 59 c9	 mulsd	 xmm9, xmm1
  00347	f3 41 0f 10 7e
	14		 movss	 xmm7, DWORD PTR [r14+20]
  0034d	0f 5a ff	 cvtps2pd xmm7, xmm7
  00350	f2 41 0f 59 fb	 mulsd	 xmm7, xmm11
  00355	f2 41 0f 5e fc	 divsd	 xmm7, xmm12
  0035a	0f 28 c7	 movaps	 xmm0, xmm7
  0035d	e8 00 00 00 00	 call	 sin
  00362	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  00367	f3 41 0f 10 0e	 movss	 xmm1, DWORD PTR [r14]
  0036c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0036f	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00373	0f 57 c9	 xorps	 xmm1, xmm1
  00376	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  0037a	f3 41 0f 11 0e	 movss	 DWORD PTR [r14], xmm1
  0037f	f3 41 0f 10 76
	04		 movss	 xmm6, DWORD PTR [r14+4]

; 67   : 		cam->pos.y -= b * sin(cam->rot.x * M_PI / 180.0f);

  00385	0f 5a f6	 cvtps2pd xmm6, xmm6
  00388	41 0f 28 c0	 movaps	 xmm0, xmm8
  0038c	e8 00 00 00 00	 call	 sin
  00391	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  00395	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00399	f2 0f 5c f0	 subsd	 xmm6, xmm0
  0039d	66 0f 5a d6	 cvtpd2ps xmm2, xmm6
  003a1	f3 41 0f 11 56
	04		 movss	 DWORD PTR [r14+4], xmm2
  003a7	f3 41 0f 10 76
	08		 movss	 xmm6, DWORD PTR [r14+8]

; 68   : 		cam->pos.z -= b * cos(cam->rot.x * M_PI / 180.0f) * cos(cam->rot.y * M_PI / 180.0f);

  003ad	0f 5a f6	 cvtps2pd xmm6, xmm6
  003b0	0f 28 c7	 movaps	 xmm0, xmm7
  003b3	e8 00 00 00 00	 call	 cos
  003b8	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  003bd	f2 0f 5c f0	 subsd	 xmm6, xmm0
  003c1	66 0f 5a c6	 cvtpd2ps xmm0, xmm6
  003c5	f3 41 0f 11 46
	08		 movss	 DWORD PTR [r14+8], xmm0
$LN32@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  003d2	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  003d7	85 c0		 test	 eax, eax
  003d9	74 07		 je	 SHORT $LN133@mainLoop

; 33   : 		_Throw_C_error(_Res);

  003db	8b c8		 mov	 ecx, eax
  003dd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN133@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  003e2	0f b6 1d 41 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+65
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  003e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  003f0	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  003f5	85 c0		 test	 eax, eax
  003f7	74 07		 je	 SHORT $LN140@mainLoop

; 33   : 		_Throw_C_error(_Res);

  003f9	8b c8		 mov	 ecx, eax
  003fb	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN140@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 71   : 	if(Keyboard::getKey(65)) //A

  00400	84 db		 test	 bl, bl
  00402	74 5f		 je	 SHORT $LN31@mainLoop
  00404	f3 41 0f 10 7e
	14		 movss	 xmm7, DWORD PTR [r14+20]

; 72   : 	{
; 73   : 		cam->pos.x -= b * cos(cam->rot.y * M_PI / 180.0f);

  0040a	0f 5a ff	 cvtps2pd xmm7, xmm7
  0040d	f2 41 0f 59 fb	 mulsd	 xmm7, xmm11
  00412	f2 41 0f 5e fc	 divsd	 xmm7, xmm12
  00417	f3 41 0f 10 36	 movss	 xmm6, DWORD PTR [r14]
  0041c	0f 5a f6	 cvtps2pd xmm6, xmm6
  0041f	0f 28 c7	 movaps	 xmm0, xmm7
  00422	e8 00 00 00 00	 call	 cos
  00427	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  0042b	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0042f	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00433	66 0f 5a d6	 cvtpd2ps xmm2, xmm6
  00437	f3 41 0f 11 16	 movss	 DWORD PTR [r14], xmm2
  0043c	f3 41 0f 10 76
	08		 movss	 xmm6, DWORD PTR [r14+8]

; 74   : 		cam->pos.z -= b * sin(cam->rot.y * M_PI / 180.0f);

  00442	0f 5a f6	 cvtps2pd xmm6, xmm6
  00445	0f 28 c7	 movaps	 xmm0, xmm7
  00448	e8 00 00 00 00	 call	 sin
  0044d	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  00451	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00455	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00459	66 0f 5a c6	 cvtpd2ps xmm0, xmm6
  0045d	f3 41 0f 11 46
	08		 movss	 DWORD PTR [r14+8], xmm0
$LN31@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00463	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0046a	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0046f	85 c0		 test	 eax, eax
  00471	74 07		 je	 SHORT $LN149@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00473	8b c8		 mov	 ecx, eax
  00475	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN149@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  0047a	0f b6 1d 44 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+68
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00488	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0048d	85 c0		 test	 eax, eax
  0048f	74 07		 je	 SHORT $LN156@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00491	8b c8		 mov	 ecx, eax
  00493	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN156@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 77   : 	if(Keyboard::getKey(68)) //D

  00498	84 db		 test	 bl, bl
  0049a	74 62		 je	 SHORT $LN30@mainLoop
  0049c	f3 41 0f 10 76
	14		 movss	 xmm6, DWORD PTR [r14+20]

; 78   : 	{
; 79   : 		cam->pos.x += b * cos(cam->rot.y * M_PI / 180.0f);

  004a2	0f 5a f6	 cvtps2pd xmm6, xmm6
  004a5	f2 41 0f 59 f3	 mulsd	 xmm6, xmm11
  004aa	f2 41 0f 5e f4	 divsd	 xmm6, xmm12
  004af	0f 28 c6	 movaps	 xmm0, xmm6
  004b2	e8 00 00 00 00	 call	 cos
  004b7	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  004bb	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  004bf	f3 41 0f 10 16	 movss	 xmm2, DWORD PTR [r14]
  004c4	0f 5a d2	 cvtps2pd xmm2, xmm2
  004c7	f2 0f 58 c2	 addsd	 xmm0, xmm2
  004cb	0f 57 c9	 xorps	 xmm1, xmm1
  004ce	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  004d2	f3 41 0f 11 0e	 movss	 DWORD PTR [r14], xmm1

; 80   : 		cam->pos.z += b * sin(cam->rot.y * M_PI / 180.0f);

  004d7	0f 28 c6	 movaps	 xmm0, xmm6
  004da	e8 00 00 00 00	 call	 sin
  004df	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  004e3	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  004e7	f3 41 0f 10 56
	08		 movss	 xmm2, DWORD PTR [r14+8]
  004ed	0f 5a d2	 cvtps2pd xmm2, xmm2
  004f0	f2 0f 58 c2	 addsd	 xmm0, xmm2
  004f4	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  004f8	f3 41 0f 11 46
	08		 movss	 DWORD PTR [r14+8], xmm0
$LN30@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  004fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00505	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0050a	85 c0		 test	 eax, eax
  0050c	74 07		 je	 SHORT $LN165@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0050e	8b c8		 mov	 ecx, eax
  00510	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN165@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  00515	0f b6 1d 20 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+32
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0051c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00523	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00528	85 c0		 test	 eax, eax
  0052a	74 07		 je	 SHORT $LN172@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0052c	8b c8		 mov	 ecx, eax
  0052e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN172@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 83   : 	if(Keyboard::getKey(32)) //SPACE

  00533	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  0053a	84 db		 test	 bl, bl
  0053c	74 46		 je	 SHORT $LN29@mainLoop

; 84   : 	{ //SPACE!
; 85   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), Blocks::stone); //SPAAAAAAAAAAAAAACE!

  0053e	f3 41 0f 10 46
	08		 movss	 xmm0, DWORD PTR [r14+8]
  00544	e8 00 00 00 00	 call	 floorf
  00549	f3 0f 2c f8	 cvttss2si edi, xmm0
  0054d	f3 41 0f 10 46
	04		 movss	 xmm0, DWORD PTR [r14+4]
  00553	e8 00 00 00 00	 call	 floorf
  00558	f3 0f 2c d8	 cvttss2si ebx, xmm0
  0055c	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  00561	e8 00 00 00 00	 call	 floorf
  00566	f3 0f 2c d0	 cvttss2si edx, xmm0
  0056a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?stone@Blocks@@3PEAVBlock@@EA ; Blocks::stone
  00571	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00576	44 8b cf	 mov	 r9d, edi
  00579	44 8b c3	 mov	 r8d, ebx
  0057c	48 8b ce	 mov	 rcx, rsi
  0057f	e8 00 00 00 00	 call	 ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z ; World::setBlock
$LN29@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00584	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0058b	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00590	85 c0		 test	 eax, eax
  00592	74 07		 je	 SHORT $LN181@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00594	8b c8		 mov	 ecx, eax
  00596	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN181@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  0059b	0f b6 1d 11 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+17
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  005a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  005a9	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  005ae	85 c0		 test	 eax, eax
  005b0	74 07		 je	 SHORT $LN188@mainLoop

; 33   : 		_Throw_C_error(_Res);

  005b2	8b c8		 mov	 ecx, eax
  005b4	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN188@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 88   : 	if(Keyboard::getKey(17)) //CTRL

  005b9	84 db		 test	 bl, bl
  005bb	0f 84 af 00 00
	00		 je	 $LN25@mainLoop

; 89   : 	{
; 90   : 		for(int i = -1; i < 2; i++)

  005c1	41 83 cd ff	 or	 r13d, -1
  005c5	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  005cc	0f 1f 40 00	 npad	 4
$LL27@mainLoop:

; 91   : 		{
; 92   : 			for(int j = -1; j < 2; j++)

  005d0	41 83 cf ff	 or	 r15d, -1
  005d4	66 41 0f 6e fd	 movd	 xmm7, r13d
  005d9	0f 5b ff	 cvtdq2ps xmm7, xmm7
  005dc	0f 1f 40 00	 npad	 4
$LL24@mainLoop:

; 93   : 			{
; 94   : 				for(int k = -1; k < 2; k++)

  005e0	83 ce ff	 or	 esi, -1
  005e3	66 41 0f 6e f7	 movd	 xmm6, r15d
  005e8	0f 5b f6	 cvtdq2ps xmm6, xmm6
  005eb	0f 1f 44 00 00	 npad	 5
$LL21@mainLoop:

; 95   : 				{
; 96   : 					GlobalThread::world.setBlock(floorf(cam->pos.x) + i, floorf(cam->pos.y) + j, floorf(cam->pos.z) + k, Blocks::air);

  005f0	f3 41 0f 10 46
	08		 movss	 xmm0, DWORD PTR [r14+8]
  005f6	e8 00 00 00 00	 call	 floorf
  005fb	66 0f 6e ce	 movd	 xmm1, esi
  005ff	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00602	f3 0f 58 c1	 addss	 xmm0, xmm1
  00606	f3 0f 2c f8	 cvttss2si edi, xmm0
  0060a	f3 41 0f 10 46
	04		 movss	 xmm0, DWORD PTR [r14+4]
  00610	e8 00 00 00 00	 call	 floorf
  00615	f3 0f 58 c6	 addss	 xmm0, xmm6
  00619	f3 0f 2c d8	 cvttss2si ebx, xmm0
  0061d	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  00622	e8 00 00 00 00	 call	 floorf
  00627	f3 0f 58 c7	 addss	 xmm0, xmm7
  0062b	f3 0f 2c d0	 cvttss2si edx, xmm0
  0062f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?air@Blocks@@3PEAVBlockAir@@EA ; Blocks::air
  00636	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0063b	44 8b cf	 mov	 r9d, edi
  0063e	44 8b c3	 mov	 r8d, ebx
  00641	49 8b cc	 mov	 rcx, r12
  00644	e8 00 00 00 00	 call	 ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z ; World::setBlock

; 93   : 			{
; 94   : 				for(int k = -1; k < 2; k++)

  00649	ff c6		 inc	 esi
  0064b	83 fe 02	 cmp	 esi, 2
  0064e	7c a0		 jl	 SHORT $LL21@mainLoop

; 91   : 		{
; 92   : 			for(int j = -1; j < 2; j++)

  00650	41 ff c7	 inc	 r15d
  00653	41 83 ff 02	 cmp	 r15d, 2
  00657	7c 87		 jl	 SHORT $LL24@mainLoop

; 89   : 	{
; 90   : 		for(int i = -1; i < 2; i++)

  00659	41 ff c5	 inc	 r13d
  0065c	41 83 fd 02	 cmp	 r13d, 2
  00660	0f 8c 6a ff ff
	ff		 jl	 $LL27@mainLoop
  00666	45 33 e4	 xor	 r12d, r12d
  00669	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
$LN25@mainLoop:

; 97   : 				}
; 98   : 			}
; 99   : 		}
; 100  : 	}
; 101  : 
; 102  : 	GlobalThread::world.tick();

  00670	48 8b ce	 mov	 rcx, rsi
  00673	e8 00 00 00 00	 call	 ?tick@World@@QEAAXXZ	; World::tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h

; 37   : 		count = 0;

  00678	44 89 25 40 01
	00 00		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, r12d
  0067f	44 89 25 80 00
	00 00		 mov	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128, r12d
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 107  : 	camX = cam->pos.x / 16.0f;

  00686	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  0068b	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3d800000
  00693	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00697	f3 0f 2c d0	 cvttss2si edx, xmm0
  0069b	89 15 00 00 00
	00		 mov	 DWORD PTR ?camX@@3HA, edx ; camX

; 108  : 	camY = cam->pos.y / 16.0f;

  006a1	f3 41 0f 10 46
	04		 movss	 xmm0, DWORD PTR [r14+4]
  006a7	f3 0f 59 c2	 mulss	 xmm0, xmm2
  006ab	f3 0f 2c c0	 cvttss2si eax, xmm0
  006af	89 05 00 00 00
	00		 mov	 DWORD PTR ?camY@@3HA, eax ; camY

; 109  : 	camZ = cam->pos.z / 16.0f;

  006b5	f3 41 0f 10 4e
	08		 movss	 xmm1, DWORD PTR [r14+8]
  006bb	f3 0f 59 ca	 mulss	 xmm1, xmm2
  006bf	f3 0f 2c c9	 cvttss2si ecx, xmm1
  006c3	89 0d 00 00 00
	00		 mov	 DWORD PTR ?camZ@@3HA, ecx ; camZ

; 110  : 	
; 111  : 	if(camX != prevCamX || camY != prevCamY || camZ != prevCamZ)

  006c9	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?prevCamY@@3HA ; prevCamY
  006cf	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  006d5	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?prevCamX@@3HA ; prevCamX
  006db	3b d7		 cmp	 edx, edi
  006dd	75 0e		 jne	 SHORT $LN588@mainLoop
  006df	3b c3		 cmp	 eax, ebx
  006e1	75 08		 jne	 SHORT $LN17@mainLoop
  006e3	3b ce		 cmp	 ecx, esi
  006e5	0f 84 17 06 00
	00		 je	 $LN530@mainLoop
$LN17@mainLoop:

; 112  : 	{
; 113  : 		int xLimit = (camX > prevCamX ? camX : prevCamX) + renderDistance;

  006eb	3b d7		 cmp	 edx, edi
$LN588@mainLoop:
  006ed	0f 4f fa	 cmovg	 edi, edx
  006f0	83 c7 08	 add	 edi, 8
  006f3	89 7c 24 48	 mov	 DWORD PTR xLimit$1$[rsp], edi

; 114  : 		int yLimit = (camY > prevCamY ? camY : prevCamY) + renderDistance;

  006f7	3b c3		 cmp	 eax, ebx
  006f9	0f 4f d8	 cmovg	 ebx, eax
  006fc	83 c3 08	 add	 ebx, 8
  006ff	89 5c 24 44	 mov	 DWORD PTR yLimit$1$[rsp], ebx

; 115  : 		int zLimit = (camZ > prevCamZ ? camZ : prevCamZ) + renderDistance;

  00703	3b ce		 cmp	 ecx, esi
  00705	0f 4f f1	 cmovg	 esi, ecx
  00708	83 c6 08	 add	 esi, 8
  0070b	89 75 60	 mov	 DWORD PTR zLimit$1$[rbp-256], esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0070e	48 8d 0d 90 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+144
  00715	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0071a	85 c0		 test	 eax, eax
  0071c	74 07		 je	 SHORT $LN199@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0071e	8b c8		 mov	 ecx, eax
  00720	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN199@mainLoop:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00725	48 8d 0d c0 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+192
  0072c	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00731	85 c0		 test	 eax, eax
  00733	74 07		 je	 SHORT $LN206@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00735	8b c8		 mov	 ecx, eax
  00737	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN206@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 118  : 		for(int i = (camX < prevCamX ? camX : prevCamX) - renderDistance; i <= xLimit; i++)

  0073c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?prevCamX@@3HA ; prevCamX
  00742	44 8b e8	 mov	 r13d, eax
  00745	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camX@@3HA ; camX
  0074b	3b c8		 cmp	 ecx, eax
  0074d	44 0f 4c e9	 cmovl	 r13d, ecx
  00751	41 83 ed 08	 sub	 r13d, 8
  00755	44 3b ef	 cmp	 r13d, edi
  00758	0f 8f 64 05 00
	00		 jg	 $LN580@mainLoop
  0075e	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR ?camY@@3HA ; camY
  00765	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR ?prevCamY@@3HA ; prevCamY
  0076c	0f 1f 40 00	 npad	 4
$LL16@mainLoop:

; 119  : 		{
; 120  : 			int xDist = (i - camX) * (i - camX);

  00770	45 8b d5	 mov	 r10d, r13d
  00773	44 2b d1	 sub	 r10d, ecx
  00776	45 0f af d2	 imul	 r10d, r10d
  0077a	44 89 55 78	 mov	 DWORD PTR xDist$1$[rbp-256], r10d

; 121  : 			int xPrevDist = (i - prevCamX) * (i - prevCamX);

  0077e	45 8b dd	 mov	 r11d, r13d
  00781	44 2b d8	 sub	 r11d, eax
  00784	45 0f af db	 imul	 r11d, r11d
  00788	44 89 5c 24 40	 mov	 DWORD PTR xPrevDist$1$[rsp], r11d

; 122  : 			for(int j = (camY < prevCamY ? camY : prevCamY) - renderDistance; j <= yLimit; j++)

  0078d	45 8b f9	 mov	 r15d, r9d
  00790	45 3b c1	 cmp	 r8d, r9d
  00793	45 0f 4c f8	 cmovl	 r15d, r8d
  00797	41 83 ef 08	 sub	 r15d, 8
  0079b	44 3b fb	 cmp	 r15d, ebx
  0079e	0f 8f 05 05 00
	00		 jg	 $LN15@mainLoop
  007a4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL13@mainLoop:

; 123  : 			{
; 124  : 				int yDist = (j - camY) * (j - camY);

  007b0	41 8b cf	 mov	 ecx, r15d
  007b3	41 2b c8	 sub	 ecx, r8d
  007b6	0f af c9	 imul	 ecx, ecx

; 125  : 				int yPrevDist = (j - prevCamY) * (j - prevCamY);

  007b9	41 8b d7	 mov	 edx, r15d
  007bc	41 2b d1	 sub	 edx, r9d
  007bf	0f af d2	 imul	 edx, edx

; 126  : 				for(int k = (camZ < prevCamZ ? camZ : prevCamZ) - renderDistance; k <= zLimit; k++)

  007c2	44 8b 35 00 00
	00 00		 mov	 r14d, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  007c9	44 39 35 00 00
	00 00		 cmp	 DWORD PTR ?camZ@@3HA, r14d ; camZ
  007d0	44 0f 4c 35 00
	00 00 00	 cmovl	 r14d, DWORD PTR ?camZ@@3HA ; camZ
  007d8	41 83 ee 08	 sub	 r14d, 8
  007dc	44 3b f6	 cmp	 r14d, esi
  007df	0f 8f a8 04 00
	00		 jg	 $LN12@mainLoop
  007e5	46 8d 04 11	 lea	 r8d, DWORD PTR [rcx+r10]
  007e9	44 89 45 68	 mov	 DWORD PTR tv2278[rbp-256], r8d
  007ed	41 03 d3	 add	 edx, r11d
  007f0	89 55 70	 mov	 DWORD PTR tv2277[rbp-256], edx
  007f3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL10@mainLoop:

; 127  : 				{
; 128  : 					int zDist = (k - camZ) * (k - camZ);

  00800	41 8b c6	 mov	 eax, r14d
  00803	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?camZ@@3HA ; camZ
  00809	0f af c0	 imul	 eax, eax

; 129  : 					int zPrevDist = (k - prevCamZ) * (k - prevCamZ);

  0080c	41 8b ce	 mov	 ecx, r14d
  0080f	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  00815	0f af c9	 imul	 ecx, ecx

; 130  : 
; 131  : 					bool in1 = xDist + yDist + zDist <= renderDistance * renderDistance;

  00818	41 03 c0	 add	 eax, r8d
  0081b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0081e	0f 9e c3	 setle	 bl

; 132  : 					bool in2 = xPrevDist + yPrevDist + zPrevDist <= renderDistance * renderDistance;

  00821	8d 04 0a	 lea	 eax, DWORD PTR [rdx+rcx]
  00824	83 f8 40	 cmp	 eax, 64			; 00000040H
  00827	40 0f 9e c7	 setle	 dil

; 133  : 
; 134  : 					if(j > 12) continue;

  0082b	41 83 ff 0c	 cmp	 r15d, 12
  0082f	0f 8f 31 04 00
	00		 jg	 $LN9@mainLoop

; 135  : 
; 136  : 					std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(i, j, k);

  00835	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  0083a	45 8b cf	 mov	 r9d, r15d
  0083d	45 8b c5	 mov	 r8d, r13d
  00840	48 8d 54 24 30	 lea	 rdx, QWORD PTR c$1[rsp]
  00845	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  0084c	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  00851	90		 npad	 1

; 137  : 
; 138  : 					if(in1 & !in2)

  00852	40 84 ff	 test	 dil, dil
  00855	0f 94 c1	 sete	 cl
  00858	84 cb		 test	 cl, bl
  0085a	0f 84 d2 02 00
	00		 je	 $LN6@mainLoop

; 139  : 					{
; 140  : 						if(c->isEmpty())

  00860	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$1[rsp]
  00865	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00868	ff 50 18	 call	 QWORD PTR [rax+24]
  0086b	84 c0		 test	 al, al
  0086d	0f 84 be 03 00
	00		 je	 $LN565@mainLoop

; 142  : 							c = std::shared_ptr<ChunkBase>(new Chunk(GlobalThread::world, i, j, k));

  00873	b9 60 20 00 00	 mov	 ecx, 8288		; 00002060H
  00878	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0087d	48 8b d8	 mov	 rbx, rax
  00880	48 89 45 88	 mov	 QWORD PTR $T7[rbp-256], rax
  00884	48 85 c0	 test	 rax, rax
  00887	0f 84 99 00 00
	00		 je	 $LN49@mainLoop
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0088d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkBase@@6B@
  00894	48 89 03	 mov	 QWORD PTR [rbx], rax
  00897	66 c7 43 08 00
	00		 mov	 WORD PTR [rbx+8], 0
  0089d	c6 43 0a 00	 mov	 BYTE PTR [rbx+10], 0
  008a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  008a8	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 11   : {

  008ac	44 89 6b 18	 mov	 DWORD PTR [rbx+24], r13d
  008b0	44 89 7b 1c	 mov	 DWORD PTR [rbx+28], r15d
  008b4	44 89 73 20	 mov	 DWORD PTR [rbx+32], r14d

; 54   : {

  008b8	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  008bc	ba 02 00 00 00	 mov	 edx, 2
  008c1	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  008c6	85 c0		 test	 eax, eax
  008c8	74 08		 je	 SHORT $LN230@mainLoop

; 33   : 		_Throw_C_error(_Res);

  008ca	8b c8		 mov	 ecx, eax
  008cc	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  008d1	90		 npad	 1
$LN230@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  008d2	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  008d6	ba 02 00 00 00	 mov	 edx, 2
  008db	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  008e0	85 c0		 test	 eax, eax
  008e2	74 08		 je	 SHORT $LN239@mainLoop

; 33   : 		_Throw_C_error(_Res);

  008e4	8b c8		 mov	 ecx, eax
  008e6	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  008eb	90		 npad	 1
$LN239@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  008ec	48 8d 4b 38	 lea	 rcx, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  008f0	4c 89 21	 mov	 QWORD PTR [rcx], r12
  008f3	4c 89 61 08	 mov	 QWORD PTR [rcx+8], r12

; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  008f7	33 d2		 xor	 edx, edx
  008f9	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  008fe	90		 npad	 1
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  008ff	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00903	4c 89 21	 mov	 QWORD PTR [rcx], r12
  00906	4c 89 61 08	 mov	 QWORD PTR [rcx+8], r12

; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  0090a	33 d2		 xor	 edx, edx
  0090c	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  00911	90		 npad	 1
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 150  : {

  00912	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  00919	48 89 03	 mov	 QWORD PTR [rbx], rax
  0091c	48 c7 43 58 00
	00 00 00	 mov	 QWORD PTR [rbx+88], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 142  : 							c = std::shared_ptr<ChunkBase>(new Chunk(GlobalThread::world, i, j, k));

  00924	eb 03		 jmp	 SHORT $LN50@mainLoop
$LN49@mainLoop:
  00926	49 8b dc	 mov	 rbx, r12
$LN50@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00929	4c 89 64 24 60	 mov	 QWORD PTR $T3[rsp], r12
  0092e	4c 89 64 24 68	 mov	 QWORD PTR $T3[rsp+8], r12

; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00933	48 8b d3	 mov	 rdx, rbx
  00936	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  0093b	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00940	48 8b 74 24 68	 mov	 rsi, QWORD PTR $T3[rsp+8]

; 49   : 	_Right = _Move(_Tmp);

  00945	4c 89 64 24 68	 mov	 QWORD PTR $T3[rsp+8], r12

; 48   : 	_Left = _Move(_Right);

  0094a	48 8b 44 24 60	 mov	 rax, QWORD PTR $T3[rsp]
  0094f	48 89 44 24 70	 mov	 QWORD PTR $T4[rsp], rax

; 49   : 	_Right = _Move(_Tmp);

  00954	4c 89 64 24 60	 mov	 QWORD PTR $T3[rsp], r12

; 48   : 	_Left = _Move(_Right);

  00959	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$1[rsp+8]
  0095e	48 89 4c 24 78	 mov	 QWORD PTR $T4[rsp+8], rcx

; 49   : 	_Right = _Move(_Tmp);

  00963	48 89 74 24 38	 mov	 QWORD PTR c$1[rsp+8], rsi
  00968	48 89 44 24 30	 mov	 QWORD PTR c$1[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0096d	48 85 c9	 test	 rcx, rcx
  00970	74 24		 je	 SHORT $LN560@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00972	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00976	75 1e		 jne	 SHORT $LN560@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00978	48 8b 5c 24 78	 mov	 rbx, QWORD PTR $T4[rsp+8]
  0097d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00980	48 8b cb	 mov	 rcx, rbx
  00983	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00985	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00989	75 0b		 jne	 SHORT $LN560@mainLoop

; 128  : 			_Delete_this();

  0098b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T4[rsp+8]
  00990	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00993	ff 50 08	 call	 QWORD PTR [rax+8]
$LN560@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00996	48 8b 05 b8 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+184
  0099d	48 ff c0	 inc	 rax
  009a0	48 8b 3d a8 00
	00 00		 mov	 rdi, QWORD PTR ?world@GlobalThread@@3VWorld@@A+168
  009a7	48 3b f8	 cmp	 rdi, rax
  009aa	77 13		 ja	 SHORT $LN332@mainLoop
  009ac	48 8d 0d 98 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+152
  009b3	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
  009b8	48 8b 3d a8 00
	00 00		 mov	 rdi, QWORD PTR ?world@GlobalThread@@3VWorld@@A+168
$LN332@mainLoop:
  009bf	48 ff cf	 dec	 rdi
  009c2	48 8b 0d b0 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+176
  009c9	48 23 cf	 and	 rcx, rdi
  009cc	48 89 0d b0 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+176, rcx
  009d3	48 03 0d b8 00
	00 00		 add	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+184

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  009da	48 23 f9	 and	 rdi, rcx

; 1487 : 		_PUSH_BACK_BEGIN;

  009dd	48 8b 05 a0 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+160
  009e4	48 83 3c f8 00	 cmp	 QWORD PTR [rax+rdi*8], 0
  009e9	75 25		 jne	 SHORT $LN331@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  009eb	b9 10 00 00 00	 mov	 ecx, 16
  009f0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  009f5	48 85 c0	 test	 rax, rax
  009f8	0f 84 b8 02 00
	00		 je	 $LN541@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  009fe	48 8b 0d a0 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+160
  00a05	48 89 04 f9	 mov	 QWORD PTR [rcx+rdi*8], rax
  00a09	48 8b 05 a0 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+160
$LN331@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00a10	48 8b 3c f8	 mov	 rdi, QWORD PTR [rax+rdi*8]
  00a14	48 85 ff	 test	 rdi, rdi
  00a17	74 42		 je	 SHORT $LN366@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00a19	4c 89 27	 mov	 QWORD PTR [rdi], r12
  00a1c	4c 89 67 08	 mov	 QWORD PTR [rdi+8], r12

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00a20	48 85 f6	 test	 rsi, rsi
  00a23	74 04		 je	 SHORT $LN379@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00a25	f0 ff 46 08	 lock inc DWORD PTR [rsi+8]
$LN379@mainLoop:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00a29	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00a2d	48 85 db	 test	 rbx, rbx
  00a30	74 1d		 je	 SHORT $LN561@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00a32	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00a36	75 17		 jne	 SHORT $LN561@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00a38	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a3b	48 8b cb	 mov	 rcx, rbx
  00a3e	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00a40	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00a44	75 09		 jne	 SHORT $LN561@mainLoop

; 128  : 			_Delete_this();

  00a46	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a49	48 8b cb	 mov	 rcx, rbx
  00a4c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN561@mainLoop:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00a4f	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 427  : 		_Ptr = _Other_ptr;

  00a53	48 8b 44 24 70	 mov	 rax, QWORD PTR $T4[rsp]
  00a58	48 89 07	 mov	 QWORD PTR [rdi], rax
$LN366@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00a5b	48 ff 05 b8 00
	00 00		 inc	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+184
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00a62	4c 89 64 24 50	 mov	 QWORD PTR $T2[rsp], r12
  00a67	4c 89 64 24 58	 mov	 QWORD PTR $T2[rsp+8], r12

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00a6c	48 85 f6	 test	 rsi, rsi
  00a6f	74 2b		 je	 SHORT $LN562@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00a71	f0 ff 46 08	 lock inc DWORD PTR [rsi+8]

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00a75	48 8b 5c 24 58	 mov	 rbx, QWORD PTR $T2[rsp+8]
  00a7a	48 85 db	 test	 rbx, rbx
  00a7d	74 1d		 je	 SHORT $LN562@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00a7f	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00a83	75 17		 jne	 SHORT $LN562@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00a85	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a88	48 8b cb	 mov	 rcx, rbx
  00a8b	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00a8d	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00a91	75 09		 jne	 SHORT $LN562@mainLoop

; 128  : 			_Delete_this();

  00a93	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a96	48 8b cb	 mov	 rcx, rbx
  00a99	ff 50 08	 call	 QWORD PTR [rax+8]
$LN562@mainLoop:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00a9c	48 89 74 24 58	 mov	 QWORD PTR $T2[rsp+8], rsi

; 427  : 		_Ptr = _Other_ptr;

  00aa1	48 8b 44 24 70	 mov	 rax, QWORD PTR $T4[rsp]
  00aa6	48 89 44 24 50	 mov	 QWORD PTR $T2[rsp], rax
  00aab	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  00ab0	48 89 45 88	 mov	 QWORD PTR $T6[rbp-256], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 215  : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  00ab4	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00aba	48 8d 0d 60 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2400
  00ac1	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00ac6	85 c0		 test	 eax, eax
  00ac8	74 07		 je	 SHORT $LN419@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00aca	8b c8		 mov	 ecx, eax
  00acc	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN419@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00ad1	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00ad6	48 8d 0d 38 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2360
  00add	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00ae2	48 8d 0d 60 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2400
  00ae9	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00aee	85 c0		 test	 eax, eax
  00af0	74 08		 je	 SHORT $LN428@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00af2	8b c8		 mov	 ecx, eax
  00af4	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00af9	90		 npad	 1
$LN428@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00afa	48 8b 5c 24 58	 mov	 rbx, QWORD PTR $T2[rsp+8]
  00aff	48 85 db	 test	 rbx, rbx
  00b02	0f 84 26 01 00
	00		 je	 $LN583@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00b08	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00b0c	0f 85 1c 01 00
	00		 jne	 $LN583@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00b12	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00b15	48 8b cb	 mov	 rcx, rbx
  00b18	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00b1a	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00b1e	0f 85 0a 01 00
	00		 jne	 $LN583@mainLoop

; 128  : 			_Delete_this();

  00b24	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00b27	48 8b cb	 mov	 rcx, rbx
  00b2a	ff 50 08	 call	 QWORD PTR [rax+8]
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 146  : 					}

  00b2d	e9 fc 00 00 00	 jmp	 $LN583@mainLoop
$LN6@mainLoop:

; 147  : 					else if(!in1 & in2)

  00b32	84 db		 test	 bl, bl
  00b34	0f 94 c1	 sete	 cl
  00b37	40 84 cf	 test	 cl, dil
  00b3a	0f 84 f1 00 00
	00		 je	 $LN565@mainLoop

; 148  : 					{
; 149  : 						if(!c->isEmpty())

  00b40	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$1[rsp]
  00b45	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00b48	ff 50 18	 call	 QWORD PTR [rax+24]
  00b4b	84 c0		 test	 al, al
  00b4d	0f 85 de 00 00
	00		 jne	 $LN565@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00b53	48 8b 05 e8 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+232
  00b5a	48 ff c0	 inc	 rax
  00b5d	48 8b 15 d8 00
	00 00		 mov	 rdx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+216
  00b64	48 3b d0	 cmp	 rdx, rax
  00b67	77 13		 ja	 SHORT $LN449@mainLoop
  00b69	48 8d 0d c8 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+200
  00b70	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
  00b75	48 8b 15 d8 00
	00 00		 mov	 rdx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+216
$LN449@mainLoop:
  00b7c	48 ff ca	 dec	 rdx
  00b7f	48 8b 0d e0 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+224
  00b86	48 23 ca	 and	 rcx, rdx
  00b89	48 89 0d e0 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+224, rcx
  00b90	48 8b 3d e8 00
	00 00		 mov	 rdi, QWORD PTR ?world@GlobalThread@@3VWorld@@A+232
  00b97	48 03 f9	 add	 rdi, rcx

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00b9a	48 23 fa	 and	 rdi, rdx

; 1487 : 		_PUSH_BACK_BEGIN;

  00b9d	48 8b 05 d0 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+208
  00ba4	48 83 3c f8 00	 cmp	 QWORD PTR [rax+rdi*8], 0
  00ba9	75 25		 jne	 SHORT $LN448@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00bab	b9 10 00 00 00	 mov	 ecx, 16
  00bb0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00bb5	48 85 c0	 test	 rax, rax
  00bb8	0f 84 fe 00 00
	00		 je	 $LN542@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00bbe	48 8b 0d d0 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+208
  00bc5	48 89 04 f9	 mov	 QWORD PTR [rcx+rdi*8], rax
  00bc9	48 8b 05 d0 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+208
$LN448@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00bd0	48 8b 3c f8	 mov	 rdi, QWORD PTR [rax+rdi*8]
  00bd4	48 85 ff	 test	 rdi, rdi
  00bd7	74 4c		 je	 SHORT $LN564@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00bd9	4c 89 27	 mov	 QWORD PTR [rdi], r12
  00bdc	4c 89 67 08	 mov	 QWORD PTR [rdi+8], r12

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00be0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$1[rsp+8]
  00be5	48 85 c9	 test	 rcx, rcx
  00be8	74 04		 je	 SHORT $LN496@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00bea	f0 ff 41 08	 lock inc DWORD PTR [rcx+8]
$LN496@mainLoop:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00bee	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00bf2	48 85 db	 test	 rbx, rbx
  00bf5	74 1d		 je	 SHORT $LN563@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00bf7	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00bfb	75 17		 jne	 SHORT $LN563@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00bfd	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00c00	48 8b cb	 mov	 rcx, rbx
  00c03	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00c05	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00c09	75 09		 jne	 SHORT $LN563@mainLoop

; 128  : 			_Delete_this();

  00c0b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00c0e	48 8b cb	 mov	 rcx, rbx
  00c11	ff 50 08	 call	 QWORD PTR [rax+8]
$LN563@mainLoop:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00c14	48 8b 44 24 38	 mov	 rax, QWORD PTR c$1[rsp+8]
  00c19	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 427  : 		_Ptr = _Other_ptr;

  00c1d	48 8b 44 24 30	 mov	 rax, QWORD PTR c$1[rsp]
  00c22	48 89 07	 mov	 QWORD PTR [rdi], rax
$LN564@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00c25	48 ff 05 e8 00
	00 00		 inc	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+232
  00c2c	eb 03		 jmp	 SHORT $LN565@mainLoop
$LN583@mainLoop:
  00c2e	8b 75 60	 mov	 esi, DWORD PTR zLimit$1$[rbp-256]
$LN565@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00c31	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$1[rsp+8]
  00c36	48 85 c9	 test	 rcx, rcx
  00c39	74 24		 je	 SHORT $LN586@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00c3b	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00c3f	75 1e		 jne	 SHORT $LN586@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00c41	48 8b 5c 24 38	 mov	 rbx, QWORD PTR c$1[rsp+8]
  00c46	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00c49	48 8b cb	 mov	 rcx, rbx
  00c4c	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00c4e	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00c52	75 0b		 jne	 SHORT $LN586@mainLoop

; 128  : 			_Delete_this();

  00c54	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$1[rsp+8]
  00c59	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00c5c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN586@mainLoop:
  00c5f	8b 55 70	 mov	 edx, DWORD PTR tv2277[rbp-256]
  00c62	44 8b 45 68	 mov	 r8d, DWORD PTR tv2278[rbp-256]
$LN9@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 126  : 				for(int k = (camZ < prevCamZ ? camZ : prevCamZ) - renderDistance; k <= zLimit; k++)

  00c66	41 ff c6	 inc	 r14d
  00c69	44 3b f6	 cmp	 r14d, esi
  00c6c	0f 8e 8e fb ff
	ff		 jle	 $LL10@mainLoop
  00c72	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR ?camY@@3HA ; camY
  00c79	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR ?prevCamY@@3HA ; prevCamY
  00c80	44 8b 55 78	 mov	 r10d, DWORD PTR xDist$1$[rbp-256]
  00c84	44 8b 5c 24 40	 mov	 r11d, DWORD PTR xPrevDist$1$[rsp]
  00c89	8b 5c 24 44	 mov	 ebx, DWORD PTR yLimit$1$[rsp]
$LN12@mainLoop:

; 122  : 			for(int j = (camY < prevCamY ? camY : prevCamY) - renderDistance; j <= yLimit; j++)

  00c8d	41 ff c7	 inc	 r15d
  00c90	44 3b fb	 cmp	 r15d, ebx
  00c93	0f 8e 17 fb ff
	ff		 jle	 $LL13@mainLoop
  00c99	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camX@@3HA ; camX
  00c9f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?prevCamX@@3HA ; prevCamX
  00ca5	8b 7c 24 48	 mov	 edi, DWORD PTR xLimit$1$[rsp]
$LN15@mainLoop:

; 118  : 		for(int i = (camX < prevCamX ? camX : prevCamX) - renderDistance; i <= xLimit; i++)

  00ca9	41 ff c5	 inc	 r13d
  00cac	44 3b ef	 cmp	 r13d, edi
  00caf	7f 11		 jg	 SHORT $LN580@mainLoop
  00cb1	e9 ba fa ff ff	 jmp	 $LL16@mainLoop
$LN541@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00cb6	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00cbb	cc		 int	 3
$LN542@mainLoop:
  00cbc	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00cc1	90		 npad	 1
$LN580@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00cc2	48 8d 0d 90 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+144
  00cc9	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00cce	85 c0		 test	 eax, eax
  00cd0	74 07		 je	 SHORT $LN523@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00cd2	8b c8		 mov	 ecx, eax
  00cd4	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN523@mainLoop:

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00cd9	48 8d 0d c0 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+192
  00ce0	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00ce5	85 c0		 test	 eax, eax
  00ce7	74 07		 je	 SHORT $LN567@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00ce9	8b c8		 mov	 ecx, eax
  00ceb	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN567@mainLoop:
  00cf0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camZ@@3HA ; camZ
  00cf6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?camY@@3HA ; camY
  00cfc	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?camX@@3HA ; camX
$LN530@mainLoop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 161  : 	prevCamX = camX;

  00d02	89 15 00 00 00
	00		 mov	 DWORD PTR ?prevCamX@@3HA, edx ; prevCamX

; 162  : 	prevCamY = camY;

  00d08	89 05 00 00 00
	00		 mov	 DWORD PTR ?prevCamY@@3HA, eax ; prevCamY

; 163  : 	prevCamZ = camZ;

  00d0e	89 0d 00 00 00
	00		 mov	 DWORD PTR ?prevCamZ@@3HA, ecx ; prevCamZ

; 164  : 
; 165  : 	GameStates::swapProcessedPending();

  00d14	e8 00 00 00 00	 call	 ?swapProcessedPending@GameStates@@YAXXZ ; GameStates::swapProcessedPending

; 166  : 
; 167  : 	if((GameStates::processedState == GameStates::pendingState) | (GameStates::pendingState == GameStates::renderingState) | (GameStates::processedState == GameStates::renderingState))

  00d19	45 8b cc	 mov	 r9d, r12d
  00d1c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ?pendingState@GameStates@@3PEAVGameState@1@EA ; GameStates::pendingState
  00d23	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?renderingState@GameStates@@3PEAVGameState@1@EA ; GameStates::renderingState
  00d2a	4c 3b c0	 cmp	 r8, rax
  00d2d	41 0f 94 c1	 sete	 r9b
  00d31	41 8b cc	 mov	 ecx, r12d
  00d34	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA, rax ; GameStates::processedState
  00d3b	0f 94 c1	 sete	 cl
  00d3e	44 0b c9	 or	 r9d, ecx
  00d41	4c 39 05 00 00
	00 00		 cmp	 QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA, r8 ; GameStates::processedState
  00d48	41 0f 94 c4	 sete	 r12b
  00d4c	45 0b cc	 or	 r9d, r12d
  00d4f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00d56	b9 01 00 00 00	 mov	 ecx, 1
  00d5b	0f 45 c1	 cmovne	 eax, ecx
  00d5e	88 05 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, al ; GlobalThread::stop

; 168  : 	{
; 169  : 		GlobalThread::stop = true;
; 170  : 	}
; 171  : 
; 172  : 	ticks++;

  00d64	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ticks@@3HA	; ticks

; 173  : 	return true;

  00d6a	0f b6 c1	 movzx	 eax, cl

; 174  : }

  00d6d	4c 8d 9c 24 18
	01 00 00	 lea	 r11, QWORD PTR [rsp+280]
  00d75	41 0f 28 73 e8	 movaps	 xmm6, XMMWORD PTR [r11-24]
  00d7a	41 0f 28 7b d8	 movaps	 xmm7, XMMWORD PTR [r11-40]
  00d7f	45 0f 28 43 c8	 movaps	 xmm8, XMMWORD PTR [r11-56]
  00d84	45 0f 28 4b b8	 movaps	 xmm9, XMMWORD PTR [r11-72]
  00d89	45 0f 28 53 a8	 movaps	 xmm10, XMMWORD PTR [r11-88]
  00d8e	45 0f 28 5b 98	 movaps	 xmm11, XMMWORD PTR [r11-104]
  00d93	45 0f 28 63 88	 movaps	 xmm12, XMMWORD PTR [r11-120]
  00d98	49 8b e3	 mov	 rsp, r11
  00d9b	41 5f		 pop	 r15
  00d9d	41 5e		 pop	 r14
  00d9f	41 5d		 pop	 r13
  00da1	41 5c		 pop	 r12
  00da3	5f		 pop	 rdi
  00da4	5e		 pop	 rsi
  00da5	5b		 pop	 rbx
  00da6	5d		 pop	 rbp
  00da7	c3		 ret	 0
$LN587@mainLoop:
?mainLoop@@YA_NXZ ENDP					; mainLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2278 = 360
tv2277 = 368
xDist$1$ = 376
?dtor$0@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$0
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR c$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2278 = 360
tv2277 = 368
xDist$1$ = 376
?dtor$1@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$1
  0000c	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  00013	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$1@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2278 = 360
tv2277 = 368
xDist$1$ = 376
?dtor$5@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$5
  00018	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  0001f	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00023	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$5@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2278 = 360
tv2277 = 368
xDist$1$ = 376
?dtor$6@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$6
  00028	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  0002f	48 83 c1 30	 add	 rcx, 48			; 00000030H
  00033	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$6@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2278 = 360
tv2277 = 368
xDist$1$ = 376
?dtor$7@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$7
  00038	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  0003f	48 83 c1 38	 add	 rcx, 56			; 00000038H
  00043	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
?dtor$7@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2278 = 360
tv2277 = 368
xDist$1$ = 376
?dtor$9@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$9
  00048	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T6[rdx]
  0004f	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$9@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\erlend\documents\github\wind\project\wind\wind\gamestates.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp
;	COMDAT WinMain
_TEXT	SEGMENT
c$1 = 64
r2$1$ = 80
xDist$1$ = 84
r1$1$ = 88
tv2946 = 92
lastTick$1$ = 96
theThread$2 = 104
$T3 = 112
$T4 = 128
theThread$5 = 144
theThread$6 = 152
$T7 = 160
$T8 = 176
$T9 = 192
$T10 = 208
$T11 = 240
$T12 = 256
$T13 = 272
_Launcher$14 = 288
$T15 = 336
$T16 = 352
$T17 = 368
$T18 = 384
$T19 = 400
$T20 = 416
_Launcher$21 = 432
$T22 = 480
_Launcher$23 = 496
msg$ = 544
$T24 = 592
$T25 = 608
$T26 = 624
$T27 = 640
_hInstance$ = 720
hPrevInstance$ = 728
lpCmdLine$ = 736
_nCmdShow$ = 744
WinMain	PROC						; COMDAT

; 177  : {

$LN995:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	41 54		 push	 r12
  00017	41 55		 push	 r13
  00019	41 56		 push	 r14
  0001b	41 57		 push	 r15
  0001d	48 8d ac 24 60
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-416]
  00025	48 81 ec a0 02
	00 00		 sub	 rsp, 672		; 000002a0H

; 178  : 	long long tickTime = 20000000;
; 179  : 	long long lastTick = 0;

  0002c	45 33 ff	 xor	 r15d, r15d

; 180  : 
; 181  : 	for(int r = 0; r <= renderDistance; r++)

  0002f	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00036	4c 89 7c 24 60	 mov	 QWORD PTR lastTick$1$[rsp], r15
  0003b	0f 1f 44 00 00	 npad	 5
$LL37@WinMain:

; 182  : 	{
; 183  : 		int r1 = r * r;

  00040	41 8b c7	 mov	 eax, r15d
  00043	41 0f af c7	 imul	 eax, r15d
  00047	89 44 24 58	 mov	 DWORD PTR r1$1$[rsp], eax

; 184  : 		int r2 = r == 0 ? -1 : (r - 1) * (r - 1);

  0004b	45 85 ff	 test	 r15d, r15d
  0004e	75 0a		 jne	 SHORT $LN40@WinMain
  00050	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR r2$1$[rsp], -1
  00058	eb 0b		 jmp	 SHORT $LN41@WinMain
$LN40@WinMain:
  0005a	41 8d 47 ff	 lea	 eax, DWORD PTR [r15-1]
  0005e	0f af c0	 imul	 eax, eax
  00061	89 44 24 50	 mov	 DWORD PTR r2$1$[rsp], eax
$LN41@WinMain:

; 185  : 		for(int i = -r; i <= r; i++)

  00065	41 8b cf	 mov	 ecx, r15d
  00068	f7 d9		 neg	 ecx
  0006a	89 4c 24 5c	 mov	 DWORD PTR tv2946[rsp], ecx
  0006e	44 8b e9	 mov	 r13d, ecx
  00071	41 3b cf	 cmp	 ecx, r15d
  00074	0f 8f b7 02 00
	00		 jg	 $LN36@WinMain
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL34@WinMain:

; 186  : 		{
; 187  : 			int xDist = i * i;

  00080	41 8b c5	 mov	 eax, r13d

; 188  : 			for(int j = -r; j <= r; j++)

  00083	44 8b f1	 mov	 r14d, ecx
  00086	41 0f af c5	 imul	 eax, r13d
  0008a	89 44 24 54	 mov	 DWORD PTR xDist$1$[rsp], eax
  0008e	41 3b cf	 cmp	 ecx, r15d
  00091	0f 8f 8e 02 00
	00		 jg	 $LN33@WinMain
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL31@WinMain:

; 189  : 			{
; 190  : 				int yDist = xDist + j * j;

  000a0	45 8b e6	 mov	 r12d, r14d

; 191  : 				for(int k = -r; k <= r; k++)

  000a3	8b f1		 mov	 esi, ecx
  000a5	45 0f af e6	 imul	 r12d, r14d
  000a9	44 03 e0	 add	 r12d, eax
  000ac	41 3b cf	 cmp	 ecx, r15d
  000af	0f 8f 64 02 00
	00		 jg	 $LN30@WinMain
  000b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL28@WinMain:

; 192  : 				{
; 193  : 					int zDist = yDist + k * k;

  000c0	8b fe		 mov	 edi, esi

; 194  : 					bool b = GlobalThread::world.getChunk(i, j, k)->isEmpty();

  000c2	48 8d 55 70	 lea	 rdx, QWORD PTR $T17[rbp-256]
  000c6	45 8b ce	 mov	 r9d, r14d
  000c9	45 8b c5	 mov	 r8d, r13d
  000cc	49 8b ca	 mov	 rcx, r10
  000cf	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  000d3	0f af fe	 imul	 edi, esi
  000d6	41 03 fc	 add	 edi, r12d
  000d9	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  000de	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 194  : 					bool b = GlobalThread::world.getChunk(i, j, k)->isEmpty();

  000e1	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000e4	ff 50 18	 call	 QWORD PTR [rax+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000e7	48 8b 5d 78	 mov	 rbx, QWORD PTR $T17[rbp-248]
  000eb	48 85 db	 test	 rbx, rbx
  000ee	74 1d		 je	 SHORT $LN60@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000f0	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  000f4	75 17		 jne	 SHORT $LN60@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000f6	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000f9	48 8b cb	 mov	 rcx, rbx
  000fc	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  000fe	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00102	75 09		 jne	 SHORT $LN60@WinMain

; 128  : 			_Delete_this();

  00104	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00107	48 8b cb	 mov	 rcx, rbx
  0010a	ff 50 08	 call	 QWORD PTR [rax+8]
$LN60@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 201  : 					if((zDist <= r1) && (zDist > r2))

  0010d	3b 7c 24 58	 cmp	 edi, DWORD PTR r1$1$[rsp]
  00111	0f 8f e1 01 00
	00		 jg	 $LN27@WinMain
  00117	3b 7c 24 50	 cmp	 edi, DWORD PTR r2$1$[rsp]
  0011b	0f 8e d7 01 00
	00		 jle	 $LN27@WinMain

; 203  : 						std::shared_ptr<ChunkBase> c(new Chunk(GlobalThread::world, i, j, k));

  00121	b9 60 20 00 00	 mov	 ecx, 8288		; 00002060H
  00126	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0012b	48 8b d8	 mov	 rbx, rax
  0012e	48 85 c0	 test	 rax, rax
  00131	0f 84 92 00 00
	00		 je	 $LN42@WinMain
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00137	66 c7 43 08 00
	00		 mov	 WORD PTR [rbx+8], 0
  0013d	c6 43 0a 00	 mov	 BYTE PTR [rbx+10], 0
  00141	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkBase@@6B@
  00148	48 89 03	 mov	 QWORD PTR [rbx], rax
  0014b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 28   : 		_Mtx_initX(&_Mtx, _Flags | _Mtx_try);

  00152	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00156	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0015a	ba 02 00 00 00	 mov	 edx, 2
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 11   : {

  0015f	44 89 6b 18	 mov	 DWORD PTR [rbx+24], r13d
  00163	44 89 73 1c	 mov	 DWORD PTR [rbx+28], r14d
  00167	89 73 20	 mov	 DWORD PTR [rbx+32], esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0016a	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0016f	85 c0		 test	 eax, eax
  00171	74 07		 je	 SHORT $LN75@WinMain

; 33   : 		_Throw_C_error(_Res);

  00173	8b c8		 mov	 ecx, eax
  00175	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN75@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 28   : 		_Mtx_initX(&_Mtx, _Flags | _Mtx_try);

  0017a	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0017e	ba 02 00 00 00	 mov	 edx, 2
  00183	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00188	85 c0		 test	 eax, eax
  0018a	74 07		 je	 SHORT $LN84@WinMain

; 33   : 		_Throw_C_error(_Res);

  0018c	8b c8		 mov	 ecx, eax
  0018e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN84@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00193	48 8d 4b 38	 lea	 rcx, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00197	33 ff		 xor	 edi, edi

; 501  : 		_Resetp((_Ty *)0);

  00199	33 d2		 xor	 edx, edx

; 282  : 		{	// construct

  0019b	48 89 39	 mov	 QWORD PTR [rcx], rdi
  0019e	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 501  : 		_Resetp((_Ty *)0);

  001a2	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  001a7	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 501  : 		_Resetp((_Ty *)0);

  001ab	33 d2		 xor	 edx, edx

; 282  : 		{	// construct

  001ad	48 89 39	 mov	 QWORD PTR [rcx], rdi
  001b0	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 501  : 		_Resetp((_Ty *)0);

  001b4	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 150  : {

  001b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  001c0	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  001c4	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 203  : 						std::shared_ptr<ChunkBase> c(new Chunk(GlobalThread::world, i, j, k));

  001c7	eb 04		 jmp	 SHORT $LN43@WinMain
$LN42@WinMain:
  001c9	33 ff		 xor	 edi, edi
  001cb	8b df		 mov	 ebx, edi
$LN43@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 487  : 		_Resetp(_Px);

  001cd	48 8d 4c 24 40	 lea	 rcx, QWORD PTR c$1[rsp]
  001d2	48 8b d3	 mov	 rdx, rbx

; 282  : 		{	// construct

  001d5	48 89 7c 24 40	 mov	 QWORD PTR c$1[rsp], rdi
  001da	48 89 7c 24 48	 mov	 QWORD PTR c$1[rsp+8], rdi

; 487  : 		_Resetp(_Px);

  001df	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 204  : 						GlobalThread::world.chunkMap[c->pos] = c;

  001e4	48 8b 54 24 40	 mov	 rdx, QWORD PTR c$1[rsp]
  001e9	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+80
  001f0	48 83 c2 18	 add	 rdx, 24
  001f4	e8 00 00 00 00	 call	 ??A?$unordered_map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$hash@VChunkPosition@@@3@U?$equal_to@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ; std::unordered_map<ChunkPosition,std::shared_ptr<ChunkBase>,std::hash<ChunkPosition>,std::equal_to<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 407  : 		if (_Other_rep)

  001f9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp+8]
  001fe	48 85 ff	 test	 rdi, rdi
  00201	74 09		 je	 SHORT $LN122@WinMain

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00203	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]
  00207	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp+8]
$LN122@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0020c	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]

; 49   : 	_Right = _Move(_Tmp);

  00210	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$1[rsp]
  00215	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
  00219	48 89 55 b8	 mov	 QWORD PTR $T8[rbp-248], rdx
  0021d	48 89 08	 mov	 QWORD PTR [rax], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00220	48 85 d2	 test	 rdx, rdx
  00223	74 27		 je	 SHORT $LN153@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00225	f0 ff 4a 08	 lock dec DWORD PTR [rdx+8]
  00229	75 1c		 jne	 SHORT $LN989@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0022b	48 8b 5d b8	 mov	 rbx, QWORD PTR $T8[rbp-248]
  0022f	48 8b cb	 mov	 rcx, rbx
  00232	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00235	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00237	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0023b	75 0a		 jne	 SHORT $LN989@WinMain

; 128  : 			_Delete_this();

  0023d	48 8b 4d b8	 mov	 rcx, QWORD PTR $T8[rbp-248]
  00241	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00244	ff 50 08	 call	 QWORD PTR [rax+8]
$LN989@WinMain:
  00247	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp+8]
$LN153@WinMain:

; 407  : 		if (_Other_rep)

  0024c	48 85 ff	 test	 rdi, rdi
  0024f	74 09		 je	 SHORT $LN165@WinMain

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00251	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]
  00255	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp+8]
$LN165@WinMain:

; 427  : 		_Ptr = _Other_ptr;

  0025a	48 8b 44 24 40	 mov	 rax, QWORD PTR c$1[rsp]
; File c:\users\erlend\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 215  : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  0025f	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00265	48 8d 0d 60 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2400
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 427  : 		_Ptr = _Other_ptr;

  0026c	48 89 45 c0	 mov	 QWORD PTR $T9[rbp-256], rax
  00270	48 89 7d c8	 mov	 QWORD PTR $T9[rbp-248], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00274	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00279	85 c0		 test	 eax, eax
  0027b	74 07		 je	 SHORT $LN182@WinMain

; 33   : 		_Throw_C_error(_Res);

  0027d	8b c8		 mov	 ecx, eax
  0027f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN182@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00284	48 8d 55 c0	 lea	 rdx, QWORD PTR $T9[rbp-256]
  00288	48 8d 0d 38 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2360
  0028f	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00294	48 8d 0d 60 09
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2400
  0029b	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  002a0	85 c0		 test	 eax, eax
  002a2	74 07		 je	 SHORT $LN191@WinMain

; 33   : 		_Throw_C_error(_Res);

  002a4	8b c8		 mov	 ecx, eax
  002a6	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN191@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  002ab	48 85 ff	 test	 rdi, rdi
  002ae	74 48		 je	 SHORT $LN27@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002b0	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  002b4	75 1e		 jne	 SHORT $LN202@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002b6	48 8b 5c 24 48	 mov	 rbx, QWORD PTR c$1[rsp+8]
  002bb	48 8b cb	 mov	 rcx, rbx
  002be	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002c1	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  002c3	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  002c7	75 0b		 jne	 SHORT $LN202@WinMain

; 128  : 			_Delete_this();

  002c9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$1[rsp+8]
  002ce	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002d1	ff 50 08	 call	 QWORD PTR [rax+8]
$LN202@WinMain:

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002d4	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  002d8	75 1e		 jne	 SHORT $LN27@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002da	48 8b 5c 24 48	 mov	 rbx, QWORD PTR c$1[rsp+8]
  002df	48 8b cb	 mov	 rcx, rbx
  002e2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002e5	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  002e7	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  002eb	75 0b		 jne	 SHORT $LN27@WinMain

; 128  : 			_Delete_this();

  002ed	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$1[rsp+8]
  002f2	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002f5	ff 50 08	 call	 QWORD PTR [rax+8]
$LN27@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 191  : 				for(int k = -r; k <= r; k++)

  002f8	ff c6		 inc	 esi
  002fa	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00301	41 3b f7	 cmp	 esi, r15d
  00304	0f 8e b6 fd ff
	ff		 jle	 $LL28@WinMain
  0030a	8b 44 24 54	 mov	 eax, DWORD PTR xDist$1$[rsp]
  0030e	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv2946[rsp]
  00312	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
$LN30@WinMain:

; 188  : 			for(int j = -r; j <= r; j++)

  00319	41 ff c6	 inc	 r14d
  0031c	45 3b f7	 cmp	 r14d, r15d
  0031f	0f 8e 7b fd ff
	ff		 jle	 $LL31@WinMain
$LN33@WinMain:

; 185  : 		for(int i = -r; i <= r; i++)

  00325	41 ff c5	 inc	 r13d
  00328	45 3b ef	 cmp	 r13d, r15d
  0032b	0f 8e 4f fd ff
	ff		 jle	 $LL34@WinMain
$LN36@WinMain:

; 180  : 
; 181  : 	for(int r = 0; r <= renderDistance; r++)

  00331	41 ff c7	 inc	 r15d
  00334	41 83 ff 08	 cmp	 r15d, 8
  00338	0f 8e 02 fd ff
	ff		 jle	 $LL37@WinMain

; 205  : 						requestChunkLoad(c);
; 206  : 					}
; 207  : 				}
; 208  : 			}
; 209  : 		}
; 210  : 	}
; 211  : 
; 212  : 	IOUtil::staticInit();

  0033e	e8 00 00 00 00	 call	 ?staticInit@IOUtil@@YAXXZ ; IOUtil::staticInit

; 213  : 	cl::staticInit();

  00343	e8 00 00 00 00	 call	 ?staticInit@cl@@YA_NXZ	; cl::staticInit
; File c:\users\erlend\documents\github\wind\project\wind\wind\noise.cpp

; 21   : 	Noise::noiseProgram.create(IOUtil::EXE_DIR + L"\\programs\\noise.cl");

  00348	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294895145
  0034f	48 8d 8d 80 01
	00 00		 lea	 rcx, QWORD PTR $T27[rbp-256]
  00356	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0035b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?noiseProgram@Noise@@3VProgram@cl@@A ; Noise::noiseProgram
  00362	48 8b d0	 mov	 rdx, rax
  00365	e8 00 00 00 00	 call	 ?create@Program@cl@@QEAA_NV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; cl::Program::create
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 215  : 	Blocks::staticInit();

  0036a	e8 00 00 00 00	 call	 ?staticInit@Blocks@@YAXXZ ; Blocks::staticInit

; 216  : 	ChunkDrawThread::staticInit();
; 217  : 	ChunkLoadThread::staticInit();

  0036f	e8 00 00 00 00	 call	 ?staticInit@ChunkLoadThread@@SAXXZ ; ChunkLoadThread::staticInit

; 219  : 	GLWindow::instance = new GLWindow(L"Wind", 600, 600, _hInstance, 3, 4);

  00374	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00379	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0037e	45 33 ff	 xor	 r15d, r15d
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 219  : 	GLWindow::instance = new GLWindow(L"Wind", 600, 600, _hInstance, 3, 4);

  00381	48 8b d8	 mov	 rbx, rax
  00384	48 85 c0	 test	 rax, rax
  00387	74 3f		 je	 SHORT $LN44@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00389	45 8d 47 04	 lea	 r8d, QWORD PTR [r15+4]
  0038d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294898609
  00394	48 8d 4d d0	 lea	 rcx, QWORD PTR $T10[rbp-256]

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00398	48 c7 45 e8 07
	00 00 00	 mov	 QWORD PTR $T10[rbp-232], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  003a0	4c 89 7d e0	 mov	 QWORD PTR $T10[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  003a4	66 44 89 7d d0	 mov	 WORD PTR $T10[rbp-256], r15w
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  003a9	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 219  : 	GLWindow::instance = new GLWindow(L"Wind", 600, 600, _hInstance, 3, 4);

  003ae	48 8b 85 d0 01
	00 00		 mov	 rax, QWORD PTR _hInstance$[rbp-256]
  003b5	48 8d 55 d0	 lea	 rdx, QWORD PTR $T10[rbp-256]
  003b9	48 8b cb	 mov	 rcx, rbx
  003bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c1	e8 00 00 00 00	 call	 ??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z ; GLWindow::GLWindow
  003c6	eb 03		 jmp	 SHORT $LN45@WinMain
$LN44@WinMain:
  003c8	49 8b c7	 mov	 rax, r15
$LN45@WinMain:
  003cb	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?instance@GLWindow@@2PEAV1@EA, rax ; GLWindow::instance

; 220  : 	GLWindow::instance->initWindow();

  003d2	e8 00 00 00 00	 call	 ?initWindow@GLWindow@@QEAAXXZ ; GLWindow::initWindow
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  003d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?renderThread@@3VRenderThread@@A ; renderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  003de	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$21[rbp-256]
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  003e5	48 89 45 90	 mov	 QWORD PTR theThread$5[rbp-256], rax
  003e9	66 c7 05 18 00
	00 00 01 00	 mov	 WORD PTR ?renderThread@@3VRenderThread@@A+24, 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  003f2	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  003f7	48 8d 45 90	 lea	 rax, QWORD PTR theThread$5[rbp-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  003fb	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00402	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:?loop@Thread@@KAXPEAV1@@Z ; Thread::loop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00409	48 8d 55 a0	 lea	 rdx, QWORD PTR $T7[rbp-256]
  0040d	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$21[rbp-256]

; 182  : 		{	// construct from target

  00414	48 89 bd b0 00
	00 00		 mov	 QWORD PTR _Launcher$21[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0041b	48 89 85 d8 00
	00 00		 mov	 QWORD PTR _Launcher$21[rbp-216], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00422	48 89 b5 d0 00
	00 00		 mov	 QWORD PTR _Launcher$21[rbp-224], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00429	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  0042e	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$21[rbp-256]
  00435	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0043a	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  00441	0f 85 5c 05 00
	00		 jne	 $LN993@WinMain

; 113  : 		_Thr = _Other._Thr;

  00447	48 8b 45 a0	 mov	 rax, QWORD PTR $T7[rbp-256]
  0044b	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A+8, rax
  00452	48 8b 45 a8	 mov	 rax, QWORD PTR $T7[rbp-248]

; 114  : 		_Thr_set_null(_Other._Thr);

  00456	44 89 7d a8	 mov	 DWORD PTR $T7[rbp-248], r15d
  0045a	48 89 05 10 00
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A+16, rax
  00461	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
$LL23@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 223  : 	while(GLWindow::instance == nullptr || !GLWindow::instance->isOK())

  00468	48 85 c0	 test	 rax, rax
  0046b	74 fb		 je	 SHORT $LL23@WinMain
  0046d	80 38 00	 cmp	 BYTE PTR [rax], 0
  00470	74 f6		 je	 SHORT $LL23@WinMain

; 228  : 	for(int i = 0; i < LOAD_THREAD_AMOUNT; i++)

  00472	48 8d 1d 18 00
	00 00		 lea	 rbx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+24
  00479	4c 8d 35 80 09
	00 00		 lea	 r14, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2432
$LL20@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  00480	48 8d 43 e8	 lea	 rax, QWORD PTR [rbx-24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00484	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$23[rbp-256]
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 35   : 	started = true;

  0048b	66 c7 03 01 00	 mov	 WORD PTR [rbx], 1

; 37   : 	Thread* theThread = this;

  00490	48 89 45 98	 mov	 QWORD PTR theThread$6[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00494	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00499	48 8d 45 98	 lea	 rax, QWORD PTR theThread$6[rbp-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  0049d	48 8d 54 24 70	 lea	 rdx, QWORD PTR $T3[rsp]
  004a2	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$23[rbp-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  004a9	48 89 85 18 01
	00 00		 mov	 QWORD PTR _Launcher$23[rbp-216], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  004b0	48 89 bd f0 00
	00 00		 mov	 QWORD PTR _Launcher$23[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  004b7	48 89 b5 10 01
	00 00		 mov	 QWORD PTR _Launcher$23[rbp-224], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  004be	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  004c3	48 8d 8d f0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$23[rbp-256]
  004ca	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  004cf	83 7b f8 00	 cmp	 DWORD PTR [rbx-8], 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  004d3	0f 85 d6 04 00
	00		 jne	 $LN951@WinMain

; 113  : 		_Thr = _Other._Thr;

  004d9	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 228  : 	for(int i = 0; i < LOAD_THREAD_AMOUNT; i++)

  004de	48 81 c3 68 09
	00 00		 add	 rbx, 2408		; 00000968H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 113  : 		_Thr = _Other._Thr;

  004e5	48 89 83 88 f6
	ff ff		 mov	 QWORD PTR [rbx-2424], rax
  004ec	48 8b 44 24 78	 mov	 rax, QWORD PTR $T3[rsp+8]

; 114  : 		_Thr_set_null(_Other._Thr);

  004f1	44 89 7c 24 78	 mov	 DWORD PTR $T3[rsp+8], r15d
  004f6	48 89 83 90 f6
	ff ff		 mov	 QWORD PTR [rbx-2416], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 228  : 	for(int i = 0; i < LOAD_THREAD_AMOUNT; i++)

  004fd	49 3b de	 cmp	 rbx, r14
  00500	0f 8c 7a ff ff
	ff		 jl	 $LL20@WinMain

; 233  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  00506	48 8d 1d 18 00
	00 00		 lea	 rbx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+24
  0050d	4c 8d 35 d0 08
	00 00		 lea	 r14, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+2256
  00514	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL17@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  00520	48 8d 43 e8	 lea	 rax, QWORD PTR [rbx-24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00524	48 8d 4d 20	 lea	 rcx, QWORD PTR _Launcher$14[rbp-256]
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 35   : 	started = true;

  00528	66 c7 03 01 00	 mov	 WORD PTR [rbx], 1

; 37   : 	Thread* theThread = this;

  0052d	48 89 44 24 68	 mov	 QWORD PTR theThread$2[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00532	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00537	48 8d 44 24 68	 lea	 rax, QWORD PTR theThread$2[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  0053c	48 8d 55 80	 lea	 rdx, QWORD PTR $T4[rbp-256]
  00540	48 8d 4d 20	 lea	 rcx, QWORD PTR _Launcher$14[rbp-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00544	48 89 45 48	 mov	 QWORD PTR _Launcher$14[rbp-216], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00548	48 89 7d 20	 mov	 QWORD PTR _Launcher$14[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0054c	48 89 75 40	 mov	 QWORD PTR _Launcher$14[rbp-224], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  00550	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  00555	48 8d 4d 20	 lea	 rcx, QWORD PTR _Launcher$14[rbp-256]
  00559	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0055e	83 7b f8 00	 cmp	 DWORD PTR [rbx-8], 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  00562	0f 85 41 04 00
	00		 jne	 $LN953@WinMain

; 113  : 		_Thr = _Other._Thr;

  00568	48 8b 45 80	 mov	 rax, QWORD PTR $T4[rbp-256]
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 233  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  0056c	48 81 c3 b8 08
	00 00		 add	 rbx, 2232		; 000008b8H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 113  : 		_Thr = _Other._Thr;

  00573	48 89 83 38 f7
	ff ff		 mov	 QWORD PTR [rbx-2248], rax
  0057a	48 8b 45 88	 mov	 rax, QWORD PTR $T4[rbp-248]

; 114  : 		_Thr_set_null(_Other._Thr);

  0057e	44 89 7d 88	 mov	 DWORD PTR $T4[rbp-248], r15d
  00582	48 89 83 40 f7
	ff ff		 mov	 QWORD PTR [rbx-2240], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 233  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  00589	49 3b de	 cmp	 rbx, r14
  0058c	7c 92		 jl	 SHORT $LL17@WinMain

; 234  : 	{
; 235  : 		chunkDrawThreads[i].start();
; 236  : 	}
; 237  : 
; 238  : 	GameStates::staticInit();

  0058e	e8 00 00 00 00	 call	 ?staticInit@GameStates@@YAXXZ ; GameStates::staticInit
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  00593	e8 00 00 00 00	 call	 _Xtime_get_ticks
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 244  : 	while(!GlobalThread::stop)

  00598	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  0059f	48 8b d8	 mov	 rbx, rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 244  : 	while(!GlobalThread::stop)

  005a2	0f 85 d8 00 00
	00		 jne	 $LL991@WinMain
  005a8	48 bf bd 42 7a
	e5 d5 94 bf d6	 mov	 rdi, -2972493582642298179 ; d6bf94d5e57a42bdH
  005b2	66 66 66 66 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL14@WinMain:

; 245  : 	{
; 246  : 		if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))

  005c0	48 8d 8d 20 01
	00 00		 lea	 rcx, QWORD PTR msg$[rbp-256]
  005c7	45 33 c9	 xor	 r9d, r9d
  005ca	45 33 c0	 xor	 r8d, r8d
  005cd	33 d2		 xor	 edx, edx
  005cf	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  005d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageW
  005dd	85 c0		 test	 eax, eax
  005df	74 29		 je	 SHORT $LN12@WinMain

; 247  : 		{
; 248  : 			if(msg.message == WM_QUIT)

  005e1	83 bd 28 01 00
	00 12		 cmp	 DWORD PTR msg$[rbp-248], 18
  005e8	0f 84 83 00 00
	00		 je	 $LN988@WinMain

; 249  : 			{
; 250  : 				GlobalThread::stop = true;
; 251  : 			} else
; 252  : 			{
; 253  : 				TranslateMessage(&msg);

  005ee	48 8d 8d 20 01
	00 00		 lea	 rcx, QWORD PTR msg$[rbp-256]
  005f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 254  : 				DispatchMessage(&msg);

  005fb	48 8d 8d 20 01
	00 00		 lea	 rcx, QWORD PTR msg$[rbp-256]
  00602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageW

; 255  : 			}
; 256  : 		} else

  00608	eb 58		 jmp	 SHORT $LN990@WinMain
$LN12@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  0060a	e8 00 00 00 00	 call	 _Xtime_get_ticks
  0060f	48 8b c8	 mov	 rcx, rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 261  : 			long long tick = difference / tickTime;

  00612	48 8b c7	 mov	 rax, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 105  : 		{	// construct from representation

  00615	48 2b cb	 sub	 rcx, rbx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2>
; 114  : 		duration(const duration<_Rep2, _Period2>& _Dur,
; 115  : 			typename enable_if<treat_as_floating_point<_Rep>::value
; 116  : 				|| ratio_divide<_Period2, _Period>::type::den == 1
; 117  : 					&& !treat_as_floating_point<_Rep2>::value,
; 118  : 				void>::type ** = 0)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef typename ratio_divide<_Period2, _Period>::type _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);
; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);
; 368  : 	}
; 369  : 
; 370  : template<class _Rep1,
; 371  : 	class _Period1,
; 372  : 	class _Rep2> inline
; 373  : 	typename enable_if<is_convertible<_Rep2,
; 374  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 375  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 376  : 		operator*(
; 377  : 			const duration<_Rep1, _Period1>& _Left,
; 378  : 			const _Rep2& _Right)
; 379  : 	{	// multiply duration by rep
; 380  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 381  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 382  : 	}
; 383  : 
; 384  : template<class _Rep1,
; 385  : 	class _Rep2,
; 386  : 	class _Period2> inline
; 387  : 	typename enable_if<is_convertible<_Rep1,
; 388  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 389  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 390  : 		operator*(
; 391  : 			const _Rep1& _Left,
; 392  : 			const duration<_Rep2, _Period2>& _Right)
; 393  : 	{	// multiply rep by duration
; 394  : 	return (_Right * _Left);
; 395  : 	}
; 396  : 
; 397  : template<class _Rep1,
; 398  : 	class _Period1,
; 399  : 	class _Rep2> inline
; 400  : 	typename enable_if<is_convertible<_Rep2,
; 401  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 402  : 		&& !_Is_duration<_Rep2>::value,
; 403  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 404  : 		operator/(
; 405  : 			const duration<_Rep1, _Period1>& _Left,
; 406  : 			const _Rep2& _Right)
; 407  : 	{	// divide duration by rep
; 408  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 409  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 410  : 	}
; 411  : 
; 412  : template<class _Rep1,
; 413  : 	class _Period1,
; 414  : 	class _Rep2,
; 415  : 	class _Period2> inline
; 416  : 	typename common_type<_Rep1, _Rep2>::type
; 417  : 		operator/(
; 418  : 			const duration<_Rep1, _Period1>& _Left,
; 419  : 			const duration<_Rep2, _Period2>& _Right)
; 420  : 	{	// divide duration by duration
; 421  : 	typedef typename common_type<
; 422  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 423  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 424  : 	}
; 425  : 
; 426  : template<class _Rep1,
; 427  : 	class _Period1,
; 428  : 	class _Rep2> inline
; 429  : 	typename enable_if<is_convertible<_Rep2,
; 430  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 431  : 		&& !_Is_duration<_Rep2>::value,
; 432  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 433  : 		operator%(
; 434  : 			const duration<_Rep1, _Period1>& _Left,
; 435  : 			const _Rep2& _Right)
; 436  : 	{	// divide duration by rep
; 437  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 438  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 439  : 	}
; 440  : 
; 441  : template<class _Rep1,
; 442  : 	class _Period1,
; 443  : 	class _Rep2,
; 444  : 	class _Period2> inline
; 445  : 	typename common_type<_Rep1, _Rep2>::type
; 446  : 		operator%(
; 447  : 			const duration<_Rep1, _Period1>& _Left,
; 448  : 			const duration<_Rep2, _Period2>& _Right)
; 449  : 	{	// divide duration by duration
; 450  : 	typedef typename common_type<
; 451  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 452  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 453  : 	}
; 454  : 
; 455  : 	// duration COMPARISONS
; 456  : template<class _Rep1,
; 457  : 	class _Period1,
; 458  : 	class _Rep2,
; 459  : 	class _Period2> inline
; 460  : 	bool operator==(
; 461  : 		const duration<_Rep1, _Period1>& _Left,
; 462  : 		const duration<_Rep2, _Period2>& _Right)
; 463  : 	{	// test if duration == duration
; 464  : 	typedef typename common_type<
; 465  : 		duration<_Rep1, _Period1>,
; 466  : 		duration<_Rep2, _Period2> >::type _CT;
; 467  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 468  : 	}
; 469  : 
; 470  : template<class _Rep1,
; 471  : 	class _Period1,
; 472  : 	class _Rep2,
; 473  : 	class _Period2> inline
; 474  : 	bool operator!=(
; 475  : 		const duration<_Rep1, _Period1>& _Left,
; 476  : 		const duration<_Rep2, _Period2>& _Right)
; 477  : 	{	// test if duration != duration
; 478  : 	return (!(_Left == _Right));
; 479  : 	}
; 480  : 
; 481  : template<class _Rep1,
; 482  : 	class _Period1,
; 483  : 	class _Rep2,
; 484  : 	class _Period2> inline
; 485  : 	bool operator<(
; 486  : 		const duration<_Rep1, _Period1>& _Left,
; 487  : 		const duration<_Rep2, _Period2>& _Right)
; 488  : 	{	// test if duration < duration
; 489  : 	typedef typename common_type<
; 490  : 		duration<_Rep1, _Period1>,
; 491  : 		duration<_Rep2, _Period2> >::type _CT;
; 492  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 493  : 	}
; 494  : 
; 495  : template<class _Rep1,
; 496  : 	class _Period1,
; 497  : 	class _Rep2,
; 498  : 	class _Period2> inline
; 499  : 	bool operator<=(
; 500  : 		const duration<_Rep1, _Period1>& _Left,
; 501  : 		const duration<_Rep2, _Period2>& _Right)
; 502  : 	{	// test if duration <= duration
; 503  : 	return (!(_Right < _Left));
; 504  : 	}
; 505  : 
; 506  : template<class _Rep1,
; 507  : 	class _Period1,
; 508  : 	class _Rep2,
; 509  : 	class _Period2> inline
; 510  : 	bool operator>(
; 511  : 		const duration<_Rep1, _Period1>& _Left,
; 512  : 		const duration<_Rep2, _Period2>& _Right)
; 513  : 	{	// test if duration > duration
; 514  : 	return (_Right < _Left);
; 515  : 	}
; 516  : 
; 517  : template<class _Rep1,
; 518  : 	class _Period1,
; 519  : 	class _Rep2,
; 520  : 	class _Period2> inline
; 521  : 	bool operator>=(
; 522  : 		const duration<_Rep1, _Period1>& _Left,
; 523  : 		const duration<_Rep2, _Period2>& _Right)
; 524  : 	{	// test if duration >= duration
; 525  : 	return (!(_Left < _Right));
; 526  : 	}
; 527  : 
; 528  : 	// duration_cast
; 529  : template<class _To,
; 530  : 	class _Rep,
; 531  : 	class _Period> inline
; 532  : 	typename enable_if<_Is_duration<_To>::value,
; 533  : 		_To>::type
; 534  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 535  : 	{	// convert duration to another duration
; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  00618	48 6b c9 64	 imul	 rcx, 100		; 00000064H
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 261  : 			long long tick = difference / tickTime;

  0061c	48 f7 e9	 imul	 rcx
  0061f	48 03 d1	 add	 rdx, rcx
  00622	48 c1 fa 18	 sar	 rdx, 24
  00626	48 8b c2	 mov	 rax, rdx
  00629	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0062d	48 03 d0	 add	 rdx, rax

; 262  : 			long long ticksToProcess = tick - lastTick;

  00630	48 8b 44 24 60	 mov	 rax, QWORD PTR lastTick$1$[rsp]
  00635	48 2b d0	 sub	 rdx, rax

; 263  : 
; 264  : 			if(ticksToProcess > 0)

  00638	48 85 d2	 test	 rdx, rdx
  0063b	7e 25		 jle	 SHORT $LN990@WinMain

; 265  : 			{
; 266  : 				lastTick++;

  0063d	48 ff c0	 inc	 rax

; 267  : 				RenderThread::skipRender = false;

  00640	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?skipRender@RenderThread@@2_NA, 0 ; RenderThread::skipRender
  00647	48 89 44 24 60	 mov	 QWORD PTR lastTick$1$[rsp], rax

; 268  : 				if(GLWindow::instance->active && !mainLoop())

  0064c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00653	80 78 6c 00	 cmp	 BYTE PTR [rax+108], 0
  00657	74 09		 je	 SHORT $LN990@WinMain
  00659	e8 00 00 00 00	 call	 ?mainLoop@@YA_NXZ	; mainLoop
  0065e	84 c0		 test	 al, al
  00660	74 0f		 je	 SHORT $LN988@WinMain
$LN990@WinMain:

; 244  : 	while(!GlobalThread::stop)

  00662	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
  00669	0f 84 51 ff ff
	ff		 je	 $LL14@WinMain
  0066f	eb 0f		 jmp	 SHORT $LL991@WinMain
$LN988@WinMain:

; 269  : 				{
; 270  : 					GlobalThread::stop = true;

  00671	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
  00678	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL991@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  00680	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+24, 0
  00687	c6 05 19 00 00
	00 01		 mov	 BYTE PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+25, 1
  0068e	0f 84 9c 00 00
	00		 je	 $LL5@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00694	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+16, 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  0069b	75 1d		 jne	 SHORT $LN808@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  0069d	b9 01 00 00 00	 mov	 ecx, 1
  006a2	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error

; 213  : 	if (_Thr_is_null(_Thr))

  006a7	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+16, 0
  006ae	75 0a		 jne	 SHORT $LN808@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  006b0	b9 01 00 00 00	 mov	 ecx, 1
  006b5	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN808@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  006ba	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR $T24[rbp-256]
  006c1	e8 00 00 00 00	 call	 _Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  006c6	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR $T19[rbp-256]
  006cd	48 8d 4d f0	 lea	 rcx, QWORD PTR $T11[rbp-256]
  006d1	0f 10 0d 08 00
	00 00		 movups	 xmm1, XMMWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8
  006d8	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  006db	0f 29 4d f0	 movaps	 XMMWORD PTR $T11[rbp-256], xmm1
  006df	0f 29 85 90 00
	00 00		 movaps	 XMMWORD PTR $T19[rbp-256], xmm0
  006e6	e8 00 00 00 00	 call	 _Thrd_equal
  006eb	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  006ed	74 0a		 je	 SHORT $LN807@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  006ef	b9 05 00 00 00	 mov	 ecx, 5
  006f4	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN807@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  006f9	0f 10 05 08 00
	00 00		 movups	 xmm0, XMMWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8
  00700	48 8d 4d 10	 lea	 rcx, QWORD PTR $T13[rbp-256]
  00704	33 d2		 xor	 edx, edx
  00706	0f 29 45 10	 movaps	 XMMWORD PTR $T13[rbp-256], xmm0
  0070a	e8 00 00 00 00	 call	 _Thrd_join
  0070f	85 c0		 test	 eax, eax
  00711	74 0a		 je	 SHORT $LN806@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  00713	b9 02 00 00 00	 mov	 ecx, 2
  00718	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN806@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  0071d	44 89 3d 10 00
	00 00		 mov	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+16, r15d
  00724	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL5@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  00730	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?chunkDrawThreads@@3PAVChunkDrawThread@@A+24, 0
  00737	c6 05 19 00 00
	00 01		 mov	 BYTE PTR ?chunkDrawThreads@@3PAVChunkDrawThread@@A+25, 1
  0073e	0f 84 96 00 00
	00		 je	 $LN2@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00744	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?chunkDrawThreads@@3PAVChunkDrawThread@@A+16, 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  0074b	75 1d		 jne	 SHORT $LN829@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  0074d	b9 01 00 00 00	 mov	 ecx, 1
  00752	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error

; 213  : 	if (_Thr_is_null(_Thr))

  00757	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?chunkDrawThreads@@3PAVChunkDrawThread@@A+16, 0
  0075e	75 0a		 jne	 SHORT $LN829@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  00760	b9 01 00 00 00	 mov	 ecx, 1
  00765	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN829@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  0076a	48 8d 8d 70 01
	00 00		 lea	 rcx, QWORD PTR $T26[rbp-256]
  00771	e8 00 00 00 00	 call	 _Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  00776	48 8d 95 e0 00
	00 00		 lea	 rdx, QWORD PTR $T22[rbp-256]
  0077d	48 8d 4d 60	 lea	 rcx, QWORD PTR $T16[rbp-256]
  00781	0f 10 0d 08 00
	00 00		 movups	 xmm1, XMMWORD PTR ?chunkDrawThreads@@3PAVChunkDrawThread@@A+8
  00788	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0078b	0f 29 4d 60	 movaps	 XMMWORD PTR $T16[rbp-256], xmm1
  0078f	0f 29 85 e0 00
	00 00		 movaps	 XMMWORD PTR $T22[rbp-256], xmm0
  00796	e8 00 00 00 00	 call	 _Thrd_equal
  0079b	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  0079d	74 0a		 je	 SHORT $LN828@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  0079f	b9 05 00 00 00	 mov	 ecx, 5
  007a4	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN828@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  007a9	0f 10 05 08 00
	00 00		 movups	 xmm0, XMMWORD PTR ?chunkDrawThreads@@3PAVChunkDrawThread@@A+8
  007b0	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR $T20[rbp-256]
  007b7	33 d2		 xor	 edx, edx
  007b9	0f 29 85 a0 00
	00 00		 movaps	 XMMWORD PTR $T20[rbp-256], xmm0
  007c0	e8 00 00 00 00	 call	 _Thrd_join
  007c5	85 c0		 test	 eax, eax
  007c7	74 0a		 je	 SHORT $LN827@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  007c9	b9 02 00 00 00	 mov	 ecx, 2
  007ce	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN827@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  007d3	44 89 3d 10 00
	00 00		 mov	 DWORD PTR ?chunkDrawThreads@@3PAVChunkDrawThread@@A+16, r15d
$LN2@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  007da	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?renderThread@@3VRenderThread@@A+24, 0
  007e1	c6 05 19 00 00
	00 01		 mov	 BYTE PTR ?renderThread@@3VRenderThread@@A+25, 1
  007e8	0f 84 90 00 00
	00		 je	 $LN852@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  007ee	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  007f5	75 1d		 jne	 SHORT $LN850@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  007f7	b9 01 00 00 00	 mov	 ecx, 1
  007fc	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error

; 213  : 	if (_Thr_is_null(_Thr))

  00801	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0
  00808	75 0a		 jne	 SHORT $LN850@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  0080a	b9 01 00 00 00	 mov	 ecx, 1
  0080f	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN850@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  00814	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR $T25[rbp-256]
  0081b	e8 00 00 00 00	 call	 _Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  00820	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR $T18[rbp-256]
  00827	48 8d 4d 00	 lea	 rcx, QWORD PTR $T12[rbp-256]
  0082b	0f 10 0d 08 00
	00 00		 movups	 xmm1, XMMWORD PTR ?renderThread@@3VRenderThread@@A+8
  00832	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00835	0f 29 4d 00	 movaps	 XMMWORD PTR $T12[rbp-256], xmm1
  00839	0f 29 85 80 00
	00 00		 movaps	 XMMWORD PTR $T18[rbp-256], xmm0
  00840	e8 00 00 00 00	 call	 _Thrd_equal
  00845	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  00847	74 0a		 je	 SHORT $LN849@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  00849	b9 05 00 00 00	 mov	 ecx, 5
  0084e	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN849@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  00853	0f 10 05 08 00
	00 00		 movups	 xmm0, XMMWORD PTR ?renderThread@@3VRenderThread@@A+8
  0085a	48 8d 4d 50	 lea	 rcx, QWORD PTR $T15[rbp-256]
  0085e	33 d2		 xor	 edx, edx
  00860	0f 29 45 50	 movaps	 XMMWORD PTR $T15[rbp-256], xmm0
  00864	e8 00 00 00 00	 call	 _Thrd_join
  00869	85 c0		 test	 eax, eax
  0086b	74 0a		 je	 SHORT $LN848@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  0086d	b9 02 00 00 00	 mov	 ecx, 2
  00872	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN848@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  00877	44 89 3d 10 00
	00 00		 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, r15d
$LN852@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 287  : 	delete GLWindow::instance;

  0087e	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00885	48 85 db	 test	 rbx, rbx
  00888	0f 84 a9 00 00
	00		 je	 $LN866@WinMain
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp

; 264  : 	if(hDC && !ReleaseDC(hWnd, hDC))

  0088e	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00892	40 32 ff	 xor	 dil, dil
  00895	48 85 d2	 test	 rdx, rdx
  00898	74 15		 je	 SHORT $LN874@WinMain
  0089a	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0089e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC
  008a4	85 c0		 test	 eax, eax
  008a6	75 07		 jne	 SHORT $LN874@WinMain

; 265  : 	{
; 266  : 		hDC = NULL;

  008a8	4c 89 7b 18	 mov	 QWORD PTR [rbx+24], r15

; 267  : 		error = true;

  008ac	40 b7 01	 mov	 dil, 1
$LN874@WinMain:

; 268  : 	}
; 269  : 	if(hWnd && !DestroyWindow(hWnd))

  008af	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  008b3	48 85 c9	 test	 rcx, rcx
  008b6	74 11		 je	 SHORT $LN873@WinMain
  008b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DestroyWindow
  008be	85 c0		 test	 eax, eax
  008c0	75 07		 jne	 SHORT $LN873@WinMain

; 270  : 	{
; 271  : 		hWnd = NULL;

  008c2	4c 89 7b 10	 mov	 QWORD PTR [rbx+16], r15

; 272  : 		error = true;

  008c6	40 b7 01	 mov	 dil, 1
$LN873@WinMain:

; 273  : 	}
; 274  : 	if(!UnregisterClass(L"GLWindow", hInstance))

  008c9	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  008cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4294889935
  008d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnregisterClassW
  008da	85 c0		 test	 eax, eax
  008dc	75 06		 jne	 SHORT $LN872@WinMain

; 275  : 	{
; 276  : 		hInstance = NULL;

  008de	4c 89 7b 08	 mov	 QWORD PTR [rbx+8], r15

; 277  : 		error = true;
; 278  : 	}
; 279  : 	if(error)

  008e2	eb 05		 jmp	 SHORT $LN980@WinMain
$LN872@WinMain:
  008e4	40 84 ff	 test	 dil, dil
  008e7	74 1c		 je	 SHORT $LN871@WinMain
$LN980@WinMain:

; 280  : 	{
; 281  : 		MessageBox(NULL, L"There was an error while destroying the window", L"ERROR", MB_OK | MB_ICONINFORMATION);

  008e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294889934
  008f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294889933
  008f7	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  008fd	33 c9		 xor	 ecx, ecx
  008ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW
$LN871@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00905	48 83 7b 50 08	 cmp	 QWORD PTR [rbx+80], 8
  0090a	72 09		 jb	 SHORT $LN899@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  0090c	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00910	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN899@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00915	48 c7 43 50 07
	00 00 00	 mov	 QWORD PTR [rbx+80], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0091d	4c 89 7b 48	 mov	 QWORD PTR [rbx+72], r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00921	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00925	66 44 89 7b 38	 mov	 WORD PTR [rbx+56], r15w
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  0092a	e8 00 00 00 00	 call	 _Mtx_destroy
  0092f	48 8b cb	 mov	 rcx, rbx
  00932	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN866@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\gamestates.cpp

; 42   : 	delete GameStates::renderingState;

  00937	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?renderingState@GameStates@@3PEAVGameState@1@EA ; GameStates::renderingState
  0093e	48 85 c9	 test	 rcx, rcx
  00941	74 05		 je	 SHORT $LN923@WinMain
  00943	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN923@WinMain:

; 43   : 	delete GameStates::processedState;

  00948	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA ; GameStates::processedState
  0094f	48 85 c9	 test	 rcx, rcx
  00952	74 05		 je	 SHORT $LN928@WinMain
  00954	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN928@WinMain:

; 44   : 	delete GameStates::pendingState;

  00959	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?pendingState@GameStates@@3PEAVGameState@1@EA ; GameStates::pendingState
  00960	48 85 c9	 test	 rcx, rcx
  00963	74 05		 je	 SHORT $LN933@WinMain
  00965	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN933@WinMain:
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 38   : 	clReleaseContext(context);

  0096a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00971	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseContext
; File c:\users\erlend\documents\github\wind\project\wind\wind\main.cpp

; 290  : 	Blocks::destroy();

  00977	e8 00 00 00 00	 call	 ?destroy@Blocks@@YAXXZ	; Blocks::destroy

; 291  : 	return msg.wParam;

  0097c	8b 85 30 01 00
	00		 mov	 eax, DWORD PTR msg$[rbp-240]

; 292  : }

  00982	4c 8d 9c 24 a0
	02 00 00	 lea	 r11, QWORD PTR [rsp+672]
  0098a	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  0098e	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00992	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  00996	49 8b e3	 mov	 rsp, r11
  00999	41 5f		 pop	 r15
  0099b	41 5e		 pop	 r14
  0099d	41 5d		 pop	 r13
  0099f	41 5c		 pop	 r12
  009a1	5d		 pop	 rbp
  009a2	c3		 ret	 0
$LN993@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 112  : 			_XSTD terminate();

  009a3	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  009a8	cc		 int	 3
$LN953@WinMain:
  009a9	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  009ae	cc		 int	 3
$LN951@WinMain:
  009af	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  009b4	cc		 int	 3
$LN992@WinMain:
WinMain	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
;	COMDAT ??_GGLWindow@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GGLWindow@@QEAAPEAXI@Z PROC				; GLWindow::`scalar deleting destructor', COMDAT
$LN45:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp

; 28   : 	destroyWindow();

  00009	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QEAAXXZ ; GLWindow::destroyWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0000e	48 83 7b 50 08	 cmp	 QWORD PTR [rbx+80], 8
  00013	72 09		 jb	 SHORT $LN28@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00015	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00019	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN28@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	33 c0		 xor	 eax, eax

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00020	48 c7 43 50 07
	00 00 00	 mov	 QWORD PTR [rbx+80], 7
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00028	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0002c	48 89 43 48	 mov	 QWORD PTR [rbx+72], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00030	66 89 43 38	 mov	 WORD PTR [rbx+56], ax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 33   : 		_Mtx_destroy(&_Mtx);

  00034	e8 00 00 00 00	 call	 _Mtx_destroy
  00039	48 8b cb	 mov	 rcx, rbx
  0003c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00041	48 8b c3	 mov	 rax, rbx
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
??_GGLWindow@@QEAAPEAXI@Z ENDP				; GLWindow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$List@VKeyboardAction@@$0BA@@@QEAAAEAVKeyboardAction@@H@Z
_TEXT	SEGMENT
this$dead$ = 8
index$ = 16
??A?$List@VKeyboardAction@@$0BA@@@QEAAAEAVKeyboardAction@@H@Z PROC ; List<KeyboardAction,16>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A ; Keyboard::actions
  00007	48 63 c2	 movsxd	 rax, edx
  0000a	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]

; 20   : 	}

  0000e	c3		 ret	 0
??A?$List@VKeyboardAction@@$0BA@@@QEAAAEAVKeyboardAction@@H@Z ENDP ; List<KeyboardAction,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$List@VKeyboardAction@@$0BA@@@QEAAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?getSize@?$List@VKeyboardAction@@$0BA@@@QEAAHXZ PROC	; List<KeyboardAction,16>::getSize, COMDAT

; 32   : 		return count;

  00000	8b 05 80 00 00
	00		 mov	 eax, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128

; 33   : 	}

  00006	c3		 ret	 0
?getSize@?$List@VKeyboardAction@@$0BA@@@QEAAHXZ ENDP	; List<KeyboardAction,16>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@VKeyboardAction@@$0BA@@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?clear@?$List@VKeyboardAction@@$0BA@@@QEAAXXZ PROC	; List<KeyboardAction,16>::clear, COMDAT

; 37   : 		count = 0;

  00000	c7 05 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128, 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@VKeyboardAction@@$0BA@@@QEAAXXZ ENDP	; List<KeyboardAction,16>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$List@VMouseAction@@$0BA@@@QEAAAEAVMouseAction@@H@Z
_TEXT	SEGMENT
this$dead$ = 8
index$ = 16
??A?$List@VMouseAction@@$0BA@@@QEAAAEAVMouseAction@@H@Z PROC ; List<MouseAction,16>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 63 c2	 movsxd	 rax, edx
  00003	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00007	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A ; Mouse::actions
  0000e	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]

; 20   : 	}

  00012	c3		 ret	 0
??A?$List@VMouseAction@@$0BA@@@QEAAAEAVMouseAction@@H@Z ENDP ; List<MouseAction,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$List@VMouseAction@@$0BA@@@QEAAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?getSize@?$List@VMouseAction@@$0BA@@@QEAAHXZ PROC	; List<MouseAction,16>::getSize, COMDAT

; 32   : 		return count;

  00000	8b 05 40 01 00
	00		 mov	 eax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320

; 33   : 	}

  00006	c3		 ret	 0
?getSize@?$List@VMouseAction@@$0BA@@@QEAAHXZ ENDP	; List<MouseAction,16>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@VMouseAction@@$0BA@@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?clear@?$List@VMouseAction@@$0BA@@@QEAAXXZ PROC		; List<MouseAction,16>::clear, COMDAT

; 37   : 		count = 0;

  00000	c7 05 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@VMouseAction@@$0BA@@@QEAAXXZ ENDP		; List<MouseAction,16>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::shared_ptr<ChunkBase>::operator=, COMDAT

; 609  : 		{	// construct shared_ptr object that takes resource from _Right

$LN70:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00006	45 33 c9	 xor	 r9d, r9d

; 609  : 		{	// construct shared_ptr object that takes resource from _Right

  00009	48 8b f9	 mov	 rdi, rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00011	41 8b c1	 mov	 eax, r9d
  00014	45 8b c1	 mov	 r8d, r9d
  00017	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0001c	48 3b ca	 cmp	 rcx, rdx
  0001f	74 13		 je	 SHORT $LN26@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00021	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]

; 49   : 	_Right = _Move(_Tmp);

  00025	4c 89 4a 08	 mov	 QWORD PTR [rdx+8], r9

; 48   : 	_Left = _Move(_Right);

  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax

; 49   : 	_Right = _Move(_Tmp);

  00031	4c 89 0a	 mov	 QWORD PTR [rdx], r9
$LN26@operator:

; 48   : 	_Left = _Move(_Right);

  00034	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]

; 49   : 	_Right = _Move(_Tmp);

  00038	4c 89 47 08	 mov	 QWORD PTR [rdi+8], r8
  0003c	48 89 07	 mov	 QWORD PTR [rdi], rax

; 48   : 	_Left = _Move(_Right);

  0003f	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp+8], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00044	48 85 c9	 test	 rcx, rcx
  00047	74 41		 je	 SHORT $LN67@operator

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00049	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  0004d	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00052	75 28		 jne	 SHORT $LN66@operator
  00054	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00059	48 8b 5c 24 28	 mov	 rbx, QWORD PTR $T1[rsp+8]
  0005e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00061	48 8b cb	 mov	 rcx, rbx
  00064	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00066	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0006a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006f	75 0b		 jne	 SHORT $LN66@operator

; 128  : 			_Delete_this();

  00071	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp+8]
  00076	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00079	ff 50 08	 call	 QWORD PTR [rax+8]
$LN66@operator:

; 610  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 611  : 		return (*this);

  0007c	48 8b c7	 mov	 rax, rdi
  0007f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 612  : 		}

  00084	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
$LN67@operator:

; 610  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 611  : 		return (*this);

  0008a	48 8b c7	 mov	 rax, rdi

; 612  : 		}

  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::shared_ptr<ChunkBase>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z
_TEXT	SEGMENT
this$ = 48
_Px$ = 56
??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>, COMDAT

; 485  : 		explicit shared_ptr(_Ux *_Px)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00008	48 8b d9	 mov	 rbx, rcx

; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00012	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>

; 488  : 		}

  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$move@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z PROC ; std::move<std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 1791 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1792 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ENDP ; std::move<std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>, COMDAT

; 708  : 		void _Resetp(_Ux *_Px)

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  0001e	b9 18 00 00 00	 mov	 ecx, 24
  00023	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00028	48 85 c0	 test	 rax, rax
  0002b	74 1c		 je	 SHORT $LN5@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0002d	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1
  00034	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$_Ref_count@VChunk@@@std@@6B@
  00042	48 89 08	 mov	 QWORD PTR [rax], rcx
  00045	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
$LN5@Resetp:

; 717  : 
; 718  : 	template<class _Ux,
; 719  : 		class _Dx>
; 720  : 		void _Resetp(_Ux *_Px, _Dx _Dt)
; 721  : 		{	// release, take ownership of _Px, deleter _Dt
; 722  : 		_TRY_BEGIN	// allocate control block and reset
; 723  : 		_Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
; 724  : 		_CATCH_ALL	// allocation failed, delete resource
; 725  : 		_Dt(_Px);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : //#if _HAS_CPP0X
; 731  : 	template<class _Ux,
; 732  : 		class _Dx,
; 733  : 		class _Alloc>
; 734  : 		void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 735  : 		{	// release, take ownership of _Px, deleter _Dt, allocator _Ax
; 736  : 		typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
; 737  : 		typename _Alloc::template rebind<_Refd>::other _Al = _Ax;
; 738  : 
; 739  : 		_TRY_BEGIN	// allocate control block and reset
; 740  : 		_Refd *_Ptr = _Al.allocate(1);
; 741  : 		::new (_Ptr) _Refd(_Px, _Dt, _Al);
; 742  : 		_Resetp0(_Px, _Ptr);
; 743  : 		_CATCH_ALL	// allocation failed, delete resource
; 744  : 		_Dt(_Px);
; 745  : 		_RERAISE;
; 746  : 		_CATCH_END
; 747  : 		}
; 748  : //#endif /* _HAS_CPP0X */
; 749  : 
; 750  : public:
; 751  : 	template<class _Ux>
; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00049	4c 8b c0	 mov	 r8, rax
  0004c	48 8b d3	 mov	 rdx, rbx
  0004f	48 8b cf	 mov	 rcx, rdi
  00052	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
  00057	90		 npad	 1

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;
; 714  : 		_RERAISE;
; 715  : 		_CATCH_END
; 716  : 		}

  00058	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN30@Resetp:
??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA PROC ; `std::shared_ptr<ChunkBase>::_Resetp<Chunk>'::`1'::catch$0

; 712  : 		_CATCH_ALL	// allocation failed, delete resource

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000b	48 8b ea	 mov	 rbp, rdx
__catch$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z$0:

; 713  : 		delete _Px;

  0000e	48 8b 5d 48	 mov	 rbx, QWORD PTR _Px$[rbp]
  00012	48 85 db	 test	 rbx, rbx
  00015	74 1a		 je	 SHORT $LN25@catch$0
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 155  : {

  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  0001e	48 89 03	 mov	 QWORD PTR [rbx], rax

; 156  : 
; 157  : }

  00021	48 8b cb	 mov	 rcx, rbx
  00024	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN25@catch$0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 714  : 		_RERAISE;

  00031	33 d2		 xor	 edx, edx
  00033	33 c9		 xor	 ecx, ecx
  00035	e8 00 00 00 00	 call	 _CxxThrowException
  0003a	90		 npad	 1
?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA ENDP ; `std::shared_ptr<ChunkBase>::_Resetp<Chunk>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??_GChunk@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GChunk@@QEAAPEAXI@Z PROC				; Chunk::`scalar deleting destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 155  : {

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax

; 156  : 
; 157  : }

  00013	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00018	48 8b cb	 mov	 rcx, rbx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00020	48 8b c3	 mov	 rax, rbx
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??_GChunk@@QEAAPEAXI@Z ENDP				; Chunk::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VChunk@@@std@@QEAA@PEAVChunk@@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
??0?$_Ref_count@VChunk@@@std@@QEAA@PEAVChunk@@@Z PROC	; std::_Ref_count<Chunk>::_Ref_count<Chunk>, COMDAT

; 155  : 		{	// construct

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_Ref_count@VChunk@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00007	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [rcx+8], 1
  0000e	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 156  : 		}

  00018	48 8b c1	 mov	 rax, rcx
  0001b	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  0001f	c3		 ret	 0
??0?$_Ref_count@VChunk@@@std@@QEAA@PEAVChunk@@@Z ENDP	; std::_Ref_count<Chunk>::_Ref_count<Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ PROC	; std::_Ref_count<Chunk>::_Destroy, COMDAT

; 160  : 		{	// destroy managed resource

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 161  : 		delete _Ptr;

  00006	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 1f		 je	 SHORT $LN5@Destroy
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 155  : {

  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@

; 156  : 
; 157  : }

  00016	48 8b cb	 mov	 rcx, rbx
  00019	48 89 03	 mov	 QWORD PTR [rbx], rax
  0001c	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00021	48 8b cb	 mov	 rcx, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 162  : 		}

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
$LN5@Destroy:
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ ENDP	; std::_Ref_count<Chunk>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ PROC	; std::_Ref_count<Chunk>::_Delete_this, COMDAT

; 166  : 		delete this;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 0c		 je	 SHORT $LN3@Delete_thi
  00005	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00008	ba 01 00 00 00	 mov	 edx, 1
  0000d	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
$LN3@Delete_thi:

; 167  : 		}

  00011	f3 c3		 fatret	 0
?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ ENDP	; std::_Ref_count<Chunk>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z PROC		; std::_Ref_count<Chunk>::`scalar deleting destructor', COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN8@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN8@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z ENDP		; std::_Ref_count<Chunk>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VChunk@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Ref_count@VChunk@@@std@@UEAA@XZ PROC		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>, COMDAT

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1?$_Ref_count@VChunk@@@std@@UEAA@XZ ENDP		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVChunk@@PEAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
_Rx$ = 24
??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVChunk@@PEAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>, COMDAT

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00000	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVChunk@@PEAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>
_TEXT	ENDS
END
