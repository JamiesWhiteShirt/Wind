; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?camX@@3HA					; camX
PUBLIC	?camY@@3HA					; camY
PUBLIC	??_7?$_Ref_count@VChunk@@@std@@6B@		; std::_Ref_count<Chunk>::`vftable'
PUBLIC	??_R3?$_Ref_count@VChunk@@@std@@8		; std::_Ref_count<Chunk>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count@VChunk@@@std@@8		; std::_Ref_count<Chunk>::`RTTI Base Class Array'
PUBLIC	?prevCamX@@3HA					; prevCamX
PUBLIC	??_R0?AV?$_Ref_count@VChunk@@@std@@@8		; std::_Ref_count<Chunk> `RTTI Type Descriptor'
PUBLIC	?prevCamZ@@3HA					; prevCamZ
PUBLIC	?ticks@@3HA					; ticks
PUBLIC	??_R4?$_Ref_count@VChunk@@@std@@6B@		; std::_Ref_count<Chunk>::`RTTI Complete Object Locator'
PUBLIC	?camZ@@3HA					; camZ
PUBLIC	?prevCamY@@3HA					; prevCamY
PUBLIC	??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8	; std::_Ref_count<Chunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__imp_TranslateMessage:PROC
EXTRN	__imp_PeekMessageW:PROC
EXTRN	__imp_DispatchMessageW:PROC
?camX@@3HA DD	01H DUP (?)				; camX
?camY@@3HA DD	01H DUP (?)				; camY
?prevCamX@@3HA DD 01H DUP (?)				; prevCamX
?prevCamZ@@3HA DD 01H DUP (?)				; prevCamZ
?ticks@@3HA DD	01H DUP (?)				; ticks
?camZ@@3HA DD	01H DUP (?)				; camZ
?prevCamY@@3HA DD 01H DUP (?)				; prevCamY
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8 DD imagerel ??_R0?AV?$_Ref_count@VChunk@@@std@@@8 ; std::_Ref_count<Chunk>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Ref_count@VChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$_Ref_count@VChunk@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count@VChunk@@@std@@6B@ DD 01H		; std::_Ref_count<Chunk>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$_Ref_count@VChunk@@@std@@@8
	DD	imagerel ??_R3?$_Ref_count@VChunk@@@std@@8
	DD	imagerel ??_R4?$_Ref_count@VChunk@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Ref_count@VChunk@@@std@@@8
_DATA	SEGMENT
??_R0?AV?$_Ref_count@VChunk@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Ref_count<Chunk> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Ref_count@VChunk@@@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R2?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count@VChunk@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Ref_count@VChunk@@@std@@8 ; std::_Ref_count<Chunk>::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_Ref_count_base@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count@VChunk@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count@VChunk@@@std@@8 DD 00H		; std::_Ref_count<Chunk>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$_Ref_count@VChunk@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count@VChunk@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count@VChunk@@@std@@6B@ DQ FLAT:??_R4?$_Ref_count@VChunk@@@std@@6B@ ; std::_Ref_count<Chunk>::`vftable'
	DQ	FLAT:?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ
	DQ	FLAT:?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ
	DQ	FLAT:??_E?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Get_deleter@_Ref_count_base@std@@UEBAPEAXAEBVtype_info@@@Z
	ORG $+5
$SG4294915918 DB 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 00H, 00H
	ORG $+6
$SG4294915917 DB '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, 's', 00H, '\', 00H, 'g', 00H, 'e', 00H, 'n'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, '.', 00H, 'c', 00H, 'l', 00H, 00H, 00H
PUBLIC	??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVChunk@@PEAV_Ref_count_base@1@@Z ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>
PUBLIC	??1?$_Ref_count@VChunk@@@std@@UEAA@XZ		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>
PUBLIC	??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z	; std::_Ref_count<Chunk>::`scalar deleting destructor'
PUBLIC	?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ ; std::_Ref_count<Chunk>::_Delete_this
PUBLIC	?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ	; std::_Ref_count<Chunk>::_Destroy
PUBLIC	??0?$_Ref_count@VChunk@@@std@@QEAA@PEAVChunk@@@Z ; std::_Ref_count<Chunk>::_Ref_count<Chunk>
PUBLIC	??_GChunk@@QEAAPEAXI@Z				; Chunk::`scalar deleting destructor'
PUBLIC	??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve
PUBLIC	??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
PUBLIC	??$move@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ; std::move<std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>
PUBLIC	?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
PUBLIC	??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::shared_ptr<ChunkBase>::operator=
PUBLIC	?clear@?$List@VMouseAction@@$0BA@@@QEAAXXZ	; List<MouseAction,16>::clear
PUBLIC	?getSize@?$List@VMouseAction@@$0BA@@@QEAAHXZ	; List<MouseAction,16>::getSize
PUBLIC	??A?$List@VMouseAction@@$0BA@@@QEAAAEAVMouseAction@@H@Z ; List<MouseAction,16>::operator[]
PUBLIC	?clear@?$List@VKeyboardAction@@$0BA@@@QEAAXXZ	; List<KeyboardAction,16>::clear
PUBLIC	?getSize@?$List@VKeyboardAction@@$0BA@@@QEAAHXZ	; List<KeyboardAction,16>::getSize
PUBLIC	??A?$List@VKeyboardAction@@$0BA@@@QEAAAEAVKeyboardAction@@H@Z ; List<KeyboardAction,16>::operator[]
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??_GGLWindow@@QEAAPEAXI@Z			; GLWindow::`scalar deleting destructor'
PUBLIC	WinMain
PUBLIC	?mainLoop@@YA_NXZ				; mainLoop
EXTRN	??_E?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z:PROC	; std::_Ref_count<Chunk>::`vector deleting destructor'
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z DD imagerel $LN10
	DD	imagerel $LN10+38
	DD	imagerel $unwind$??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ DD imagerel $LN11
	DD	imagerel $LN11+52
	DD	imagerel $unwind$?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GChunk@@QEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+41
	DD	imagerel $unwind$??_GChunk@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD imagerel $LN31
	DD	imagerel $LN31+99
	DD	imagerel $unwind$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA DD imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA
	DD	imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA+59
	DD	imagerel $unwind$?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z DD imagerel $LN16
	DD	imagerel $LN16+71
	DD	imagerel $unwind$?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z DD imagerel $LN77
	DD	imagerel $LN77+185
	DD	imagerel $unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z@4HA DD imagerel ?dtor$0@?0???$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z@4HA
	DD	imagerel ?dtor$0@?0???$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z DD imagerel $LN6
	DD	imagerel $LN6+32
	DD	imagerel $unwind$??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z DD imagerel $LN62
	DD	imagerel $LN62+110
	DD	imagerel $unwind$?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70
	DD	imagerel $LN70+77
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70+77
	DD	imagerel $LN70+84
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70+84
	DD	imagerel $LN70+113
	DD	imagerel $chain$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70+113
	DD	imagerel $LN70+138
	DD	imagerel $chain$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN70+138
	DD	imagerel $LN70+147
	DD	imagerel $chain$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD imagerel $LN104
	DD	imagerel $LN104+123
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GGLWindow@@QEAAPEAXI@Z DD imagerel $LN41
	DD	imagerel $LN41+65
	DD	imagerel $unwind$??_GGLWindow@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WinMain DD imagerel $LN999
	DD	imagerel $LN999+2950
	DD	imagerel $unwind$WinMain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?mainLoop@@YA_NXZ DD imagerel $LN566
	DD	imagerel $LN566+3359
	DD	imagerel $unwind$?mainLoop@@YA_NXZ
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?mainLoop@@YA_NXZ DD imagerel ?mainLoop@@YA_NXZ
	DD	0ffffffffH
	DD	imagerel ?mainLoop@@YA_NXZ+1985
	DD	00H
	DD	imagerel ?mainLoop@@YA_NXZ+2035
	DD	01H
	DD	imagerel ?mainLoop@@YA_NXZ+2113
	DD	02H
	DD	imagerel ?mainLoop@@YA_NXZ+2139
	DD	03H
	DD	imagerel ?mainLoop@@YA_NXZ+2158
	DD	04H
	DD	imagerel ?mainLoop@@YA_NXZ+2177
	DD	01H
	DD	imagerel ?mainLoop@@YA_NXZ+2196
	DD	00H
	DD	imagerel ?mainLoop@@YA_NXZ+2591
	DD	05H
	DD	imagerel ?mainLoop@@YA_NXZ+2661
	DD	00H
	DD	imagerel ?mainLoop@@YA_NXZ+2973
	DD	0ffffffffH
	DD	imagerel ?mainLoop@@YA_NXZ+3118
	DD	00H
	DD	imagerel ?mainLoop@@YA_NXZ+3130
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?mainLoop@@YA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??mainLoop@@YA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??mainLoop@@YA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$5@?0??mainLoop@@YA_NXZ@4HA
	DD	02H
	DD	imagerel ?dtor$6@?0??mainLoop@@YA_NXZ@4HA
	DD	03H
	DD	imagerel ?dtor$7@?0??mainLoop@@YA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$9@?0??mainLoop@@YA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?mainLoop@@YA_NXZ DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$?mainLoop@@YA_NXZ
	DD	00H
	DD	00H
	DD	0dH
	DD	imagerel $ip2state$?mainLoop@@YA_NXZ
	DD	090H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?mainLoop@@YA_NXZ DD 0184f11H
	DD	0ac84fH
	DD	0bb847H
	DD	0ca83fH
	DD	0d9837H
	DD	0e882fH
	DD	0f782aH
	DD	0106826H
	DD	023011aH
	DD	0e00df00fH
	DD	0c009d00bH
	DD	060067007H
	DD	050043005H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?mainLoop@@YA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WinMain DD 0d2c01H
	DD	05f742cH
	DD	05e642cH
	DD	05d342cH
	DD	056012cH
	DD	0e01bf01dH
	DD	0c017d019H
	DD	05015H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GGLWindow@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN70
	DD	imagerel $LN70+77
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 021H
	DD	imagerel $LN70+77
	DD	imagerel $LN70+84
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	083405H
	DD	imagerel $LN70+77
	DD	imagerel $LN70+84
	DD	imagerel $chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020521H
	DD	096405H
	DD	imagerel $LN70
	DD	imagerel $LN70+77
	DD	imagerel $unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z DD imagerel ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z
	DD	0ffffffffH
	DD	imagerel ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z+32
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z DD 061d11H
	DD	0a641dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD imagerel ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
	DD	0ffffffffH
	DD	imagerel ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z+30
	DD	00H
	DD	imagerel ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z+88
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA+14
	DD	01H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
	DD	01H
	DD	imagerel $tryMap$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
	DD	05H
	DD	imagerel $ip2state$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z DD 041819H
	DD	083418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GChunk@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
;	COMDAT ?mainLoop@@YA_NXZ
_TEXT	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2230 = 360
tv2229 = 368
xDist$1$ = 376
?mainLoop@@YA_NXZ PROC					; mainLoop, COMDAT

; 22   : {

$LN566:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	53		 push	 rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 55		 push	 r13
  0000b	41 56		 push	 r14
  0000d	41 57		 push	 r15
  0000f	48 8d 68 a8	 lea	 rbp, QWORD PTR [rax-88]
  00013	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001a	48 c7 45 90 fe
	ff ff ff	 mov	 QWORD PTR $T8[rbp-256], -2
  00022	0f 29 70 a8	 movaps	 XMMWORD PTR [rax-88], xmm6
  00026	0f 29 78 98	 movaps	 XMMWORD PTR [rax-104], xmm7
  0002a	44 0f 29 40 88	 movaps	 XMMWORD PTR [rax-120], xmm8
  0002f	44 0f 29 88 78
	ff ff ff	 movaps	 XMMWORD PTR [rax-136], xmm9
  00037	44 0f 29 90 68
	ff ff ff	 movaps	 XMMWORD PTR [rax-152], xmm10
  0003f	44 0f 29 98 58
	ff ff ff	 movaps	 XMMWORD PTR [rax-168], xmm11
  00047	44 0f 29 a0 48
	ff ff ff	 movaps	 XMMWORD PTR [rax-184], xmm12

; 23   : 	Camera* cam = &GameStates::processedState->cam;

  0004f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA ; GameStates::processedState
  00056	4c 8b f2	 mov	 r14, rdx

; 24   : 
; 25   : 	for(int i = 0; i < Mouse::actions.getSize(); i++)

  00059	33 f6		 xor	 esi, esi
  0005b	8b fe		 mov	 edi, esi
  0005d	39 35 40 01 00
	00		 cmp	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, esi
  00063	0f 8e c0 00 00
	00		 jle	 $LN32@mainLoop

; 23   : 	Camera* cam = &GameStates::processedState->cam;

  00069	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A ; Mouse::actions
  00070	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3f000000
  00078	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL34@mainLoop:

; 26   : 	{
; 27   : 		MouseAction ma = Mouse::actions[i];

  00080	44 8b 23	 mov	 r12d, DWORD PTR [rbx]
  00083	44 8b 6b 04	 mov	 r13d, DWORD PTR [rbx+4]
  00087	8b 4b 08	 mov	 ecx, DWORD PTR [rbx+8]
  0008a	8b 43 0c	 mov	 eax, DWORD PTR [rbx+12]
  0008d	89 44 24 7c	 mov	 DWORD PTR ma$5[rsp+12], eax
  00091	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  00094	89 45 80	 mov	 DWORD PTR ma$5[rbp-240], eax

; 28   : 		GameStates::processedState->FOV -= ma.sc * 5;

  00097	6b c9 fb	 imul	 ecx, -5
  0009a	01 4a 20	 add	 DWORD PTR [rdx+32], ecx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  000a4	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  000a9	85 c0		 test	 eax, eax
  000ab	74 07		 je	 SHORT $LN55@mainLoop

; 33   : 		_Throw_C_error(_Res);

  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN55@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 48   : 	bool value = mbs[index];

  000b4	44 0f b6 3d 00
	00 00 00	 movzx	 r15d, BYTE PTR ?mbs@Mouse@@0PA_NA
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  000c3	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  000c8	85 c0		 test	 eax, eax
  000ca	74 07		 je	 SHORT $LN62@mainLoop

; 33   : 		_Throw_C_error(_Res);

  000cc	8b c8		 mov	 ecx, eax
  000ce	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN62@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 29   : 		if(Mouse::getMB(0))

  000d3	45 84 ff	 test	 r15b, r15b
  000d6	74 38		 je	 SHORT $LN33@mainLoop
  000d8	66 41 0f 6e cd	 movd	 xmm1, r13d

; 30   : 		{
; 31   : 			cam->rot.x -= ma.ry * 0.5f;

  000dd	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000e0	f3 0f 59 ce	 mulss	 xmm1, xmm6
  000e4	f3 41 0f 10 46
	10		 movss	 xmm0, DWORD PTR [r14+16]
  000ea	f3 0f 5c c1	 subss	 xmm0, xmm1
  000ee	f3 41 0f 11 46
	10		 movss	 DWORD PTR [r14+16], xmm0
  000f4	66 41 0f 6e cc	 movd	 xmm1, r12d

; 32   : 			cam->rot.y -= ma.rx * 0.5f;

  000f9	0f 5b c9	 cvtdq2ps xmm1, xmm1
  000fc	f3 0f 59 ce	 mulss	 xmm1, xmm6
  00100	f3 41 0f 10 46
	14		 movss	 xmm0, DWORD PTR [r14+20]
  00106	f3 0f 5c c1	 subss	 xmm0, xmm1
  0010a	f3 41 0f 11 46
	14		 movss	 DWORD PTR [r14+20], xmm0
$LN33@mainLoop:

; 24   : 
; 25   : 	for(int i = 0; i < Mouse::actions.getSize(); i++)

  00110	ff c7		 inc	 edi
  00112	48 83 c3 14	 add	 rbx, 20

; 23   : 	Camera* cam = &GameStates::processedState->cam;

  00116	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA ; GameStates::processedState

; 24   : 
; 25   : 	for(int i = 0; i < Mouse::actions.getSize(); i++)

  0011d	3b 3d 40 01 00
	00		 cmp	 edi, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
  00123	0f 8c 57 ff ff
	ff		 jl	 $LL34@mainLoop
$LN32@mainLoop:

; 33   : 		}
; 34   : 	}
; 35   : 
; 36   : 	for(int i = 0; i < Keyboard::actions.getSize(); i++)

  00129	44 8b c6	 mov	 r8d, esi
  0012c	44 8b 15 80 00
	00 00		 mov	 r10d, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
  00133	45 85 d2	 test	 r10d, r10d
  00136	7e 3f		 jle	 SHORT $LN28@mainLoop
  00138	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A ; Keyboard::actions
  0013f	90		 npad	 1
$LL30@mainLoop:

; 37   : 	{
; 38   : 		KeyboardAction kba = Keyboard::actions[i];

  00140	49 8b 01	 mov	 rax, QWORD PTR [r9]

; 39   : 		
; 40   : 		if(kba.released && kba.button == 69)

  00143	48 8b c8	 mov	 rcx, rax
  00146	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  0014a	84 c9		 test	 cl, cl
  0014c	74 1d		 je	 SHORT $LN29@mainLoop
  0014e	83 f8 45	 cmp	 eax, 69			; 00000045H
  00151	75 18		 jne	 SHORT $LN29@mainLoop

; 41   : 		{
; 42   : 			GameStates::processedState->devEnabled = !GameStates::processedState->devEnabled;

  00153	40 38 72 24	 cmp	 BYTE PTR [rdx+36], sil
  00157	0f 94 c0	 sete	 al
  0015a	88 42 24	 mov	 BYTE PTR [rdx+36], al
  0015d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA ; GameStates::processedState
  00164	44 8b 15 80 00
	00 00		 mov	 r10d, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
$LN29@mainLoop:

; 33   : 		}
; 34   : 	}
; 35   : 
; 36   : 	for(int i = 0; i < Keyboard::actions.getSize(); i++)

  0016b	41 ff c0	 inc	 r8d
  0016e	49 83 c1 08	 add	 r9, 8
  00172	45 3b c2	 cmp	 r8d, r10d
  00175	7c c9		 jl	 SHORT $LL30@mainLoop
$LN28@mainLoop:

; 43   : 		}
; 44   : 	}
; 45   : 
; 46   : 	if(GameStates::processedState->FOV < 5)

  00177	8b 42 20	 mov	 eax, DWORD PTR [rdx+32]
  0017a	83 f8 05	 cmp	 eax, 5
  0017d	7d 09		 jge	 SHORT $LN26@mainLoop

; 47   : 	{
; 48   : 		GameStates::processedState->FOV = 5;

  0017f	c7 42 20 05 00
	00 00		 mov	 DWORD PTR [rdx+32], 5
  00186	eb 0e		 jmp	 SHORT $LN24@mainLoop
$LN26@mainLoop:

; 49   : 	}
; 50   : 	else if(GameStates::processedState->FOV > 175)

  00188	3d af 00 00 00	 cmp	 eax, 175		; 000000afH
  0018d	7e 07		 jle	 SHORT $LN24@mainLoop

; 51   : 	{
; 52   : 		GameStates::processedState->FOV = 175;

  0018f	c7 42 20 af 00
	00 00		 mov	 DWORD PTR [rdx+32], 175	; 000000afH
$LN24@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0019d	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  001a2	85 c0		 test	 eax, eax
  001a4	74 07		 je	 SHORT $LN75@mainLoop

; 33   : 		_Throw_C_error(_Res);

  001a6	8b c8		 mov	 ecx, eax
  001a8	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN75@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  001ad	0f b6 1d 10 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  001bb	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  001c0	85 c0		 test	 eax, eax
  001c2	74 07		 je	 SHORT $LN82@mainLoop

; 33   : 		_Throw_C_error(_Res);

  001c4	8b c8		 mov	 ecx, eax
  001c6	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN82@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 55   : 	float b = Keyboard::getKey(16) ? 0.4f : 0.1f;

  001cb	84 db		 test	 bl, bl
  001cd	74 0b		 je	 SHORT $LN37@mainLoop
  001cf	f3 44 0f 10 15
	00 00 00 00	 movss	 xmm10, DWORD PTR __real@3ecccccd
  001d8	eb 09		 jmp	 SHORT $LN38@mainLoop
$LN37@mainLoop:
  001da	f3 44 0f 10 15
	00 00 00 00	 movss	 xmm10, DWORD PTR __real@3dcccccd
$LN38@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  001ea	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  001ef	85 c0		 test	 eax, eax
  001f1	74 07		 je	 SHORT $LN91@mainLoop

; 33   : 		_Throw_C_error(_Res);

  001f3	8b c8		 mov	 ecx, eax
  001f5	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN91@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  001fa	0f b6 1d 57 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+87
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00201	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00208	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0020d	85 c0		 test	 eax, eax
  0020f	74 07		 je	 SHORT $LN98@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00211	8b c8		 mov	 ecx, eax
  00213	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN98@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 57   : 	if(Keyboard::getKey(87)) //W

  00218	f2 44 0f 10 1d
	00 00 00 00	 movsdx	 xmm11, QWORD PTR __real@400921fb54442d18
  00221	f2 44 0f 10 25
	00 00 00 00	 movsdx	 xmm12, QWORD PTR __real@4066800000000000
  0022a	84 db		 test	 bl, bl
  0022c	0f 84 ae 00 00
	00		 je	 $LN23@mainLoop
  00232	f3 41 0f 10 7e
	10		 movss	 xmm7, DWORD PTR [r14+16]

; 58   : 	{
; 59   : 		cam->pos.x -= b * cos(cam->rot.x * M_PI / 180.0f) * sin(cam->rot.y * M_PI / 180.0f);

  00238	0f 5a ff	 cvtps2pd xmm7, xmm7
  0023b	f2 41 0f 59 fb	 mulsd	 xmm7, xmm11
  00240	f2 41 0f 5e fc	 divsd	 xmm7, xmm12
  00245	0f 28 c7	 movaps	 xmm0, xmm7
  00248	e8 00 00 00 00	 call	 cos
  0024d	44 0f 28 c8	 movaps	 xmm9, xmm0
  00251	41 0f 5a c2	 cvtps2pd xmm0, xmm10
  00255	f2 44 0f 59 c8	 mulsd	 xmm9, xmm0
  0025a	f3 45 0f 10 46
	14		 movss	 xmm8, DWORD PTR [r14+20]
  00260	45 0f 5a c0	 cvtps2pd xmm8, xmm8
  00264	f2 45 0f 59 c3	 mulsd	 xmm8, xmm11
  00269	f2 45 0f 5e c4	 divsd	 xmm8, xmm12
  0026e	f3 41 0f 10 36	 movss	 xmm6, DWORD PTR [r14]
  00273	0f 5a f6	 cvtps2pd xmm6, xmm6
  00276	41 0f 28 c0	 movaps	 xmm0, xmm8
  0027a	e8 00 00 00 00	 call	 sin
  0027f	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  00284	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00288	66 0f 5a ce	 cvtpd2ps xmm1, xmm6
  0028c	f3 41 0f 11 0e	 movss	 DWORD PTR [r14], xmm1

; 60   : 		cam->pos.y += b * sin(cam->rot.x * M_PI / 180.0f);

  00291	0f 28 c7	 movaps	 xmm0, xmm7
  00294	e8 00 00 00 00	 call	 sin
  00299	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  0029d	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  002a1	f3 41 0f 10 56
	04		 movss	 xmm2, DWORD PTR [r14+4]
  002a7	0f 5a d2	 cvtps2pd xmm2, xmm2
  002aa	f2 0f 58 c2	 addsd	 xmm0, xmm2
  002ae	0f 57 c9	 xorps	 xmm1, xmm1
  002b1	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  002b5	f3 41 0f 11 4e
	04		 movss	 DWORD PTR [r14+4], xmm1

; 61   : 		cam->pos.z += b * cos(cam->rot.x * M_PI / 180.0f) * cos(cam->rot.y * M_PI / 180.0f);

  002bb	41 0f 28 c0	 movaps	 xmm0, xmm8
  002bf	e8 00 00 00 00	 call	 cos
  002c4	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  002c9	f3 41 0f 10 4e
	08		 movss	 xmm1, DWORD PTR [r14+8]
  002cf	0f 5a c9	 cvtps2pd xmm1, xmm1
  002d2	f2 0f 58 c1	 addsd	 xmm0, xmm1
  002d6	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  002da	f3 41 0f 11 46
	08		 movss	 DWORD PTR [r14+8], xmm0
$LN23@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  002e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  002e7	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  002ec	85 c0		 test	 eax, eax
  002ee	74 07		 je	 SHORT $LN107@mainLoop

; 33   : 		_Throw_C_error(_Res);

  002f0	8b c8		 mov	 ecx, eax
  002f2	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN107@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  002f7	0f b6 1d 53 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+83
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  002fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00305	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0030a	85 c0		 test	 eax, eax
  0030c	74 07		 je	 SHORT $LN114@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0030e	8b c8		 mov	 ecx, eax
  00310	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN114@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 64   : 	if(Keyboard::getKey(83)) //S

  00315	84 db		 test	 bl, bl
  00317	0f 84 ae 00 00
	00		 je	 $LN22@mainLoop
  0031d	f3 45 0f 10 46
	10		 movss	 xmm8, DWORD PTR [r14+16]

; 65   : 	{
; 66   : 		cam->pos.x += b * cos(cam->rot.x * M_PI / 180.0f) * sin(cam->rot.y * M_PI / 180.0f);

  00323	45 0f 5a c0	 cvtps2pd xmm8, xmm8
  00327	f2 45 0f 59 c3	 mulsd	 xmm8, xmm11
  0032c	f2 45 0f 5e c4	 divsd	 xmm8, xmm12
  00331	41 0f 28 c0	 movaps	 xmm0, xmm8
  00335	e8 00 00 00 00	 call	 cos
  0033a	44 0f 28 c8	 movaps	 xmm9, xmm0
  0033e	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  00342	f2 44 0f 59 c9	 mulsd	 xmm9, xmm1
  00347	f3 41 0f 10 7e
	14		 movss	 xmm7, DWORD PTR [r14+20]
  0034d	0f 5a ff	 cvtps2pd xmm7, xmm7
  00350	f2 41 0f 59 fb	 mulsd	 xmm7, xmm11
  00355	f2 41 0f 5e fc	 divsd	 xmm7, xmm12
  0035a	0f 28 c7	 movaps	 xmm0, xmm7
  0035d	e8 00 00 00 00	 call	 sin
  00362	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  00367	f3 41 0f 10 0e	 movss	 xmm1, DWORD PTR [r14]
  0036c	0f 5a c9	 cvtps2pd xmm1, xmm1
  0036f	f2 0f 58 c1	 addsd	 xmm0, xmm1
  00373	0f 57 c9	 xorps	 xmm1, xmm1
  00376	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  0037a	f3 41 0f 11 0e	 movss	 DWORD PTR [r14], xmm1
  0037f	f3 41 0f 10 76
	04		 movss	 xmm6, DWORD PTR [r14+4]

; 67   : 		cam->pos.y -= b * sin(cam->rot.x * M_PI / 180.0f);

  00385	0f 5a f6	 cvtps2pd xmm6, xmm6
  00388	41 0f 28 c0	 movaps	 xmm0, xmm8
  0038c	e8 00 00 00 00	 call	 sin
  00391	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  00395	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00399	f2 0f 5c f0	 subsd	 xmm6, xmm0
  0039d	66 0f 5a d6	 cvtpd2ps xmm2, xmm6
  003a1	f3 41 0f 11 56
	04		 movss	 DWORD PTR [r14+4], xmm2
  003a7	f3 41 0f 10 76
	08		 movss	 xmm6, DWORD PTR [r14+8]

; 68   : 		cam->pos.z -= b * cos(cam->rot.x * M_PI / 180.0f) * cos(cam->rot.y * M_PI / 180.0f);

  003ad	0f 5a f6	 cvtps2pd xmm6, xmm6
  003b0	0f 28 c7	 movaps	 xmm0, xmm7
  003b3	e8 00 00 00 00	 call	 cos
  003b8	f2 41 0f 59 c1	 mulsd	 xmm0, xmm9
  003bd	f2 0f 5c f0	 subsd	 xmm6, xmm0
  003c1	66 0f 5a c6	 cvtpd2ps xmm0, xmm6
  003c5	f3 41 0f 11 46
	08		 movss	 DWORD PTR [r14+8], xmm0
$LN22@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  003d2	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  003d7	85 c0		 test	 eax, eax
  003d9	74 07		 je	 SHORT $LN123@mainLoop

; 33   : 		_Throw_C_error(_Res);

  003db	8b c8		 mov	 ecx, eax
  003dd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN123@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  003e2	0f b6 1d 41 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+65
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  003e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  003f0	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  003f5	85 c0		 test	 eax, eax
  003f7	74 07		 je	 SHORT $LN130@mainLoop

; 33   : 		_Throw_C_error(_Res);

  003f9	8b c8		 mov	 ecx, eax
  003fb	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN130@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 71   : 	if(Keyboard::getKey(65)) //A

  00400	84 db		 test	 bl, bl
  00402	74 5f		 je	 SHORT $LN21@mainLoop
  00404	f3 41 0f 10 7e
	14		 movss	 xmm7, DWORD PTR [r14+20]

; 72   : 	{
; 73   : 		cam->pos.x -= b * cos(cam->rot.y * M_PI / 180.0f);

  0040a	0f 5a ff	 cvtps2pd xmm7, xmm7
  0040d	f2 41 0f 59 fb	 mulsd	 xmm7, xmm11
  00412	f2 41 0f 5e fc	 divsd	 xmm7, xmm12
  00417	f3 41 0f 10 36	 movss	 xmm6, DWORD PTR [r14]
  0041c	0f 5a f6	 cvtps2pd xmm6, xmm6
  0041f	0f 28 c7	 movaps	 xmm0, xmm7
  00422	e8 00 00 00 00	 call	 cos
  00427	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  0042b	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  0042f	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00433	66 0f 5a d6	 cvtpd2ps xmm2, xmm6
  00437	f3 41 0f 11 16	 movss	 DWORD PTR [r14], xmm2
  0043c	f3 41 0f 10 76
	08		 movss	 xmm6, DWORD PTR [r14+8]

; 74   : 		cam->pos.z -= b * sin(cam->rot.y * M_PI / 180.0f);

  00442	0f 5a f6	 cvtps2pd xmm6, xmm6
  00445	0f 28 c7	 movaps	 xmm0, xmm7
  00448	e8 00 00 00 00	 call	 sin
  0044d	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  00451	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  00455	f2 0f 5c f0	 subsd	 xmm6, xmm0
  00459	66 0f 5a c6	 cvtpd2ps xmm0, xmm6
  0045d	f3 41 0f 11 46
	08		 movss	 DWORD PTR [r14+8], xmm0
$LN21@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00463	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0046a	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0046f	85 c0		 test	 eax, eax
  00471	74 07		 je	 SHORT $LN139@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00473	8b c8		 mov	 ecx, eax
  00475	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN139@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  0047a	0f b6 1d 44 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+68
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00488	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  0048d	85 c0		 test	 eax, eax
  0048f	74 07		 je	 SHORT $LN146@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00491	8b c8		 mov	 ecx, eax
  00493	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN146@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 77   : 	if(Keyboard::getKey(68)) //D

  00498	84 db		 test	 bl, bl
  0049a	74 62		 je	 SHORT $LN20@mainLoop
  0049c	f3 41 0f 10 76
	14		 movss	 xmm6, DWORD PTR [r14+20]

; 78   : 	{
; 79   : 		cam->pos.x += b * cos(cam->rot.y * M_PI / 180.0f);

  004a2	0f 5a f6	 cvtps2pd xmm6, xmm6
  004a5	f2 41 0f 59 f3	 mulsd	 xmm6, xmm11
  004aa	f2 41 0f 5e f4	 divsd	 xmm6, xmm12
  004af	0f 28 c6	 movaps	 xmm0, xmm6
  004b2	e8 00 00 00 00	 call	 cos
  004b7	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  004bb	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  004bf	f3 41 0f 10 16	 movss	 xmm2, DWORD PTR [r14]
  004c4	0f 5a d2	 cvtps2pd xmm2, xmm2
  004c7	f2 0f 58 c2	 addsd	 xmm0, xmm2
  004cb	0f 57 c9	 xorps	 xmm1, xmm1
  004ce	f2 0f 5a c8	 cvtsd2ss xmm1, xmm0
  004d2	f3 41 0f 11 0e	 movss	 DWORD PTR [r14], xmm1

; 80   : 		cam->pos.z += b * sin(cam->rot.y * M_PI / 180.0f);

  004d7	0f 28 c6	 movaps	 xmm0, xmm6
  004da	e8 00 00 00 00	 call	 sin
  004df	41 0f 5a ca	 cvtps2pd xmm1, xmm10
  004e3	f2 0f 59 c1	 mulsd	 xmm0, xmm1
  004e7	f3 41 0f 10 56
	08		 movss	 xmm2, DWORD PTR [r14+8]
  004ed	0f 5a d2	 cvtps2pd xmm2, xmm2
  004f0	f2 0f 58 c2	 addsd	 xmm0, xmm2
  004f4	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  004f8	f3 41 0f 11 46
	08		 movss	 DWORD PTR [r14+8], xmm0
$LN20@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  004fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00505	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0050a	85 c0		 test	 eax, eax
  0050c	74 07		 je	 SHORT $LN155@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0050e	8b c8		 mov	 ecx, eax
  00510	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN155@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  00515	0f b6 1d 20 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+32
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0051c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  00523	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00528	85 c0		 test	 eax, eax
  0052a	74 07		 je	 SHORT $LN162@mainLoop

; 33   : 		_Throw_C_error(_Res);

  0052c	8b c8		 mov	 ecx, eax
  0052e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN162@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 83   : 	if(Keyboard::getKey(32)) //SPACE

  00533	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  0053a	84 db		 test	 bl, bl
  0053c	74 46		 je	 SHORT $LN19@mainLoop

; 84   : 	{ //SPACE!
; 85   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), Blocks::stone); //SPAAAAAAAAAAAAAACE!

  0053e	f3 41 0f 10 46
	08		 movss	 xmm0, DWORD PTR [r14+8]
  00544	e8 00 00 00 00	 call	 floorf
  00549	f3 0f 2c f8	 cvttss2si edi, xmm0
  0054d	f3 41 0f 10 46
	04		 movss	 xmm0, DWORD PTR [r14+4]
  00553	e8 00 00 00 00	 call	 floorf
  00558	f3 0f 2c d8	 cvttss2si ebx, xmm0
  0055c	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  00561	e8 00 00 00 00	 call	 floorf
  00566	f3 0f 2c d0	 cvttss2si edx, xmm0
  0056a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?stone@Blocks@@3PEAVBlock@@EA ; Blocks::stone
  00571	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00576	44 8b cf	 mov	 r9d, edi
  00579	44 8b c3	 mov	 r8d, ebx
  0057c	49 8b cf	 mov	 rcx, r15
  0057f	e8 00 00 00 00	 call	 ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z ; World::setBlock
$LN19@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00584	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  0058b	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00590	85 c0		 test	 eax, eax
  00592	74 07		 je	 SHORT $LN171@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00594	8b c8		 mov	 ecx, eax
  00596	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN171@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 23   : 	bool value = keys[index];

  0059b	0f b6 1d 11 00
	00 00		 movzx	 ebx, BYTE PTR ?keys@Keyboard@@0PA_NA+17
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  005a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  005a9	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  005ae	85 c0		 test	 eax, eax
  005b0	74 07		 je	 SHORT $LN178@mainLoop

; 33   : 		_Throw_C_error(_Res);

  005b2	8b c8		 mov	 ecx, eax
  005b4	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN178@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 88   : 	if(Keyboard::getKey(17)) //CTRL

  005b9	84 db		 test	 bl, bl
  005bb	74 46		 je	 SHORT $LN18@mainLoop

; 89   : 	{
; 90   : 		GlobalThread::world.setBlock(floorf(cam->pos.x), floorf(cam->pos.y), floorf(cam->pos.z), Blocks::air);

  005bd	f3 41 0f 10 46
	08		 movss	 xmm0, DWORD PTR [r14+8]
  005c3	e8 00 00 00 00	 call	 floorf
  005c8	f3 0f 2c f8	 cvttss2si edi, xmm0
  005cc	f3 41 0f 10 46
	04		 movss	 xmm0, DWORD PTR [r14+4]
  005d2	e8 00 00 00 00	 call	 floorf
  005d7	f3 0f 2c d8	 cvttss2si ebx, xmm0
  005db	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  005e0	e8 00 00 00 00	 call	 floorf
  005e5	f3 0f 2c d0	 cvttss2si edx, xmm0
  005e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?air@Blocks@@3PEAVBlockAir@@EA ; Blocks::air
  005f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f5	44 8b cf	 mov	 r9d, edi
  005f8	44 8b c3	 mov	 r8d, ebx
  005fb	49 8b cf	 mov	 rcx, r15
  005fe	e8 00 00 00 00	 call	 ?setBlock@World@@QEAAXHHHPEAVBlock@@@Z ; World::setBlock
$LN18@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 37   : 		count = 0;

  00603	89 35 40 01 00
	00		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, esi
  00609	89 35 80 00 00
	00		 mov	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128, esi
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 96   : 	camX = cam->pos.x / 16.0f;

  0060f	f3 41 0f 10 06	 movss	 xmm0, DWORD PTR [r14]
  00614	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3d800000
  0061c	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00620	f3 0f 2c d0	 cvttss2si edx, xmm0
  00624	89 15 00 00 00
	00		 mov	 DWORD PTR ?camX@@3HA, edx ; camX

; 97   : 	camY = cam->pos.y / 16.0f;

  0062a	f3 41 0f 10 46
	04		 movss	 xmm0, DWORD PTR [r14+4]
  00630	f3 0f 59 c2	 mulss	 xmm0, xmm2
  00634	f3 0f 2c c0	 cvttss2si eax, xmm0
  00638	89 05 00 00 00
	00		 mov	 DWORD PTR ?camY@@3HA, eax ; camY

; 98   : 	camZ = cam->pos.z / 16.0f;

  0063e	f3 41 0f 10 4e
	08		 movss	 xmm1, DWORD PTR [r14+8]
  00644	f3 0f 59 ca	 mulss	 xmm1, xmm2
  00648	f3 0f 2c c9	 cvttss2si ecx, xmm1
  0064c	89 0d 00 00 00
	00		 mov	 DWORD PTR ?camZ@@3HA, ecx ; camZ

; 99   : 	
; 100  : 	if(camX != prevCamX || camY != prevCamY || camZ != prevCamZ)

  00652	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?prevCamY@@3HA ; prevCamY
  00658	44 8b 35 00 00
	00 00		 mov	 r14d, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  0065f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?prevCamX@@3HA ; prevCamX
  00665	3b d3		 cmp	 edx, ebx
  00667	75 0f		 jne	 SHORT $LN564@mainLoop
  00669	3b c7		 cmp	 eax, edi
  0066b	75 09		 jne	 SHORT $LN16@mainLoop
  0066d	41 3b ce	 cmp	 ecx, r14d
  00670	0f 84 04 06 00
	00		 je	 $LN520@mainLoop
$LN16@mainLoop:

; 101  : 	{
; 102  : 		int xLimit = (camX > prevCamX ? camX : prevCamX) + renderDistance;

  00676	3b d3		 cmp	 edx, ebx
$LN564@mainLoop:
  00678	0f 4f da	 cmovg	 ebx, edx
  0067b	83 c3 08	 add	 ebx, 8
  0067e	89 5c 24 48	 mov	 DWORD PTR xLimit$1$[rsp], ebx

; 103  : 		int yLimit = (camY > prevCamY ? camY : prevCamY) + renderDistance;

  00682	3b c7		 cmp	 eax, edi
  00684	0f 4f f8	 cmovg	 edi, eax
  00687	83 c7 08	 add	 edi, 8
  0068a	89 7c 24 44	 mov	 DWORD PTR yLimit$1$[rsp], edi

; 104  : 		int zLimit = (camZ > prevCamZ ? camZ : prevCamZ) + renderDistance;

  0068e	41 3b ce	 cmp	 ecx, r14d
  00691	44 0f 4f f1	 cmovg	 r14d, ecx
  00695	41 83 c6 08	 add	 r14d, 8
  00699	44 89 75 60	 mov	 DWORD PTR zLimit$1$[rbp-256], r14d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0069d	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+24
  006a4	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  006a9	85 c0		 test	 eax, eax
  006ab	74 07		 je	 SHORT $LN189@mainLoop

; 33   : 		_Throw_C_error(_Res);

  006ad	8b c8		 mov	 ecx, eax
  006af	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN189@mainLoop:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  006b4	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  006bb	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  006c0	85 c0		 test	 eax, eax
  006c2	74 07		 je	 SHORT $LN196@mainLoop

; 33   : 		_Throw_C_error(_Res);

  006c4	8b c8		 mov	 ecx, eax
  006c6	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN196@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 107  : 		for(int i = (camX < prevCamX ? camX : prevCamX) - renderDistance; i <= xLimit; i++)

  006cb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?prevCamX@@3HA ; prevCamX
  006d1	44 8b e8	 mov	 r13d, eax
  006d4	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR ?camX@@3HA ; camX
  006db	44 3b c0	 cmp	 r8d, eax
  006de	45 0f 4c e8	 cmovl	 r13d, r8d
  006e2	41 83 ed 08	 sub	 r13d, 8
  006e6	44 3b eb	 cmp	 r13d, ebx
  006e9	0f 8f 4b 05 00
	00		 jg	 $LN559@mainLoop
  006ef	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR ?camY@@3HA ; camY
  006f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camZ@@3HA ; camZ
  006fc	44 8b 15 00 00
	00 00		 mov	 r10d, DWORD PTR ?prevCamY@@3HA ; prevCamY
  00703	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  00709	0f 1f 80 00 00
	00 00		 npad	 7
$LL15@mainLoop:

; 108  : 		{
; 109  : 			int xDist = (i - camX) * (i - camX);

  00710	45 8b dd	 mov	 r11d, r13d
  00713	45 2b d8	 sub	 r11d, r8d
  00716	45 0f af db	 imul	 r11d, r11d
  0071a	44 89 5d 78	 mov	 DWORD PTR xDist$1$[rbp-256], r11d

; 110  : 			int xPrevDist = (i - prevCamX) * (i - prevCamX);

  0071e	41 8b dd	 mov	 ebx, r13d
  00721	2b d8		 sub	 ebx, eax
  00723	0f af db	 imul	 ebx, ebx
  00726	89 5c 24 40	 mov	 DWORD PTR xPrevDist$1$[rsp], ebx

; 111  : 			for(int j = (camY < prevCamY ? camY : prevCamY) - renderDistance; j <= yLimit; j++)

  0072a	45 8b e2	 mov	 r12d, r10d
  0072d	45 3b ca	 cmp	 r9d, r10d
  00730	45 0f 4c e1	 cmovl	 r12d, r9d
  00734	41 83 ec 08	 sub	 r12d, 8
  00738	44 3b e7	 cmp	 r12d, edi
  0073b	0f 8f de 04 00
	00		 jg	 $LN14@mainLoop
$LL12@mainLoop:

; 112  : 			{
; 113  : 				int yDist = (j - camY) * (j - camY);

  00741	41 8b c4	 mov	 eax, r12d
  00744	41 2b c1	 sub	 eax, r9d
  00747	0f af c0	 imul	 eax, eax

; 114  : 				int yPrevDist = (j - prevCamY) * (j - prevCamY);

  0074a	45 8b c4	 mov	 r8d, r12d
  0074d	45 2b c2	 sub	 r8d, r10d
  00750	45 0f af c0	 imul	 r8d, r8d

; 115  : 				for(int k = (camZ < prevCamZ ? camZ : prevCamZ) - renderDistance; k <= zLimit; k++)

  00754	44 8b fa	 mov	 r15d, edx
  00757	3b ca		 cmp	 ecx, edx
  00759	44 0f 4c f9	 cmovl	 r15d, ecx
  0075d	41 83 ef 08	 sub	 r15d, 8
  00761	45 3b fe	 cmp	 r15d, r14d
  00764	0f 8f 9c 04 00
	00		 jg	 $LN11@mainLoop
  0076a	46 8d 0c 18	 lea	 r9d, DWORD PTR [rax+r11]
  0076e	44 89 4d 68	 mov	 DWORD PTR tv2230[rbp-256], r9d
  00772	44 03 c3	 add	 r8d, ebx
  00775	44 89 45 70	 mov	 DWORD PTR tv2229[rbp-256], r8d
  00779	0f 1f 80 00 00
	00 00		 npad	 7
$LL9@mainLoop:

; 116  : 				{
; 117  : 					int zDist = (k - camZ) * (k - camZ);

  00780	41 8b c7	 mov	 eax, r15d
  00783	2b c1		 sub	 eax, ecx
  00785	0f af c0	 imul	 eax, eax

; 118  : 					int zPrevDist = (k - prevCamZ) * (k - prevCamZ);

  00788	41 8b cf	 mov	 ecx, r15d
  0078b	2b ca		 sub	 ecx, edx
  0078d	0f af c9	 imul	 ecx, ecx

; 119  : 
; 120  : 					bool in1 = xDist + yDist + zDist <= renderDistance * renderDistance;

  00790	41 03 c1	 add	 eax, r9d
  00793	83 f8 40	 cmp	 eax, 64			; 00000040H
  00796	0f 9e c3	 setle	 bl

; 121  : 					bool in2 = xPrevDist + yPrevDist + zPrevDist <= renderDistance * renderDistance;

  00799	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  0079d	83 f8 40	 cmp	 eax, 64			; 00000040H
  007a0	40 0f 9e c7	 setle	 dil

; 122  : 
; 123  : 					std::shared_ptr<ChunkBase> c = GlobalThread::world.getChunk(i, j, k);

  007a4	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  007a9	45 8b cc	 mov	 r9d, r12d
  007ac	45 8b c5	 mov	 r8d, r13d
  007af	48 8d 54 24 30	 lea	 rdx, QWORD PTR c$1[rsp]
  007b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  007bb	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
  007c0	90		 npad	 1

; 124  : 
; 125  : 					if(in1 & !in2)

  007c1	40 84 ff	 test	 dil, dil
  007c4	0f 94 c1	 sete	 cl
  007c7	84 cb		 test	 cl, bl
  007c9	0f 84 ce 02 00
	00		 je	 $LN6@mainLoop

; 126  : 					{
; 127  : 						if(c->isEmpty())

  007cf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$1[rsp]
  007d4	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  007d7	ff 50 18	 call	 QWORD PTR [rax+24]
  007da	84 c0		 test	 al, al
  007dc	0f 84 bb 03 00
	00		 je	 $LN547@mainLoop

; 129  : 							c = std::shared_ptr<ChunkBase>(new Chunk(GlobalThread::world, i, j, k));

  007e2	b9 60 20 00 00	 mov	 ecx, 8288		; 00002060H
  007e7	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  007ec	48 8b d8	 mov	 rbx, rax
  007ef	48 89 45 88	 mov	 QWORD PTR $T7[rbp-256], rax
  007f3	48 85 c0	 test	 rax, rax
  007f6	0f 84 95 00 00
	00		 je	 $LN39@mainLoop
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  007fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkBase@@6B@
  00803	48 89 03	 mov	 QWORD PTR [rbx], rax
  00806	66 c7 43 08 00
	00		 mov	 WORD PTR [rbx+8], 0
  0080c	c6 43 0a 00	 mov	 BYTE PTR [rbx+10], 0
  00810	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00817	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 11   : {

  0081b	44 89 6b 18	 mov	 DWORD PTR [rbx+24], r13d
  0081f	44 89 63 1c	 mov	 DWORD PTR [rbx+28], r12d
  00823	44 89 7b 20	 mov	 DWORD PTR [rbx+32], r15d

; 54   : {

  00827	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0082b	ba 02 00 00 00	 mov	 edx, 2
  00830	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00835	85 c0		 test	 eax, eax
  00837	74 08		 je	 SHORT $LN220@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00839	8b c8		 mov	 ecx, eax
  0083b	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00840	90		 npad	 1
$LN220@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00841	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00845	ba 02 00 00 00	 mov	 edx, 2
  0084a	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0084f	85 c0		 test	 eax, eax
  00851	74 08		 je	 SHORT $LN229@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00853	8b c8		 mov	 ecx, eax
  00855	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  0085a	90		 npad	 1
$LN229@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0085b	48 8d 4b 38	 lea	 rcx, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0085f	48 89 31	 mov	 QWORD PTR [rcx], rsi
  00862	48 89 71 08	 mov	 QWORD PTR [rcx+8], rsi

; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00866	33 d2		 xor	 edx, edx
  00868	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  0086d	90		 npad	 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0086e	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00872	48 89 31	 mov	 QWORD PTR [rcx], rsi
  00875	48 89 71 08	 mov	 QWORD PTR [rcx+8], rsi

; 488  : 		}
; 489  : 
; 490  : 	template<class _Ux,
; 491  : 		class _Dx>
; 492  : 		shared_ptr(_Ux *_Px, _Dx _Dt)
; 493  : 		{	// construct with _Px, deleter
; 494  : 		_Resetp(_Px, _Dt);
; 495  : 		}
; 496  : 
; 497  : //#if _HAS_CPP0X
; 498  : 
; 499  : 	shared_ptr(nullptr_t)
; 500  : 		{	// construct with nullptr
; 501  : 		_Resetp((_Ty *)0);

  00879	33 d2		 xor	 edx, edx
  0087b	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
  00880	90		 npad	 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 145  : {

  00881	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  00888	48 89 03	 mov	 QWORD PTR [rbx], rax
  0088b	48 89 73 58	 mov	 QWORD PTR [rbx+88], rsi
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 129  : 							c = std::shared_ptr<ChunkBase>(new Chunk(GlobalThread::world, i, j, k));

  0088f	eb 03		 jmp	 SHORT $LN40@mainLoop
$LN39@mainLoop:
  00891	48 8b de	 mov	 rbx, rsi
$LN40@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00894	48 89 74 24 60	 mov	 QWORD PTR $T3[rsp], rsi
  00899	48 89 74 24 68	 mov	 QWORD PTR $T3[rsp+8], rsi

; 428  : 		}
; 429  : 
; 430  : 	void _Decwref()
; 431  : 		{	// decrement weak reference count
; 432  : 		if (_Rep != 0)
; 433  : 			_Rep->_Decwref();
; 434  : 		}
; 435  : 
; 436  : 	void _Resetw()
; 437  : 		{	// release weak reference to resource
; 438  : 		_Resetw((_Elem *)0, 0);
; 439  : 		}
; 440  : 
; 441  : 	template<class _Ty2>
; 442  : 		void _Resetw(const _Ptr_base<_Ty2>& _Other)
; 443  : 		{	// release weak reference to resource and take _Other._Ptr
; 444  : 		_Resetw(_Other._Ptr, _Other._Rep);
; 445  : 		}
; 446  : 
; 447  : 	template<class _Ty2>
; 448  : 		void _Resetw(const _Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 449  : 		{	// point to _Other_ptr through _Other_rep
; 450  : 		_Resetw(const_cast<_Ty2*>(_Other_ptr), _Other_rep);
; 451  : 		}
; 452  : 
; 453  : 	template<class _Ty2>
; 454  : 		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
; 455  : 		{	// point to _Other_ptr through _Other_rep
; 456  : 		if (_Other_rep)
; 457  : 			_Other_rep->_Incwref();
; 458  : 		if (_Rep != 0)
; 459  : 			_Rep->_Decwref();
; 460  : 		_Rep = _Other_rep;
; 461  : 		_Ptr = _Other_ptr;
; 462  : 		}
; 463  : 
; 464  : private:
; 465  : 	_Ty *_Ptr;
; 466  : 	_Ref_count_base *_Rep;
; 467  : 	template<class _Ty0>
; 468  : 		friend class _Ptr_base;
; 469  : 	};
; 470  : 
; 471  : 	// TEMPLATE CLASS shared_ptr
; 472  : template<class _Ty>
; 473  : 	class shared_ptr
; 474  : 		: public _Ptr_base<_Ty>
; 475  : 	{	// class for reference counted resource management
; 476  : public:
; 477  : 	typedef shared_ptr<_Ty> _Myt;
; 478  : 	typedef _Ptr_base<_Ty> _Mybase;
; 479  : 
; 480  : 	shared_ptr() _NOEXCEPT
; 481  : 		{	// construct empty shared_ptr object
; 482  : 		}
; 483  : 
; 484  : 	template<class _Ux>
; 485  : 		explicit shared_ptr(_Ux *_Px)
; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  0089e	48 8b d3	 mov	 rdx, rbx
  008a1	48 8d 4c 24 60	 lea	 rcx, QWORD PTR $T3[rsp]
  008a6	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  008ab	48 8b 7c 24 68	 mov	 rdi, QWORD PTR $T3[rsp+8]

; 49   : 	_Right = _Move(_Tmp);

  008b0	48 89 74 24 68	 mov	 QWORD PTR $T3[rsp+8], rsi

; 48   : 	_Left = _Move(_Right);

  008b5	48 8b 44 24 60	 mov	 rax, QWORD PTR $T3[rsp]
  008ba	48 89 44 24 70	 mov	 QWORD PTR $T4[rsp], rax

; 49   : 	_Right = _Move(_Tmp);

  008bf	48 89 74 24 60	 mov	 QWORD PTR $T3[rsp], rsi

; 48   : 	_Left = _Move(_Right);

  008c4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$1[rsp+8]
  008c9	48 89 4c 24 78	 mov	 QWORD PTR $T4[rsp+8], rcx

; 49   : 	_Right = _Move(_Tmp);

  008ce	48 89 7c 24 38	 mov	 QWORD PTR c$1[rsp+8], rdi
  008d3	48 89 44 24 30	 mov	 QWORD PTR c$1[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  008d8	48 85 c9	 test	 rcx, rcx
  008db	74 24		 je	 SHORT $LN542@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  008dd	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  008e1	75 1e		 jne	 SHORT $LN542@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  008e3	48 8b 5c 24 78	 mov	 rbx, QWORD PTR $T4[rsp+8]
  008e8	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  008eb	48 8b cb	 mov	 rcx, rbx
  008ee	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  008f0	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  008f4	75 0b		 jne	 SHORT $LN542@mainLoop

; 128  : 			_Delete_this();

  008f6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T4[rsp+8]
  008fb	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  008fe	ff 50 08	 call	 QWORD PTR [rax+8]
$LN542@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00901	48 8b 05 40 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+64
  00908	48 ff c0	 inc	 rax
  0090b	4c 8b 35 30 00
	00 00		 mov	 r14, QWORD PTR ?world@GlobalThread@@3VWorld@@A+48
  00912	4c 3b f0	 cmp	 r14, rax
  00915	77 13		 ja	 SHORT $LN322@mainLoop
  00917	48 8d 0d 20 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+32
  0091e	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
  00923	4c 8b 35 30 00
	00 00		 mov	 r14, QWORD PTR ?world@GlobalThread@@3VWorld@@A+48
$LN322@mainLoop:
  0092a	49 ff ce	 dec	 r14
  0092d	48 8b 0d 38 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+56
  00934	49 23 ce	 and	 rcx, r14
  00937	48 89 0d 38 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+56, rcx
  0093e	48 03 0d 40 00
	00 00		 add	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+64

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00945	4c 23 f1	 and	 r14, rcx

; 1487 : 		_PUSH_BACK_BEGIN;

  00948	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+40
  0094f	4a 83 3c f0 00	 cmp	 QWORD PTR [rax+r14*8], 0
  00954	75 25		 jne	 SHORT $LN321@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00956	b9 10 00 00 00	 mov	 ecx, 16
  0095b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00960	48 85 c0	 test	 rax, rax
  00963	0f 84 c5 02 00
	00		 je	 $LN528@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00969	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+40
  00970	4a 89 04 f1	 mov	 QWORD PTR [rcx+r14*8], rax
  00974	48 8b 05 28 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+40
$LN321@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  0097b	4e 8b 34 f0	 mov	 r14, QWORD PTR [rax+r14*8]
  0097f	4d 85 f6	 test	 r14, r14
  00982	74 42		 je	 SHORT $LN356@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00984	49 89 36	 mov	 QWORD PTR [r14], rsi
  00987	49 89 76 08	 mov	 QWORD PTR [r14+8], rsi

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0098b	48 85 ff	 test	 rdi, rdi
  0098e	74 04		 je	 SHORT $LN369@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00990	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]
$LN369@mainLoop:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00994	49 8b 5e 08	 mov	 rbx, QWORD PTR [r14+8]
  00998	48 85 db	 test	 rbx, rbx
  0099b	74 1d		 je	 SHORT $LN543@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0099d	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  009a1	75 17		 jne	 SHORT $LN543@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  009a3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  009a6	48 8b cb	 mov	 rcx, rbx
  009a9	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  009ab	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  009af	75 09		 jne	 SHORT $LN543@mainLoop

; 128  : 			_Delete_this();

  009b1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  009b4	48 8b cb	 mov	 rcx, rbx
  009b7	ff 50 08	 call	 QWORD PTR [rax+8]
$LN543@mainLoop:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  009ba	49 89 7e 08	 mov	 QWORD PTR [r14+8], rdi

; 427  : 		_Ptr = _Other_ptr;

  009be	48 8b 44 24 70	 mov	 rax, QWORD PTR $T4[rsp]
  009c3	49 89 06	 mov	 QWORD PTR [r14], rax
$LN356@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  009c6	48 ff 05 40 00
	00 00		 inc	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+64
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  009cd	48 89 74 24 50	 mov	 QWORD PTR $T2[rsp], rsi
  009d2	48 89 74 24 58	 mov	 QWORD PTR $T2[rsp+8], rsi

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  009d7	48 85 ff	 test	 rdi, rdi
  009da	74 2b		 je	 SHORT $LN544@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  009dc	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  009e0	48 8b 5c 24 58	 mov	 rbx, QWORD PTR $T2[rsp+8]
  009e5	48 85 db	 test	 rbx, rbx
  009e8	74 1d		 je	 SHORT $LN544@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  009ea	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  009ee	75 17		 jne	 SHORT $LN544@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  009f0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  009f3	48 8b cb	 mov	 rcx, rbx
  009f6	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  009f8	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  009fc	75 09		 jne	 SHORT $LN544@mainLoop

; 128  : 			_Delete_this();

  009fe	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a01	48 8b cb	 mov	 rcx, rbx
  00a04	ff 50 08	 call	 QWORD PTR [rax+8]
$LN544@mainLoop:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00a07	48 89 7c 24 58	 mov	 QWORD PTR $T2[rsp+8], rdi

; 427  : 		_Ptr = _Other_ptr;

  00a0c	48 8b 44 24 70	 mov	 rax, QWORD PTR $T4[rsp]
  00a11	48 89 44 24 50	 mov	 QWORD PTR $T2[rsp], rax
  00a16	48 8d 44 24 50	 lea	 rax, QWORD PTR $T2[rsp]
  00a1b	48 89 45 88	 mov	 QWORD PTR $T6[rbp-256], rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 118  : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  00a1f	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00a25	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2184
  00a2c	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00a31	85 c0		 test	 eax, eax
  00a33	74 07		 je	 SHORT $LN409@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00a35	8b c8		 mov	 ecx, eax
  00a37	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN409@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  00a3c	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T2[rsp]
  00a41	48 8d 0d 60 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2144
  00a48	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00a4d	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2184
  00a54	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00a59	85 c0		 test	 eax, eax
  00a5b	74 08		 je	 SHORT $LN418@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00a5d	8b c8		 mov	 ecx, eax
  00a5f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00a64	90		 npad	 1
$LN418@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00a65	48 8b 5c 24 58	 mov	 rbx, QWORD PTR $T2[rsp+8]
  00a6a	48 85 db	 test	 rbx, rbx
  00a6d	0f 84 26 01 00
	00		 je	 $LN562@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00a73	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00a77	0f 85 1c 01 00
	00		 jne	 $LN562@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00a7d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a80	48 8b cb	 mov	 rcx, rbx
  00a83	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00a85	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00a89	0f 85 0a 01 00
	00		 jne	 $LN562@mainLoop

; 128  : 			_Delete_this();

  00a8f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00a92	48 8b cb	 mov	 rcx, rbx
  00a95	ff 50 08	 call	 QWORD PTR [rax+8]
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 133  : 					}

  00a98	e9 fc 00 00 00	 jmp	 $LN562@mainLoop
$LN6@mainLoop:

; 134  : 					else if(!in1 & in2)

  00a9d	84 db		 test	 bl, bl
  00a9f	0f 94 c1	 sete	 cl
  00aa2	40 84 cf	 test	 cl, dil
  00aa5	0f 84 f2 00 00
	00		 je	 $LN547@mainLoop

; 135  : 					{
; 136  : 						if(!c->isEmpty())

  00aab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR c$1[rsp]
  00ab0	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00ab3	ff 50 18	 call	 QWORD PTR [rax+24]
  00ab6	84 c0		 test	 al, al
  00ab8	0f 85 df 00 00
	00		 jne	 $LN547@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00abe	48 8b 05 70 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+112
  00ac5	48 ff c0	 inc	 rax
  00ac8	48 8b 15 60 00
	00 00		 mov	 rdx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+96
  00acf	48 3b d0	 cmp	 rdx, rax
  00ad2	77 13		 ja	 SHORT $LN439@mainLoop
  00ad4	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+80
  00adb	e8 00 00 00 00	 call	 ?_Growmap@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Growmap
  00ae0	48 8b 15 60 00
	00 00		 mov	 rdx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+96
$LN439@mainLoop:
  00ae7	48 ff ca	 dec	 rdx
  00aea	48 8b 0d 68 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+104
  00af1	48 23 ca	 and	 rcx, rdx
  00af4	48 89 0d 68 00
	00 00		 mov	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+104, rcx
  00afb	48 8b 3d 70 00
	00 00		 mov	 rdi, QWORD PTR ?world@GlobalThread@@3VWorld@@A+112
  00b02	48 03 f9	 add	 rdi, rcx

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00b05	48 23 fa	 and	 rdi, rdx

; 1487 : 		_PUSH_BACK_BEGIN;

  00b08	48 8b 05 58 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+88
  00b0f	48 83 3c f8 00	 cmp	 QWORD PTR [rax+rdi*8], 0
  00b14	75 25		 jne	 SHORT $LN438@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00b16	b9 10 00 00 00	 mov	 ecx, 16
  00b1b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00b20	48 85 c0	 test	 rax, rax
  00b23	0f 84 0b 01 00
	00		 je	 $LN529@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1487 : 		_PUSH_BACK_BEGIN;

  00b29	48 8b 0d 58 00
	00 00		 mov	 rcx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+88
  00b30	48 89 04 f9	 mov	 QWORD PTR [rcx+rdi*8], rax
  00b34	48 8b 05 58 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+88
$LN438@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00b3b	48 8b 3c f8	 mov	 rdi, QWORD PTR [rax+rdi*8]
  00b3f	48 85 ff	 test	 rdi, rdi
  00b42	74 4c		 je	 SHORT $LN546@mainLoop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00b44	48 89 37	 mov	 QWORD PTR [rdi], rsi
  00b47	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);
; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00b4b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$1[rsp+8]
  00b50	48 85 c9	 test	 rcx, rcx
  00b53	74 04		 je	 SHORT $LN486@mainLoop

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00b55	f0 ff 41 08	 lock inc DWORD PTR [rcx+8]
$LN486@mainLoop:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);
; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)

  00b59	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00b5d	48 85 db	 test	 rbx, rbx
  00b60	74 1d		 je	 SHORT $LN545@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00b62	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00b66	75 17		 jne	 SHORT $LN545@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00b68	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00b6b	48 8b cb	 mov	 rcx, rbx
  00b6e	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00b70	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00b74	75 09		 jne	 SHORT $LN545@mainLoop

; 128  : 			_Delete_this();

  00b76	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00b79	48 8b cb	 mov	 rcx, rbx
  00b7c	ff 50 08	 call	 QWORD PTR [rax+8]
$LN545@mainLoop:

; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00b7f	48 8b 44 24 38	 mov	 rax, QWORD PTR c$1[rsp+8]
  00b84	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax

; 427  : 		_Ptr = _Other_ptr;

  00b88	48 8b 44 24 30	 mov	 rax, QWORD PTR c$1[rsp]
  00b8d	48 89 07	 mov	 QWORD PTR [rdi], rax
$LN546@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1490 : 		_PUSH_BACK_END;

  00b90	48 ff 05 70 00
	00 00		 inc	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+112
  00b97	eb 04		 jmp	 SHORT $LN547@mainLoop
$LN562@mainLoop:
  00b99	44 8b 75 60	 mov	 r14d, DWORD PTR zLimit$1$[rbp-256]
$LN547@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00b9d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$1[rsp+8]
  00ba2	48 85 c9	 test	 rcx, rcx
  00ba5	74 24		 je	 SHORT $LN8@mainLoop

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00ba7	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  00bab	75 1e		 jne	 SHORT $LN8@mainLoop

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00bad	48 8b 5c 24 38	 mov	 rbx, QWORD PTR c$1[rsp+8]
  00bb2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00bb5	48 8b cb	 mov	 rcx, rbx
  00bb8	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00bba	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00bbe	75 0b		 jne	 SHORT $LN8@mainLoop

; 128  : 			_Delete_this();

  00bc0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR c$1[rsp+8]
  00bc5	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00bc8	ff 50 08	 call	 QWORD PTR [rax+8]
$LN8@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 115  : 				for(int k = (camZ < prevCamZ ? camZ : prevCamZ) - renderDistance; k <= zLimit; k++)

  00bcb	41 ff c7	 inc	 r15d
  00bce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camZ@@3HA ; camZ
  00bd4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?prevCamZ@@3HA ; prevCamZ
  00bda	45 3b fe	 cmp	 r15d, r14d
  00bdd	7f 0d		 jg	 SHORT $LN557@mainLoop
  00bdf	44 8b 4d 68	 mov	 r9d, DWORD PTR tv2230[rbp-256]
  00be3	44 8b 45 70	 mov	 r8d, DWORD PTR tv2229[rbp-256]
  00be7	e9 94 fb ff ff	 jmp	 $LL9@mainLoop
$LN557@mainLoop:
  00bec	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR ?camY@@3HA ; camY
  00bf3	44 8b 15 00 00
	00 00		 mov	 r10d, DWORD PTR ?prevCamY@@3HA ; prevCamY
  00bfa	44 8b 5d 78	 mov	 r11d, DWORD PTR xDist$1$[rbp-256]
  00bfe	8b 5c 24 40	 mov	 ebx, DWORD PTR xPrevDist$1$[rsp]
  00c02	8b 7c 24 44	 mov	 edi, DWORD PTR yLimit$1$[rsp]
$LN11@mainLoop:

; 111  : 			for(int j = (camY < prevCamY ? camY : prevCamY) - renderDistance; j <= yLimit; j++)

  00c06	41 ff c4	 inc	 r12d
  00c09	44 3b e7	 cmp	 r12d, edi
  00c0c	0f 8e 2f fb ff
	ff		 jle	 $LL12@mainLoop
  00c12	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR ?camX@@3HA ; camX
  00c19	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?prevCamX@@3HA ; prevCamX
$LN14@mainLoop:

; 107  : 		for(int i = (camX < prevCamX ? camX : prevCamX) - renderDistance; i <= xLimit; i++)

  00c1f	41 ff c5	 inc	 r13d
  00c22	44 3b 6c 24 48	 cmp	 r13d, DWORD PTR xLimit$1$[rsp]
  00c27	7f 11		 jg	 SHORT $LN559@mainLoop
  00c29	e9 e2 fa ff ff	 jmp	 $LL15@mainLoop
$LN528@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  00c2e	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00c33	cc		 int	 3
$LN529@mainLoop:
  00c34	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00c39	90		 npad	 1
$LN559@mainLoop:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00c3a	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+24
  00c41	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00c46	85 c0		 test	 eax, eax
  00c48	74 07		 je	 SHORT $LN513@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00c4a	8b c8		 mov	 ecx, eax
  00c4c	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN513@mainLoop:

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00c51	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  00c58	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00c5d	85 c0		 test	 eax, eax
  00c5f	74 07		 je	 SHORT $LN548@mainLoop

; 33   : 		_Throw_C_error(_Res);

  00c61	8b c8		 mov	 ecx, eax
  00c63	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN548@mainLoop:
  00c68	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?camZ@@3HA ; camZ
  00c6e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?camY@@3HA ; camY
  00c74	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?camX@@3HA ; camX
$LN520@mainLoop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 152  : 	prevCamX = camX;

  00c7a	89 15 00 00 00
	00		 mov	 DWORD PTR ?prevCamX@@3HA, edx ; prevCamX

; 153  : 	prevCamY = camY;

  00c80	89 05 00 00 00
	00		 mov	 DWORD PTR ?prevCamY@@3HA, eax ; prevCamY

; 154  : 	prevCamZ = camZ;

  00c86	89 0d 00 00 00
	00		 mov	 DWORD PTR ?prevCamZ@@3HA, ecx ; prevCamZ

; 155  : 
; 156  : 	GameStates::swapProcessedPending();

  00c8c	e8 00 00 00 00	 call	 ?swapProcessedPending@GameStates@@YAXXZ ; GameStates::swapProcessedPending

; 157  : 
; 158  : 	if((GameStates::processedState == GameStates::pendingState) | (GameStates::pendingState == GameStates::renderingState) | (GameStates::processedState == GameStates::renderingState))

  00c91	44 8b ce	 mov	 r9d, esi
  00c94	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR ?pendingState@GameStates@@3PEAVGameState@1@EA ; GameStates::pendingState
  00c9b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?renderingState@GameStates@@3PEAVGameState@1@EA ; GameStates::renderingState
  00ca2	4c 3b c0	 cmp	 r8, rax
  00ca5	41 0f 94 c1	 sete	 r9b
  00ca9	8b ce		 mov	 ecx, esi
  00cab	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA, rax ; GameStates::processedState
  00cb2	0f 94 c1	 sete	 cl
  00cb5	44 0b c9	 or	 r9d, ecx
  00cb8	4c 39 05 00 00
	00 00		 cmp	 QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA, r8 ; GameStates::processedState
  00cbf	40 0f 94 c6	 sete	 sil
  00cc3	44 0b ce	 or	 r9d, esi
  00cc6	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00ccd	b9 01 00 00 00	 mov	 ecx, 1
  00cd2	0f 45 c1	 cmovne	 eax, ecx
  00cd5	88 05 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, al ; GlobalThread::stop

; 159  : 	{
; 160  : 		GlobalThread::stop = true;
; 161  : 	}
; 162  : 
; 163  : 	ticks++;

  00cdb	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ticks@@3HA	; ticks

; 164  : 	return true;

  00ce1	0f b6 c1	 movzx	 eax, cl

; 165  : }

  00ce4	4c 8d 9c 24 18
	01 00 00	 lea	 r11, QWORD PTR [rsp+280]
  00cec	41 0f 28 73 e8	 movaps	 xmm6, XMMWORD PTR [r11-24]
  00cf1	41 0f 28 7b d8	 movaps	 xmm7, XMMWORD PTR [r11-40]
  00cf6	45 0f 28 43 c8	 movaps	 xmm8, XMMWORD PTR [r11-56]
  00cfb	45 0f 28 4b b8	 movaps	 xmm9, XMMWORD PTR [r11-72]
  00d00	45 0f 28 53 a8	 movaps	 xmm10, XMMWORD PTR [r11-88]
  00d05	45 0f 28 5b 98	 movaps	 xmm11, XMMWORD PTR [r11-104]
  00d0a	45 0f 28 63 88	 movaps	 xmm12, XMMWORD PTR [r11-120]
  00d0f	49 8b e3	 mov	 rsp, r11
  00d12	41 5f		 pop	 r15
  00d14	41 5e		 pop	 r14
  00d16	41 5d		 pop	 r13
  00d18	41 5c		 pop	 r12
  00d1a	5f		 pop	 rdi
  00d1b	5e		 pop	 rsi
  00d1c	5b		 pop	 rbx
  00d1d	5d		 pop	 rbp
  00d1e	c3		 ret	 0
$LN563@mainLoop:
?mainLoop@@YA_NXZ ENDP					; mainLoop
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2230 = 360
tv2229 = 368
xDist$1$ = 376
?dtor$0@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$0
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR c$1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$0@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2230 = 360
tv2229 = 368
xDist$1$ = 376
?dtor$1@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$1
  0000c	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  00013	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$1@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2230 = 360
tv2229 = 368
xDist$1$ = 376
?dtor$5@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$5
  00018	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  0001f	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00023	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$5@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2230 = 360
tv2229 = 368
xDist$1$ = 376
?dtor$6@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$6
  00028	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  0002f	48 83 c1 30	 add	 rcx, 48			; 00000030H
  00033	e9 00 00 00 00	 jmp	 ??1mutex@std@@QEAA@XZ
?dtor$6@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2230 = 360
tv2229 = 368
xDist$1$ = 376
?dtor$7@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$7
  00038	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  0003f	48 83 c1 38	 add	 rcx, 56			; 00000038H
  00043	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VVertexStream@gfxu@@@std@@QEAA@XZ ; std::shared_ptr<gfxu::VertexStream>::~shared_ptr<gfxu::VertexStream>
?dtor$7@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
c$1 = 48
xPrevDist$1$ = 64
yLimit$1$ = 68
xLimit$1$ = 72
$T2 = 80
$T3 = 96
$T4 = 112
ma$5 = 112
$T6 = 136
$T7 = 136
$T8 = 144
zLimit$1$ = 352
tv2230 = 360
tv2229 = 368
xDist$1$ = 376
?dtor$9@?0??mainLoop@@YA_NXZ@4HA PROC			; `mainLoop'::`1'::dtor$9
  00048	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR $T6[rdx]
  0004f	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$9@?0??mainLoop@@YA_NXZ@4HA ENDP			; `mainLoop'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\users\glenn\documents\github\wind\project\wind\wind\gamestates.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp
;	COMDAT WinMain
_TEXT	SEGMENT
c$1 = 64
r2$1$ = 80
tv3163 = 84
error$2 = 88
r1$1$ = 92
xDist$1$ = 96
error$3 = 100
lastTick$1$ = 104
theThread$4 = 112
$T5 = 120
$T6 = 136
theThread$7 = 152
theThread$8 = 160
$T9 = 168
$T10 = 184
$T11 = 200
$T12 = 216
$T13 = 256
$T14 = 272
$T15 = 288
_Launcher$16 = 304
$T17 = 352
$T18 = 368
$T19 = 384
$T20 = 400
$T21 = 416
$T22 = 432
_Launcher$23 = 448
$T24 = 496
_Launcher$25 = 512
msg$ = 560
$T26 = 608
$T27 = 624
$T28 = 640
$T29 = 656
_hInstance$ = 736
hPrevInstance$ = 744
lpCmdLine$ = 752
_nCmdShow$ = 760
WinMain	PROC						; COMDAT

; 168  : {

$LN999:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	55		 push	 rbp
  00015	41 54		 push	 r12
  00017	41 55		 push	 r13
  00019	41 56		 push	 r14
  0001b	41 57		 push	 r15
  0001d	48 8d ac 24 50
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-432]
  00025	48 81 ec b0 02
	00 00		 sub	 rsp, 688		; 000002b0H

; 169  : 	long long tickTime = 20000000;
; 170  : 	long long lastTick = 0;

  0002c	45 33 ff	 xor	 r15d, r15d

; 171  : 
; 172  : 	for(int r = 0; r <= renderDistance; r++)

  0002f	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00036	49 83 ce ff	 or	 r14, -1
  0003a	4c 89 7c 24 68	 mov	 QWORD PTR lastTick$1$[rsp], r15
  0003f	90		 npad	 1
$LL37@WinMain:

; 173  : 	{
; 174  : 		int r1 = r * r;

  00040	41 8b c7	 mov	 eax, r15d
  00043	41 0f af c7	 imul	 eax, r15d
  00047	89 44 24 5c	 mov	 DWORD PTR r1$1$[rsp], eax

; 175  : 		int r2 = r == 0 ? -1 : (r - 1) * (r - 1);

  0004b	45 85 ff	 test	 r15d, r15d
  0004e	75 07		 jne	 SHORT $LN40@WinMain
  00050	44 89 74 24 50	 mov	 DWORD PTR r2$1$[rsp], r14d
  00055	eb 0b		 jmp	 SHORT $LN41@WinMain
$LN40@WinMain:
  00057	41 8d 47 ff	 lea	 eax, DWORD PTR [r15-1]
  0005b	0f af c0	 imul	 eax, eax
  0005e	89 44 24 50	 mov	 DWORD PTR r2$1$[rsp], eax
$LN41@WinMain:

; 176  : 		for(int i = -r; i <= r; i++)

  00062	41 8b cf	 mov	 ecx, r15d
  00065	f7 d9		 neg	 ecx
  00067	89 4c 24 54	 mov	 DWORD PTR tv3163[rsp], ecx
  0006b	44 8b e9	 mov	 r13d, ecx
  0006e	41 3b cf	 cmp	 ecx, r15d
  00071	0f 8f c4 02 00
	00		 jg	 $LN36@WinMain
  00077	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL34@WinMain:

; 177  : 		{
; 178  : 			int xDist = i * i;

  00080	41 8b c5	 mov	 eax, r13d

; 179  : 			for(int j = -r; j <= r; j++)

  00083	44 8b f1	 mov	 r14d, ecx
  00086	41 0f af c5	 imul	 eax, r13d
  0008a	89 44 24 60	 mov	 DWORD PTR xDist$1$[rsp], eax
  0008e	41 3b cf	 cmp	 ecx, r15d
  00091	0f 8f 94 02 00
	00		 jg	 $LN33@WinMain
  00097	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL31@WinMain:

; 180  : 			{
; 181  : 				int yDist = xDist + j * j;

  000a0	45 8b e6	 mov	 r12d, r14d

; 182  : 				for(int k = -r; k <= r; k++)

  000a3	8b f1		 mov	 esi, ecx
  000a5	45 0f af e6	 imul	 r12d, r14d
  000a9	44 03 e0	 add	 r12d, eax
  000ac	41 3b cf	 cmp	 ecx, r15d
  000af	0f 8f 6a 02 00
	00		 jg	 $LN30@WinMain
  000b5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL28@WinMain:

; 183  : 				{
; 184  : 					int zDist = yDist + k * k;

  000c0	8b fe		 mov	 edi, esi

; 185  : 					bool b = GlobalThread::world.getChunk(i, j, k)->isEmpty();

  000c2	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR $T21[rbp-256]
  000c9	45 8b ce	 mov	 r9d, r14d
  000cc	45 8b c5	 mov	 r8d, r13d
  000cf	49 8b ca	 mov	 rcx, r10
  000d2	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  000d6	0f af fe	 imul	 edi, esi
  000d9	41 03 fc	 add	 edi, r12d
  000dc	e8 00 00 00 00	 call	 ?getChunk@World@@QEAA?AV?$shared_ptr@VChunkBase@@@std@@HHH@Z ; World::getChunk
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 335  : 		return (_Ptr);

  000e1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 185  : 					bool b = GlobalThread::world.getChunk(i, j, k)->isEmpty();

  000e4	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  000e7	ff 50 18	 call	 QWORD PTR [rax+24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  000ea	48 8b 9d a8 00
	00 00		 mov	 rbx, QWORD PTR $T21[rbp-248]
  000f1	48 85 db	 test	 rbx, rbx
  000f4	74 1d		 je	 SHORT $LN60@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  000f6	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  000fa	75 17		 jne	 SHORT $LN60@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  000fc	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000ff	48 8b cb	 mov	 rcx, rbx
  00102	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00104	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00108	75 09		 jne	 SHORT $LN60@WinMain

; 128  : 			_Delete_this();

  0010a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0010d	48 8b cb	 mov	 rcx, rbx
  00110	ff 50 08	 call	 QWORD PTR [rax+8]
$LN60@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 192  : 					if((zDist <= r1) && (zDist > r2))

  00113	3b 7c 24 5c	 cmp	 edi, DWORD PTR r1$1$[rsp]
  00117	0f 8f e1 01 00
	00		 jg	 $LN27@WinMain
  0011d	3b 7c 24 50	 cmp	 edi, DWORD PTR r2$1$[rsp]
  00121	0f 8e d7 01 00
	00		 jle	 $LN27@WinMain

; 194  : 						std::shared_ptr<ChunkBase> c(new Chunk(GlobalThread::world, i, j, k));

  00127	b9 60 20 00 00	 mov	 ecx, 8288		; 00002060H
  0012c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00131	48 8b d8	 mov	 rbx, rax
  00134	48 85 c0	 test	 rax, rax
  00137	0f 84 92 00 00
	00		 je	 $LN42@WinMain
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0013d	66 c7 43 08 00
	00		 mov	 WORD PTR [rbx+8], 0
  00143	c6 43 0a 00	 mov	 BYTE PTR [rbx+10], 0
  00147	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7ChunkBase@@6B@
  0014e	48 89 03	 mov	 QWORD PTR [rbx], rax
  00151	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 28   : 		_Mtx_initX(&_Mtx, _Flags | _Mtx_try);

  00158	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  0015c	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00160	ba 02 00 00 00	 mov	 edx, 2
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 11   : {

  00165	44 89 6b 18	 mov	 DWORD PTR [rbx+24], r13d
  00169	44 89 73 1c	 mov	 DWORD PTR [rbx+28], r14d
  0016d	89 73 20	 mov	 DWORD PTR [rbx+32], esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00170	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00175	85 c0		 test	 eax, eax
  00177	74 07		 je	 SHORT $LN75@WinMain

; 33   : 		_Throw_C_error(_Res);

  00179	8b c8		 mov	 ecx, eax
  0017b	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN75@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\mutex

; 28   : 		_Mtx_initX(&_Mtx, _Flags | _Mtx_try);

  00180	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00184	ba 02 00 00 00	 mov	 edx, 2
  00189	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0018e	85 c0		 test	 eax, eax
  00190	74 07		 je	 SHORT $LN84@WinMain

; 33   : 		_Throw_C_error(_Res);

  00192	8b c8		 mov	 ecx, eax
  00194	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN84@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  00199	48 8d 4b 38	 lea	 rcx, QWORD PTR [rbx+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0019d	33 ff		 xor	 edi, edi

; 501  : 		_Resetp((_Ty *)0);

  0019f	33 d2		 xor	 edx, edx

; 282  : 		{	// construct

  001a1	48 89 39	 mov	 QWORD PTR [rcx], rdi
  001a4	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 501  : 		_Resetp((_Ty *)0);

  001a8	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 54   : {

  001ad	48 8d 4b 48	 lea	 rcx, QWORD PTR [rbx+72]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 501  : 		_Resetp((_Ty *)0);

  001b1	33 d2		 xor	 edx, edx

; 282  : 		{	// construct

  001b3	48 89 39	 mov	 QWORD PTR [rcx], rdi
  001b6	48 89 79 08	 mov	 QWORD PTR [rcx+8], rdi

; 501  : 		_Resetp((_Ty *)0);

  001ba	e8 00 00 00 00	 call	 ??$_Resetp@VVertexStream@gfxu@@@?$shared_ptr@VVertexStream@gfxu@@@std@@AEAAXPEAVVertexStream@gfxu@@@Z ; std::shared_ptr<gfxu::VertexStream>::_Resetp<gfxu::VertexStream>
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 145  : {

  001bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  001c6	48 89 7b 58	 mov	 QWORD PTR [rbx+88], rdi
  001ca	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 194  : 						std::shared_ptr<ChunkBase> c(new Chunk(GlobalThread::world, i, j, k));

  001cd	eb 04		 jmp	 SHORT $LN43@WinMain
$LN42@WinMain:
  001cf	33 ff		 xor	 edi, edi
  001d1	8b df		 mov	 ebx, edi
$LN43@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 487  : 		_Resetp(_Px);

  001d3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR c$1[rsp]
  001d8	48 8b d3	 mov	 rdx, rbx

; 282  : 		{	// construct

  001db	48 89 7c 24 40	 mov	 QWORD PTR c$1[rsp], rdi
  001e0	48 89 7c 24 48	 mov	 QWORD PTR c$1[rsp+8], rdi

; 487  : 		_Resetp(_Px);

  001e5	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 195  : 						GlobalThread::world.chunkMap[c->pos] = c;

  001ea	48 8b 54 24 40	 mov	 rdx, QWORD PTR c$1[rsp]
  001ef	48 8d 0d 08 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+8
  001f6	48 83 c2 18	 add	 rdx, 24
  001fa	e8 00 00 00 00	 call	 ??A?$map@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@U?$less@VChunkPosition@@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@AEBVChunkPosition@@@Z ; std::map<ChunkPosition,std::shared_ptr<ChunkBase>,std::less<ChunkPosition>,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::operator[]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 407  : 		if (_Other_rep)

  001ff	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp+8]
  00204	48 85 ff	 test	 rdi, rdi
  00207	74 09		 je	 SHORT $LN122@WinMain

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00209	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]
  0020d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp+8]
$LN122@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00212	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]

; 49   : 	_Right = _Move(_Tmp);

  00216	48 8b 4c 24 40	 mov	 rcx, QWORD PTR c$1[rsp]
  0021b	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
  0021f	48 89 55 c0	 mov	 QWORD PTR $T10[rbp-248], rdx
  00223	48 89 08	 mov	 QWORD PTR [rax], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00226	48 85 d2	 test	 rdx, rdx
  00229	74 27		 je	 SHORT $LN153@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  0022b	f0 ff 4a 08	 lock dec DWORD PTR [rdx+8]
  0022f	75 1c		 jne	 SHORT $LN995@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00231	48 8b 5d c0	 mov	 rbx, QWORD PTR $T10[rbp-248]
  00235	48 8b cb	 mov	 rcx, rbx
  00238	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0023b	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  0023d	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00241	75 0a		 jne	 SHORT $LN995@WinMain

; 128  : 			_Delete_this();

  00243	48 8b 4d c0	 mov	 rcx, QWORD PTR $T10[rbp-248]
  00247	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0024a	ff 50 08	 call	 QWORD PTR [rax+8]
$LN995@WinMain:
  0024d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp+8]
$LN153@WinMain:

; 407  : 		if (_Other_rep)

  00252	48 85 ff	 test	 rdi, rdi
  00255	74 09		 je	 SHORT $LN165@WinMain

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00257	f0 ff 47 08	 lock inc DWORD PTR [rdi+8]
  0025b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR c$1[rsp+8]
$LN165@WinMain:

; 427  : 		_Ptr = _Other_ptr;

  00260	48 8b 44 24 40	 mov	 rax, QWORD PTR c$1[rsp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\chunkloadthread.cpp

; 118  : 	ChunkLoadThread* thread = &chunkLoadThreads[(loaderThread++) % LOAD_THREAD_AMOUNT];

  00265	ff 05 00 00 00
	00		 inc	 DWORD PTR ?loaderThread@@3HA ; loaderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0026b	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2184
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 427  : 		_Ptr = _Other_ptr;

  00272	48 89 45 c8	 mov	 QWORD PTR $T11[rbp-256], rax
  00276	48 89 7d d0	 mov	 QWORD PTR $T11[rbp-248], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0027a	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0027f	85 c0		 test	 eax, eax
  00281	74 07		 je	 SHORT $LN182@WinMain

; 33   : 		_Throw_C_error(_Res);

  00283	8b c8		 mov	 ecx, eax
  00285	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN182@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 155  : 		c.push_back(_Val);

  0028a	48 8d 55 c8	 lea	 rdx, QWORD PTR $T11[rbp-256]
  0028e	48 8d 0d 60 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2144
  00295	e8 00 00 00 00	 call	 ?push_back@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0029a	48 8d 0d 88 08
	00 00		 lea	 rcx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2184
  002a1	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  002a6	85 c0		 test	 eax, eax
  002a8	74 07		 je	 SHORT $LN191@WinMain

; 33   : 		_Throw_C_error(_Res);

  002aa	8b c8		 mov	 ecx, eax
  002ac	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN191@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  002b1	48 85 ff	 test	 rdi, rdi
  002b4	74 48		 je	 SHORT $LN27@WinMain

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002b6	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  002ba	75 1e		 jne	 SHORT $LN202@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002bc	48 8b 5c 24 48	 mov	 rbx, QWORD PTR c$1[rsp+8]
  002c1	48 8b cb	 mov	 rcx, rbx
  002c4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002c7	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  002c9	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  002cd	75 0b		 jne	 SHORT $LN202@WinMain

; 128  : 			_Delete_this();

  002cf	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$1[rsp+8]
  002d4	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002d7	ff 50 08	 call	 QWORD PTR [rax+8]
$LN202@WinMain:

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  002da	f0 ff 4f 08	 lock dec DWORD PTR [rdi+8]
  002de	75 1e		 jne	 SHORT $LN27@WinMain

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  002e0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR c$1[rsp+8]
  002e5	48 8b cb	 mov	 rcx, rbx
  002e8	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002eb	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  002ed	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  002f1	75 0b		 jne	 SHORT $LN27@WinMain

; 128  : 			_Delete_this();

  002f3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR c$1[rsp+8]
  002f8	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  002fb	ff 50 08	 call	 QWORD PTR [rax+8]
$LN27@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 182  : 				for(int k = -r; k <= r; k++)

  002fe	ff c6		 inc	 esi
  00300	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00307	41 3b f7	 cmp	 esi, r15d
  0030a	0f 8e b0 fd ff
	ff		 jle	 $LL28@WinMain
  00310	8b 44 24 60	 mov	 eax, DWORD PTR xDist$1$[rsp]
  00314	8b 4c 24 54	 mov	 ecx, DWORD PTR tv3163[rsp]
  00318	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
$LN30@WinMain:

; 179  : 			for(int j = -r; j <= r; j++)

  0031f	41 ff c6	 inc	 r14d
  00322	45 3b f7	 cmp	 r14d, r15d
  00325	0f 8e 75 fd ff
	ff		 jle	 $LL31@WinMain
$LN33@WinMain:

; 176  : 		for(int i = -r; i <= r; i++)

  0032b	41 ff c5	 inc	 r13d
  0032e	45 3b ef	 cmp	 r13d, r15d
  00331	0f 8e 49 fd ff
	ff		 jle	 $LL34@WinMain
  00337	49 83 ce ff	 or	 r14, -1
$LN36@WinMain:

; 171  : 
; 172  : 	for(int r = 0; r <= renderDistance; r++)

  0033b	41 ff c7	 inc	 r15d
  0033e	41 83 ff 08	 cmp	 r15d, 8
  00342	0f 8e f8 fc ff
	ff		 jle	 $LL37@WinMain

; 196  : 						requestChunkLoad(c);
; 197  : 					}
; 198  : 				}
; 199  : 			}
; 200  : 		}
; 201  : 	}
; 202  : 
; 203  : 	IOUtil::init();

  00348	e8 00 00 00 00	 call	 ?init@IOUtil@@YAXXZ	; IOUtil::init

; 204  : 	cl::load();

  0034d	e8 00 00 00 00	 call	 ?load@cl@@YA_NXZ	; cl::load

; 205  : 	Blocks::initialize();

  00352	e8 00 00 00 00	 call	 ?initialize@Blocks@@YAXXZ ; Blocks::initialize

; 207  : 	GLWindow::instance = new GLWindow(L"Wind", 600, 600, _hInstance, 3, 4);

  00357	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0035c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00361	45 33 ff	 xor	 r15d, r15d
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 207  : 	GLWindow::instance = new GLWindow(L"Wind", 600, 600, _hInstance, 3, 4);

  00364	48 8b d8	 mov	 rbx, rax
  00367	48 85 c0	 test	 rax, rax
  0036a	74 3f		 je	 SHORT $LN44@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0036c	45 8d 47 04	 lea	 r8d, QWORD PTR [r15+4]
  00370	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294915918
  00377	48 8d 4d d8	 lea	 rcx, QWORD PTR $T12[rbp-256]

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0037b	48 c7 45 f0 07
	00 00 00	 mov	 QWORD PTR $T12[rbp-232], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00383	4c 89 7d e8	 mov	 QWORD PTR $T12[rbp-240], r15
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00387	66 44 89 7d d8	 mov	 WORD PTR $T12[rbp-256], r15w
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0038c	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 207  : 	GLWindow::instance = new GLWindow(L"Wind", 600, 600, _hInstance, 3, 4);

  00391	48 8b 85 e0 01
	00 00		 mov	 rax, QWORD PTR _hInstance$[rbp-256]
  00398	48 8d 55 d8	 lea	 rdx, QWORD PTR $T12[rbp-256]
  0039c	48 8b cb	 mov	 rcx, rbx
  0039f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a4	e8 00 00 00 00	 call	 ??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z ; GLWindow::GLWindow
  003a9	eb 03		 jmp	 SHORT $LN45@WinMain
$LN44@WinMain:
  003ab	49 8b c7	 mov	 rax, r15
$LN45@WinMain:
  003ae	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?instance@GLWindow@@2PEAV1@EA, rax ; GLWindow::instance

; 208  : 	GLWindow::instance->initWindow();

  003b5	e8 00 00 00 00	 call	 ?initWindow@GLWindow@@QEAAXXZ ; GLWindow::initWindow
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  003ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?renderThread@@3VRenderThread@@A ; renderThread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  003c1	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$23[rbp-256]
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  003c8	48 89 45 98	 mov	 QWORD PTR theThread$7[rbp-256], rax
  003cc	66 c7 05 18 00
	00 00 01 00	 mov	 WORD PTR ?renderThread@@3VRenderThread@@A+24, 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  003d5	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  003da	48 8d 45 98	 lea	 rax, QWORD PTR theThread$7[rbp-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  003de	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:??_7?$_LaunchPad@V?$_Bind@$00XQ6AXPEAVThread@@@ZV?$reference_wrapper@PEAVThread@@@std@@U_Nil@3@U43@U43@U43@U43@U43@@std@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  003e5	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:?loop@Thread@@KAXPEAV1@@Z ; Thread::loop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  003ec	48 8d 55 a8	 lea	 rdx, QWORD PTR $T9[rbp-256]
  003f0	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$23[rbp-256]

; 182  : 		{	// construct from target

  003f7	4c 89 a5 c0 00
	00 00		 mov	 QWORD PTR _Launcher$23[rbp-256], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  003fe	48 89 85 e8 00
	00 00		 mov	 QWORD PTR _Launcher$23[rbp-216], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  00405	4c 89 ad e0 00
	00 00		 mov	 QWORD PTR _Launcher$23[rbp-224], r13
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  0040c	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  00411	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR _Launcher$23[rbp-256]
  00418	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0041d	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  00424	0f 85 4a 07 00
	00		 jne	 $LN997@WinMain

; 113  : 		_Thr = _Other._Thr;

  0042a	48 8b 45 a8	 mov	 rax, QWORD PTR $T9[rbp-256]
  0042e	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A+8, rax
  00435	48 8b 45 b0	 mov	 rax, QWORD PTR $T9[rbp-248]

; 114  : 		_Thr_set_null(_Other._Thr);

  00439	44 89 7d b0	 mov	 DWORD PTR $T9[rbp-248], r15d
  0043d	48 89 05 10 00
	00 00		 mov	 QWORD PTR ?renderThread@@3VRenderThread@@A+16, rax
  00444	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  0044b	0f 1f 44 00 00	 npad	 5
$LL23@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 211  : 	while(GLWindow::instance == nullptr || !GLWindow::instance->isOK())

  00450	48 85 c0	 test	 rax, rax
  00453	74 fb		 je	 SHORT $LL23@WinMain
  00455	80 38 00	 cmp	 BYTE PTR [rax], 0
  00458	74 f6		 je	 SHORT $LL23@WinMain

; 212  : 	{
; 213  : 
; 214  : 	}
; 215  : 
; 216  : 	ChunkLoadThread::program.create(IOUtil::EXE_DIR + L"\\programs\\generation.cl");

  0045a	48 8d 8d 90 01
	00 00		 lea	 rcx, QWORD PTR $T29[rbp-256]
  00461	e8 00 00 00 00	 call	 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00466	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@ChunkLoadThread@@2VProgram@cl@@A ; ChunkLoadThread::program
  0046d	48 8b d0	 mov	 rdx, rax
  00470	e8 00 00 00 00	 call	 ?create@Program@cl@@QEAA_NV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; cl::Program::create
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 260  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00475	4c 8b 0d 18 00
	00 00		 mov	 r9, QWORD PTR ?noise@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24
  0047c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00483	48 8d 44 24 64	 lea	 rax, QWORD PTR error$3[rsp]
  00488	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  0048d	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00493	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00498	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 261  : 	if(error != CL_SUCCESS)

  0049e	83 7c 24 64 00	 cmp	 DWORD PTR error$3[rsp], 0
  004a3	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A+8, rax
  004aa	bb 18 00 00 00	 mov	 ebx, 24
  004af	0f 84 a6 00 00
	00		 je	 $LN427@WinMain

; 262  : 	{
; 263  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  004b5	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  004bc	b8 02 00 00 00	 mov	 eax, 2
  004c1	48 f7 e3	 mul	 rbx
  004c4	49 0f 40 c6	 cmovo	 rax, r14
  004c8	48 8b c8	 mov	 rcx, rax
  004cb	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  004d0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956353
  004d7	44 8b c3	 mov	 r8d, ebx
  004da	33 c9		 xor	 ecx, ecx
  004dc	48 8b d0	 mov	 rdx, rax
  004df	48 c7 44 24 20
	17 00 00 00	 mov	 QWORD PTR [rsp+32], 23
  004e8	48 8b f8	 mov	 rdi, rax
  004eb	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  004f0	b8 02 00 00 00	 mov	 eax, 2
  004f5	48 f7 e3	 mul	 rbx
  004f8	49 0f 40 c6	 cmovo	 rax, r14
  004fc	48 8b c8	 mov	 rcx, rax
  004ff	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00504	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956354
  0050b	41 b8 18 00 00
	00		 mov	 r8d, 24
  00511	33 c9		 xor	 ecx, ecx
  00513	48 8b d0	 mov	 rdx, rax
  00516	48 c7 44 24 20
	17 00 00 00	 mov	 QWORD PTR [rsp+32], 23
  0051f	48 8b d8	 mov	 rbx, rax
  00522	e8 00 00 00 00	 call	 mbstowcs_s

; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  00527	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  0052b	41 b9 10 00 00
	00		 mov	 r9d, 16
  00531	4c 8b c7	 mov	 r8, rdi
  00534	48 8b d7	 mov	 rdx, rdi
  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;
; 228  : 
; 229  : 	delete wText;

  0053d	48 8b cf	 mov	 rcx, rdi
  00540	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
  00547	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  0054c	48 8b cb	 mov	 rcx, rbx
  0054f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 264  : 		return false;

  00554	bb 18 00 00 00	 mov	 ebx, 24
  00559	eb 12		 jmp	 SHORT $LN428@WinMain
$LN427@WinMain:

; 265  : 	}
; 266  : 
; 267  : 	this->size = size;

  0055b	48 c7 05 10 00
	00 00 00 10 00
	00		 mov	 QWORD PTR ?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A+16, 4096 ; 00001000H

; 268  : 	okay = true;

  00566	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?noiseBuffer@ChunkLoadThread@@2VBuffer@cl@@A, 1
$LN428@WinMain:

; 260  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  0056d	4c 8b 0d 18 00
	00 00		 mov	 r9, QWORD PTR ?noise2@ChunkLoadThread@@2VNoiseGenerator3D@Noise@@A+24
  00574	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  0057b	48 8d 44 24 58	 lea	 rax, QWORD PTR error$2[rsp]
  00580	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  00585	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  0058b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00590	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer

; 261  : 	if(error != CL_SUCCESS)

  00596	83 7c 24 58 00	 cmp	 DWORD PTR error$2[rsp], 0
  0059b	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A+8, rax
  005a2	0f 84 a1 00 00
	00		 je	 $LN434@WinMain

; 262  : 	{
; 263  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  005a8	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  005af	b8 02 00 00 00	 mov	 eax, 2
  005b4	48 f7 e3	 mul	 rbx
  005b7	49 0f 40 c6	 cmovo	 rax, r14
  005bb	48 8b c8	 mov	 rcx, rax
  005be	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  005c3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956353
  005ca	4c 8b c3	 mov	 r8, rbx
  005cd	33 c9		 xor	 ecx, ecx
  005cf	48 8b d0	 mov	 rdx, rax
  005d2	48 c7 44 24 20
	17 00 00 00	 mov	 QWORD PTR [rsp+32], 23
  005db	48 8b f8	 mov	 rdi, rax
  005de	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);
; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  005e3	b8 02 00 00 00	 mov	 eax, 2
  005e8	48 f7 e3	 mul	 rbx
  005eb	49 0f 40 c6	 cmovo	 rax, r14
  005ef	48 8b c8	 mov	 rcx, rax
  005f2	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  005f7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG4294956354
  005fe	41 b8 18 00 00
	00		 mov	 r8d, 24
  00604	33 c9		 xor	 ecx, ecx
  00606	48 8b d0	 mov	 rdx, rax
  00609	48 c7 44 24 20
	17 00 00 00	 mov	 QWORD PTR [rsp+32], 23
  00612	48 8b d8	 mov	 rbx, rax
  00615	e8 00 00 00 00	 call	 mbstowcs_s

; 212  : 	MessageBox(hWnd, lpText, lpText, uType);

  0061a	48 8b 4e 10	 mov	 rcx, QWORD PTR [rsi+16]
  0061e	41 b9 10 00 00
	00		 mov	 r9d, 16
  00624	4c 8b c7	 mov	 r8, rdi
  00627	48 8b d7	 mov	 rdx, rdi
  0062a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;
; 228  : 
; 229  : 	delete wText;

  00630	48 8b cf	 mov	 rcx, rdi
  00633	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
  0063a	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  0063f	48 8b cb	 mov	 rcx, rbx
  00642	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 264  : 		return false;

  00647	eb 12		 jmp	 SHORT $LN435@WinMain
$LN434@WinMain:

; 265  : 	}
; 266  : 
; 267  : 	this->size = size;

  00649	48 c7 05 10 00
	00 00 00 10 00
	00		 mov	 QWORD PTR ?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A+16, 4096 ; 00001000H

; 268  : 	okay = true;

  00654	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?noise2Buffer@ChunkLoadThread@@2VBuffer@cl@@A, 1
$LN435@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 220  : 	for(int i = 0; i < LOAD_THREAD_AMOUNT; i++)

  0065b	48 8d 1d 18 00
	00 00		 lea	 rbx, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+24
  00662	48 8d 3d a8 08
	00 00		 lea	 rdi, OFFSET FLAT:?chunkLoadThreads@@3PAVChunkLoadThread@@A+2216
  00669	0f 1f 80 00 00
	00 00		 npad	 7
$LL20@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  00670	48 8d 43 e8	 lea	 rax, QWORD PTR [rbx-24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00674	48 8d 8d 00 01
	00 00		 lea	 rcx, QWORD PTR _Launcher$25[rbp-256]
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 35   : 	started = true;

  0067b	66 c7 03 01 00	 mov	 WORD PTR [rbx], 1

; 37   : 	Thread* theThread = this;

  00680	48 89 44 24 70	 mov	 QWORD PTR theThread$4[rsp], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00685	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0068a	48 8d 44 24 70	 lea	 rax, QWORD PTR theThread$4[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  0068f	48 8d 54 24 78	 lea	 rdx, QWORD PTR $T5[rsp]
  00694	48 8d 8d 00 01
	00 00		 lea	 rcx, QWORD PTR _Launcher$25[rbp-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  0069b	48 89 85 28 01
	00 00		 mov	 QWORD PTR _Launcher$25[rbp-216], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  006a2	4c 89 a5 00 01
	00 00		 mov	 QWORD PTR _Launcher$25[rbp-256], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  006a9	4c 89 ad 20 01
	00 00		 mov	 QWORD PTR _Launcher$25[rbp-224], r13
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  006b0	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  006b5	48 8d 8d 00 01
	00 00		 lea	 rcx, QWORD PTR _Launcher$25[rbp-256]
  006bc	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  006c1	83 7b f8 00	 cmp	 DWORD PTR [rbx-8], 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  006c5	0f 85 b5 04 00
	00		 jne	 $LN957@WinMain

; 113  : 		_Thr = _Other._Thr;

  006cb	48 8b 44 24 78	 mov	 rax, QWORD PTR $T5[rsp]
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 220  : 	for(int i = 0; i < LOAD_THREAD_AMOUNT; i++)

  006d0	48 81 c3 90 08
	00 00		 add	 rbx, 2192		; 00000890H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 113  : 		_Thr = _Other._Thr;

  006d7	48 89 83 60 f7
	ff ff		 mov	 QWORD PTR [rbx-2208], rax
  006de	48 8b 45 80	 mov	 rax, QWORD PTR $T5[rbp-248]

; 114  : 		_Thr_set_null(_Other._Thr);

  006e2	44 89 7d 80	 mov	 DWORD PTR $T5[rbp-248], r15d
  006e6	48 89 83 68 f7
	ff ff		 mov	 QWORD PTR [rbx-2200], rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 220  : 	for(int i = 0; i < LOAD_THREAD_AMOUNT; i++)

  006ed	48 3b df	 cmp	 rbx, rdi
  006f0	0f 8c 7a ff ff
	ff		 jl	 $LL20@WinMain

; 225  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  006f6	48 8d 1d 18 00
	00 00		 lea	 rbx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+24
  006fd	48 8d 3d 88 11
	00 00		 lea	 rdi, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+4488
  00704	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL17@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 37   : 	Thread* theThread = this;

  00710	48 8d 43 e8	 lea	 rax, QWORD PTR [rbx-24]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00714	48 8d 4d 30	 lea	 rcx, QWORD PTR _Launcher$16[rbp-256]
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 35   : 	started = true;

  00718	66 c7 03 01 00	 mov	 WORD PTR [rbx], 1

; 37   : 	Thread* theThread = this;

  0071d	48 89 45 a0	 mov	 QWORD PTR theThread$8[rbp-256], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00721	e8 00 00 00 00	 call	 ??0_Pad@std@@QEAA@XZ	; std::_Pad::_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00726	48 8d 45 a0	 lea	 rax, QWORD PTR theThread$8[rbp-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  0072a	48 8d 55 88	 lea	 rdx, QWORD PTR $T6[rbp-256]
  0072e	48 8d 4d 30	 lea	 rcx, QWORD PTR _Launcher$16[rbp-256]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xrefwrap

; 346  : 		{	// construct

  00732	48 89 45 58	 mov	 QWORD PTR _Launcher$16[rbp-216], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 182  : 		{	// construct from target

  00736	4c 89 65 30	 mov	 QWORD PTR _Launcher$16[rbp-256], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\functional

; 1152 : _VARIADIC_EXPAND_0X(_CLASS_BIND, , , , )

  0073a	4c 89 6d 50	 mov	 QWORD PTR _Launcher$16[rbp-224], r13
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 206  : 	_Launcher._Launch(_Thr);

  0073e	e8 00 00 00 00	 call	 ?_Launch@_Pad@std@@QEAAXPEAU_Thrd_imp_t@@@Z ; std::_Pad::_Launch
  00743	48 8d 4d 30	 lea	 rcx, QWORD PTR _Launcher$16[rbp-256]
  00747	e8 00 00 00 00	 call	 ??1_Pad@std@@QEAA@XZ	; std::_Pad::~_Pad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0074c	83 7b f8 00	 cmp	 DWORD PTR [rbx-8], 0

; 84   : 		}
; 85   : 
; 86   : 	void join();
; 87   : 
; 88   : 	void detach()
; 89   : 		{	// detach thread
; 90   : 		if (!joinable())
; 91   : 			_Throw_Cpp_error(_INVALID_ARGUMENT);
; 92   : 		_Thrd_detachX(_Thr);
; 93   : 		_Thr_set_null(_Thr);
; 94   : 		}
; 95   : 
; 96   : 	id get_id() const _NOEXCEPT;
; 97   : 
; 98   : 	static unsigned int hardware_concurrency() _NOEXCEPT
; 99   : 		{	// return number of hardware thread contexts
; 100  : 		return (::Concurrency::details::_GetConcurrency());
; 101  : 		}
; 102  : 
; 103  : 	native_handle_type native_handle()
; 104  : 		{	// return Win32 HANDLE as void *
; 105  : 		return (_Thr._Hnd);
; 106  : 		}
; 107  : 
; 108  : private:
; 109  : 	thread& _Move_thread(thread& _Other)
; 110  : 		{	// move from _Other
; 111  : 		if (joinable())

  00750	0f 85 24 04 00
	00		 jne	 $LN959@WinMain

; 113  : 		_Thr = _Other._Thr;

  00756	48 8b 45 88	 mov	 rax, QWORD PTR $T6[rbp-256]
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 225  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  0075a	48 81 c3 b8 08
	00 00		 add	 rbx, 2232		; 000008b8H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 113  : 		_Thr = _Other._Thr;

  00761	48 89 83 38 f7
	ff ff		 mov	 QWORD PTR [rbx-2248], rax
  00768	48 8b 45 90	 mov	 rax, QWORD PTR $T6[rbp-248]

; 114  : 		_Thr_set_null(_Other._Thr);

  0076c	44 89 7d 90	 mov	 DWORD PTR $T6[rbp-248], r15d
  00770	48 89 83 40 f7
	ff ff		 mov	 QWORD PTR [rbx-2240], rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 225  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  00777	48 3b df	 cmp	 rbx, rdi
  0077a	7c 94		 jl	 SHORT $LL17@WinMain

; 226  : 	{
; 227  : 		chunkDrawThreads[i].start();
; 228  : 	}
; 229  : 
; 230  : 	GameStates::init();

  0077c	e8 00 00 00 00	 call	 ?init@GameStates@@YAXXZ	; GameStates::init
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  00781	e8 00 00 00 00	 call	 _Xtime_get_ticks
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 236  : 	while(!GlobalThread::stop)

  00786	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  0078d	48 8b d8	 mov	 rbx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 236  : 	while(!GlobalThread::stop)

  00790	0f 85 c2 00 00
	00		 jne	 $LN985@WinMain
  00796	48 bf bd 42 7a
	e5 d5 94 bf d6	 mov	 rdi, -2972493582642298179 ; d6bf94d5e57a42bdH
$LL14@WinMain:

; 237  : 	{
; 238  : 		if(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))

  007a0	48 8d 8d 30 01
	00 00		 lea	 rcx, QWORD PTR msg$[rbp-256]
  007a7	45 33 c9	 xor	 r9d, r9d
  007aa	45 33 c0	 xor	 r8d, r8d
  007ad	33 d2		 xor	 edx, edx
  007af	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  007b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PeekMessageW
  007bd	85 c0		 test	 eax, eax
  007bf	74 29		 je	 SHORT $LN12@WinMain

; 239  : 		{
; 240  : 			if(msg.message == WM_QUIT)

  007c1	83 bd 38 01 00
	00 12		 cmp	 DWORD PTR msg$[rbp-248], 18
  007c8	0f 84 83 00 00
	00		 je	 $LN994@WinMain

; 241  : 			{
; 242  : 				GlobalThread::stop = true;
; 243  : 			} else
; 244  : 			{
; 245  : 				TranslateMessage(&msg);

  007ce	48 8d 8d 30 01
	00 00		 lea	 rcx, QWORD PTR msg$[rbp-256]
  007d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TranslateMessage

; 246  : 				DispatchMessage(&msg);

  007db	48 8d 8d 30 01
	00 00		 lea	 rcx, QWORD PTR msg$[rbp-256]
  007e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DispatchMessageW

; 247  : 			}
; 248  : 		} else

  007e8	eb 58		 jmp	 SHORT $LN7@WinMain
$LN12@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 706  : 		return (time_point(duration(_Xtime_get_ticks())));

  007ea	e8 00 00 00 00	 call	 _Xtime_get_ticks
  007ef	48 8b c8	 mov	 rcx, rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 253  : 			long long tick = difference / tickTime;

  007f2	48 8b c7	 mov	 rax, rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\chrono

; 105  : 		{	// construct from representation

  007f5	48 2b cb	 sub	 rcx, rbx

; 106  : 		static_assert(_Is_ratio<_Period>::value,
; 107  : 			"period not an instance of std::ratio");
; 108  : 		static_assert(0 < _Period::num,
; 109  : 			"duration negative or zero");
; 110  : 		}
; 111  : 
; 112  : 	template<class _Rep2,
; 113  : 		class _Period2>
; 114  : 		duration(const duration<_Rep2, _Period2>& _Dur,
; 115  : 			typename enable_if<treat_as_floating_point<_Rep>::value
; 116  : 				|| ratio_divide<_Period2, _Period>::type::den == 1
; 117  : 					&& !treat_as_floating_point<_Rep2>::value,
; 118  : 				void>::type ** = 0)
; 119  : 		: _MyRep(duration_cast<_Myt>(_Dur).count())
; 120  : 		{	// construct from a duration
; 121  : 		typedef typename ratio_divide<_Period2, _Period>::type _Checked_type;
; 122  : 
; 123  : 		static_assert(_Is_ratio<_Period>::value,
; 124  : 			"period not an instance of std::ratio");
; 125  : 		static_assert(0 < _Period::num,
; 126  : 			"duration negative or zero");
; 127  : 		}
; 128  : 
; 129  : 	_Rep count() const
; 130  : 		{	// get stored rep
; 131  : 		return (_MyRep);
; 132  : 		}
; 133  : 
; 134  : 	_Myt operator+() const
; 135  : 		{	// get value
; 136  : 		return (*this);
; 137  : 		}
; 138  : 
; 139  : 	_Myt operator-() const
; 140  : 		{	// get negated value
; 141  : 		return (_Myt(0 - _MyRep));
; 142  : 		}
; 143  : 
; 144  : 	_Myt& operator++()
; 145  : 		{	// increment rep
; 146  : 		++_MyRep;
; 147  : 		return (*this);
; 148  : 		}
; 149  : 
; 150  : 	_Myt operator++(int)
; 151  : 		{	// postincrement rep
; 152  : 		return (_Myt(_MyRep++));
; 153  : 		}
; 154  : 
; 155  : 	_Myt& operator--()
; 156  : 		{	// decrement rep
; 157  : 		--_MyRep;
; 158  : 		return (*this);
; 159  : 		}
; 160  : 
; 161  : 	_Myt operator--(int)
; 162  : 		{	// postdecrement rep
; 163  : 		return (_Myt(_MyRep--));
; 164  : 		}
; 165  : 
; 166  : 	_Myt& operator+=(const _Myt& _Right)
; 167  : 		{	// add _Right to rep
; 168  : 		_MyRep += _Right._MyRep;
; 169  : 		return (*this);
; 170  : 		}
; 171  : 
; 172  : 	_Myt& operator-=(const _Myt& _Right)
; 173  : 		{	// subtract _Right from rep
; 174  : 		_MyRep -= _Right._MyRep;
; 175  : 		return (*this);
; 176  : 		}
; 177  : 
; 178  : 	_Myt& operator*=(const _Rep& _Right)
; 179  : 		{	// multiply rep by _Right
; 180  : 		_MyRep *= _Right;
; 181  : 		return (*this);
; 182  : 		}
; 183  : 
; 184  : 	_Myt& operator/=(const _Rep& _Right)
; 185  : 		{	// divide rep by _Right
; 186  : 		_MyRep /= _Right;
; 187  : 		return (*this);
; 188  : 		}
; 189  : 
; 190  : 	_Myt& operator%=(const _Rep& _Right)
; 191  : 		{	// modulus rep by _Right
; 192  : 		_MyRep %= _Right;
; 193  : 		return (*this);
; 194  : 		}
; 195  : 
; 196  : 	_Myt& operator%=(const _Myt& _Right)
; 197  : 		{	// modulus rep by _Right
; 198  : 		_MyRep %= _Right.count();
; 199  : 		return (*this);
; 200  : 		}
; 201  : 
; 202  : 	static _Myt zero()
; 203  : 		{	// get zero value
; 204  : 		return (_Myt(duration_values<_Rep>::zero()));
; 205  : 		}
; 206  : 
; 207  : 	static _Myt (min)()
; 208  : 		{	// get minimum value
; 209  : 		return (_Myt((duration_values<_Rep>::min)()));
; 210  : 		}
; 211  : 	static _Myt (max)()
; 212  : 		{	// get maximum value
; 213  : 		return (_Myt((duration_values<_Rep>::max)()));
; 214  : 		}
; 215  : 
; 216  : private:
; 217  : 	_Rep _MyRep;	// the stored rep
; 218  : 	};
; 219  : 
; 220  : template<class _Rep1,
; 221  : 	class _Period1,
; 222  : 	class _Period2>
; 223  : 	class duration<duration<_Rep1, _Period1>, _Period2>
; 224  : 	{	// undefined: duration type as first template argument
; 225  : 	duration()
; 226  : 		{	// check asserts
; 227  : 		static_assert(_Always_false<_Rep1>::value,
; 228  : 			"duration can't have duration as first template argument");
; 229  : 		}
; 230  : 	};
; 231  : 
; 232  : 	// CLASS TEMPLATE _Is_duration
; 233  : template<class _Rep,
; 234  : 	class _Period>
; 235  : 	struct _Is_duration<duration<_Rep, _Period> >
; 236  : 	{	// tests for duration
; 237  : 	static const bool value = true;
; 238  : 	};
; 239  : 
; 240  : template<class _Clock,
; 241  : 	class _Duration = typename _Clock::duration>
; 242  : 	class time_point
; 243  : 	{	// represents a point in time
; 244  : public:
; 245  : 	typedef _Clock clock;
; 246  : 	typedef _Duration duration;
; 247  : 	typedef typename _Duration::rep rep;
; 248  : 	typedef typename _Duration::period period;
; 249  : 
; 250  : 	time_point()
; 251  : 		: _MyDur(_Duration::zero())
; 252  : 		{	// check asserts
; 253  : 		static_assert(_Is_duration<_Duration>::value,
; 254  : 			"duration must be an instance of std::duration");
; 255  : 		}
; 256  : 
; 257  : 	explicit time_point(const _Duration& _Other)
; 258  : 		: _MyDur(_Other)
; 259  : 		{	// construct from a duration
; 260  : 		}
; 261  : 
; 262  : 	template<class _Duration2>
; 263  : 		time_point(const time_point<_Clock, _Duration2>& _Tp,
; 264  : 			typename enable_if<is_convertible<_Duration2, _Duration>::value,
; 265  : 			void>::type ** = 0)
; 266  : 		: _MyDur(_Tp.time_since_epoch())
; 267  : 		{	// construct from another duration
; 268  : 		}
; 269  : 
; 270  : 	_Duration time_since_epoch() const
; 271  : 		{	// get duration from epoch
; 272  : 		return (_MyDur);
; 273  : 		}
; 274  : 
; 275  : 	time_point& operator+=(const _Duration& _Dur)
; 276  : 		{	// increment by duration
; 277  : 		_MyDur += _Dur;
; 278  : 		return (*this);
; 279  : 		}
; 280  : 
; 281  : 	time_point& operator-=(const _Duration& _Dur)
; 282  : 		{	// decrement by duration
; 283  : 		_MyDur -= _Dur;
; 284  : 		return (*this);
; 285  : 		}
; 286  : 
; 287  : 	static time_point (min)()
; 288  : 		{	// get minimum time point
; 289  : 		return (time_point((_Duration::min)()));
; 290  : 		}
; 291  : 	static time_point (max)()
; 292  : 		{	// get maximum time point
; 293  : 		return (time_point((_Duration::max)()));
; 294  : 		}
; 295  : 
; 296  : private:
; 297  : 	_Duration _MyDur;	// duration since the epoch
; 298  : 	};
; 299  : }	// namespace chrono
; 300  : 
; 301  : 	// CLASS TEMPLATE _Lcm (LEAST COMMON MULTIPLE)
; 302  : template<intmax_t _Ax,
; 303  : 	intmax_t _Bx>
; 304  : 	struct _Lcm
; 305  : 	{   /* compute least common multiple of _Ax and _Bx */
; 306  : 	static const intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
; 307  : 	static const intmax_t value = (_Ax / _Gx) * _Bx;
; 308  : 	};
; 309  : 
; 310  : 	// CLASS TEMPLATE common_type SPECIALIZATIONS
; 311  : template<class _Rep1,
; 312  : 	class _Period1,
; 313  : 	class _Rep2,
; 314  : 	class _Period2>
; 315  : 	struct common_type<
; 316  : 		chrono::duration<_Rep1, _Period1>,
; 317  : 		chrono::duration<_Rep2, _Period2> >
; 318  : 	{	// common type of two durations
; 319  : 	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
; 320  : 		ratio<_Gcd<_Period1::num, _Period2::num>::value,
; 321  : 			_Lcm<_Period1::den, _Period2::den>::value> > type;
; 322  : 	};
; 323  : 
; 324  : template<class _Clock,
; 325  : 	class _Duration1,
; 326  : 	class _Duration2>
; 327  : 	struct common_type<
; 328  : 		chrono::time_point<_Clock, _Duration1>,
; 329  : 		chrono::time_point<_Clock, _Duration2> >
; 330  : 	{	// common type of two time points
; 331  : 	typedef chrono::time_point<
; 332  : 		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
; 333  : 	};
; 334  : 
; 335  : namespace chrono {
; 336  : 	// duration ARITHMETIC
; 337  : template<class _Rep1,
; 338  : 	class _Period1,
; 339  : 	class _Rep2,
; 340  : 	class _Period2> inline
; 341  : 	typename common_type<
; 342  : 		duration<_Rep1, _Period1>,
; 343  : 		duration<_Rep2, _Period2> >::type
; 344  : 		operator+(
; 345  : 			const duration<_Rep1, _Period1>& _Left,
; 346  : 			const duration<_Rep2, _Period2>& _Right)
; 347  : 	{	// add two durations
; 348  : 	typedef typename common_type<
; 349  : 		duration<_Rep1, _Period1>,
; 350  : 		duration<_Rep2, _Period2> >::type _CD;
; 351  : 		return (_CD(_Left) += _Right);
; 352  : 		}
; 353  : 
; 354  : template<class _Rep1,
; 355  : 	class _Period1,
; 356  : 	class _Rep2,
; 357  : 	class _Period2> inline
; 358  : 	typename common_type<
; 359  : 		duration<_Rep1, _Period1>,
; 360  : 		duration<_Rep2, _Period2> >::type
; 361  : 		operator-(
; 362  : 			const duration<_Rep1, _Period1>& _Left,
; 363  : 			const duration<_Rep2, _Period2>& _Right)
; 364  : 	{	// subtract two durations
; 365  : 	typedef typename common_type<
; 366  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 367  : 	return (_CD(_Left) -= _Right);
; 368  : 	}
; 369  : 
; 370  : template<class _Rep1,
; 371  : 	class _Period1,
; 372  : 	class _Rep2> inline
; 373  : 	typename enable_if<is_convertible<_Rep2,
; 374  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 375  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 376  : 		operator*(
; 377  : 			const duration<_Rep1, _Period1>& _Left,
; 378  : 			const _Rep2& _Right)
; 379  : 	{	// multiply duration by rep
; 380  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 381  : 	return (duration<_CR, _Period1>(_Left) *= _Right);
; 382  : 	}
; 383  : 
; 384  : template<class _Rep1,
; 385  : 	class _Rep2,
; 386  : 	class _Period2> inline
; 387  : 	typename enable_if<is_convertible<_Rep1,
; 388  : 		typename common_type<_Rep1, _Rep2>::type>::value,
; 389  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
; 390  : 		operator*(
; 391  : 			const _Rep1& _Left,
; 392  : 			const duration<_Rep2, _Period2>& _Right)
; 393  : 	{	// multiply rep by duration
; 394  : 	return (_Right * _Left);
; 395  : 	}
; 396  : 
; 397  : template<class _Rep1,
; 398  : 	class _Period1,
; 399  : 	class _Rep2> inline
; 400  : 	typename enable_if<is_convertible<_Rep2,
; 401  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 402  : 		&& !_Is_duration<_Rep2>::value,
; 403  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 404  : 		operator/(
; 405  : 			const duration<_Rep1, _Period1>& _Left,
; 406  : 			const _Rep2& _Right)
; 407  : 	{	// divide duration by rep
; 408  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 409  : 	return (duration<_CR, _Period1>(_Left) /= _Right);
; 410  : 	}
; 411  : 
; 412  : template<class _Rep1,
; 413  : 	class _Period1,
; 414  : 	class _Rep2,
; 415  : 	class _Period2> inline
; 416  : 	typename common_type<_Rep1, _Rep2>::type
; 417  : 		operator/(
; 418  : 			const duration<_Rep1, _Period1>& _Left,
; 419  : 			const duration<_Rep2, _Period2>& _Right)
; 420  : 	{	// divide duration by duration
; 421  : 	typedef typename common_type<
; 422  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 423  : 	return (_CD(_Left).count() / _CD(_Right).count());
; 424  : 	}
; 425  : 
; 426  : template<class _Rep1,
; 427  : 	class _Period1,
; 428  : 	class _Rep2> inline
; 429  : 	typename enable_if<is_convertible<_Rep2,
; 430  : 		typename common_type<_Rep1, _Rep2>::type>::value
; 431  : 		&& !_Is_duration<_Rep2>::value,
; 432  : 		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
; 433  : 		operator%(
; 434  : 			const duration<_Rep1, _Period1>& _Left,
; 435  : 			const _Rep2& _Right)
; 436  : 	{	// divide duration by rep
; 437  : 	typedef typename common_type<_Rep1, _Rep2>::type _CR;
; 438  : 	return (duration<_CR, _Period1>(_Left) %= _Right);
; 439  : 	}
; 440  : 
; 441  : template<class _Rep1,
; 442  : 	class _Period1,
; 443  : 	class _Rep2,
; 444  : 	class _Period2> inline
; 445  : 	typename common_type<_Rep1, _Rep2>::type
; 446  : 		operator%(
; 447  : 			const duration<_Rep1, _Period1>& _Left,
; 448  : 			const duration<_Rep2, _Period2>& _Right)
; 449  : 	{	// divide duration by duration
; 450  : 	typedef typename common_type<
; 451  : 		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
; 452  : 	return (_CD(_Left).count() % _CD(_Right).count());
; 453  : 	}
; 454  : 
; 455  : 	// duration COMPARISONS
; 456  : template<class _Rep1,
; 457  : 	class _Period1,
; 458  : 	class _Rep2,
; 459  : 	class _Period2> inline
; 460  : 	bool operator==(
; 461  : 		const duration<_Rep1, _Period1>& _Left,
; 462  : 		const duration<_Rep2, _Period2>& _Right)
; 463  : 	{	// test if duration == duration
; 464  : 	typedef typename common_type<
; 465  : 		duration<_Rep1, _Period1>,
; 466  : 		duration<_Rep2, _Period2> >::type _CT;
; 467  : 	return (_CT(_Left).count() == _CT(_Right).count());
; 468  : 	}
; 469  : 
; 470  : template<class _Rep1,
; 471  : 	class _Period1,
; 472  : 	class _Rep2,
; 473  : 	class _Period2> inline
; 474  : 	bool operator!=(
; 475  : 		const duration<_Rep1, _Period1>& _Left,
; 476  : 		const duration<_Rep2, _Period2>& _Right)
; 477  : 	{	// test if duration != duration
; 478  : 	return (!(_Left == _Right));
; 479  : 	}
; 480  : 
; 481  : template<class _Rep1,
; 482  : 	class _Period1,
; 483  : 	class _Rep2,
; 484  : 	class _Period2> inline
; 485  : 	bool operator<(
; 486  : 		const duration<_Rep1, _Period1>& _Left,
; 487  : 		const duration<_Rep2, _Period2>& _Right)
; 488  : 	{	// test if duration < duration
; 489  : 	typedef typename common_type<
; 490  : 		duration<_Rep1, _Period1>,
; 491  : 		duration<_Rep2, _Period2> >::type _CT;
; 492  : 	return (_CT(_Left).count() < _CT(_Right).count());
; 493  : 	}
; 494  : 
; 495  : template<class _Rep1,
; 496  : 	class _Period1,
; 497  : 	class _Rep2,
; 498  : 	class _Period2> inline
; 499  : 	bool operator<=(
; 500  : 		const duration<_Rep1, _Period1>& _Left,
; 501  : 		const duration<_Rep2, _Period2>& _Right)
; 502  : 	{	// test if duration <= duration
; 503  : 	return (!(_Right < _Left));
; 504  : 	}
; 505  : 
; 506  : template<class _Rep1,
; 507  : 	class _Period1,
; 508  : 	class _Rep2,
; 509  : 	class _Period2> inline
; 510  : 	bool operator>(
; 511  : 		const duration<_Rep1, _Period1>& _Left,
; 512  : 		const duration<_Rep2, _Period2>& _Right)
; 513  : 	{	// test if duration > duration
; 514  : 	return (_Right < _Left);
; 515  : 	}
; 516  : 
; 517  : template<class _Rep1,
; 518  : 	class _Period1,
; 519  : 	class _Rep2,
; 520  : 	class _Period2> inline
; 521  : 	bool operator>=(
; 522  : 		const duration<_Rep1, _Period1>& _Left,
; 523  : 		const duration<_Rep2, _Period2>& _Right)
; 524  : 	{	// test if duration >= duration
; 525  : 	return (!(_Left < _Right));
; 526  : 	}
; 527  : 
; 528  : 	// duration_cast
; 529  : template<class _To,
; 530  : 	class _Rep,
; 531  : 	class _Period> inline
; 532  : 	typename enable_if<_Is_duration<_To>::value,
; 533  : 		_To>::type
; 534  : 		duration_cast(const duration<_Rep, _Period>& _Dur)
; 535  : 	{	// convert duration to another duration
; 536  : 	typedef typename ratio_divide<_Period, typename _To::period>::type _CF;
; 537  : 	typedef typename common_type<
; 538  : 		typename common_type<typename _To::rep, _Rep>::type,
; 539  : 			intmax_t>::type _CR;
; 540  : 	if (_CF::num == 1 && _CF::den == 1)
; 541  : 		return (_To(static_cast<typename _To::rep>(_Dur.count())));
; 542  : 	else if (_CF::num != 1 && _CF::den == 1)
; 543  : 		return (_To(static_cast<typename _To::rep>(

  007f8	48 6b c9 64	 imul	 rcx, 100		; 00000064H
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 253  : 			long long tick = difference / tickTime;

  007fc	48 f7 e9	 imul	 rcx
  007ff	48 03 d1	 add	 rdx, rcx
  00802	48 c1 fa 18	 sar	 rdx, 24
  00806	48 8b c2	 mov	 rax, rdx
  00809	48 c1 e8 3f	 shr	 rax, 63			; 0000003fH
  0080d	48 03 d0	 add	 rdx, rax

; 254  : 			long long ticksToProcess = tick - lastTick;

  00810	48 8b 44 24 68	 mov	 rax, QWORD PTR lastTick$1$[rsp]
  00815	48 2b d0	 sub	 rdx, rax

; 255  : 
; 256  : 			if(ticksToProcess > 0)

  00818	48 85 d2	 test	 rdx, rdx
  0081b	7e 25		 jle	 SHORT $LN7@WinMain

; 257  : 			{
; 258  : 				lastTick++;

  0081d	48 ff c0	 inc	 rax

; 259  : 				RenderThread::skipRender = false;

  00820	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?skipRender@RenderThread@@2_NA, 0 ; RenderThread::skipRender
  00827	48 89 44 24 68	 mov	 QWORD PTR lastTick$1$[rsp], rax

; 260  : 				if(GLWindow::instance->active && !mainLoop())

  0082c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00833	80 78 64 00	 cmp	 BYTE PTR [rax+100], 0
  00837	74 09		 je	 SHORT $LN7@WinMain
  00839	e8 00 00 00 00	 call	 ?mainLoop@@YA_NXZ	; mainLoop
  0083e	84 c0		 test	 al, al
  00840	74 0f		 je	 SHORT $LN994@WinMain
$LN7@WinMain:

; 236  : 	while(!GlobalThread::stop)

  00842	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?stop@GlobalThread@@3_NA, 0 ; GlobalThread::stop
  00849	0f 84 51 ff ff
	ff		 je	 $LL14@WinMain
  0084f	eb 07		 jmp	 SHORT $LN985@WinMain
$LN994@WinMain:

; 261  : 				{
; 262  : 					GlobalThread::stop = true;

  00851	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN985@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  00858	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?renderThread@@3VRenderThread@@A+24, 0
  0085f	c6 05 19 00 00
	00 01		 mov	 BYTE PTR ?renderThread@@3VRenderThread@@A+25, 1
  00866	0f 84 94 00 00
	00		 je	 $LL820@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  0086c	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  00873	75 1d		 jne	 SHORT $LN818@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  00875	b9 01 00 00 00	 mov	 ecx, 1
  0087a	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error

; 213  : 	if (_Thr_is_null(_Thr))

  0087f	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, 0
  00886	75 0a		 jne	 SHORT $LN818@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  00888	b9 01 00 00 00	 mov	 ecx, 1
  0088d	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN818@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  00892	48 8d 8d 60 01
	00 00		 lea	 rcx, QWORD PTR $T26[rbp-256]
  00899	e8 00 00 00 00	 call	 _Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  0089e	48 8d 55 00	 lea	 rdx, QWORD PTR $T13[rbp-256]
  008a2	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR $T19[rbp-256]
  008a9	0f 10 0d 08 00
	00 00		 movups	 xmm1, XMMWORD PTR ?renderThread@@3VRenderThread@@A+8
  008b0	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  008b3	0f 29 8d 80 00
	00 00		 movaps	 XMMWORD PTR $T19[rbp-256], xmm1
  008ba	0f 29 45 00	 movaps	 XMMWORD PTR $T13[rbp-256], xmm0
  008be	e8 00 00 00 00	 call	 _Thrd_equal
  008c3	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  008c5	74 0a		 je	 SHORT $LN817@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  008c7	b9 05 00 00 00	 mov	 ecx, 5
  008cc	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN817@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  008d1	0f 10 05 08 00
	00 00		 movups	 xmm0, XMMWORD PTR ?renderThread@@3VRenderThread@@A+8
  008d8	48 8d 4d 20	 lea	 rcx, QWORD PTR $T15[rbp-256]
  008dc	33 d2		 xor	 edx, edx
  008de	0f 29 45 20	 movaps	 XMMWORD PTR $T15[rbp-256], xmm0
  008e2	e8 00 00 00 00	 call	 _Thrd_join
  008e7	85 c0		 test	 eax, eax
  008e9	74 0a		 je	 SHORT $LN816@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  008eb	b9 02 00 00 00	 mov	 ecx, 2
  008f0	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN816@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  008f5	44 89 3d 10 00
	00 00		 mov	 DWORD PTR ?renderThread@@3VRenderThread@@A+16, r15d
  008fc	0f 1f 40 00	 npad	 4
$LL820@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  00900	80 3d 18 00 00
	00 00		 cmp	 BYTE PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+24, 0
  00907	c6 05 19 00 00
	00 01		 mov	 BYTE PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+25, 1
  0090e	0f 84 96 00 00
	00		 je	 $LN5@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  00914	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+16, 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  0091b	75 1d		 jne	 SHORT $LN839@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  0091d	b9 01 00 00 00	 mov	 ecx, 1
  00922	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error

; 213  : 	if (_Thr_is_null(_Thr))

  00927	83 3d 10 00 00
	00 00		 cmp	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+16, 0
  0092e	75 0a		 jne	 SHORT $LN839@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  00930	b9 01 00 00 00	 mov	 ecx, 1
  00935	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN839@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  0093a	48 8d 8d 80 01
	00 00		 lea	 rcx, QWORD PTR $T28[rbp-256]
  00941	e8 00 00 00 00	 call	 _Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  00946	48 8d 95 f0 00
	00 00		 lea	 rdx, QWORD PTR $T24[rbp-256]
  0094d	48 8d 4d 70	 lea	 rcx, QWORD PTR $T18[rbp-256]
  00951	0f 10 0d 08 00
	00 00		 movups	 xmm1, XMMWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8
  00958	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0095b	0f 29 4d 70	 movaps	 XMMWORD PTR $T18[rbp-256], xmm1
  0095f	0f 29 85 f0 00
	00 00		 movaps	 XMMWORD PTR $T24[rbp-256], xmm0
  00966	e8 00 00 00 00	 call	 _Thrd_equal
  0096b	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  0096d	74 0a		 je	 SHORT $LN838@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  0096f	b9 05 00 00 00	 mov	 ecx, 5
  00974	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN838@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  00979	0f 10 05 08 00
	00 00		 movups	 xmm0, XMMWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+8
  00980	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR $T22[rbp-256]
  00987	33 d2		 xor	 edx, edx
  00989	0f 29 85 b0 00
	00 00		 movaps	 XMMWORD PTR $T22[rbp-256], xmm0
  00990	e8 00 00 00 00	 call	 _Thrd_join
  00995	85 c0		 test	 eax, eax
  00997	74 0a		 je	 SHORT $LN837@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  00999	b9 02 00 00 00	 mov	 ecx, 2
  0099e	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN837@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  009a3	44 89 3d 10 00
	00 00		 mov	 DWORD PTR ?chunkLoadThreads@@3PAVChunkLoadThread@@A+16, r15d
$LN5@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 273  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  009aa	48 8d 1d 10 00
	00 00		 lea	 rbx, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+16
  009b1	48 8d 3d 80 11
	00 00		 lea	 rdi, OFFSET FLAT:?chunkDrawThreads@@3PAVChunkDrawThread@@A+4480
  009b8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL3@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\threads.cpp

; 45   : 	if(started) thread.join();

  009c0	80 7b 08 00	 cmp	 BYTE PTR [rbx+8], 0
  009c4	c6 43 09 01	 mov	 BYTE PTR [rbx+9], 1
  009c8	74 7e		 je	 SHORT $LN2@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 83   : 		return (!_Thr_is_null(_Thr));

  009ca	83 3b 00	 cmp	 DWORD PTR [rbx], 0

; 115  : 		return (*this);
; 116  : 		}
; 117  : 
; 118  : 	_Thrd_t _Thr;
; 119  : 	};
; 120  : 
; 121  : 	namespace this_thread {
; 122  : thread::id get_id() _NOEXCEPT;
; 123  : 
; 124  : inline void yield() _NOEXCEPT
; 125  : 	{	// give up balance of time slice
; 126  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 127  : 		{	// yield, then quit
; 128  : 		::Concurrency::details::_Context::_Yield();
; 129  : 		return;
; 130  : 		}
; 131  : 	_Thrd_yield();
; 132  : 	}
; 133  : 
; 134  : inline void sleep_until(const stdext::threads::xtime *_Abs_time)
; 135  : 	{	// sleep until _Abs_time
; 136  : 	if (::Concurrency::details::_CurrentScheduler::_Id() != -1)
; 137  : 		{
; 138  : 		stdext::threads::xtime _Now;
; 139  : 		stdext::threads::xtime_get(&_Now, stdext::threads::TIME_UTC);
; 140  : 		::Concurrency::wait(_Xtime_diff_to_millis2(_Abs_time, &_Now));
; 141  : 		return;
; 142  : 		}
; 143  : 
; 144  : 	_Thrd_sleep(_Abs_time);
; 145  : 	}
; 146  : 
; 147  : template<class _Clock,
; 148  : 	class _Duration> inline
; 149  : 	void sleep_until(
; 150  : 		const chrono::time_point<_Clock, _Duration>& _Abs_time)
; 151  : 	{	// sleep until time point
; 152  : 	stdext::threads::xtime _Tgt;
; 153  : 	_Tgt.sec = chrono::duration_cast<chrono::seconds>(
; 154  : 		_Abs_time.time_since_epoch()).count();
; 155  : 	_Tgt.nsec = (long)chrono::duration_cast<chrono::nanoseconds>(
; 156  : 		_Abs_time.time_since_epoch() - chrono::seconds(_Tgt.sec)).count();
; 157  : 	sleep_until(&_Tgt);
; 158  : 	}
; 159  : 
; 160  : template<class _Rep,
; 161  : 	class _Period> inline
; 162  : 	void sleep_for(const chrono::duration<_Rep, _Period>& _Rel_time)
; 163  : 	{	// sleep for duration
; 164  : 	stdext::threads::xtime _Tgt = _To_xtime(_Rel_time);
; 165  : 	sleep_until(&_Tgt);
; 166  : 	}
; 167  : 	}	// namespace this_thread
; 168  : 
; 169  : class thread::id
; 170  : 	{	// thread id
; 171  : public:
; 172  : 	id() _NOEXCEPT
; 173  : 		{	// id for no thread
; 174  : 		_Thr_set_null(_Thr);
; 175  : 		}
; 176  : 
; 177  : 	template<class _Ch,
; 178  : 		class _Tr>
; 179  : 		basic_ostream<_Ch, _Tr>& _To_text(
; 180  : 			basic_ostream<_Ch, _Tr>& _Str)
; 181  : 		{	// insert representation into stream
; 182  : 		return (_Str << _Thr_val(_Thr));
; 183  : 		}
; 184  : 
; 185  : 	size_t hash() const
; 186  : 		{	// hash bits to size_t value by pseudorandomizing transform
; 187  : 		return (_STD hash<size_t>()((size_t)_Thr_val(_Thr)));
; 188  : 		}
; 189  : 
; 190  : private:
; 191  : 	id(const thread& _Thrd)
; 192  : 		: _Thr(_Thrd._Thr)
; 193  : 		{	// construct from thread object
; 194  : 		}
; 195  : 
; 196  : 	id(_Thrd_t _Thrd)
; 197  : 		: _Thr(_Thrd)
; 198  : 		{	// construct from thread identifier
; 199  : 		}
; 200  : 
; 201  : 	_Thrd_t _Thr;
; 202  : 
; 203  : 	friend thread::id thread::get_id() const _NOEXCEPT;
; 204  : 	friend thread::id this_thread::get_id() _NOEXCEPT;
; 205  : 	friend bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 206  : 	friend bool operator<(thread::id _Left, thread::id _Right) _NOEXCEPT;
; 207  : 	};
; 208  : 
; 209  : inline void thread::join()
; 210  : 	{	// join thread
; 211  : 	if (!joinable())

  009cd	75 19		 jne	 SHORT $LN860@WinMain

; 212  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  009cf	b9 01 00 00 00	 mov	 ecx, 1
  009d4	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error

; 213  : 	if (_Thr_is_null(_Thr))

  009d9	83 3b 00	 cmp	 DWORD PTR [rbx], 0
  009dc	75 0a		 jne	 SHORT $LN860@WinMain

; 214  : 		_Throw_Cpp_error(_INVALID_ARGUMENT);

  009de	b9 01 00 00 00	 mov	 ecx, 1
  009e3	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN860@WinMain:

; 220  : 	}
; 221  : 
; 222  : inline thread::id thread::get_id() const _NOEXCEPT
; 223  : 	{	// return id for this thread
; 224  : 	return (id(*this));
; 225  : 	}
; 226  : 
; 227  : inline thread::id this_thread::get_id() _NOEXCEPT
; 228  : 	{	// return id for current thread
; 229  : 	return (_Thrd_current());

  009e8	48 8d 8d 70 01
	00 00		 lea	 rcx, QWORD PTR $T27[rbp-256]
  009ef	e8 00 00 00 00	 call	 _Thrd_current

; 230  : 	}
; 231  : 
; 232  : inline void swap(thread& _Left, thread& _Right) _NOEXCEPT
; 233  : 	{	// swap _Left with _Right
; 234  : 	_Left.swap(_Right);
; 235  : 	}
; 236  : 
; 237  : inline bool operator==(thread::id _Left, thread::id _Right) _NOEXCEPT
; 238  : 	{	// return true if _Left and _Right identify the same thread
; 239  : 	return (_Thrd_equal(_Left._Thr, _Right._Thr));

  009f4	48 8d 95 90 00
	00 00		 lea	 rdx, QWORD PTR $T20[rbp-256]
  009fb	48 8d 4d 10	 lea	 rcx, QWORD PTR $T14[rbp-256]
  009ff	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00a02	0f 29 85 90 00
	00 00		 movaps	 XMMWORD PTR $T20[rbp-256], xmm0
  00a09	0f 10 43 f8	 movups	 xmm0, XMMWORD PTR [rbx-8]
  00a0d	0f 29 45 10	 movaps	 XMMWORD PTR $T14[rbp-256], xmm0
  00a11	e8 00 00 00 00	 call	 _Thrd_equal
  00a16	85 c0		 test	 eax, eax

; 215  : 	if (get_id() == _STD this_thread::get_id())

  00a18	74 0a		 je	 SHORT $LN859@WinMain

; 216  : 		_Throw_Cpp_error(_RESOURCE_DEADLOCK_WOULD_OCCUR);

  00a1a	b9 05 00 00 00	 mov	 ecx, 5
  00a1f	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN859@WinMain:

; 217  : 	if (_Thrd_join(_Thr, 0) != _Thrd_success)

  00a24	0f 10 43 f8	 movups	 xmm0, XMMWORD PTR [rbx-8]
  00a28	48 8d 4d 60	 lea	 rcx, QWORD PTR $T17[rbp-256]
  00a2c	33 d2		 xor	 edx, edx
  00a2e	0f 29 45 60	 movaps	 XMMWORD PTR $T17[rbp-256], xmm0
  00a32	e8 00 00 00 00	 call	 _Thrd_join
  00a37	85 c0		 test	 eax, eax
  00a39	74 0a		 je	 SHORT $LN858@WinMain

; 218  : 		_Throw_Cpp_error(_NO_SUCH_PROCESS);

  00a3b	b9 02 00 00 00	 mov	 ecx, 2
  00a40	e8 00 00 00 00	 call	 ?_Throw_Cpp_error@std@@YAXH@Z ; std::_Throw_Cpp_error
$LN858@WinMain:

; 219  : 	_Thr_set_null(_Thr);

  00a45	44 89 3b	 mov	 DWORD PTR [rbx], r15d
$LN2@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 273  : 	for(int i = 0; i < DRAW_THREAD_AMOUNT; i++)

  00a48	48 81 c3 b8 08
	00 00		 add	 rbx, 2232		; 000008b8H
  00a4f	48 3b df	 cmp	 rbx, rdi
  00a52	0f 8c 68 ff ff
	ff		 jl	 $LL3@WinMain

; 274  : 	{
; 275  : 		chunkDrawThreads[i].stop();
; 276  : 	}
; 277  : 
; 278  : 	delete GLWindow::instance;

  00a58	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00a5f	48 85 db	 test	 rbx, rbx
  00a62	0f 84 a0 00 00
	00		 je	 $LN876@WinMain
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 257  : 	if(hDC && !ReleaseDC(hWnd, hDC))

  00a68	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  00a6c	40 32 ff	 xor	 dil, dil
  00a6f	48 85 d2	 test	 rdx, rdx
  00a72	74 15		 je	 SHORT $LN884@WinMain
  00a74	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00a78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC
  00a7e	85 c0		 test	 eax, eax
  00a80	75 07		 jne	 SHORT $LN884@WinMain

; 258  : 	{
; 259  : 		hDC = NULL;

  00a82	4c 89 7b 18	 mov	 QWORD PTR [rbx+24], r15

; 260  : 		error = true;

  00a86	40 b7 01	 mov	 dil, 1
$LN884@WinMain:

; 261  : 	}
; 262  : 	if(hWnd && !DestroyWindow(hWnd))

  00a89	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00a8d	48 85 c9	 test	 rcx, rcx
  00a90	74 11		 je	 SHORT $LN883@WinMain
  00a92	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DestroyWindow
  00a98	85 c0		 test	 eax, eax
  00a9a	75 07		 jne	 SHORT $LN883@WinMain

; 263  : 	{
; 264  : 		hWnd = NULL;

  00a9c	4c 89 7b 10	 mov	 QWORD PTR [rbx+16], r15

; 265  : 		error = true;

  00aa0	40 b7 01	 mov	 dil, 1
$LN883@WinMain:

; 266  : 	}
; 267  : 	if(!UnregisterClass(L"GLWindow", hInstance))

  00aa3	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00aa7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4294910141
  00aae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnregisterClassW
  00ab4	85 c0		 test	 eax, eax
  00ab6	75 06		 jne	 SHORT $LN882@WinMain

; 268  : 	{
; 269  : 		hInstance = NULL;

  00ab8	4c 89 7b 08	 mov	 QWORD PTR [rbx+8], r15

; 270  : 		error = true;
; 271  : 	}
; 272  : 	if(error)

  00abc	eb 05		 jmp	 SHORT $LN986@WinMain
$LN882@WinMain:
  00abe	40 84 ff	 test	 dil, dil
  00ac1	74 1c		 je	 SHORT $LN881@WinMain
$LN986@WinMain:

; 273  : 	{
; 274  : 		MessageBox(NULL, L"There was an error while destroying the window", L"ERROR", MB_OK | MB_ICONINFORMATION);

  00ac3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294910140
  00aca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294910139
  00ad1	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00ad7	33 c9		 xor	 ecx, ecx
  00ad9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW
$LN881@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00adf	48 83 7b 48 08	 cmp	 QWORD PTR [rbx+72], 8
  00ae4	72 09		 jb	 SHORT $LN909@WinMain
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00ae6	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00aea	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN909@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00aef	48 c7 43 48 07
	00 00 00	 mov	 QWORD PTR [rbx+72], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00af7	4c 89 7b 40	 mov	 QWORD PTR [rbx+64], r15
  00afb	48 8b cb	 mov	 rcx, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00afe	66 44 89 7b 30	 mov	 WORD PTR [rbx+48], r15w
  00b03	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN876@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\gamestates.cpp

; 42   : 	delete GameStates::renderingState;

  00b08	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?renderingState@GameStates@@3PEAVGameState@1@EA ; GameStates::renderingState
  00b0f	48 85 c9	 test	 rcx, rcx
  00b12	74 05		 je	 SHORT $LN929@WinMain
  00b14	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN929@WinMain:

; 43   : 	delete GameStates::processedState;

  00b19	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?processedState@GameStates@@3PEAVGameState@1@EA ; GameStates::processedState
  00b20	48 85 c9	 test	 rcx, rcx
  00b23	74 05		 je	 SHORT $LN934@WinMain
  00b25	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN934@WinMain:

; 44   : 	delete GameStates::pendingState;

  00b2a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?pendingState@GameStates@@3PEAVGameState@1@EA ; GameStates::pendingState
  00b31	48 85 c9	 test	 rcx, rcx
  00b34	74 05		 je	 SHORT $LN939@WinMain
  00b36	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN939@WinMain:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 38   : 	clReleaseContext(context);

  00b3b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00b42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseContext
; File c:\users\glenn\documents\github\wind\project\wind\wind\main.cpp

; 281  : 	Blocks::destroy();

  00b48	e8 00 00 00 00	 call	 ?destroy@Blocks@@YAXXZ	; Blocks::destroy

; 282  : 	return msg.wParam;

  00b4d	8b 85 40 01 00
	00		 mov	 eax, DWORD PTR msg$[rbp-240]

; 283  : }

  00b53	4c 8d 9c 24 b0
	02 00 00	 lea	 r11, QWORD PTR [rsp+688]
  00b5b	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00b5f	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00b63	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  00b67	49 8b e3	 mov	 rsp, r11
  00b6a	41 5f		 pop	 r15
  00b6c	41 5e		 pop	 r14
  00b6e	41 5d		 pop	 r13
  00b70	41 5c		 pop	 r12
  00b72	5d		 pop	 rbp
  00b73	c3		 ret	 0
$LN997@WinMain:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thread

; 112  : 			_XSTD terminate();

  00b74	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  00b79	cc		 int	 3
$LN959@WinMain:
  00b7a	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  00b7f	cc		 int	 3
$LN957@WinMain:
  00b80	e8 00 00 00 00	 call	 ?terminate@@YAXXZ	; terminate
  00b85	cc		 int	 3
$LN996@WinMain:
WinMain	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??_GGLWindow@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GGLWindow@@QEAAPEAXI@Z PROC				; GLWindow::`scalar deleting destructor', COMDAT
$LN41:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 28   : 	destroyWindow();

  00009	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QEAAXXZ ; GLWindow::destroyWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0000e	48 83 7b 48 08	 cmp	 QWORD PTR [rbx+72], 8
  00013	72 09		 jb	 SHORT $LN28@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00015	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00019	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN28@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	33 c0		 xor	 eax, eax

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00020	48 c7 43 48 07
	00 00 00	 mov	 QWORD PTR [rbx+72], 7
  00028	48 8b cb	 mov	 rcx, rbx

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0002b	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0002f	66 89 43 30	 mov	 WORD PTR [rbx+48], ax
  00033	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00038	48 8b c3	 mov	 rax, rbx
  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
??_GGLWindow@@QEAAPEAXI@Z ENDP				; GLWindow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 898  : 		{	// construct by moving _Right

$LN104:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0000f	33 f6		 xor	 esi, esi

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00011	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 898  : 		{	// construct by moving _Right

  00019	48 8b da	 mov	 rbx, rdx

; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001c	48 89 71 10	 mov	 QWORD PTR [rcx+16], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00020	66 89 31	 mov	 WORD PTR [rcx], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 949  : 		if (_Right._Myres < this->_BUF_SIZE)

  00023	48 83 7a 18 08	 cmp	 QWORD PTR [rdx+24], 8

; 898  : 		{	// construct by moving _Right

  00028	48 8b f9	 mov	 rdi, rcx

; 949  : 		if (_Right._Myres < this->_BUF_SIZE)

  0002b	73 13		 jae	 SHORT $LN44@basic_stri

; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);

  0002d	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00031	49 ff c0	 inc	 r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 336  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));

  00034	74 13		 je	 SHORT $LN43@basic_stri
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h

; 1267 :             return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00036	4d 03 c0	 add	 r8, r8
  00039	e8 00 00 00 00	 call	 memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 952  : 		else

  0003e	eb 09		 jmp	 SHORT $LN43@basic_stri
$LN44@basic_stri:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00040	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00043	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 955  : 			_Right._Bx._Ptr = pointer();

  00046	48 89 32	 mov	 QWORD PTR [rdx], rsi
$LN43@basic_stri:

; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;

  00049	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0004d	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 958  : 		this->_Myres = _Right._Myres;

  00051	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00055	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00059	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0005d	48 c7 43 18 07
	00 00 00	 mov	 QWORD PTR [rbx+24], 7
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00065	66 89 33	 mov	 WORD PTR [rbx], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 901  : 		}

  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00072	48 8b c7	 mov	 rax, rdi
  00075	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$List@VKeyboardAction@@$0BA@@@QEAAAEAVKeyboardAction@@H@Z
_TEXT	SEGMENT
this$dead$ = 8
index$ = 16
??A?$List@VKeyboardAction@@$0BA@@@QEAAAEAVKeyboardAction@@H@Z PROC ; List<KeyboardAction,16>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A ; Keyboard::actions
  00007	48 63 c2	 movsxd	 rax, edx
  0000a	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]

; 20   : 	}

  0000e	c3		 ret	 0
??A?$List@VKeyboardAction@@$0BA@@@QEAAAEAVKeyboardAction@@H@Z ENDP ; List<KeyboardAction,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$List@VKeyboardAction@@$0BA@@@QEAAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?getSize@?$List@VKeyboardAction@@$0BA@@@QEAAHXZ PROC	; List<KeyboardAction,16>::getSize, COMDAT

; 32   : 		return count;

  00000	8b 05 80 00 00
	00		 mov	 eax, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128

; 33   : 	}

  00006	c3		 ret	 0
?getSize@?$List@VKeyboardAction@@$0BA@@@QEAAHXZ ENDP	; List<KeyboardAction,16>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@VKeyboardAction@@$0BA@@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?clear@?$List@VKeyboardAction@@$0BA@@@QEAAXXZ PROC	; List<KeyboardAction,16>::clear, COMDAT

; 37   : 		count = 0;

  00000	c7 05 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128, 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@VKeyboardAction@@$0BA@@@QEAAXXZ ENDP	; List<KeyboardAction,16>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$List@VMouseAction@@$0BA@@@QEAAAEAVMouseAction@@H@Z
_TEXT	SEGMENT
this$dead$ = 8
index$ = 16
??A?$List@VMouseAction@@$0BA@@@QEAAAEAVMouseAction@@H@Z PROC ; List<MouseAction,16>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 63 c2	 movsxd	 rax, edx
  00003	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00007	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A ; Mouse::actions
  0000e	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]

; 20   : 	}

  00012	c3		 ret	 0
??A?$List@VMouseAction@@$0BA@@@QEAAAEAVMouseAction@@H@Z ENDP ; List<MouseAction,16>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$List@VMouseAction@@$0BA@@@QEAAHXZ
_TEXT	SEGMENT
this$dead$ = 8
?getSize@?$List@VMouseAction@@$0BA@@@QEAAHXZ PROC	; List<MouseAction,16>::getSize, COMDAT

; 32   : 		return count;

  00000	8b 05 40 01 00
	00		 mov	 eax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320

; 33   : 	}

  00006	c3		 ret	 0
?getSize@?$List@VMouseAction@@$0BA@@@QEAAHXZ ENDP	; List<MouseAction,16>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@VMouseAction@@$0BA@@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?clear@?$List@VMouseAction@@$0BA@@@QEAAXXZ PROC		; List<MouseAction,16>::clear, COMDAT

; 37   : 		count = 0;

  00000	c7 05 40 01 00
	00 00 00 00 00	 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320, 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@VMouseAction@@$0BA@@@QEAAXXZ ENDP		; List<MouseAction,16>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Right$ = 72
??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::shared_ptr<ChunkBase>::operator=, COMDAT

; 609  : 		{	// construct shared_ptr object that takes resource from _Right

$LN70:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00006	45 33 c9	 xor	 r9d, r9d

; 609  : 		{	// construct shared_ptr object that takes resource from _Right

  00009	48 8b f9	 mov	 rdi, rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR $T1[rsp]

; 129  : 		}
; 130  : 
; 131  : 	long _Use_count() const
; 132  : 		{	// return use count
; 133  : 		return (_Get_uses());
; 134  : 		}
; 135  : 
; 136  : 	bool _Expired() const
; 137  : 		{	// return true if _Uses == 0
; 138  : 		return (_Get_uses() == 0);
; 139  : 		}
; 140  : 
; 141  : 	virtual void *_Get_deleter(const _XSTD2 type_info&) const
; 142  : 		{	// return address of deleter object
; 143  : 		return (0);
; 144  : 		}
; 145  : 	};
; 146  : 
; 147  : 	// TEMPLATE CLASS _Ref_count
; 148  : template<class _Ty>
; 149  : 	class _Ref_count
; 150  : 	: public _Ref_count_base
; 151  : 	{	// handle reference counting for object without deleter
; 152  : public:
; 153  : 	_Ref_count(_Ty *_Px)
; 154  : 		: _Ref_count_base(), _Ptr(_Px)
; 155  : 		{	// construct
; 156  : 		}
; 157  : 
; 158  : private:
; 159  : 	virtual void _Destroy()
; 160  : 		{	// destroy managed resource
; 161  : 		delete _Ptr;
; 162  : 		}
; 163  : 
; 164  : 	virtual void _Delete_this()
; 165  : 		{	// destroy self
; 166  : 		delete this;
; 167  : 		}
; 168  : 
; 169  : 	_Ty * _Ptr;
; 170  : 	};
; 171  : 
; 172  : 	// TEMPLATE CLASS _Ref_count_del
; 173  : template<class _Ty,
; 174  : 	class _Dx>
; 175  : 	class _Ref_count_del
; 176  : 	: public _Ref_count_base
; 177  : 	{	// handle reference counting for object with deleter
; 178  : public:
; 179  : 	_Ref_count_del(_Ty *_Px, _Dx _Dt)
; 180  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt)
; 181  : 		{	// construct
; 182  : 		}
; 183  : 
; 184  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 185  : 		{	// return address of deleter object
; 186  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 187  : 		}
; 188  : 
; 189  : private:
; 190  : 	virtual void _Destroy()
; 191  : 		{	// destroy managed resource
; 192  : 		_Dtor(_Ptr);
; 193  : 		}
; 194  : 
; 195  : 	virtual void _Delete_this()
; 196  : 		{	// destroy self
; 197  : 		delete this;
; 198  : 		}
; 199  : 
; 200  : 	_Ty * _Ptr;
; 201  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 202  : 	};
; 203  : 
; 204  : 	// TEMPLATE CLASS _Ref_count_del_alloc
; 205  : template<class _Ty,
; 206  : 	class _Dx,
; 207  : 	class _Alloc>
; 208  : 	class _Ref_count_del_alloc
; 209  : 	: public _Ref_count_base
; 210  : 	{	// handle reference counting for object with deleter and allocator
; 211  : public:
; 212  : 	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myty;
; 213  : 	typedef typename _Alloc::template rebind<_Myty>::other _Myalty;
; 214  : 
; 215  : 	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, _Myalty _Al)
; 216  : 		: _Ref_count_base(), _Ptr(_Px), _Dtor(_Dt), _Myal(_Al)
; 217  : 		{	// construct
; 218  : 		}
; 219  : 
; 220  : 	virtual void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 221  : 		{	// return address of deleter object
; 222  : 		return ((void *)(_Typeid == typeid(_Dx) ? &_Dtor : 0));
; 223  : 		}
; 224  : 
; 225  : private:
; 226  : 	virtual void _Destroy()
; 227  : 		{	// destroy managed resource
; 228  : 		_Dtor(_Ptr);
; 229  : 		}
; 230  : 
; 231  : 	virtual void _Delete_this()
; 232  : 		{	// destroy self
; 233  : 		_Myalty _Al = _Myal;
; 234  : 		_Al.destroy(this);
; 235  : 		_Al.deallocate(this, 1);
; 236  : 		}
; 237  : 
; 238  : 	_Ty * _Ptr;
; 239  : 	_Dx _Dtor;	// the stored destructor for the controlled object
; 240  : 	_Myalty _Myal;	// the stored allocator for this
; 241  : 	};
; 242  : 
; 243  : 	// DECLARATIONS
; 244  : template<class _Ty>
; 245  : 	class weak_ptr;
; 246  : template<class _Ty>
; 247  : 	class shared_ptr;
; 248  : template<class _Ty>
; 249  : 	class enable_shared_from_this;
; 250  : struct _Static_tag {};
; 251  : struct _Const_tag {};
; 252  : struct _Dynamic_tag {};
; 253  : template<class _Ty1,
; 254  : 	class _Ty2>
; 255  : 	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
; 256  : 		_Ref_count_base *);
; 257  : 
; 258  : template<class _Ty>
; 259  : 	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
; 260  : 		typename _Ty::_EStype * = 0)
; 261  : 	{	// reset internal weak pointer
; 262  : 	if (_Ptr)
; 263  : 		_Do_enable(_Ptr,
; 264  : 			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
; 265  : 	}
; 266  : 
; 267  : inline void _Enable_shared(const volatile void *, const volatile void *)
; 268  : 	{	// not derived from enable_shared_from_this; do nothing
; 269  : 	}
; 270  : 
; 271  : 	// TEMPLATE CLASS _Ptr_base
; 272  : template<class _Ty>
; 273  : 	class _Ptr_base
; 274  : 	{	// base class for shared_ptr and weak_ptr
; 275  : public:
; 276  : 	typedef _Ptr_base<_Ty> _Myt;
; 277  : 	typedef _Ty _Elem;
; 278  : 	typedef _Elem element_type;
; 279  : 
; 280  : 	_Ptr_base()
; 281  : 		: _Ptr(0), _Rep(0)
; 282  : 		{	// construct
; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00011	41 8b c1	 mov	 eax, r9d
  00014	45 8b c1	 mov	 r8d, r9d
  00017	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0001c	48 3b ca	 cmp	 rcx, rdx
  0001f	74 13		 je	 SHORT $LN26@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00021	4c 8b 42 08	 mov	 r8, QWORD PTR [rdx+8]

; 49   : 	_Right = _Move(_Tmp);

  00025	4c 89 4a 08	 mov	 QWORD PTR [rdx+8], r9

; 48   : 	_Left = _Move(_Right);

  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax

; 49   : 	_Right = _Move(_Tmp);

  00031	4c 89 0a	 mov	 QWORD PTR [rdx], r9
$LN26@operator:

; 48   : 	_Left = _Move(_Right);

  00034	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]

; 49   : 	_Right = _Move(_Tmp);

  00038	4c 89 47 08	 mov	 QWORD PTR [rdi+8], r8
  0003c	48 89 07	 mov	 QWORD PTR [rdi], rax

; 48   : 	_Left = _Move(_Right);

  0003f	48 89 4c 24 28	 mov	 QWORD PTR $T1[rsp+8], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00044	48 85 c9	 test	 rcx, rcx
  00047	74 41		 je	 SHORT $LN67@operator

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00049	f0 ff 49 08	 lock dec DWORD PTR [rcx+8]
  0004d	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00052	75 28		 jne	 SHORT $LN66@operator
  00054	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00059	48 8b 5c 24 28	 mov	 rbx, QWORD PTR $T1[rsp+8]
  0005e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00061	48 8b cb	 mov	 rcx, rbx
  00064	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00066	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0006a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006f	75 0b		 jne	 SHORT $LN66@operator

; 128  : 			_Delete_this();

  00071	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp+8]
  00076	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00079	ff 50 08	 call	 QWORD PTR [rax+8]
$LN66@operator:

; 610  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 611  : 		return (*this);

  0007c	48 8b c7	 mov	 rax, rdi
  0007f	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]

; 612  : 		}

  00084	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
$LN67@operator:

; 610  : 		shared_ptr(_STD move(_Right)).swap(*this);
; 611  : 		return (*this);

  0008a	48 8b c7	 mov	 rax, rdi

; 612  : 		}

  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
??4?$shared_ptr@VChunkBase@@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::shared_ptr<ChunkBase>::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv, COMDAT

; 948  : 		{	// assign by moving _Right

$LN62:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 949  : 		if (_Right._Myres < this->_BUF_SIZE)

  0000f	33 f6		 xor	 esi, esi
  00011	48 83 7a 18 08	 cmp	 QWORD PTR [rdx+24], 8
  00016	48 8b da	 mov	 rbx, rdx
  00019	48 8b f9	 mov	 rdi, rcx
  0001c	73 13		 jae	 SHORT $LN2@Assign_rv

; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);

  0001e	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00022	49 ff c0	 inc	 r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 336  : 			: (_Elem *)_CSTD wmemmove(_First1, _First2, _Count));

  00025	74 18		 je	 SHORT $LN1@Assign_rv
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\wchar.h

; 1267 :             return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));

  00027	4d 03 c0	 add	 r8, r8
  0002a	e8 00 00 00 00	 call	 memmove
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 952  : 		else

  0002f	eb 0e		 jmp	 SHORT $LN1@Assign_rv
$LN2@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00031	48 85 c9	 test	 rcx, rcx
  00034	74 06		 je	 SHORT $LN23@Assign_rv
  00036	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN23@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 955  : 			_Right._Bx._Ptr = pointer();

  0003c	48 89 32	 mov	 QWORD PTR [rdx], rsi
$LN1@Assign_rv:

; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;

  0003f	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  00043	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 958  : 		this->_Myres = _Right._Myres;

  00047	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0004b	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0004f	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 2219 : 		}
; 2220 : 
; 2221 : 	bool _Grow(size_type _Newsize,
; 2222 : 		bool _Trim = false)
; 2223 : 		{	// ensure buffer is big enough, trim to size if _Trim is true
; 2224 : 		if (max_size() < _Newsize)
; 2225 : 			_Xlen();	// result too long
; 2226 : 		if (this->_Myres < _Newsize)
; 2227 : 			_Copy(_Newsize, this->_Mysize);	// reallocate to grow
; 2228 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2229 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2230 : 				_Newsize < this->_Mysize ? _Newsize : this->_Mysize);
; 2231 : 		else if (_Newsize == 0)
; 2232 : 			_Eos(0);	// new size is zero, just null terminate
; 2233 : 		return (0 < _Newsize);	// return true only if more work to do
; 2234 : 		}
; 2235 : 
; 2236 : 	bool _Inside(const _Elem *_Ptr)
; 2237 : 		{	// test if _Ptr points inside string
; 2238 : 		if (_Ptr == 0 || _Ptr < this->_Myptr()
; 2239 : 			|| this->_Myptr() + this->_Mysize <= _Ptr)
; 2240 : 			return (false);	// don't ask
; 2241 : 		else
; 2242 : 			return (true);
; 2243 : 		}
; 2244 : 
; 2245 : 	static size_type _Pdif(const_iterator _P2,
; 2246 : 		const_iterator _P1)
; 2247 : 		{	// compute safe iterator difference
; 2248 : 		return (_STRING_ITER_BASE(_P2) == 0 ? 0 : _P2 - _P1);
; 2249 : 		}
; 2250 : 
; 2251 : 	void _Tidy(bool _Built = false,
; 2252 : 		size_type _Newsize = 0)
; 2253 : 		{	// initialize buffer, deallocating any storage
; 2254 : 		if (!_Built)
; 2255 : 			;
; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)
; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00053	48 c7 43 18 07
	00 00 00	 mov	 QWORD PTR [rbx+24], 7
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0005b	66 89 33	 mov	 WORD PTR [rbx], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 960  : 		}

  0005e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00063	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX$$QEAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z
_TEXT	SEGMENT
this$ = 48
_Px$ = 56
??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>, COMDAT

; 485  : 		explicit shared_ptr(_Ux *_Px)

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 282  : 		{	// construct

  00006	33 c0		 xor	 eax, eax

; 485  : 		explicit shared_ptr(_Ux *_Px)

  00008	48 8b d9	 mov	 rbx, rcx

; 282  : 		{	// construct

  0000b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 486  : 		{	// construct shared_ptr object that owns _Px
; 487  : 		_Resetp(_Px);

  00012	e8 00 00 00 00	 call	 ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>

; 488  : 		}

  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
??$?0VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAA@PEAVChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase><Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string
;	COMDAT ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
_Left$dead$ = 72
_Right$dead$ = 80
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z PROC ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 66   : 	{	// return string + NTCS

$LN77:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0001d	48 8b d9	 mov	 rbx, rcx
  00020	33 f6		 xor	 esi, esi
  00022	89 74 24 20	 mov	 DWORD PTR $T1[rsp], esi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00026	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0002e	48 89 71 10	 mov	 QWORD PTR [rcx+16], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00032	66 89 31	 mov	 WORD PTR [rcx], si
  00035	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string

; 68   : 	_Ans.reserve(_Left.size() + _Traits::length(_Right));

  0003d	48 8b 15 10 00
	00 00		 mov	 rdx, QWORD PTR ?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A+16
  00044	48 83 c2 17	 add	 rdx, 23
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

  00048	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]
  0004c	48 3b fa	 cmp	 rdi, rdx
  0004f	77 29		 ja	 SHORT $LN63@operator
  00051	48 39 51 18	 cmp	 QWORD PTR [rcx+24], rdx
  00055	74 23		 je	 SHORT $LN63@operator

; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))

  00057	41 b0 01	 mov	 r8b, 1
  0005a	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_N_K_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  0005f	84 c0		 test	 al, al
  00061	74 17		 je	 SHORT $LN63@operator

; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00063	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 517  : 			: this->_Bx._Buf);

  00067	48 83 7b 18 08	 cmp	 QWORD PTR [rbx+24], 8
  0006c	72 05		 jb	 SHORT $LN59@operator
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  0006e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 517  : 			: this->_Bx._Buf);

  00071	eb 03		 jmp	 SHORT $LN60@operator
$LN59@operator:
  00073	48 8b c3	 mov	 rax, rbx
$LN60@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00076	66 89 34 78	 mov	 WORD PTR [rax+rdi*2], si
$LN63@operator:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1014 : 		return (append(_Right, 0, npos));

  0007a	49 83 c9 ff	 or	 r9, -1
  0007e	45 33 c0	 xor	 r8d, r8d
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  00088	48 8b cb	 mov	 rcx, rbx
  0008b	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00090	41 b8 17 00 00
	00		 mov	 r8d, 23
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294915917
  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\string

; 71   : 	return (_Ans);

  000a5	48 8b c3	 mov	 rax, rbx

; 72   : 	}

  000a8	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000ad	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000b2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b6	5f		 pop	 rdi
  000b7	c3		 ret	 0
  000b8	cc		 int	 3
??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z ENDP ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
__$ReturnUdt$ = 64
_Left$dead$ = 72
_Right$dead$ = 80
?dtor$0@?0???$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z@4HA PROC ; `std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEBV10@PEB_W@Z@4HA ENDP ; `std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z PROC ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QEAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AEAV10@@Z ENDP ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$move@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z PROC ; std::move<std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 1791 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1792 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ENDP ; std::move<std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=, COMDAT

; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));

  00000	49 83 c9 ff	 or	 r9, -1
  00004	45 33 c0	 xor	 r8d, r8d
  00007	e9 00 00 00 00	 jmp	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcap$ = 56
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve, COMDAT

; 1761 : 		{	// determine new minimum length of allocated storage

$LN16:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)

  0000a	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	48 3b fa	 cmp	 rdi, rdx
  00014	77 26		 ja	 SHORT $LN13@reserve
  00016	48 39 51 18	 cmp	 QWORD PTR [rcx+24], rdx
  0001a	74 20		 je	 SHORT $LN13@reserve

; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))

  0001c	41 b0 01	 mov	 r8b, 1
  0001f	e8 00 00 00 00	 call	 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA_N_K_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Grow
  00024	84 c0		 test	 al, al
  00026	74 14		 je	 SHORT $LN13@reserve

; 517  : 			: this->_Bx._Buf);

  00028	48 83 7b 18 08	 cmp	 QWORD PTR [rbx+24], 8

; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0002d	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 517  : 			: this->_Bx._Buf);

  00031	72 03		 jb	 SHORT $LN9@reserve
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00033	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN9@reserve:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00036	33 c0		 xor	 eax, eax
  00038	66 89 04 7b	 mov	 WORD PTR [rbx+rdi*2], ax
$LN13@reserve:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1768 : 		}

  0003c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5f		 pop	 rdi
  00046	c3		 ret	 0
?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT

; 1014 : 		return (append(_Right, 0, npos));

  00000	49 83 c9 ff	 or	 r9, -1
  00004	45 33 c0	 xor	 r8d, r8d
  00007	e9 00 00 00 00	 jmp	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>, COMDAT

; 708  : 		void _Resetp(_Ux *_Px)

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 709  : 		{	// release, take ownership of _Px
; 710  : 		_TRY_BEGIN	// allocate control block and reset
; 711  : 		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));

  0001e	b9 18 00 00 00	 mov	 ecx, 24
  00023	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00028	48 85 c0	 test	 rax, rax
  0002b	74 1c		 je	 SHORT $LN5@Resetp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  0002d	c7 40 08 01 00
	00 00		 mov	 DWORD PTR [rax+8], 1
  00034	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7?$_Ref_count@VChunk@@@std@@6B@
  00042	48 89 08	 mov	 QWORD PTR [rax], rcx
  00045	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
$LN5@Resetp:

; 717  : 
; 718  : 	template<class _Ux,
; 719  : 		class _Dx>
; 720  : 		void _Resetp(_Ux *_Px, _Dx _Dt)
; 721  : 		{	// release, take ownership of _Px, deleter _Dt
; 722  : 		_TRY_BEGIN	// allocate control block and reset
; 723  : 		_Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
; 724  : 		_CATCH_ALL	// allocation failed, delete resource
; 725  : 		_Dt(_Px);
; 726  : 		_RERAISE;
; 727  : 		_CATCH_END
; 728  : 		}
; 729  : 
; 730  : //#if _HAS_CPP0X
; 731  : 	template<class _Ux,
; 732  : 		class _Dx,
; 733  : 		class _Alloc>
; 734  : 		void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
; 735  : 		{	// release, take ownership of _Px, deleter _Dt, allocator _Ax
; 736  : 		typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
; 737  : 		typename _Alloc::template rebind<_Refd>::other _Al = _Ax;
; 738  : 
; 739  : 		_TRY_BEGIN	// allocate control block and reset
; 740  : 		_Refd *_Ptr = _Al.allocate(1);
; 741  : 		::new (_Ptr) _Refd(_Px, _Dt, _Al);
; 742  : 		_Resetp0(_Px, _Ptr);
; 743  : 		_CATCH_ALL	// allocation failed, delete resource
; 744  : 		_Dt(_Px);
; 745  : 		_RERAISE;
; 746  : 		_CATCH_END
; 747  : 		}
; 748  : //#endif /* _HAS_CPP0X */
; 749  : 
; 750  : public:
; 751  : 	template<class _Ux>
; 752  : 		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00049	4c 8b c0	 mov	 r8, rax
  0004c	48 8b d3	 mov	 rdx, rbx
  0004f	48 8b cf	 mov	 rcx, rdi
  00052	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
  00057	90		 npad	 1

; 712  : 		_CATCH_ALL	// allocation failed, delete resource
; 713  : 		delete _Px;
; 714  : 		_RERAISE;
; 715  : 		_CATCH_END
; 716  : 		}

  00058	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN30@Resetp:
??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp<Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Px$ = 72
?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA PROC ; `std::shared_ptr<ChunkBase>::_Resetp<Chunk>'::`1'::catch$0

; 712  : 		_CATCH_ALL	// allocation failed, delete resource

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000b	48 8b ea	 mov	 rbp, rdx
__catch$??$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z$0:

; 713  : 		delete _Px;

  0000e	48 8b 5d 48	 mov	 rbx, QWORD PTR _Px$[rbp]
  00012	48 85 db	 test	 rbx, rbx
  00015	74 1a		 je	 SHORT $LN25@catch$0
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 150  : {

  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  0001e	48 89 03	 mov	 QWORD PTR [rbx], rax

; 151  : 
; 152  : }

  00021	48 8b cb	 mov	 rcx, rbx
  00024	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00029	48 8b cb	 mov	 rcx, rbx
  0002c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN25@catch$0:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 714  : 		_RERAISE;

  00031	33 d2		 xor	 edx, edx
  00033	33 c9		 xor	 ecx, ecx
  00035	e8 00 00 00 00	 call	 _CxxThrowException
  0003a	90		 npad	 1
?catch$0@?0???$_Resetp@VChunk@@@?$shared_ptr@VChunkBase@@@std@@AEAAXPEAVChunk@@@Z@4HA ENDP ; `std::shared_ptr<ChunkBase>::_Resetp<Chunk>'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
;	COMDAT ??_GChunk@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GChunk@@QEAAPEAXI@Z PROC				; Chunk::`scalar deleting destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 150  : {

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax

; 151  : 
; 152  : }

  00013	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00018	48 8b cb	 mov	 rcx, rbx
  0001b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00020	48 8b c3	 mov	 rax, rbx
  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??_GChunk@@QEAAPEAXI@Z ENDP				; Chunk::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ref_count@VChunk@@@std@@QEAA@PEAVChunk@@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
??0?$_Ref_count@VChunk@@@std@@QEAA@PEAVChunk@@@Z PROC	; std::_Ref_count<Chunk>::_Ref_count<Chunk>, COMDAT

; 155  : 		{	// construct

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$_Ref_count@VChunk@@@std@@6B@
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xatomic0.h

; 219  : 	_Counter = _Value;

  00007	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [rcx+8], 1
  0000e	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [rcx+12], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 155  : 		{	// construct

  00015	48 89 01	 mov	 QWORD PTR [rcx], rax

; 156  : 		}

  00018	48 8b c1	 mov	 rax, rcx
  0001b	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  0001f	c3		 ret	 0
??0?$_Ref_count@VChunk@@@std@@QEAA@PEAVChunk@@@Z ENDP	; std::_Ref_count<Chunk>::_Ref_count<Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ PROC	; std::_Ref_count<Chunk>::_Destroy, COMDAT

; 160  : 		{	// destroy managed resource

$LN11:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 161  : 		delete _Ptr;

  00006	48 8b 59 10	 mov	 rbx, QWORD PTR [rcx+16]
  0000a	48 85 db	 test	 rbx, rbx
  0000d	74 1f		 je	 SHORT $LN5@Destroy
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 150  : {

  0000f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Chunk@@6B@

; 151  : 
; 152  : }

  00016	48 8b cb	 mov	 rcx, rbx
  00019	48 89 03	 mov	 QWORD PTR [rbx], rax
  0001c	e8 00 00 00 00	 call	 ??1ChunkBase@@QEAA@XZ	; ChunkBase::~ChunkBase
  00021	48 8b cb	 mov	 rcx, rbx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 162  : 		}

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
$LN5@Destroy:
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
?_Destroy@?$_Ref_count@VChunk@@@std@@EEAAXXZ ENDP	; std::_Ref_count<Chunk>::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ PROC	; std::_Ref_count<Chunk>::_Delete_this, COMDAT

; 166  : 		delete this;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 0c		 je	 SHORT $LN3@Delete_thi
  00005	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00008	ba 01 00 00 00	 mov	 edx, 1
  0000d	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
$LN3@Delete_thi:

; 167  : 		}

  00011	f3 c3		 fatret	 0
?_Delete_this@?$_Ref_count@VChunk@@@std@@EEAAXXZ ENDP	; std::_Ref_count<Chunk>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z PROC		; std::_Ref_count<Chunk>::`scalar deleting destructor', COMDAT
$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 89 01	 mov	 QWORD PTR [rcx], rax
  00013	f6 c2 01	 test	 dl, 1
  00016	74 05		 je	 SHORT $LN8@scalar
  00018	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN8@scalar:
  0001d	48 8b c3	 mov	 rax, rbx
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5b		 pop	 rbx
  00025	c3		 ret	 0
??_G?$_Ref_count@VChunk@@@std@@UEAAPEAXI@Z ENDP		; std::_Ref_count<Chunk>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??1?$_Ref_count@VChunk@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Ref_count@VChunk@@@std@@UEAA@XZ PROC		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>, COMDAT

; 69   : 		{	// ensure that derived classes can be destroyed properly

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7_Ref_count_base@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	c3		 ret	 0
??1?$_Ref_count@VChunk@@@std@@UEAA@XZ ENDP		; std::_Ref_count<Chunk>::~_Ref_count<Chunk>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVChunk@@PEAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
this$ = 8
_Px$ = 16
_Rx$ = 24
??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVChunk@@PEAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>, COMDAT

; 753  : 		{	// release resource and take ownership of _Px
; 754  : 		this->_Reset0(_Px, _Rx);

  00000	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
??$_Resetp0@VChunk@@@?$shared_ptr@VChunkBase@@@std@@QEAAXPEAVChunk@@PEAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<ChunkBase>::_Resetp0<Chunk>
_TEXT	ENDS
END
