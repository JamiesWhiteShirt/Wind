; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?wglSwapIntervalEXT@@3P6APEAUHGLRC__@@H@ZEA	; wglSwapIntervalEXT
PUBLIC	?wglCreateContextAttribsARB@@3P6APEAUHGLRC__@@PEAUHDC__@@PEAU1@PEBH@ZEA ; wglCreateContextAttribsARB
PUBLIC	?instance@GLWindow@@2PEAV1@EA			; GLWindow::instance
EXTRN	__imp_wglDeleteContext:PROC
EXTRN	__imp_DestroyWindow:PROC
EXTRN	__imp_PostQuitMessage:PROC
EXTRN	__imp_GetRawInputData:PROC
EXTRN	__imp_UnregisterClassW:PROC
EXTRN	mbstowcs_s:PROC
EXTRN	__imp_SetForegroundWindow:PROC
EXTRN	__imp_LoadCursorW:PROC
EXTRN	__imp_SetFocus:PROC
EXTRN	__imp_GetDC:PROC
EXTRN	__imp_LoadIconW:PROC
EXTRN	__imp_wglMakeCurrent:PROC
EXTRN	__imp_ReleaseDC:PROC
EXTRN	__imp_ShowWindow:PROC
EXTRN	__imp_RegisterRawInputDevices:PROC
EXTRN	__imp_CreateWindowExW:PROC
EXTRN	__imp_AdjustWindowRectEx:PROC
EXTRN	__imp_MessageBoxW:PROC
EXTRN	__imp_RegisterClassW:PROC
EXTRN	__imp_ChoosePixelFormat:PROC
EXTRN	__imp_SetPixelFormat:PROC
EXTRN	__imp_SwapBuffers:PROC
EXTRN	__imp_DefWindowProcW:PROC
EXTRN	__imp_wglCreateContext:PROC
	ALIGN	8

?wglSwapIntervalEXT@@3P6APEAUHGLRC__@@H@ZEA DQ 01H DUP (?) ; wglSwapIntervalEXT
?wglCreateContextAttribsARB@@3P6APEAUHGLRC__@@PEAUHDC__@@PEAU1@PEBH@ZEA DQ 01H DUP (?) ; wglCreateContextAttribsARB
?instance@GLWindow@@2PEAV1@EA DQ 01H DUP (?)		; GLWindow::instance
_BSS	ENDS
;	COMDAT ?pfd@?7??initWindow@GLWindow@@QEAAXXZ@4UtagPIXELFORMATDESCRIPTOR@@A
_DATA	SEGMENT
?pfd@?7??initWindow@GLWindow@@QEAAXXZ@4UtagPIXELFORMATDESCRIPTOR@@A DW 028H ; `GLWindow::initWindow'::`8'::pfd
	DW	01H
	DD	025H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DD	00H
	DD	00H
	DD	00H
$SG4294909300 DB 'G', 00H, 'L', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 00H, 00H
	ORG $+6
$SG4294909299 DB 'R', 00H, 'e', 00H, 'g', 00H, 'i', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, 00H, 00H
	ORG $+10
$SG4294909298 DB 'C', 00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, ' ', 00H
	DB	'n', 00H, 'o', 00H, 't', 00H, ' ', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'i', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, ' '
	DB	00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, '.', 00H
	DB	00H, 00H
	ORG $+6
$SG4294909297 DB 'G', 00H, 'L', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 00H, 00H
	ORG $+6
$SG4294909296 DB 'wglCreateContextAttribsARB', 00H
	ORG $+5
$SG4294909295 DB 'wglSwapIntervalEXT', 00H
	ORG $+5
$SG4294909294 DB 'G', 00H, 'L', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 00H, 00H
	ORG $+6
$SG4294909293 DB 'E', 00H, 'R', 00H, 'R', 00H, 'O', 00H, 'R', 00H, 00H, 00H
	ORG $+4
$SG4294909292 DB 'T', 00H, 'h', 00H, 'e', 00H, 'r', 00H, 'e', 00H, ' ', 00H
	DB	'w', 00H, 'a', 00H, 's', 00H, ' ', 00H, 'a', 00H, 'n', 00H, ' '
	DB	00H, 'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'w', 00H, 'h', 00H, 'i', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'd'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'r', 00H, 'o', 00H, 'y', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 't', 00H, 'h', 00H, 'e'
	DB	00H, ' ', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 00H, 00H
PUBLIC	?put@?$List@VMouseAction@@$0BA@@@QEAAXVMouseAction@@@Z ; List<MouseAction,16>::put
PUBLIC	?put@?$List@VKeyboardAction@@$0BA@@@QEAAXVKeyboardAction@@@Z ; List<KeyboardAction,16>::put
PUBLIC	?wndProc@@YA_JPEAUHWND__@@I_K_J@Z		; wndProc
PUBLIC	?destroyWindow@GLWindow@@QEAAXXZ		; GLWindow::destroyWindow
PUBLIC	?messageBox@GLWindow@@QEAAXPEB_W0I@Z		; GLWindow::messageBox
PUBLIC	?initWindow@GLWindow@@QEAAXXZ			; GLWindow::initWindow
PUBLIC	??1GLWindow@@QEAA@XZ				; GLWindow::~GLWindow
PUBLIC	??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z ; GLWindow::GLWindow
PUBLIC	?isOK@GLWindow@@QEAA_NXZ			; GLWindow::isOK
PUBLIC	?destroyGL@GLWindow@@QEAAXXZ			; GLWindow::destroyGL
PUBLIC	?swapBuffers@GLWindow@@QEAAXXZ			; GLWindow::swapBuffers
PUBLIC	?initGL@GLWindow@@QEAAXXZ			; GLWindow::initGL
PUBLIC	?postError@GLWindow@@QEAAXPEBD0@Z		; GLWindow::postError
_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

allocator_arg DB 01H DUP (?)
	ALIGN	4

piecewise_construct DB 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?wndProc@@YA_JPEAUHWND__@@I_K_J@Z DD imagerel $LN189
	DD	imagerel $LN189+1321
	DD	imagerel $unwind$?wndProc@@YA_JPEAUHWND__@@I_K_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?destroyWindow@GLWindow@@QEAAXXZ DD imagerel $LN9
	DD	imagerel $LN9+155
	DD	imagerel $unwind$?destroyWindow@GLWindow@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initWindow@GLWindow@@QEAAXXZ DD imagerel $LN19
	DD	imagerel $LN19+472
	DD	imagerel $unwind$?initWindow@GLWindow@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1GLWindow@@QEAA@XZ DD imagerel $LN38
	DD	imagerel $LN38+54
	DD	imagerel $unwind$??1GLWindow@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z DD imagerel $LN83
	DD	imagerel $LN83+187
	DD	imagerel $unwind$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?destroyGL@GLWindow@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+52
	DD	imagerel $unwind$?destroyGL@GLWindow@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?initGL@GLWindow@@QEAAXXZ DD imagerel $LN17
	DD	imagerel $LN17+361
	DD	imagerel $unwind$?initGL@GLWindow@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?postError@GLWindow@@QEAAXPEBD0@Z DD imagerel $LN8
	DD	imagerel $LN8+242
	DD	imagerel $unwind$?postError@GLWindow@@QEAAXPEBD0@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?postError@GLWindow@@QEAAXPEBD0@Z DD 0c1c01H
	DD	0e641cH
	DD	0d541cH
	DD	0c341cH
	DD	0f018521cH
	DD	0d014e016H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initGL@GLWindow@@QEAAXXZ DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?destroyGL@GLWindow@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z DD imagerel ??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z
	DD	0ffffffffH
	DD	imagerel ??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z+51
	DD	00H
	DD	imagerel ??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z+125
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z DD 062819H
	DD	0d6419H
	DD	0c3414H
	DD	070027206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z
	DD	032H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1GLWindow@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?initWindow@GLWindow@@QEAAXXZ DD 072519H
	DD	01f7417H
	DD	01e3417H
	DD	01c0117H
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?destroyWindow@GLWindow@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?wndProc@@YA_JPEAUHWND__@@I_K_J@Z DD 082319H
	DD	0130115H
	DD	0e007f009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck
	DD	080H
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?postError@GLWindow@@QEAAXPEBD0@Z
_TEXT	SEGMENT
this$dead$ = 96
text$ = 104
caption$ = 112
?postError@GLWindow@@QEAAXPEBD0@Z PROC			; GLWindow::postError, COMDAT

; 216  : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001c	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance

; 217  : 	size_t lText = strlen(text);

  00023	49 83 cc ff	 or	 r12, -1
  00027	4d 8b f8	 mov	 r15, r8
  0002a	49 8b dc	 mov	 rbx, r12
  0002d	48 8b ea	 mov	 rbp, rdx
$LL6@postError:
  00030	48 ff c3	 inc	 rbx
  00033	80 3c 13 00	 cmp	 BYTE PTR [rbx+rdx], 0
  00037	75 f7		 jne	 SHORT $LL6@postError

; 218  : 	wchar_t* wText = new wchar_t[lText + 1];

  00039	48 8d 7b 01	 lea	 rdi, QWORD PTR [rbx+1]
  0003d	b8 02 00 00 00	 mov	 eax, 2
  00042	48 f7 e7	 mul	 rdi
  00045	49 0f 40 c4	 cmovo	 rax, r12
  00049	48 8b c8	 mov	 rcx, rax
  0004c	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]

; 219  : 	mbstowcs_s(NULL, wText, lText + 1, text, lText);

  00051	4c 8b cd	 mov	 r9, rbp
  00054	4c 8b c7	 mov	 r8, rdi
  00057	33 c9		 xor	 ecx, ecx
  00059	48 8b d0	 mov	 rdx, rax
  0005c	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00061	4c 8b f0	 mov	 r14, rax
  00064	e8 00 00 00 00	 call	 mbstowcs_s

; 220  : 
; 221  : 	size_t lCap = strlen(text);

  00069	49 8b f4	 mov	 rsi, r12
  0006c	0f 1f 40 00	 npad	 4
$LL5@postError:
  00070	48 ff c6	 inc	 rsi
  00073	80 3c 2e 00	 cmp	 BYTE PTR [rsi+rbp], 0
  00077	75 f7		 jne	 SHORT $LL5@postError

; 222  : 	wchar_t* wCap = new wchar_t[lCap + 1];

  00079	48 8d 5e 01	 lea	 rbx, QWORD PTR [rsi+1]
  0007d	b8 02 00 00 00	 mov	 eax, 2
  00082	48 f7 e3	 mul	 rbx
  00085	49 0f 40 c4	 cmovo	 rax, r12
  00089	48 8b c8	 mov	 rcx, rax
  0008c	e8 00 00 00 00	 call	 ??_U@YAPEAX_K@Z		; operator new[]

; 223  : 	mbstowcs_s(NULL, wCap, lCap + 1, caption, lCap);

  00091	4d 8b cf	 mov	 r9, r15
  00094	4c 8b c3	 mov	 r8, rbx
  00097	33 c9		 xor	 ecx, ecx
  00099	48 8b d0	 mov	 rdx, rax
  0009c	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  000a1	48 8b f8	 mov	 rdi, rax
  000a4	e8 00 00 00 00	 call	 mbstowcs_s

; 212  : 	MessageBox(hWnd, lpText, lpCaption, uType);

  000a9	49 8b 4d 10	 mov	 rcx, QWORD PTR [r13+16]
  000ad	41 b9 10 00 00
	00		 mov	 r9d, 16
  000b3	4c 8b c7	 mov	 r8, rdi
  000b6	49 8b d6	 mov	 rdx, r14
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 224  : 
; 225  : 	messageBox(wText, wCap, MB_OK | MB_ICONERROR);
; 226  : 
; 227  : 	GlobalThread::stop = true;
; 228  : 
; 229  : 	delete wText;

  000bf	49 8b ce	 mov	 rcx, r14
  000c2	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
  000c9	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete

; 230  : 	delete wCap;

  000ce	48 8b cf	 mov	 rcx, rdi

; 231  : }

  000d1	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000d6	48 8b 6c 24 68	 mov	 rbp, QWORD PTR [rsp+104]
  000db	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  000e0	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e4	41 5f		 pop	 r15
  000e6	41 5e		 pop	 r14
  000e8	41 5d		 pop	 r13
  000ea	41 5c		 pop	 r12
  000ec	5f		 pop	 rdi

; 230  : 	delete wCap;

  000ed	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?postError@GLWindow@@QEAAXPEBD0@Z ENDP			; GLWindow::postError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\glew.c
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?initGL@GLWindow@@QEAAXXZ
_TEXT	SEGMENT
attribs$ = 32
__$ArrayPad$ = 64
this$dead$ = 96
?initGL@GLWindow@@QEAAXXZ PROC				; GLWindow::initGL, COMDAT

; 131  : {

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00015	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance

; 132  : 	if(!(hRC_temp = wglCreateContext(hDC)))

  0001c	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglCreateContext
  00026	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax
  0002a	48 85 c0	 test	 rax, rax
  0002d	75 1e		 jne	 SHORT $LN7@initGL
$LN15@initGL:

; 133  : 	{
; 134  : 		OK = false;
; 135  : 		destroyWindow();

  0002f	48 8b cb	 mov	 rcx, rbx
  00032	c6 03 00	 mov	 BYTE PTR [rbx], 0
  00035	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QEAAXXZ ; GLWindow::destroyWindow

; 185  : 		//destroyWindow();
; 186  : 		return;
; 187  : 	}
; 188  : }

  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0003f	48 33 cc	 xor	 rcx, rsp
  00042	e8 00 00 00 00	 call	 __security_check_cookie
  00047	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0004b	5b		 pop	 rbx
  0004c	c3		 ret	 0
$LN7@initGL:

; 136  : 		return;
; 137  : 	}
; 138  : 
; 139  : 	if(!wglMakeCurrent(hDC, hRC_temp))

  0004d	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00051	48 8b d0	 mov	 rdx, rax
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglMakeCurrent
  0005a	85 c0		 test	 eax, eax
  0005c	74 d1		 je	 SHORT $LN15@initGL

; 140  : 	{
; 141  : 		OK = false;
; 142  : 		destroyWindow();
; 143  : 		return;
; 144  : 	}
; 145  : 
; 146  : 	ShowWindow(hWnd, SW_SHOW);

  0005e	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00062	ba 05 00 00 00	 mov	 edx, 5
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ShowWindow

; 147  : 	SetForegroundWindow(hWnd);

  0006d	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetForegroundWindow

; 148  : 	SetFocus(hWnd);

  00077	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetFocus
; File c:\users\glenn\documents\github\wind\project\wind\wind\glew.c

; 13482:   r = glewContextInit();

  00081	e8 00 00 00 00	 call	 glewContextInit

; 13483:   if ( r != 0 ) return r;

  00086	85 c0		 test	 eax, eax
  00088	75 a5		 jne	 SHORT $LN15@initGL

; 13484: #if defined(_WIN32)
; 13485:   return wglewContextInit();

  0008a	e8 00 00 00 00	 call	 wglewContextInit
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 150  : 	if(glewInit() != GLEW_OK)

  0008f	85 c0		 test	 eax, eax
  00091	75 9c		 jne	 SHORT $LN15@initGL

; 151  : 	{
; 152  : 		OK = false;
; 153  : 		destroyWindow();
; 154  : 		return;
; 155  : 	}
; 156  : 
; 157  : 	if((major_gl_version > 1) | (minor_gl_version > 2))

  00093	44 8b 43 5c	 mov	 r8d, DWORD PTR [rbx+92]
  00097	8b 53 60	 mov	 edx, DWORD PTR [rbx+96]
  0009a	45 33 c9	 xor	 r9d, r9d
  0009d	41 83 f8 01	 cmp	 r8d, 1
  000a1	41 8b c9	 mov	 ecx, r9d
  000a4	41 8b c1	 mov	 eax, r9d
  000a7	0f 9f c1	 setg	 cl
  000aa	83 fa 02	 cmp	 edx, 2
  000ad	0f 9f c0	 setg	 al
  000b0	0b c8		 or	 ecx, eax
  000b2	0f 85 9e 00 00
	00		 jne	 $LN2@initGL

; 158  : 	{
; 159  : 		return;
; 160  : 	}
; 161  : 
; 162  : 	int attribs[] =
; 163  : 	{
; 164  : 		WGL_CONTEXT_MAJOR_VERSION_ARB, major_gl_version,
; 165  : 		WGL_CONTEXT_MINOR_VERSION_ARB, minor_gl_version,
; 166  : 		WGL_CONTEXT_FLAGS_ARB, 0,
; 167  : 		0
; 168  : 	};
; 169  : 
; 170  : 	wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)wglGetProcAddress((LPCSTR)"wglCreateContextAttribsARB");

  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4294909296
  000bf	c7 44 24 20 91
	20 00 00	 mov	 DWORD PTR attribs$[rsp], 8337 ; 00002091H
  000c7	44 89 44 24 24	 mov	 DWORD PTR attribs$[rsp+4], r8d
  000cc	c7 44 24 28 92
	20 00 00	 mov	 DWORD PTR attribs$[rsp+8], 8338 ; 00002092H
  000d4	89 54 24 2c	 mov	 DWORD PTR attribs$[rsp+12], edx
  000d8	48 c7 44 24 30
	94 20 00 00	 mov	 QWORD PTR attribs$[rsp+16], 8340 ; 00002094H
  000e1	44 89 4c 24 38	 mov	 DWORD PTR attribs$[rsp+24], r9d
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglGetProcAddress

; 171  : 	wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress((LPCSTR)"wglSwapIntervalEXT");

  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4294909295
  000f3	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?wglCreateContextAttribsARB@@3P6APEAUHGLRC__@@PEAUHDC__@@PEAU1@PEBH@ZEA, rax ; wglCreateContextAttribsARB
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglGetProcAddress

; 172  : 
; 173  : 	wglSwapIntervalEXT(0);

  00100	33 c9		 xor	 ecx, ecx
  00102	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?wglSwapIntervalEXT@@3P6APEAUHGLRC__@@H@ZEA, rax ; wglSwapIntervalEXT
  00109	ff d0		 call	 rax

; 174  : 
; 175  : 	if(!(hRC = wglCreateContextAttribsARB(hDC, 0, attribs)))

  0010b	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  0010f	4c 8d 44 24 20	 lea	 r8, QWORD PTR attribs$[rsp]
  00114	33 d2		 xor	 edx, edx
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR ?wglCreateContextAttribsARB@@3P6APEAUHGLRC__@@PEAUHDC__@@PEAU1@PEBH@ZEA ; wglCreateContextAttribsARB
  0011c	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax
  00120	48 85 c0	 test	 rax, rax
  00123	74 2e		 je	 SHORT $LN1@initGL

; 176  : 	{
; 177  : 		OK = false;
; 178  : 		//destroyWindow();
; 179  : 		return;
; 180  : 	}
; 181  : 
; 182  : 	if(!wglMakeCurrent(NULL, NULL) || !wglDeleteContext(hRC_temp) || !wglMakeCurrent(hDC, hRC))

  00125	33 d2		 xor	 edx, edx
  00127	33 c9		 xor	 ecx, ecx
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglMakeCurrent
  0012f	85 c0		 test	 eax, eax
  00131	74 20		 je	 SHORT $LN1@initGL
  00133	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglDeleteContext
  0013d	85 c0		 test	 eax, eax
  0013f	74 12		 je	 SHORT $LN1@initGL
  00141	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  00145	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglMakeCurrent
  0014f	85 c0		 test	 eax, eax
  00151	75 03		 jne	 SHORT $LN2@initGL
$LN1@initGL:

; 183  : 	{
; 184  : 		OK = false;

  00153	c6 03 00	 mov	 BYTE PTR [rbx], 0
$LN2@initGL:

; 185  : 		//destroyWindow();
; 186  : 		return;
; 187  : 	}
; 188  : }

  00156	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015b	48 33 cc	 xor	 rcx, rsp
  0015e	e8 00 00 00 00	 call	 __security_check_cookie
  00163	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00167	5b		 pop	 rbx
  00168	c3		 ret	 0
?initGL@GLWindow@@QEAAXXZ ENDP				; GLWindow::initGL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?swapBuffers@GLWindow@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?swapBuffers@GLWindow@@QEAAXXZ PROC			; GLWindow::swapBuffers, COMDAT

; 192  : 	SwapBuffers(hDC);

  00000	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00007	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0000b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_SwapBuffers
?swapBuffers@GLWindow@@QEAAXXZ ENDP			; GLWindow::swapBuffers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?destroyGL@GLWindow@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?destroyGL@GLWindow@@QEAAXXZ PROC			; GLWindow::destroyGL, COMDAT

; 234  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance

; 235  : 	bool error = false;
; 236  : 
; 237  : 	//glBindVertexArray(0);
; 238  : 
; 239  : 	if(hRC)

  0000d	48 83 7b 20 00	 cmp	 QWORD PTR [rbx+32], 0
  00012	74 1a		 je	 SHORT $LN1@destroyGL

; 240  : 	{
; 241  : 		if(!wglMakeCurrent(NULL, NULL))

  00014	33 d2		 xor	 edx, edx
  00016	33 c9		 xor	 ecx, ecx
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglMakeCurrent

; 242  : 		{
; 243  : 			error = true;
; 244  : 		}
; 245  : 
; 246  : 		if(!wglDeleteContext(hRC))

  0001e	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]

; 247  : 		{
; 248  : 			error = true;
; 249  : 		}
; 250  : 	}
; 251  : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx

; 242  : 		{
; 243  : 			error = true;
; 244  : 		}
; 245  : 
; 246  : 		if(!wglDeleteContext(hRC))

  00027	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_wglDeleteContext
$LN1@destroyGL:

; 247  : 		{
; 248  : 			error = true;
; 249  : 		}
; 250  : 	}
; 251  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5b		 pop	 rbx
  00033	c3		 ret	 0
?destroyGL@GLWindow@@QEAAXXZ ENDP			; GLWindow::destroyGL
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?isOK@GLWindow@@QEAA_NXZ
_TEXT	SEGMENT
this$dead$ = 8
?isOK@GLWindow@@QEAA_NXZ PROC				; GLWindow::isOK, COMDAT

; 202  : 	return OK;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00007	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 203  : }

  0000a	c3		 ret	 0
?isOK@GLWindow@@QEAA_NXZ ENDP				; GLWindow::isOK
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z
_TEXT	SEGMENT
$T1 = 32
title$GSCopy$ = 40
__$ArrayPad$ = 48
this$ = 80
title$ = 88
width$dead$ = 96
height$dead$ = 104
hInstance$ = 112
major_gl_version$dead$ = 120
minor_gl_version$dead$ = 128
??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z PROC ; GLWindow::GLWindow, COMDAT

; 22   : {

$LN83:
  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00014	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00028	48 8b da	 mov	 rbx, rdx
  0002b	48 8b f9	 mov	 rdi, rcx
  0002e	48 89 54 24 28	 mov	 QWORD PTR title$GSCopy$[rsp], rdx
  00033	48 8b 44 24 70	 mov	 rax, QWORD PTR hInstance$[rsp]
  00038	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  0003c	48 83 c1 30	 add	 rcx, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 41 18 07
	00 00 00	 mov	 QWORD PTR [rcx+24], 7

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 f6		 xor	 esi, esi
  0004a	48 89 71 10	 mov	 QWORD PTR [rcx+16], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 31	 mov	 WORD PTR [rcx], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  00051	49 83 c9 ff	 or	 r9, -1
  00055	45 33 c0	 xor	 r8d, r8d
  00058	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 22   : {

  0005d	c6 47 50 01	 mov	 BYTE PTR [rdi+80], 1
  00061	c7 47 54 58 02
	00 00		 mov	 DWORD PTR [rdi+84], 600	; 00000258H
  00068	c7 47 58 58 02
	00 00		 mov	 DWORD PTR [rdi+88], 600	; 00000258H
  0006f	c7 47 5c 03 00
	00 00		 mov	 DWORD PTR [rdi+92], 3
  00076	c7 47 60 04 00
	00 00		 mov	 DWORD PTR [rdi+96], 4
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0007d	48 83 7b 18 08	 cmp	 QWORD PTR [rbx+24], 8
  00082	72 08		 jb	 SHORT $LN71@GLWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00084	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00087	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN71@GLWindow:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0008c	48 c7 43 18 07
	00 00 00	 mov	 QWORD PTR [rbx+24], 7

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));
; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00094	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00098	66 89 33	 mov	 WORD PTR [rbx], si
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 24   : }

  0009b	48 8b c7	 mov	 rax, rdi
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a3	48 33 cc	 xor	 rcx, rsp
  000a6	e8 00 00 00 00	 call	 __security_check_cookie
  000ab	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000b0	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000b5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
??0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z ENDP ; GLWindow::GLWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
title$GSCopy$ = 40
__$ArrayPad$ = 48
this$ = 80
title$ = 88
width$dead$ = 96
height$dead$ = 104
hInstance$ = 112
major_gl_version$dead$ = 120
minor_gl_version$dead$ = 128
?dtor$0@?0???0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z@4HA PROC ; `GLWindow::GLWindow'::`1'::dtor$0
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR title$GSCopy$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0???0GLWindow@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@HHPEAUHINSTANCE__@@HH@Z@4HA ENDP ; `GLWindow::GLWindow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ??1GLWindow@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1GLWindow@@QEAA@XZ PROC				; GLWindow::~GLWindow, COMDAT

; 27   : {

$LN38:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 28   : 	destroyWindow();

  00009	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QEAAXXZ ; GLWindow::destroyWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  0000e	48 83 7b 48 08	 cmp	 QWORD PTR [rbx+72], 8
  00013	72 09		 jb	 SHORT $LN25@GLWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00015	48 8b 4b 30	 mov	 rcx, QWORD PTR [rbx+48]
  00019	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN25@GLWindow:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0001e	33 c0		 xor	 eax, eax

; 2257 : 			{	// copy any leftovers to small buffer and deallocate
; 2258 : 			pointer _Ptr = this->_Bx._Ptr;
; 2259 : 			this->_Getal().destroy(&this->_Bx._Ptr);
; 2260 : 			if (0 < _Newsize)
; 2261 : 				_Traits::copy(this->_Bx._Buf,
; 2262 : 					_STD addressof(*_Ptr), _Newsize);
; 2263 : 			this->_Getal().deallocate(_Ptr, this->_Myres + 1);
; 2264 : 			}
; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00020	48 c7 43 48 07
	00 00 00	 mov	 QWORD PTR [rbx+72], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00028	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0002c	66 89 43 30	 mov	 WORD PTR [rbx+48], ax
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 29   : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
??1GLWindow@@QEAA@XZ ENDP				; GLWindow::~GLWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?initWindow@GLWindow@@QEAAXXZ
_TEXT	SEGMENT
Rid$ = 96
wc$ = 112
WindowRect$ = 192
__$ArrayPad$ = 208
this$dead$ = 240
?initWindow@GLWindow@@QEAAXXZ PROC			; GLWindow::initWindow, COMDAT

; 32   : {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	55		 push	 rbp
  0000b	48 8d 6c 24 a9	 lea	 rbp, QWORD PTR [rsp-87]
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 45 47	 mov	 QWORD PTR __$ArrayPad$[rbp-137], rax
  00025	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance

; 33   : 	GLuint PixelFormat;
; 34   : 	WNDCLASS wc;
; 35   : 	DWORD dwExStyle;
; 36   : 	DWORD dwStyle;
; 37   : 	RECT WindowRect;
; 38   : 
; 39   : 	WindowRect.left = (long)0;

  0002c	33 ff		 xor	 edi, edi

; 40   : 	WindowRect.right = (long)width;
; 41   : 	WindowRect.top = (long)0;
; 42   : 	WindowRect.bottom = (long)height;
; 43   : 
; 44   : 	OK = false;
; 45   : 
; 46   : 	wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
; 47   : 	wc.lpfnWndProc = (WNDPROC)wndProc;
; 48   : 	wc.cbClsExtra = 0;
; 49   : 	wc.cbWndExtra = 0;
; 50   : 	wc.hInstance = hInstance;
; 51   : 	//wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));
; 52   : 	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);

  0002e	ba 00 7f 00 00	 mov	 edx, 32512		; 00007f00H
  00033	8b 43 54	 mov	 eax, DWORD PTR [rbx+84]
  00036	33 c9		 xor	 ecx, ecx
  00038	c7 45 e7 23 00
	00 00		 mov	 DWORD PTR wc$[rbp-137], 35 ; 00000023H
  0003f	89 45 3f	 mov	 DWORD PTR WindowRect$[rbp-129], eax
  00042	8b 43 58	 mov	 eax, DWORD PTR [rbx+88]
  00045	48 89 7d 37	 mov	 QWORD PTR WindowRect$[rbp-137], rdi
  00049	89 45 43	 mov	 DWORD PTR WindowRect$[rbp-125], eax
  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?wndProc@@YA_JPEAUHWND__@@I_K_J@Z ; wndProc
  00053	40 88 3b	 mov	 BYTE PTR [rbx], dil
  00056	48 89 45 ef	 mov	 QWORD PTR wc$[rbp-129], rax
  0005a	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0005e	48 89 7d f7	 mov	 QWORD PTR wc$[rbp-121], rdi
  00062	48 89 45 ff	 mov	 QWORD PTR wc$[rbp-113], rax
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadIconW

; 53   : 	wc.hCursor = LoadCursor(NULL, IDC_ARROW);

  0006c	ba 00 7f 00 00	 mov	 edx, 32512		; 00007f00H
  00071	33 c9		 xor	 ecx, ecx
  00073	48 89 45 07	 mov	 QWORD PTR wc$[rbp-105], rax
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadCursorW

; 54   : 	wc.hbrBackground = NULL;			
; 55   : 	wc.lpszMenuName	= NULL;		
; 56   : 	wc.lpszClassName = L"GLWindow";
; 57   : 
; 58   : 	if(!RegisterClass(&wc))

  0007d	48 8d 4d e7	 lea	 rcx, QWORD PTR wc$[rbp-137]
  00081	48 89 45 0f	 mov	 QWORD PTR wc$[rbp-97], rax
  00085	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG4294909300
  0008c	0f 57 c0	 xorps	 xmm0, xmm0
  0008f	66 0f 7f 45 17	 movdqa	 XMMWORD PTR wc$[rbp-89], xmm0
  00094	48 89 45 27	 mov	 QWORD PTR wc$[rbp-73], rax
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterClassW
  0009e	66 85 c0	 test	 ax, ax
  000a1	75 22		 jne	 SHORT $LN6@initWindow

; 59   : 	{
; 60   : 		OK = false;
; 61   : 		MessageBox(NULL, L"Could not register window class.", L"Registration error", MB_OK | MB_ICONERROR);

  000a3	44 8d 4f 10	 lea	 r9d, QWORD PTR [rdi+16]
  000a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294909299
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294909298
  000b5	33 c9		 xor	 ecx, ecx
  000b7	40 88 3b	 mov	 BYTE PTR [rbx], dil
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW

; 62   : 		return;

  000c0	e9 f2 00 00 00	 jmp	 $LN1@initWindow
$LN6@initWindow:

; 63   : 	}
; 64   : 
; 65   : 	dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;
; 66   : 	dwStyle = WS_OVERLAPPEDWINDOW;
; 67   : 
; 68   : 	AdjustWindowRectEx(&WindowRect, dwStyle, false, dwExStyle);

  000c5	48 8d 4d 37	 lea	 rcx, QWORD PTR WindowRect$[rbp-137]
  000c9	41 b9 00 01 04
	00		 mov	 r9d, 262400		; 00040100H
  000cf	45 33 c0	 xor	 r8d, r8d
  000d2	ba 00 00 cf 00	 mov	 edx, 13565952		; 00cf0000H
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_AdjustWindowRectEx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 524  : 			: this->_Bx._Buf);

  000dd	48 83 7b 48 08	 cmp	 QWORD PTR [rbx+72], 8
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 70   : 	hWnd = CreateWindowEx(dwExStyle, L"GLWindow", this->title.c_str(), dwStyle | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, 0, WindowRect.right - WindowRect.left, WindowRect.bottom - WindowRect.top, NULL, NULL, hInstance, NULL);

  000e2	4c 8d 43 30	 lea	 r8, QWORD PTR [rbx+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 524  : 			: this->_Bx._Buf);

  000e6	72 03		 jb	 SHORT $LN13@initWindow
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef

; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  000e8	4d 8b 00	 mov	 r8, QWORD PTR [r8]
$LN13@initWindow:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 70   : 	hWnd = CreateWindowEx(dwExStyle, L"GLWindow", this->title.c_str(), dwStyle | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, 0, WindowRect.right - WindowRect.left, WindowRect.bottom - WindowRect.top, NULL, NULL, hInstance, NULL);

  000eb	8b 55 3f	 mov	 edx, DWORD PTR WindowRect$[rbp-129]
  000ee	8b 4d 43	 mov	 ecx, DWORD PTR WindowRect$[rbp-125]
  000f1	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000f5	2b 4d 3b	 sub	 ecx, DWORD PTR WindowRect$[rbp-133]
  000f8	2b 55 37	 sub	 edx, DWORD PTR WindowRect$[rbp-137]
  000fb	48 89 7c 24 58	 mov	 QWORD PTR [rsp+88], rdi
  00100	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00105	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0010a	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
  0010f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00113	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294909297
  0011e	41 b9 00 00 cf
	06		 mov	 r9d, 114229248		; 06cf0000H
  00124	b9 00 01 04 00	 mov	 ecx, 262400		; 00040100H
  00129	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  0012d	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWindowExW
  00137	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 71   : 	//hWnd = CreateWindow(L"OpenGL", title, dwStyle | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, 0, WindowRect.right - WindowRect.left, WindowRect.bottom - WindowRect.top, NULL, NULL, hInstance, NULL);
; 72   : 
; 73   : 	if(!hWnd)

  0013b	48 85 c0	 test	 rax, rax
  0013e	75 0a		 jne	 SHORT $LN5@initWindow
$LN17@initWindow:

; 74   : 	{
; 75   : 		destroyWindow();

  00140	48 8b cb	 mov	 rcx, rbx
  00143	e8 00 00 00 00	 call	 ?destroyWindow@GLWindow@@QEAAXXZ ; GLWindow::destroyWindow

; 76   : 		return;

  00148	eb 6d		 jmp	 SHORT $LN1@initWindow
$LN5@initWindow:

; 77   : 	}
; 78   : 
; 79   : 	static PIXELFORMATDESCRIPTOR pfd = {
; 80   : 		sizeof(PIXELFORMATDESCRIPTOR),
; 81   : 		1,
; 82   : 		PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,
; 83   : 		PFD_TYPE_RGBA,
; 84   : 		16,
; 85   : 		0, 0, 0, 0, 0, 0,
; 86   : 		0,
; 87   : 		0,
; 88   : 		0,
; 89   : 		0, 0, 0, 0,
; 90   : 		16, 
; 91   : 		0,
; 92   : 		0,
; 93   : 		PFD_MAIN_PLANE,
; 94   : 		0,
; 95   : 		0, 0, 0
; 96   : 	};
; 97   : 
; 98   : 	if(!(hDC = GetDC(hWnd)))

  0014a	48 8b c8	 mov	 rcx, rax
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetDC
  00153	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
  00157	48 85 c0	 test	 rax, rax
  0015a	74 e4		 je	 SHORT $LN17@initWindow

; 99   : 	{
; 100  : 		destroyWindow();
; 101  : 		return;
; 102  : 	}
; 103  : 
; 104  : 	if(!(PixelFormat = ChoosePixelFormat(hDC, &pfd)))

  0015c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?pfd@?7??initWindow@GLWindow@@QEAAXXZ@4UtagPIXELFORMATDESCRIPTOR@@A
  00163	48 8b c8	 mov	 rcx, rax
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ChoosePixelFormat
  0016c	85 c0		 test	 eax, eax
  0016e	74 d0		 je	 SHORT $LN17@initWindow

; 105  : 	{
; 106  : 		destroyWindow();
; 107  : 		return;
; 108  : 	}
; 109  : 
; 110  : 	if(!SetPixelFormat(hDC, PixelFormat, &pfd))

  00170	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00174	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?pfd@?7??initWindow@GLWindow@@QEAAXXZ@4UtagPIXELFORMATDESCRIPTOR@@A
  0017b	8b d0		 mov	 edx, eax
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetPixelFormat
  00183	85 c0		 test	 eax, eax
  00185	74 b9		 je	 SHORT $LN17@initWindow

; 111  : 	{
; 112  : 		destroyWindow();
; 113  : 		return;
; 114  : 	}
; 115  : 
; 116  : 	RAWINPUTDEVICE Rid[1];
; 117  : 	Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC;
; 118  : 	Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE;
; 119  : 	Rid[0].dwFlags = RIDEV_INPUTSINK;
; 120  : 	Rid[0].hwndTarget = hWnd;

  00187	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  0018b	ba 01 00 00 00	 mov	 edx, 1

; 121  : 	if(!RegisterRawInputDevices(Rid, 1, sizeof(Rid[0])))

  00190	48 8d 4d d7	 lea	 rcx, QWORD PTR Rid$[rbp-137]
  00194	44 8d 42 0f	 lea	 r8d, QWORD PTR [rdx+15]
  00198	c7 45 d7 01 00
	02 00		 mov	 DWORD PTR Rid$[rbp-137], 131073 ; 00020001H
  0019f	c7 45 db 00 01
	00 00		 mov	 DWORD PTR Rid$[rbp-133], 256 ; 00000100H
  001a6	48 89 45 df	 mov	 QWORD PTR Rid$[rbp-129], rax
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegisterRawInputDevices
  001b0	85 c0		 test	 eax, eax
  001b2	0f 95 c0	 setne	 al
  001b5	88 03		 mov	 BYTE PTR [rbx], al
$LN1@initWindow:

; 122  : 	{
; 123  : 		OK = false;
; 124  : 		return;
; 125  : 	}
; 126  : 
; 127  : 	OK = true;
; 128  : }

  001b7	48 8b 4d 47	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-137]
  001bb	48 33 cc	 xor	 rcx, rsp
  001be	e8 00 00 00 00	 call	 __security_check_cookie
  001c3	4c 8d 9c 24 e0
	00 00 00	 lea	 r11, QWORD PTR [rsp+224]
  001cb	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  001cf	49 8b 7b 18	 mov	 rdi, QWORD PTR [r11+24]
  001d3	49 8b e3	 mov	 rsp, r11
  001d6	5d		 pop	 rbp
  001d7	c3		 ret	 0
?initWindow@GLWindow@@QEAAXXZ ENDP			; GLWindow::initWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?messageBox@GLWindow@@QEAAXPEB_W0I@Z
_TEXT	SEGMENT
this$ = 8
lpText$ = 16
lpCaption$ = 24
uType$dead$ = 32
?messageBox@GLWindow@@QEAAXPEB_W0I@Z PROC		; GLWindow::messageBox, COMDAT

; 212  : 	MessageBox(hWnd, lpText, lpCaption, uType);

  00000	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00004	41 b9 10 00 00
	00		 mov	 r9d, 16
  0000a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_MessageBoxW
?messageBox@GLWindow@@QEAAXPEB_W0I@Z ENDP		; GLWindow::messageBox
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?destroyWindow@GLWindow@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?destroyWindow@GLWindow@@QEAAXXZ PROC			; GLWindow::destroyWindow, COMDAT

; 254  : {

$LN9:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 255  : 	bool error = false;
; 256  : 
; 257  : 	if(hDC && !ReleaseDC(hWnd, hDC))

  0000a	48 8b 51 18	 mov	 rdx, QWORD PTR [rcx+24]
  0000e	40 32 ff	 xor	 dil, dil
  00011	48 8b d9	 mov	 rbx, rcx
  00014	48 85 d2	 test	 rdx, rdx
  00017	74 19		 je	 SHORT $LN4@destroyWin
  00019	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseDC
  00023	85 c0		 test	 eax, eax
  00025	75 0b		 jne	 SHORT $LN4@destroyWin

; 258  : 	{
; 259  : 		hDC = NULL;

  00027	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0

; 260  : 		error = true;

  0002f	40 b7 01	 mov	 dil, 1
$LN4@destroyWin:

; 261  : 	}
; 262  : 	if(hWnd && !DestroyWindow(hWnd))

  00032	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]
  00036	48 85 c9	 test	 rcx, rcx
  00039	74 15		 je	 SHORT $LN3@destroyWin
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DestroyWindow
  00041	85 c0		 test	 eax, eax
  00043	75 0b		 jne	 SHORT $LN3@destroyWin

; 263  : 	{
; 264  : 		hWnd = NULL;

  00045	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 265  : 		error = true;

  0004d	40 b7 01	 mov	 dil, 1
$LN3@destroyWin:

; 266  : 	}
; 267  : 	if(!UnregisterClass(L"GLWindow", hInstance))

  00050	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG4294909294
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_UnregisterClassW
  00061	85 c0		 test	 eax, eax
  00063	75 0a		 jne	 SHORT $LN2@destroyWin

; 268  : 	{
; 269  : 		hInstance = NULL;

  00065	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0

; 270  : 		error = true;
; 271  : 	}
; 272  : 	if(error)

  0006d	eb 05		 jmp	 SHORT $LN7@destroyWin
$LN2@destroyWin:
  0006f	40 84 ff	 test	 dil, dil
  00072	74 1c		 je	 SHORT $LN1@destroyWin
$LN7@destroyWin:

; 273  : 	{
; 274  : 		MessageBox(NULL, L"There was an error while destroying the window", L"ERROR", MB_OK | MB_ICONINFORMATION);

  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294909293
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294909292
  00082	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00088	33 c9		 xor	 ecx, ecx
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MessageBoxW
$LN1@destroyWin:

; 275  : 	}
; 276  : }

  00090	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
?destroyWindow@GLWindow@@QEAAXXZ ENDP			; GLWindow::destroyWindow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
;	COMDAT ?wndProc@@YA_JPEAUHWND__@@I_K_J@Z
_TEXT	SEGMENT
dwSize$1 = 48
$T2 = 48
$T3 = 48
$T4 = 56
$T5 = 56
$T6 = 56
$T7 = 56
$T8 = 56
$T9 = 56
raw$10 = 80
__$ArrayPad$ = 128
hWnd$ = 208
uMsg$ = 216
wParam$ = 224
lParam$ = 232
?wndProc@@YA_JPEAUHWND__@@I_K_J@Z PROC			; wndProc, COMDAT

; 279  : {

$LN189:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	41 57		 push	 r15
  00009	48 8d 6c 24 d1	 lea	 rbp, QWORD PTR [rsp-47]
  0000e	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 45 17	 mov	 QWORD PTR __$ArrayPad$[rbp-105], rax
  00023	4d 8b f1	 mov	 r14, r9
  00026	49 8b f8	 mov	 rdi, r8
  00029	8b f2		 mov	 esi, edx
  0002b	4c 8b f9	 mov	 r15, rcx

; 280  : 	switch(uMsg)

  0002e	81 fa 12 01 00
	00		 cmp	 edx, 274		; 00000112H
  00034	0f 87 a5 01 00
	00		 ja	 $LN25@wndProc
  0003a	0f 84 83 01 00
	00		 je	 $LN17@wndProc
  00040	8d 42 fb	 lea	 eax, DWORD PTR [rdx-5]
  00043	3d fc 00 00 00	 cmp	 eax, 252		; 000000fcH
  00048	0f 87 94 03 00
	00		 ja	 $LN80@wndProc
  0004e	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  00055	0f b6 84 03 00
	00 00 00	 movzx	 eax, BYTE PTR $LN178@wndProc[rbx+rax]
  0005d	8b 8c 83 00 00
	00 00		 mov	 ecx, DWORD PTR $LN179@wndProc[rbx+rax*4]
  00064	48 03 cb	 add	 rcx, rbx
  00067	ff e1		 jmp	 rcx
$LN20@wndProc:

; 281  : 	{
; 282  : 	case WM_ACTIVATE:
; 283  : 		{
; 284  : 			if(!HIWORD(wParam))

  00069	49 8b c0	 mov	 rax, r8
  0006c	48 c1 e8 10	 shr	 rax, 16
  00070	66 85 c0	 test	 ax, ax
  00073	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  0007a	0f 94 c1	 sete	 cl
  0007d	88 48 64	 mov	 BYTE PTR [rax+100], cl

; 285  : 			{
; 286  : 				GLWindow::instance->active = true;
; 287  : 			} else
; 288  : 			{
; 289  : 				GLWindow::instance->active = false;
; 290  : 			}
; 291  : 
; 292  : 			break;

  00080	e9 5d 03 00 00	 jmp	 $LN80@wndProc
$LN12@wndProc:

; 306  : 				}
; 307  : 			}
; 308  : 
; 309  : 			break;
; 310  : 		}
; 311  : 	case WM_CLOSE:
; 312  : 		{
; 313  : 			PostQuitMessage(0);

  00085	33 c9		 xor	 ecx, ecx
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PostQuitMessage

; 314  : 			return 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	e9 5f 03 00 00	 jmp	 $LN23@wndProc
$LN11@wndProc:

; 315  : 		}
; 316  : 	case WM_KEYDOWN:
; 317  : 		{
; 318  : 			Keyboard::setKey(wParam, true);

  00094	b2 01		 mov	 dl, 1
  00096	41 8b c8	 mov	 ecx, r8d
  00099	e8 00 00 00 00	 call	 ?setKey@Keyboard@@SAXH_N@Z ; Keyboard::setKey
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  000a5	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  000aa	85 c0		 test	 eax, eax
  000ac	74 07		 je	 SHORT $LN30@wndProc

; 33   : 		_Throw_C_error(_Res);

  000ae	8b c8		 mov	 ecx, eax
  000b0	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN30@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 5    : {

  000b5	c6 45 cb 00	 mov	 BYTE PTR $T3[rbp-101], 0
$LN187@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  000b9	48 63 05 80 00
	00 00		 movsxd	 rax, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 5    : {

  000c0	89 7d c7	 mov	 DWORD PTR $T3[rbp-105], edi
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  000c3	83 f8 0f	 cmp	 eax, 15
  000c6	7d 15		 jge	 SHORT $LN35@wndProc

; 25   : 		{
; 26   : 			content[count++] = object;

  000c8	48 8b c8	 mov	 rcx, rax
  000cb	48 8b 45 c7	 mov	 rax, QWORD PTR $T3[rbp-105]
  000cf	48 89 84 cb 00
	00 00 00	 mov	 QWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A[rbx+rcx*8], rax
  000d7	ff 05 80 00 00
	00		 inc	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
$LN35@wndProc:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 322  : 			break;

  000e4	e9 e9 02 00 00	 jmp	 $LN181@wndProc
$LN10@wndProc:

; 323  : 		}
; 324  : 	case WM_KEYUP:
; 325  : 		{
; 326  : 			Keyboard::setKey(wParam, false);

  000e9	33 d2		 xor	 edx, edx
  000eb	41 8b c8	 mov	 ecx, r8d
  000ee	e8 00 00 00 00	 call	 ?setKey@Keyboard@@SAXH_N@Z ; Keyboard::setKey
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Keyboard@@2Vmutex@std@@A ; Keyboard::mut
  000fa	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  000ff	85 c0		 test	 eax, eax
  00101	74 07		 je	 SHORT $LN49@wndProc

; 33   : 		_Throw_C_error(_Res);

  00103	8b c8		 mov	 ecx, eax
  00105	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN49@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 5    : {

  0010a	c6 45 cb 01	 mov	 BYTE PTR $T2[rbp-101], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 330  : 			break;

  0010e	eb a9		 jmp	 SHORT $LN187@wndProc
$LN9@wndProc:

; 331  : 		}
; 332  : 	case WM_SIZE:
; 333  : 		{
; 334  : 			GLWindow::instance->rescaled = true;

  00110	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance

; 335  : 			GLWindow::instance->width = LOWORD(lParam);

  00117	41 0f b7 c1	 movzx	 eax, r9w
  0011b	89 41 54	 mov	 DWORD PTR [rcx+84], eax

; 336  : 			GLWindow::instance->height = HIWORD(lParam);

  0011e	49 8b c1	 mov	 rax, r9
  00121	c6 41 50 01	 mov	 BYTE PTR [rcx+80], 1
  00125	48 c1 e8 10	 shr	 rax, 16
  00129	0f b7 c0	 movzx	 eax, ax
  0012c	89 41 58	 mov	 DWORD PTR [rcx+88], eax

; 337  : 			break;

  0012f	e9 ae 02 00 00	 jmp	 $LN80@wndProc
$LN3@wndProc:

; 378  : 		}
; 379  : 	case WM_INPUT:
; 380  : 		{
; 381  : 			UINT dwSize = 48;
; 382  : 			RAWINPUT raw;
; 383  : 
; 384  : 			GetRawInputData((HRAWINPUT)lParam, RID_INPUT, &raw, &dwSize, sizeof(RAWINPUTHEADER));

  00134	4c 8d 4d c7	 lea	 r9, QWORD PTR dwSize$1[rbp-105]
  00138	4c 8d 45 e7	 lea	 r8, QWORD PTR raw$10[rbp-105]
  0013c	ba 03 00 00 10	 mov	 edx, 268435459		; 10000003H
  00141	49 8b ce	 mov	 rcx, r14
  00144	c7 45 c7 30 00
	00 00		 mov	 DWORD PTR dwSize$1[rbp-105], 48 ; 00000030H
  0014b	c7 44 24 20 18
	00 00 00	 mov	 DWORD PTR [rsp+32], 24
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetRawInputData

; 385  : 
; 386  : 			if(raw.header.dwType == RIM_TYPEMOUSE)

  00159	83 7d e7 00	 cmp	 DWORD PTR raw$10[rbp-105], 0
  0015d	0f 85 7f 02 00
	00		 jne	 $LN80@wndProc
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00163	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  0016a	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0016f	85 c0		 test	 eax, eax
  00171	74 07		 je	 SHORT $LN163@wndProc

; 33   : 		_Throw_C_error(_Res);

  00173	8b c8		 mov	 ecx, eax
  00175	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN163@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  0017a	48 63 05 40 01
	00 00		 movsxd	 rax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  00181	8b 55 0b	 mov	 edx, DWORD PTR raw$10[rbp-69]
  00184	44 8b 4d 0f	 mov	 r9d, DWORD PTR raw$10[rbp-65]
  00188	45 33 c0	 xor	 r8d, r8d
  0018b	44 88 45 df	 mov	 BYTE PTR $T4[rbp-89], r8b
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  0018f	83 f8 0f	 cmp	 eax, 15
  00192	0f 8d 33 02 00
	00		 jge	 $LN73@wndProc

; 25   : 		{
; 26   : 			content[count++] = object;

  00198	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  0019c	89 94 8b 00 00
	00 00		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4], edx
  001a3	44 89 8c 8b 04
	00 00 00	 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+4], r9d
  001ab	44 89 84 8b 08
	00 00 00	 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+8], r8d
  001b3	c7 84 8b 0c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+12], -1 ; ffffffffH
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 398  : 			break;

  001be	e9 f8 01 00 00	 jmp	 $LN182@wndProc
$LN17@wndProc:

; 293  : 		}
; 294  : 	case WM_SYSCOMMAND:
; 295  : 		{
; 296  : 			switch(wParam)

  001c3	49 8b c0	 mov	 rax, r8
  001c6	48 2d 40 f1 00
	00		 sub	 rax, 61760		; 0000f140H
  001cc	74 0a		 je	 SHORT $LN14@wndProc
  001ce	48 83 f8 30	 cmp	 rax, 48			; 00000030H
  001d2	0f 85 0a 02 00
	00		 jne	 $LN80@wndProc
$LN14@wndProc:

; 297  : 			{
; 298  : 				case SC_SCREENSAVE:
; 299  : 				{
; 300  : 
; 301  : 				}
; 302  : 				
; 303  : 				case SC_MONITORPOWER:
; 304  : 				{
; 305  : 					return 0;

  001d8	33 c0		 xor	 eax, eax
  001da	e9 14 02 00 00	 jmp	 $LN23@wndProc
$LN25@wndProc:

; 280  : 	switch(uMsg)

  001df	8b c2		 mov	 eax, edx
  001e1	2d 01 02 00 00	 sub	 eax, 513		; 00000201H
  001e6	0f 84 81 01 00
	00		 je	 $LN8@wndProc
  001ec	ff c8		 dec	 eax
  001ee	0f 84 50 01 00
	00		 je	 $LN7@wndProc
  001f4	83 e8 02	 sub	 eax, 2
  001f7	0f 84 e5 00 00
	00		 je	 $LN6@wndProc
  001fd	ff c8		 dec	 eax
  001ff	74 7e		 je	 SHORT $LN5@wndProc
  00201	83 f8 05	 cmp	 eax, 5
  00204	0f 85 d8 01 00
	00		 jne	 $LN80@wndProc

; 373  : 			short sc = HIWORD(wParam);

  0020a	49 8b d8	 mov	 rbx, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 373  : 			short sc = HIWORD(wParam);

  00214	48 c1 eb 10	 shr	 rbx, 16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00218	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  0021d	85 c0		 test	 eax, eax
  0021f	74 07		 je	 SHORT $LN144@wndProc

; 33   : 		_Throw_C_error(_Res);

  00221	8b c8		 mov	 ecx, eax
  00223	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN144@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 375  : 			Mouse::actions.put(MouseAction(0, 0, sc / WHEEL_DELTA, -1, false));

  00228	0f bf cb	 movsx	 ecx, bx
  0022b	b8 89 88 88 88	 mov	 eax, -2004318071	; ffffffff88888889H
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  00230	45 33 c0	 xor	 r8d, r8d
  00233	44 88 45 df	 mov	 BYTE PTR $T5[rbp-89], r8b
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 375  : 			Mouse::actions.put(MouseAction(0, 0, sc / WHEEL_DELTA, -1, false));

  00237	f7 e9		 imul	 ecx
  00239	03 d1		 add	 edx, ecx
  0023b	c1 fa 06	 sar	 edx, 6
  0023e	8b c2		 mov	 eax, edx
  00240	c1 e8 1f	 shr	 eax, 31
  00243	03 d0		 add	 edx, eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  00245	48 63 05 40 01
	00 00		 movsxd	 rax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
  0024c	83 f8 0f	 cmp	 eax, 15
  0024f	0f 8d 76 01 00
	00		 jge	 $LN73@wndProc

; 25   : 		{
; 26   : 			content[count++] = object;

  00255	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00259	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  00260	4c 89 84 8b 00
	00 00 00	 mov	 QWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4], r8
  00268	89 94 8b 08 00
	00 00		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+8], edx
  0026f	c7 84 8b 0c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+12], -1 ; ffffffffH
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 377  : 			break;

  0027a	e9 3c 01 00 00	 jmp	 $LN182@wndProc
$LN5@wndProc:

; 362  : 		}
; 363  : 	case WM_RBUTTONUP:
; 364  : 		{
; 365  : 			Mouse::setMB(1, false);

  0027f	33 d2		 xor	 edx, edx
  00281	8d 4a 01	 lea	 ecx, QWORD PTR [rdx+1]
  00284	e8 00 00 00 00	 call	 ?setMB@Mouse@@SAXH_N@Z	; Mouse::setMB
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  00290	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00295	85 c0		 test	 eax, eax
  00297	74 07		 je	 SHORT $LN125@wndProc

; 33   : 		_Throw_C_error(_Res);

  00299	8b c8		 mov	 ecx, eax
  0029b	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN125@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  002a0	48 63 05 40 01
	00 00		 movsxd	 rax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  002a7	45 33 c0	 xor	 r8d, r8d
  002aa	c6 45 df 01	 mov	 BYTE PTR $T6[rbp-89], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  002ae	83 f8 0f	 cmp	 eax, 15
  002b1	0f 8d 14 01 00
	00		 jge	 $LN73@wndProc

; 25   : 		{
; 26   : 			content[count++] = object;

  002b7	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  002bb	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  002c2	4c 89 84 8b 00
	00 00 00	 mov	 QWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4], r8
  002ca	44 89 84 8b 08
	00 00 00	 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+8], r8d
  002d2	c7 84 8b 0c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+12], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 369  : 			break;

  002dd	e9 d9 00 00 00	 jmp	 $LN182@wndProc
$LN6@wndProc:

; 354  : 		}
; 355  : 	case WM_RBUTTONDOWN:
; 356  : 		{
; 357  : 			Mouse::setMB(1, true);

  002e2	b2 01		 mov	 dl, 1
  002e4	b9 01 00 00 00	 mov	 ecx, 1
  002e9	e8 00 00 00 00	 call	 ?setMB@Mouse@@SAXH_N@Z	; Mouse::setMB
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  002f5	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  002fa	85 c0		 test	 eax, eax
  002fc	74 07		 je	 SHORT $LN106@wndProc

; 33   : 		_Throw_C_error(_Res);

  002fe	8b c8		 mov	 ecx, eax
  00300	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN106@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  00305	48 63 05 40 01
	00 00		 movsxd	 rax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  0030c	45 33 c0	 xor	 r8d, r8d
  0030f	44 88 45 df	 mov	 BYTE PTR $T7[rbp-89], r8b
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  00313	83 f8 0f	 cmp	 eax, 15
  00316	0f 8d af 00 00
	00		 jge	 $LN73@wndProc

; 25   : 		{
; 26   : 			content[count++] = object;

  0031c	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  00320	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  00327	4c 89 84 8b 00
	00 00 00	 mov	 QWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4], r8
  0032f	44 89 84 8b 08
	00 00 00	 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+8], r8d
  00337	c7 84 8b 0c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+12], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 361  : 			break;

  00342	eb 77		 jmp	 SHORT $LN182@wndProc
$LN7@wndProc:

; 342  : 			Mouse::mut.lock();
; 343  : 			Mouse::actions.put(MouseAction(0, 0, 0, 0, false));
; 344  : 			Mouse::mut.unlock();
; 345  : 			break;
; 346  : 		}
; 347  : 	case WM_LBUTTONUP:
; 348  : 		{
; 349  : 			Mouse::setMB(0, false);

  00344	33 d2		 xor	 edx, edx
  00346	33 c9		 xor	 ecx, ecx
  00348	e8 00 00 00 00	 call	 ?setMB@Mouse@@SAXH_N@Z	; Mouse::setMB
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  0034d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  00354	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00359	85 c0		 test	 eax, eax
  0035b	74 07		 je	 SHORT $LN87@wndProc

; 33   : 		_Throw_C_error(_Res);

  0035d	8b c8		 mov	 ecx, eax
  0035f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN87@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  00364	45 33 c0	 xor	 r8d, r8d
  00367	c6 45 df 01	 mov	 BYTE PTR $T8[rbp-89], 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 353  : 			break;

  0036b	eb 27		 jmp	 SHORT $LN185@wndProc
$LN8@wndProc:

; 338  : 		}
; 339  : 	case WM_LBUTTONDOWN:
; 340  : 		{
; 341  : 			Mouse::setMB(0, true);

  0036d	b2 01		 mov	 dl, 1
  0036f	33 c9		 xor	 ecx, ecx
  00371	e8 00 00 00 00	 call	 ?setMB@Mouse@@SAXH_N@Z	; Mouse::setMB
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
  0037d	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00382	85 c0		 test	 eax, eax
  00384	74 07		 je	 SHORT $LN68@wndProc

; 33   : 		_Throw_C_error(_Res);

  00386	8b c8		 mov	 ecx, eax
  00388	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN68@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\input.cpp

; 30   : {

  0038d	45 33 c0	 xor	 r8d, r8d
  00390	44 88 45 df	 mov	 BYTE PTR $T9[rbp-89], r8b
$LN185@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 24   : 		if(count < size - 1)

  00394	48 63 05 40 01
	00 00		 movsxd	 rax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
  0039b	83 f8 0f	 cmp	 eax, 15
  0039e	7d 2b		 jge	 SHORT $LN73@wndProc

; 25   : 		{
; 26   : 			content[count++] = object;

  003a0	48 8d 0c 80	 lea	 rcx, QWORD PTR [rax+rax*4]
  003a4	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  003ab	4c 89 84 8b 00
	00 00 00	 mov	 QWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4], r8
  003b3	4c 89 84 8b 08
	00 00 00	 mov	 QWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+8], r8
$LN182@wndProc:
  003bb	8b 45 df	 mov	 eax, DWORD PTR $T9[rbp-89]
  003be	89 84 8b 10 00
	00 00		 mov	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A[rbx+rcx*4+16], eax
  003c5	ff 05 40 01 00
	00		 inc	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
$LN73@wndProc:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?mut@Mouse@@2Vmutex@std@@A ; Mouse::mut
$LN181@wndProc:
  003d2	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  003d7	85 c0		 test	 eax, eax
  003d9	74 07		 je	 SHORT $LN80@wndProc

; 33   : 		_Throw_C_error(_Res);

  003db	8b c8		 mov	 ecx, eax
  003dd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN80@wndProc:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 402  : 	return DefWindowProc(hWnd, uMsg, wParam, lParam);

  003e2	4d 8b ce	 mov	 r9, r14
  003e5	4c 8b c7	 mov	 r8, rdi
  003e8	8b d6		 mov	 edx, esi
  003ea	49 8b cf	 mov	 rcx, r15
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DefWindowProcW
$LN23@wndProc:

; 403  : }

  003f3	48 8b 4d 17	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-105]
  003f7	48 33 cc	 xor	 rcx, rsp
  003fa	e8 00 00 00 00	 call	 __security_check_cookie
  003ff	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00406	41 5f		 pop	 r15
  00408	41 5e		 pop	 r14
  0040a	5f		 pop	 rdi
  0040b	5e		 pop	 rsi
  0040c	5b		 pop	 rbx
  0040d	5d		 pop	 rbp
  0040e	c3		 ret	 0
  0040f	90		 npad	 1
$LN179@wndProc:
  00410	00 00 00 00	 DD	 $LN9@wndProc
  00414	00 00 00 00	 DD	 $LN20@wndProc
  00418	00 00 00 00	 DD	 $LN12@wndProc
  0041c	00 00 00 00	 DD	 $LN3@wndProc
  00420	00 00 00 00	 DD	 $LN11@wndProc
  00424	00 00 00 00	 DD	 $LN10@wndProc
  00428	00 00 00 00	 DD	 $LN80@wndProc
$LN178@wndProc:
  0042c	00		 DB	 0
  0042d	01		 DB	 1
  0042e	06		 DB	 6
  0042f	06		 DB	 6
  00430	06		 DB	 6
  00431	06		 DB	 6
  00432	06		 DB	 6
  00433	06		 DB	 6
  00434	06		 DB	 6
  00435	06		 DB	 6
  00436	06		 DB	 6
  00437	02		 DB	 2
  00438	06		 DB	 6
  00439	06		 DB	 6
  0043a	06		 DB	 6
  0043b	06		 DB	 6
  0043c	06		 DB	 6
  0043d	06		 DB	 6
  0043e	06		 DB	 6
  0043f	06		 DB	 6
  00440	06		 DB	 6
  00441	06		 DB	 6
  00442	06		 DB	 6
  00443	06		 DB	 6
  00444	06		 DB	 6
  00445	06		 DB	 6
  00446	06		 DB	 6
  00447	06		 DB	 6
  00448	06		 DB	 6
  00449	06		 DB	 6
  0044a	06		 DB	 6
  0044b	06		 DB	 6
  0044c	06		 DB	 6
  0044d	06		 DB	 6
  0044e	06		 DB	 6
  0044f	06		 DB	 6
  00450	06		 DB	 6
  00451	06		 DB	 6
  00452	06		 DB	 6
  00453	06		 DB	 6
  00454	06		 DB	 6
  00455	06		 DB	 6
  00456	06		 DB	 6
  00457	06		 DB	 6
  00458	06		 DB	 6
  00459	06		 DB	 6
  0045a	06		 DB	 6
  0045b	06		 DB	 6
  0045c	06		 DB	 6
  0045d	06		 DB	 6
  0045e	06		 DB	 6
  0045f	06		 DB	 6
  00460	06		 DB	 6
  00461	06		 DB	 6
  00462	06		 DB	 6
  00463	06		 DB	 6
  00464	06		 DB	 6
  00465	06		 DB	 6
  00466	06		 DB	 6
  00467	06		 DB	 6
  00468	06		 DB	 6
  00469	06		 DB	 6
  0046a	06		 DB	 6
  0046b	06		 DB	 6
  0046c	06		 DB	 6
  0046d	06		 DB	 6
  0046e	06		 DB	 6
  0046f	06		 DB	 6
  00470	06		 DB	 6
  00471	06		 DB	 6
  00472	06		 DB	 6
  00473	06		 DB	 6
  00474	06		 DB	 6
  00475	06		 DB	 6
  00476	06		 DB	 6
  00477	06		 DB	 6
  00478	06		 DB	 6
  00479	06		 DB	 6
  0047a	06		 DB	 6
  0047b	06		 DB	 6
  0047c	06		 DB	 6
  0047d	06		 DB	 6
  0047e	06		 DB	 6
  0047f	06		 DB	 6
  00480	06		 DB	 6
  00481	06		 DB	 6
  00482	06		 DB	 6
  00483	06		 DB	 6
  00484	06		 DB	 6
  00485	06		 DB	 6
  00486	06		 DB	 6
  00487	06		 DB	 6
  00488	06		 DB	 6
  00489	06		 DB	 6
  0048a	06		 DB	 6
  0048b	06		 DB	 6
  0048c	06		 DB	 6
  0048d	06		 DB	 6
  0048e	06		 DB	 6
  0048f	06		 DB	 6
  00490	06		 DB	 6
  00491	06		 DB	 6
  00492	06		 DB	 6
  00493	06		 DB	 6
  00494	06		 DB	 6
  00495	06		 DB	 6
  00496	06		 DB	 6
  00497	06		 DB	 6
  00498	06		 DB	 6
  00499	06		 DB	 6
  0049a	06		 DB	 6
  0049b	06		 DB	 6
  0049c	06		 DB	 6
  0049d	06		 DB	 6
  0049e	06		 DB	 6
  0049f	06		 DB	 6
  004a0	06		 DB	 6
  004a1	06		 DB	 6
  004a2	06		 DB	 6
  004a3	06		 DB	 6
  004a4	06		 DB	 6
  004a5	06		 DB	 6
  004a6	06		 DB	 6
  004a7	06		 DB	 6
  004a8	06		 DB	 6
  004a9	06		 DB	 6
  004aa	06		 DB	 6
  004ab	06		 DB	 6
  004ac	06		 DB	 6
  004ad	06		 DB	 6
  004ae	06		 DB	 6
  004af	06		 DB	 6
  004b0	06		 DB	 6
  004b1	06		 DB	 6
  004b2	06		 DB	 6
  004b3	06		 DB	 6
  004b4	06		 DB	 6
  004b5	06		 DB	 6
  004b6	06		 DB	 6
  004b7	06		 DB	 6
  004b8	06		 DB	 6
  004b9	06		 DB	 6
  004ba	06		 DB	 6
  004bb	06		 DB	 6
  004bc	06		 DB	 6
  004bd	06		 DB	 6
  004be	06		 DB	 6
  004bf	06		 DB	 6
  004c0	06		 DB	 6
  004c1	06		 DB	 6
  004c2	06		 DB	 6
  004c3	06		 DB	 6
  004c4	06		 DB	 6
  004c5	06		 DB	 6
  004c6	06		 DB	 6
  004c7	06		 DB	 6
  004c8	06		 DB	 6
  004c9	06		 DB	 6
  004ca	06		 DB	 6
  004cb	06		 DB	 6
  004cc	06		 DB	 6
  004cd	06		 DB	 6
  004ce	06		 DB	 6
  004cf	06		 DB	 6
  004d0	06		 DB	 6
  004d1	06		 DB	 6
  004d2	06		 DB	 6
  004d3	06		 DB	 6
  004d4	06		 DB	 6
  004d5	06		 DB	 6
  004d6	06		 DB	 6
  004d7	06		 DB	 6
  004d8	06		 DB	 6
  004d9	06		 DB	 6
  004da	06		 DB	 6
  004db	06		 DB	 6
  004dc	06		 DB	 6
  004dd	06		 DB	 6
  004de	06		 DB	 6
  004df	06		 DB	 6
  004e0	06		 DB	 6
  004e1	06		 DB	 6
  004e2	06		 DB	 6
  004e3	06		 DB	 6
  004e4	06		 DB	 6
  004e5	06		 DB	 6
  004e6	06		 DB	 6
  004e7	06		 DB	 6
  004e8	06		 DB	 6
  004e9	06		 DB	 6
  004ea	06		 DB	 6
  004eb	06		 DB	 6
  004ec	06		 DB	 6
  004ed	06		 DB	 6
  004ee	06		 DB	 6
  004ef	06		 DB	 6
  004f0	06		 DB	 6
  004f1	06		 DB	 6
  004f2	06		 DB	 6
  004f3	06		 DB	 6
  004f4	06		 DB	 6
  004f5	06		 DB	 6
  004f6	06		 DB	 6
  004f7	06		 DB	 6
  004f8	06		 DB	 6
  004f9	06		 DB	 6
  004fa	06		 DB	 6
  004fb	06		 DB	 6
  004fc	06		 DB	 6
  004fd	06		 DB	 6
  004fe	06		 DB	 6
  004ff	06		 DB	 6
  00500	06		 DB	 6
  00501	06		 DB	 6
  00502	06		 DB	 6
  00503	06		 DB	 6
  00504	06		 DB	 6
  00505	06		 DB	 6
  00506	06		 DB	 6
  00507	06		 DB	 6
  00508	06		 DB	 6
  00509	06		 DB	 6
  0050a	06		 DB	 6
  0050b	06		 DB	 6
  0050c	06		 DB	 6
  0050d	06		 DB	 6
  0050e	06		 DB	 6
  0050f	06		 DB	 6
  00510	06		 DB	 6
  00511	06		 DB	 6
  00512	06		 DB	 6
  00513	06		 DB	 6
  00514	06		 DB	 6
  00515	06		 DB	 6
  00516	06		 DB	 6
  00517	06		 DB	 6
  00518	06		 DB	 6
  00519	06		 DB	 6
  0051a	06		 DB	 6
  0051b	06		 DB	 6
  0051c	06		 DB	 6
  0051d	06		 DB	 6
  0051e	06		 DB	 6
  0051f	06		 DB	 6
  00520	06		 DB	 6
  00521	06		 DB	 6
  00522	06		 DB	 6
  00523	06		 DB	 6
  00524	06		 DB	 6
  00525	06		 DB	 6
  00526	03		 DB	 3
  00527	04		 DB	 4
  00528	05		 DB	 5
?wndProc@@YA_JPEAUHWND__@@I_K_J@Z ENDP			; wndProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?put@?$List@VKeyboardAction@@$0BA@@@QEAAXVKeyboardAction@@@Z
_TEXT	SEGMENT
this$dead$ = 8
object$ = 16
?put@?$List@VKeyboardAction@@$0BA@@@QEAAXVKeyboardAction@@@Z PROC ; List<KeyboardAction,16>::put, COMDAT

; 24   : 		if(count < size - 1)

  00000	48 63 05 80 00
	00 00		 movsxd	 rax, DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
  00007	83 f8 0f	 cmp	 eax, 15
  0000a	7d 11		 jge	 SHORT $LN1@put

; 25   : 		{
; 26   : 			content[count++] = object;

  0000c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A ; Keyboard::actions
  00013	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  00017	ff 05 80 00 00
	00		 inc	 DWORD PTR ?actions@Keyboard@@2V?$List@VKeyboardAction@@$0BA@@@A+128
$LN1@put:

; 27   : 		}
; 28   : 	}

  0001d	f3 c3		 fatret	 0
?put@?$List@VKeyboardAction@@$0BA@@@QEAAXVKeyboardAction@@@Z ENDP ; List<KeyboardAction,16>::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?put@?$List@VMouseAction@@$0BA@@@QEAAXVMouseAction@@@Z
_TEXT	SEGMENT
object$ = 8
?put@?$List@VMouseAction@@$0BA@@@QEAAXVMouseAction@@@Z PROC ; List<MouseAction,16>::put, COMDAT

; 24   : 		if(count < size - 1)
; 25   : 		{
; 26   : 			content[count++] = object;

  00000	48 63 05 40 01
	00 00		 movsxd	 rax, DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320
  00007	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A ; Mouse::actions
  0000e	48 8d 14 80	 lea	 rdx, QWORD PTR [rax+rax*4]
  00012	8b 01		 mov	 eax, DWORD PTR [rcx]
  00014	41 89 04 90	 mov	 DWORD PTR [r8+rdx*4], eax
  00018	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  0001b	41 89 44 90 04	 mov	 DWORD PTR [r8+rdx*4+4], eax
  00020	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00023	41 89 44 90 08	 mov	 DWORD PTR [r8+rdx*4+8], eax
  00028	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  0002b	41 89 44 90 0c	 mov	 DWORD PTR [r8+rdx*4+12], eax
  00030	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00033	41 89 44 90 10	 mov	 DWORD PTR [r8+rdx*4+16], eax
  00038	ff 05 40 01 00
	00		 inc	 DWORD PTR ?actions@Mouse@@2V?$List@VMouseAction@@$0BA@@@A+320

; 27   : 		}
; 28   : 	}

  0003e	c3		 ret	 0
?put@?$List@VMouseAction@@$0BA@@@QEAAXVMouseAction@@@Z ENDP ; List<MouseAction,16>::put
_TEXT	ENDS
END
