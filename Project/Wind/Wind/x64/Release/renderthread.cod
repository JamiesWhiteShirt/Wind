; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
PUBLIC	?bGrid@@3PAY1BB@BB@_NA				; bGrid
PUBLIC	?normalFShader@@3PEAVFragmentShader@gfxu@@EA	; normalFShader
PUBLIC	?noTexFShader@@3PEAVFragmentShader@gfxu@@EA	; noTexFShader
PUBLIC	?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
PUBLIC	?grid@@3PEAVVertexStream@gfxu@@EA		; grid
PUBLIC	?normalVShader@@3PEAVVertexShader@gfxu@@EA	; normalVShader
PUBLIC	?noTexVShader@@3PEAVVertexShader@gfxu@@EA	; noTexVShader
PUBLIC	?square@@3PEAVVertexStream@gfxu@@EA		; square
PUBLIC	?skipRender@RenderThread@@2_NA			; RenderThread::skipRender
PUBLIC	?blocksTexture@RenderThread@@2PEAVTiledTexture@gfxu@@EA ; RenderThread::blocksTexture
EXTRN	__imp_glFlush:PROC
EXTRN	__imp_glEnable:PROC
EXTRN	__imp_glViewport:PROC
EXTRN	__imp_glBlendFunc:PROC
EXTRN	__imp_glDisable:PROC
EXTRN	__imp_glClearColor:PROC
EXTRN	__imp_glClear:PROC
EXTRN	__imp_glDepthFunc:PROC
?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA DQ 01H DUP (?) ; normalShaderProgram
?bGrid@@3PAY1BB@BB@_NA DB 01331H DUP (?)		; bGrid
	ALIGN	8

?normalFShader@@3PEAVFragmentShader@gfxu@@EA DQ 01H DUP (?) ; normalFShader
?noTexFShader@@3PEAVFragmentShader@gfxu@@EA DQ 01H DUP (?) ; noTexFShader
?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA DQ 01H DUP (?) ; noTexShaderProgram
?grid@@3PEAVVertexStream@gfxu@@EA DQ 01H DUP (?)	; grid
?normalVShader@@3PEAVVertexShader@gfxu@@EA DQ 01H DUP (?) ; normalVShader
?noTexVShader@@3PEAVVertexShader@gfxu@@EA DQ 01H DUP (?) ; noTexVShader
?square@@3PEAVVertexStream@gfxu@@EA DQ 01H DUP (?)	; square
?blocksTexture@RenderThread@@2PEAVTiledTexture@gfxu@@EA DQ 01H DUP (?) ; RenderThread::blocksTexture
_BSS	ENDS
?skipRender@RenderThread@@2_NA DB 01H			; RenderThread::skipRender
renderDistance DD 08H
$SG4294935983 DB 'gridTransform', 00H
	ORG $+2
$SG4294935982 DB 'arrayInsideCheck', 00H
	ORG $+7
$SG4294935981 DB 'OpenGL error', 00H
	ORG $+3
$SG4294935980 DB 'Graphics thread loop error', 00H
	ORG $+5
$SG4294935979 DB '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, 's', 00H, '\', 00H, 'f', 00H, 'r', 00H, 'u'
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'm', 00H, 'c', 00H, 'l', 00H
	DB	'i', 00H, 'p', 00H, '.', 00H, 'c', 00H, 'l', 00H, 00H, 00H
	ORG $+6
$SG4294935978 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 'l', 00H, '.', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	't', 00H, 00H, 00H
	ORG $+6
$SG4294935977 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 'l', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'a', 00H
	DB	'g', 00H, 00H, 00H
	ORG $+6
$SG4294935976 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'T', 00H, 'e'
	DB	00H, 'x', 00H, '.', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	00H, 00H
$SG4294935975 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'T', 00H, 'e'
	DB	00H, 'x', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'g', 00H
	DB	00H, 00H
PUBLIC	??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z ; std::_Move<ChunkBase * __ptr64 & __ptr64>
PUBLIC	??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z ; std::swap<ChunkBase * __ptr64>
PUBLIC	??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::_Ptr_base<ChunkBase> >
PUBLIC	?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z ; std::_Ptr_base<ChunkBase>::_Swap
PUBLIC	?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z ; std::_Ptr_base<ChunkBase>::_Assign_rv
PUBLIC	??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::shared_ptr<ChunkBase> >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
PUBLIC	??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z	; std::operator==<wchar_t,wchar_t>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ; std::addressof<std::shared_ptr<ChunkBase> const >
PUBLIC	??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity
PUBLIC	?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >
PUBLIC	?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
PUBLIC	?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
PUBLIC	?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to
PUBLIC	?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy
PUBLIC	?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Nextnode
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range
PUBLIC	?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
PUBLIC	?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
PUBLIC	?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside
PUBLIC	?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ	; List<Tasks::Task * __ptr64,256>::clear
PUBLIC	?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ	; List<Tasks::Task * __ptr64,256>::getSize
PUBLIC	??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z ; List<Tasks::Task * __ptr64,256>::operator[]
PUBLIC	?end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::end
PUBLIC	?begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::begin
PUBLIC	?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ; std::_Ptr_base<gfxu::VertexStream>::_Get
PUBLIC	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
PUBLIC	?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
PUBLIC	??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[]
PUBLIC	?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
PUBLIC	??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ ; VirtualList<Tasks::Task,256,4098>::clear
PUBLIC	?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ ; VirtualList<Tasks::Task,256,4098>::getSize
PUBLIC	??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z ; VirtualList<Tasks::Task,256,4098>::operator[]
PUBLIC	?end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end
PUBLIC	?begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin
PUBLIC	??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64
PUBLIC	??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ; std::shared_ptr<gfxu::VertexStream>::operator->
PUBLIC	?set@?$Uniform@M@gfxu@@QEAAXM@Z			; gfxu::Uniform<float>::set
PUBLIC	?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z ; gfxu::Uniform<geom::Vector>::set
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	??1FragmentShader@gfxu@@QEAA@XZ			; gfxu::FragmentShader::~FragmentShader
PUBLIC	??1VertexShader@gfxu@@QEAA@XZ			; gfxu::VertexShader::~VertexShader
PUBLIC	??_GTiledTexture@gfxu@@QEAAPEAXI@Z		; gfxu::TiledTexture::`scalar deleting destructor'
PUBLIC	??_GShaderProgram@gfxu@@QEAAPEAXI@Z		; gfxu::ShaderProgram::`scalar deleting destructor'
PUBLIC	??_GFragmentShader@gfxu@@QEAAPEAXI@Z		; gfxu::FragmentShader::`scalar deleting destructor'
PUBLIC	??_GVertexShader@gfxu@@QEAAPEAXI@Z		; gfxu::VertexShader::`scalar deleting destructor'
PUBLIC	?postStop@RenderThread@@UEAAXXZ			; RenderThread::postStop
PUBLIC	?preStart@RenderThread@@UEAAXXZ			; RenderThread::preStart
PUBLIC	?tick@RenderThread@@EEAA_NXZ			; RenderThread::tick
PUBLIC	?program@@3VProgram@cl@@A			; program
PUBLIC	?gridBuffer@@3VBuffer@cl@@A			; gridBuffer
PUBLIC	?projectionMatrixBuffer@@3VBuffer@cl@@A		; projectionMatrixBuffer
PUBLIC	?commandQueue@@3VCommandQueue@cl@@A		; commandQueue
PUBLIC	?boolBuffer@@3VBuffer@cl@@A			; boolBuffer
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

?program@@3VProgram@cl@@A DB 038H DUP (?)		; program
allocator_arg DB 01H DUP (?)
	ALIGN	4

?gridBuffer@@3VBuffer@cl@@A DB 018H DUP (?)		; gridBuffer
?projectionMatrixBuffer@@3VBuffer@cl@@A DB 018H DUP (?)	; projectionMatrixBuffer
piecewise_construct DB 01H DUP (?)
	ALIGN	4

?commandQueue@@3VCommandQueue@cl@@A DB 028H DUP (?)	; commandQueue
?boolBuffer@@3VBuffer@cl@@A DB 018H DUP (?)		; boolBuffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31+10
	DD	imagerel $LN31+97
	DD	imagerel $chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31+97
	DD	imagerel $LN31+99
	DD	imagerel $chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z DD imagerel $LN10
	DD	imagerel $LN10+26
	DD	imagerel $unwind$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35+10
	DD	imagerel $LN35+97
	DD	imagerel $chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35+97
	DD	imagerel $LN35+99
	DD	imagerel $chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+120
	DD	imagerel $LN85+180
	DD	imagerel $chain$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+180
	DD	imagerel $LN85+238
	DD	imagerel $chain$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+238
	DD	imagerel $LN85+244
	DD	imagerel $chain$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37+10
	DD	imagerel $LN37+97
	DD	imagerel $chain$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37+97
	DD	imagerel $LN37+99
	DD	imagerel $chain$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+35
	DD	imagerel $LN47+100
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+100
	DD	imagerel $LN47+126
	DD	imagerel $chain$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+126
	DD	imagerel $LN47+137
	DD	imagerel $chain$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN44
	DD	imagerel $LN44+139
	DD	imagerel $unwind$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD imagerel $LN80
	DD	imagerel $LN80+129
	DD	imagerel $unwind$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59
	DD	imagerel $LN59+35
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1FragmentShader@gfxu@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+88
	DD	imagerel $unwind$??1FragmentShader@gfxu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1VertexShader@gfxu@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+88
	DD	imagerel $unwind$??1VertexShader@gfxu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GTiledTexture@gfxu@@QEAAPEAXI@Z DD imagerel $LN73
	DD	imagerel $LN73+102
	DD	imagerel $unwind$??_GTiledTexture@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GShaderProgram@gfxu@@QEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_GShaderProgram@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD imagerel $LN45
	DD	imagerel $LN45+99
	DD	imagerel $unwind$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD imagerel $LN45
	DD	imagerel $LN45+99
	DD	imagerel $unwind$??_GVertexShader@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?postStop@RenderThread@@UEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+328
	DD	imagerel $unwind$?postStop@RenderThread@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?preStart@RenderThread@@UEAAXXZ DD imagerel $LN762
	DD	imagerel $LN762+2133
	DD	imagerel $unwind$?preStart@RenderThread@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@RenderThread@@EEAA_NXZ DD imagerel $LN1093
	DD	imagerel $LN1093+5286
	DD	imagerel $unwind$?tick@RenderThread@@EEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eprogram@@YAXXZ DD imagerel ??__Eprogram@@YAXXZ
	DD	imagerel ??__Eprogram@@YAXXZ+76
	DD	imagerel $unwind$??__Eprogram@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FcommandQueue@@YAXXZ DD imagerel ??__FcommandQueue@@YAXXZ
	DD	imagerel ??__FcommandQueue@@YAXXZ+91
	DD	imagerel $unwind$??__FcommandQueue@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FcommandQueue@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eprogram@@YAXXZ DD imagerel ??__Eprogram@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__Eprogram@@YAXXZ+25
	DD	00H
	DD	imagerel ??__Eprogram@@YAXXZ+60
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eprogram@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__Eprogram@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__Eprogram@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__Eprogram@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__Eprogram@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eprogram@@YAXXZ DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__Eprogram@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tick@RenderThread@@EEAA_NXZ DD imagerel ?tick@RenderThread@@EEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+2369
	DD	00H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+2430
	DD	0ffffffffH
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+2805
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+2860
	DD	02H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3410
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3471
	DD	02H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3497
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3624
	DD	03H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3934
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+4040
	DD	04H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+4340
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+5139
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tick@RenderThread@@EEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tick@RenderThread@@EEAA_NXZ DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?tick@RenderThread@@EEAA_NXZ
	DD	00H
	DD	00H
	DD	0dH
	DD	imagerel $ip2state$?tick@RenderThread@@EEAA_NXZ
	DD	0150H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@RenderThread@@EEAA_NXZ DD 0134c19H
	DD	06f983bH
	DD	0707836H
	DD	0716832H
	DD	0ed742eH
	DD	0ec642aH
	DD	0eb3426H
	DD	0e4011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?tick@RenderThread@@EEAA_NXZ
	DD	06e2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?preStart@RenderThread@@UEAAXXZ DD imagerel ?preStart@RenderThread@@UEAAXXZ
	DD	0ffffffffH
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+235
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1416
	DD	01H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1474
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1543
	DD	02H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1601
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1625
	DD	03H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1672
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1741
	DD	04H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1799
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1868
	DD	05H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1926
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1950
	DD	06H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1997
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2065
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?preStart@RenderThread@@UEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?preStart@RenderThread@@UEAAXXZ DD 019930522H
	DD	07H
	DD	imagerel $stateUnwindMap$?preStart@RenderThread@@UEAAXXZ
	DD	00H
	DD	00H
	DD	0fH
	DD	imagerel $ip2state$?preStart@RenderThread@@UEAAXXZ
	DD	048H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?preStart@RenderThread@@UEAAXXZ DD 0f3e19H
	DD	088830H
	DD	09782bH
	DD	0a6827H
	DD	01a7423H
	DD	019641fH
	DD	018341bH
	DD	016010fH
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?preStart@RenderThread@@UEAAXXZ
	DD	072H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?postStop@RenderThread@@UEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z+32
	DD	00H
	DD	imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z+32
	DD	00H
	DD	imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GShaderProgram@gfxu@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GTiledTexture@gfxu@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1VertexShader@gfxu@@QEAA@XZ DD imagerel ??1VertexShader@gfxu@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1VertexShader@gfxu@@QEAA@XZ+32
	DD	00H
	DD	imagerel ??1VertexShader@gfxu@@QEAA@XZ+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1VertexShader@gfxu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1VertexShader@gfxu@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1VertexShader@gfxu@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1VertexShader@gfxu@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1VertexShader@gfxu@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1VertexShader@gfxu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1FragmentShader@gfxu@@QEAA@XZ DD imagerel ??1FragmentShader@gfxu@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1FragmentShader@gfxu@@QEAA@XZ+32
	DD	00H
	DD	imagerel ??1FragmentShader@gfxu@@QEAA@XZ+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1FragmentShader@gfxu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1FragmentShader@gfxu@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1FragmentShader@gfxu@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1FragmentShader@gfxu@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1FragmentShader@gfxu@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1FragmentShader@gfxu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 020521H
	DD	075405H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 061221H
	DD	0dc412H
	DD	0c740dH
	DD	0b5405H
	DD	imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 040a01H
	DD	0f006520aH
	DD	06002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 010401H
	DD	06204H
commandQueue$initializer$ DQ FLAT:??__EcommandQueue@@YAXXZ
program$initializer$ DQ FLAT:??__Eprogram@@YAXXZ
projectionMatrixBuffer$initializer$ DQ FLAT:??__EprojectionMatrixBuffer@@YAXXZ
boolBuffer$initializer$ DQ FLAT:??__EboolBuffer@@YAXXZ
gridBuffer$initializer$ DQ FLAT:??__EgridBuffer@@YAXXZ
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EcommandQueue@@YAXXZ
text$yc	SEGMENT
??__EcommandQueue@@YAXXZ PROC				; `dynamic initializer for 'commandQueue'', COMDAT

; 13   : cl::CommandQueue commandQueue;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FcommandQueue@@YAXXZ ; `dynamic atexit destructor for 'commandQueue''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EcommandQueue@@YAXXZ ENDP				; `dynamic initializer for 'commandQueue''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??__FcommandQueue@@YAXXZ
text$yd	SEGMENT
$T1 = 48
??__FcommandQueue@@YAXXZ PROC				; `dynamic atexit destructor for 'commandQueue'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 49   : 	if(okay) clReleaseCommandQueue(queue);

  00004	80 3d 20 00 00
	00 00		 cmp	 BYTE PTR ?commandQueue@@3VCommandQueue@cl@@A+32, 0
  0000b	74 0d		 je	 SHORT $LN3@dynamic
  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseCommandQueue
$LN3@dynamic:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  0001a	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+8, 0
  00022	74 32		 je	 SHORT $LN8@dynamic

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00024	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PEAU_cl_event@@V?$allocator@PEAU_cl_event@@@std@@@std@@IEAAXPEAPEAU_cl_event@@0@Z ; std::vector<_cl_event * __ptr64,std::allocator<_cl_event * __ptr64> >::_Destroy

; 647  : 		return (_Alty());

  00029	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0002e	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PEAU_cl_event@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<_cl_event * __ptr64> >::_Wrap_alloc<std::allocator<_cl_event * __ptr64> >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00033	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+8
  0003a	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  0003f	33 c0		 xor	 eax, eax
  00041	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+8, rax

; 1543 : 			this->_Mylast = pointer();

  00048	48 89 05 10 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+16, rax

; 1544 : 			this->_Myend = pointer();

  0004f	48 89 05 18 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+24, rax
$LN8@dynamic:
  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
??__FcommandQueue@@YAXXZ ENDP				; `dynamic atexit destructor for 'commandQueue''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__Eprogram@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__Eprogram@@YAXXZ PROC				; `dynamic initializer for 'program'', COMDAT

; 14   : cl::Program program;

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 778  : 		this->_Myhead = _Buyheadnode();

  0000d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64> > > >::_Buyheadnode
  00012	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?program@@3VProgram@cl@@A+8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00019	ba 02 00 00 00	 mov	 edx, 2
  0001e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A+24
  00025	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN31@dynamic

; 33   : 		_Throw_C_error(_Res);

  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN31@dynamic:
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 97   : {

  00035	c6 05 30 00 00
	00 00		 mov	 BYTE PTR ?program@@3VProgram@cl@@A+48, 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 14   : cl::Program program;

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__Fprogram@@YAXXZ ; `dynamic atexit destructor for 'program''
  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	e9 00 00 00 00	 jmp	 atexit
??__Eprogram@@YAXXZ ENDP				; `dynamic initializer for 'program''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__Eprogram@@YAXXZ@4HA PROC			; ``dynamic initializer for 'program'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@QEAA@XZ
?dtor$0@?0???__Eprogram@@YAXXZ@4HA ENDP			; ``dynamic initializer for 'program'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fprogram@@YAXXZ
text$yd	SEGMENT
??__Fprogram@@YAXXZ PROC				; `dynamic atexit destructor for 'program'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00007	e9 00 00 00 00	 jmp	 ??1Program@cl@@QEAA@XZ	; cl::Program::~Program
??__Fprogram@@YAXXZ ENDP				; `dynamic atexit destructor for 'program''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EprojectionMatrixBuffer@@YAXXZ
text$yc	SEGMENT
??__EprojectionMatrixBuffer@@YAXXZ PROC			; `dynamic initializer for 'projectionMatrixBuffer'', COMDAT

; 15   : cl::Buffer projectionMatrixBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FprojectionMatrixBuffer@@YAXXZ ; `dynamic atexit destructor for 'projectionMatrixBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EprojectionMatrixBuffer@@YAXXZ ENDP			; `dynamic initializer for 'projectionMatrixBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FprojectionMatrixBuffer@@YAXXZ
text$yd	SEGMENT
??__FprojectionMatrixBuffer@@YAXXZ PROC			; `dynamic atexit destructor for 'projectionMatrixBuffer'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?projectionMatrixBuffer@@3VBuffer@cl@@A ; projectionMatrixBuffer
  00007	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__FprojectionMatrixBuffer@@YAXXZ ENDP			; `dynamic atexit destructor for 'projectionMatrixBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EboolBuffer@@YAXXZ
text$yc	SEGMENT
??__EboolBuffer@@YAXXZ PROC				; `dynamic initializer for 'boolBuffer'', COMDAT

; 16   : cl::Buffer boolBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FboolBuffer@@YAXXZ ; `dynamic atexit destructor for 'boolBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EboolBuffer@@YAXXZ ENDP				; `dynamic initializer for 'boolBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FboolBuffer@@YAXXZ
text$yd	SEGMENT
??__FboolBuffer@@YAXXZ PROC				; `dynamic atexit destructor for 'boolBuffer'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?boolBuffer@@3VBuffer@cl@@A ; boolBuffer
  00007	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__FboolBuffer@@YAXXZ ENDP				; `dynamic atexit destructor for 'boolBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EgridBuffer@@YAXXZ
text$yc	SEGMENT
??__EgridBuffer@@YAXXZ PROC				; `dynamic initializer for 'gridBuffer'', COMDAT

; 17   : cl::Buffer gridBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FgridBuffer@@YAXXZ ; `dynamic atexit destructor for 'gridBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EgridBuffer@@YAXXZ ENDP				; `dynamic initializer for 'gridBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__FgridBuffer@@YAXXZ
text$yd	SEGMENT
??__FgridBuffer@@YAXXZ PROC				; `dynamic atexit destructor for 'gridBuffer'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gridBuffer@@3VBuffer@cl@@A ; gridBuffer
  00007	e9 00 00 00 00	 jmp	 ??1Buffer@cl@@QEAA@XZ	; cl::Buffer::~Buffer
??__FgridBuffer@@YAXXZ ENDP				; `dynamic atexit destructor for 'gridBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?tick@RenderThread@@EEAA_NXZ
_TEXT	SEGMENT
chunksToRender$ = 48
yCam$ = 72
xCam$ = 76
zCam$ = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 208
chunk$9 = 224
$T10 = 240
$T11 = 256
$T12 = 288
c$13 = 320
$T14 = 336
$T15 = 344
chunk$16 = 352
chunk$17 = 368
$T18 = 384
$T19 = 448
$T20 = 512
$T21 = 576
$T22 = 640
$T23 = 704
$T24 = 768
$T25 = 832
$T26 = 896
$T27 = 960
$T28 = 976
$T29 = 1000
$T30 = 1024
$T31 = 1088
$T32 = 1152
$T33 = 1216
$T34 = 1280
projectionMatrix$ = 1344
$T35 = 1408
$T36 = 1472
$T37 = 1536
$T38 = 1600
global_ws_2$ = 1664
global_ws_1$ = 1688
local_ws_1$ = 1712
local_ws_2$ = 1736
__$ArrayPad$ = 1760
this$ = 1872
?tick@RenderThread@@EEAA_NXZ PROC			; RenderThread::tick, COMDAT

; 32   : {

$LN1093:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d a8 b8 f9
	ff ff		 lea	 rbp, QWORD PTR [rax-1608]
  00013	48 81 ec 20 07
	00 00		 sub	 rsp, 1824		; 00000720H
  0001a	48 c7 45 50 fe
	ff ff ff	 mov	 QWORD PTR $T14[rbp-256], -2
  00022	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00026	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0002a	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0002e	0f 29 70 c8	 movaps	 XMMWORD PTR [rax-56], xmm6
  00032	0f 29 78 b8	 movaps	 XMMWORD PTR [rax-72], xmm7
  00036	44 0f 29 48 a8	 movaps	 XMMWORD PTR [rax-88], xmm9
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00042	48 33 c4	 xor	 rax, rsp
  00045	48 89 85 e0 05
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0004c	48 8b f1	 mov	 rsi, rcx

; 33   : 	for(int i = 0; i < RenderThread::taskList.getSize(); i++)

  0004f	45 33 e4	 xor	 r12d, r12d
  00052	41 8b fc	 mov	 edi, r12d
  00055	45 8d 74 24 01	 lea	 r14d, QWORD PTR [r12+1]
  0005a	44 39 a1 20 08
	00 00		 cmp	 DWORD PTR [rcx+2080], r12d
  00061	7e 2d		 jle	 SHORT $LN40@tick
  00063	48 8d 59 20	 lea	 rbx, QWORD PTR [rcx+32]
$LL42@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h

; 53   : 		return List::operator[](index);

  00067	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 35   : 		if(!RenderThread::taskList[i]->invoke())

  0006a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0006d	ff 10		 call	 QWORD PTR [rax]
  0006f	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00076	84 c0		 test	 al, al
  00078	41 0f 44 ce	 cmove	 ecx, r14d
  0007c	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop

; 33   : 	for(int i = 0; i < RenderThread::taskList.getSize(); i++)

  00082	ff c7		 inc	 edi
  00084	48 8d 5b 08	 lea	 rbx, QWORD PTR [rbx+8]
  00088	3b be 20 08 00
	00		 cmp	 edi, DWORD PTR [rsi+2080]
  0008e	7c d7		 jl	 SHORT $LL42@tick
$LN40@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h

; 37   : 		count = 0;

  00090	44 89 a6 20 08
	00 00		 mov	 DWORD PTR [rsi+2080], r12d
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 18   : 	pos = 0;

  00097	44 89 a6 34 08
	00 00		 mov	 DWORD PTR [rsi+2100], r12d
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 43   : 	if(RenderThread::skipRender)

  0009e	44 38 25 00 00
	00 00		 cmp	 BYTE PTR ?skipRender@RenderThread@@2_NA, r12b ; RenderThread::skipRender
  000a5	74 09		 je	 SHORT $LN38@tick

; 44   : 	{
; 45   : 		return true;

  000a7	41 0f b6 c6	 movzx	 eax, r14b
  000ab	e9 b7 13 00 00	 jmp	 $LN43@tick
$LN38@tick:

; 46   : 	}
; 47   : 
; 48   : 	GameStates::swapPendingRendering();

  000b0	e8 00 00 00 00	 call	 ?swapPendingRendering@GameStates@@YAXXZ ; GameStates::swapPendingRendering

; 49   : 
; 50   : 	GameStates::GameState* state = GameStates::renderingState;

  000b5	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR ?renderingState@GameStates@@3PEAVGameState@1@EA ; GameStates::renderingState

; 51   : 
; 52   : 	if(GLWindow::instance->rescaled)

  000bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  000c3	44 38 60 58	 cmp	 BYTE PTR [rax+88], r12b
  000c7	74 1d		 je	 SHORT $LN37@tick

; 53   : 	{
; 54   : 		glViewport(0, 0, GLWindow::instance->width, GLWindow::instance->height);

  000c9	44 8b 48 60	 mov	 r9d, DWORD PTR [rax+96]
  000cd	44 8b 40 5c	 mov	 r8d, DWORD PTR [rax+92]
  000d1	33 d2		 xor	 edx, edx
  000d3	33 c9		 xor	 ecx, ecx
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glViewport

; 55   : 		GLWindow::instance->rescaled = false;

  000db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  000e2	44 88 60 58	 mov	 BYTE PTR [rax+88], r12b
$LN37@tick:

; 56   : 	}
; 57   : 		
; 58   : 	normalShaderProgram->bind();

  000e6	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 492  : 	glUseProgram(object);

  000ed	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 879  : 	int error = glGetError();

  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 880  : 	if(error != GL_NO_ERROR)

  000fc	85 c0		 test	 eax, eax
  000fe	74 1e		 je	 SHORT $LN71@tick

; 881  : 	{
; 882  : 		const char* errorString = (const char*)gluErrorString(error);

  00100	8b c8		 mov	 ecx, eax
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 883  : 		GLWindow::instance->postError(errorString, caption);

  00108	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294912325
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00119	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN71@tick:

; 493  : 	gfxu::getError();
; 494  : 	current = this;

  0011e	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?current@ShaderProgram@gfxu@@2PEAV12@EA, rbx ; gfxu::ShaderProgram::current

; 619  : }
; 620  : 
; 621  : void Uniforms::setForceUpload()
; 622  : {
; 623  : 	MMS.changed = PMS.changed = true;

  00125	44 88 35 68 00
	00 00		 mov	 BYTE PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+104, r14b
  0012c	44 88 35 68 00
	00 00		 mov	 BYTE PTR ?MMS@Uniforms@gfxu@@2VMatrixStack@2@A+104, r14b
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00133	f3 41 0f 10 45
	00		 movss	 xmm0, DWORD PTR [r13]
  00139	f3 0f 11 45 98	 movss	 DWORD PTR $T5[rbp-256], xmm0
  0013e	f3 41 0f 10 4d
	04		 movss	 xmm1, DWORD PTR [r13+4]
  00144	f3 0f 11 4d 9c	 movss	 DWORD PTR $T5[rbp-252], xmm1
  00149	f3 41 0f 10 45
	08		 movss	 xmm0, DWORD PTR [r13+8]
  0014f	f3 0f 11 45 a0	 movss	 DWORD PTR $T5[rbp-248], xmm0
  00154	f3 41 0f 10 4d
	0c		 movss	 xmm1, DWORD PTR [r13+12]
  0015a	f3 0f 11 4d a4	 movss	 DWORD PTR $T5[rbp-244], xmm1
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  0015f	48 8b 45 98	 mov	 rax, QWORD PTR $T5[rbp-256]
  00163	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  0016a	48 8b 45 a0	 mov	 rax, QWORD PTR $T5[rbp-248]
  0016e	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  00175	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  0017c	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3f800000
  00184	c7 44 24 78 00
	00 80 3f	 mov	 DWORD PTR $T3[rsp], 1065353216 ; 3f800000H
  0018c	c7 44 24 7c 00
	00 80 3f	 mov	 DWORD PTR $T3[rsp+4], 1065353216 ; 3f800000H
  00194	c7 45 80 00 00
	80 3f		 mov	 DWORD PTR $T3[rbp-248], 1065353216 ; 3f800000H
  0019b	c7 45 84 00 00
	80 3f		 mov	 DWORD PTR $T3[rbp-244], 1065353216 ; 3f800000H
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  001a2	48 8b 44 24 78	 mov	 rax, QWORD PTR $T3[rsp]
  001a7	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  001ae	48 8b 45 80	 mov	 rax, QWORD PTR $T3[rbp-248]
  001b2	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  001b9	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 61   : 	if(GlobalThread::world.getBlock(floorf(state->cam.pos.x), floorf(state->cam.pos.y), floorf(state->cam.pos.z)) != Blocks::water)

  001c0	f3 41 0f 10 45
	08		 movss	 xmm0, DWORD PTR [r13+8]
  001c6	e8 00 00 00 00	 call	 floorf
  001cb	f3 0f 2c f8	 cvttss2si edi, xmm0
  001cf	f3 41 0f 10 45
	04		 movss	 xmm0, DWORD PTR [r13+4]
  001d5	e8 00 00 00 00	 call	 floorf
  001da	f3 0f 2c d8	 cvttss2si ebx, xmm0
  001de	f3 41 0f 10 45
	00		 movss	 xmm0, DWORD PTR [r13]
  001e4	e8 00 00 00 00	 call	 floorf
  001e9	f3 0f 2c d0	 cvttss2si edx, xmm0
  001ed	44 8b cf	 mov	 r9d, edi
  001f0	44 8b c3	 mov	 r8d, ebx
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  001fa	e8 00 00 00 00	 call	 ?getBlock@World@@QEAAPEAVBlock@@HHH@Z ; World::getBlock
  001ff	0f 57 ff	 xorps	 xmm7, xmm7
  00202	f3 44 0f 10 0d
	00 00 00 00	 movss	 xmm9, DWORD PTR __real@43000000

; 62   : 	{
; 63   : 		glClearColor(0.5f, 0.875f, 1.0f, 1.0f);

  0020b	0f 28 de	 movaps	 xmm3, xmm6

; 61   : 	if(GlobalThread::world.getBlock(floorf(state->cam.pos.x), floorf(state->cam.pos.y), floorf(state->cam.pos.z)) != Blocks::water)

  0020e	48 3b 05 00 00
	00 00		 cmp	 rax, QWORD PTR ?water@Blocks@@3PEAVBlockFluid@@EA ; Blocks::water
  00215	74 50		 je	 SHORT $LN36@tick

; 62   : 	{
; 63   : 		glClearColor(0.5f, 0.875f, 1.0f, 1.0f);

  00217	0f 28 d6	 movaps	 xmm2, xmm6
  0021a	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f600000
  00222	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClearColor
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  00230	c7 45 a8 00 00
	00 3f		 mov	 DWORD PTR $T6[rbp-256], 1056964608 ; 3f000000H
  00237	c7 45 ac 00 00
	60 3f		 mov	 DWORD PTR $T6[rbp-252], 1063256064 ; 3f600000H
  0023e	c7 45 b0 00 00
	80 3f		 mov	 DWORD PTR $T6[rbp-248], 1065353216 ; 3f800000H
  00245	c7 45 b4 00 00
	80 3f		 mov	 DWORD PTR $T6[rbp-244], 1065353216 ; 3f800000H
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  0024c	48 8b 45 a8	 mov	 rax, QWORD PTR $T6[rbp-256]
  00250	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  00257	48 8b 45 b0	 mov	 rax, QWORD PTR $T6[rbp-248]
  0025b	c7 05 00 00 00
	00 00 00 00 43	 mov	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, 1124073472 ; 43000000H
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 67   : 	else

  00265	eb 42		 jmp	 SHORT $LN1090@tick
$LN36@tick:

; 68   : 	{
; 69   : 		glClearColor(0.0f, 0.0f, 0.1f, 1.0f);

  00267	f3 0f 10 15 00
	00 00 00	 movss	 xmm2, DWORD PTR __real@3dcccccd
  0026f	0f 28 cf	 movaps	 xmm1, xmm7
  00272	0f 28 c7	 movaps	 xmm0, xmm7
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClearColor
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  0027b	4c 89 64 24 58	 mov	 QWORD PTR $T1[rsp], r12
  00280	c7 44 24 60 cd
	cc cc 3d	 mov	 DWORD PTR $T1[rsp+8], 1036831949 ; 3dcccccdH
  00288	c7 44 24 64 00
	00 80 3f	 mov	 DWORD PTR $T1[rsp+12], 1065353216 ; 3f800000H
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  00290	49 8b c4	 mov	 rax, r12
  00293	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  0029a	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp+8]
  0029f	c7 05 00 00 00
	00 00 00 80 41	 mov	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, 1098907648 ; 41800000H
$LN1090@tick:

; 305  : 			changed = true;

  002a9	44 88 35 04 00
	00 00		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, r14b
  002b0	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b

; 304  : 			val = value;

  002b7	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 617  : 	MMS.clear();

  002be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  002c5	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear

; 618  : 	PMS.clear();

  002ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  002d1	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 74   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::perspective(state->FOV, (float)GLWindow::instance->width / (float)GLWindow::instance->height, 0.1f, 16.0f * renderDistance));

  002d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  002dd	66 0f 6e 50 5c	 movd	 xmm2, DWORD PTR [rax+92]
  002e2	0f 5b d2	 cvtdq2ps xmm2, xmm2
  002e5	66 0f 6e 40 60	 movd	 xmm0, DWORD PTR [rax+96]
  002ea	0f 5b c0	 cvtdq2ps xmm0, xmm0
  002ed	f3 0f 5e d0	 divss	 xmm2, xmm0
  002f1	66 41 0f 6e 4d
	20		 movd	 xmm1, DWORD PTR [r13+32]
  002f7	0f 5b c9	 cvtdq2ps xmm1, xmm1
  002fa	f3 44 0f 11 4c
	24 20		 movss	 DWORD PTR [rsp+32], xmm9
  00301	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3dcccccd
  00309	48 8d 8d 80 04
	00 00		 lea	 rcx, QWORD PTR $T35[rbp-256]
  00310	e8 00 00 00 00	 call	 ?perspective@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::perspective
  00315	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00318	0f 29 85 80 00
	00 00		 movaps	 XMMWORD PTR $T18[rbp-256], xmm0
  0031f	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00323	0f 29 8d 90 00
	00 00		 movaps	 XMMWORD PTR $T18[rbp-240], xmm1
  0032a	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  0032e	0f 29 85 a0 00
	00 00		 movaps	 XMMWORD PTR $T18[rbp-224], xmm0
  00335	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  00339	0f 29 8d b0 00
	00 00		 movaps	 XMMWORD PTR $T18[rbp-208], xmm1
  00340	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR $T18[rbp-256]
  00347	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  0034e	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 75   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.x, 1.0f, 0.0f, 0.0f));

  00353	f3 0f 11 7c 24
	20		 movss	 DWORD PTR [rsp+32], xmm7
  00359	0f 28 df	 movaps	 xmm3, xmm7
  0035c	0f 28 d6	 movaps	 xmm2, xmm6
  0035f	f3 41 0f 10 4d
	10		 movss	 xmm1, DWORD PTR [r13+16]
  00365	48 8d 8d c0 04
	00 00		 lea	 rcx, QWORD PTR $T36[rbp-256]
  0036c	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  00371	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00374	0f 29 85 40 02
	00 00		 movaps	 XMMWORD PTR $T25[rbp-256], xmm0
  0037b	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0037f	0f 29 8d 50 02
	00 00		 movaps	 XMMWORD PTR $T25[rbp-240], xmm1
  00386	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  0038a	0f 29 85 60 02
	00 00		 movaps	 XMMWORD PTR $T25[rbp-224], xmm0
  00391	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  00395	0f 29 8d 70 02
	00 00		 movaps	 XMMWORD PTR $T25[rbp-208], xmm1
  0039c	48 8d 95 40 02
	00 00		 lea	 rdx, QWORD PTR $T25[rbp-256]
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  003aa	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 76   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.y, 0.0f, 1.0f, 0.0f));

  003af	f3 0f 11 7c 24
	20		 movss	 DWORD PTR [rsp+32], xmm7
  003b5	0f 28 de	 movaps	 xmm3, xmm6
  003b8	0f 28 d7	 movaps	 xmm2, xmm7
  003bb	f3 41 0f 10 4d
	14		 movss	 xmm1, DWORD PTR [r13+20]
  003c1	48 8d 8d 40 05
	00 00		 lea	 rcx, QWORD PTR $T38[rbp-256]
  003c8	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  003cd	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  003d0	0f 29 85 c0 01
	00 00		 movaps	 XMMWORD PTR $T23[rbp-256], xmm0
  003d7	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  003db	0f 29 8d d0 01
	00 00		 movaps	 XMMWORD PTR $T23[rbp-240], xmm1
  003e2	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  003e6	0f 29 85 e0 01
	00 00		 movaps	 XMMWORD PTR $T23[rbp-224], xmm0
  003ed	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  003f1	0f 29 8d f0 01
	00 00		 movaps	 XMMWORD PTR $T23[rbp-208], xmm1
  003f8	48 8d 95 c0 01
	00 00		 lea	 rdx, QWORD PTR $T23[rbp-256]
  003ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  00406	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 77   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.z, 0.0f, 0.0f, 1.0f));

  0040b	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  00411	0f 28 df	 movaps	 xmm3, xmm7
  00414	0f 28 d7	 movaps	 xmm2, xmm7
  00417	f3 41 0f 10 4d
	18		 movss	 xmm1, DWORD PTR [r13+24]
  0041d	48 8d 8d 00 05
	00 00		 lea	 rcx, QWORD PTR $T37[rbp-256]
  00424	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  00429	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0042c	0f 29 85 c0 00
	00 00		 movaps	 XMMWORD PTR $T19[rbp-256], xmm0
  00433	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00437	0f 29 8d d0 00
	00 00		 movaps	 XMMWORD PTR $T19[rbp-240], xmm1
  0043e	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  00442	0f 29 85 e0 00
	00 00		 movaps	 XMMWORD PTR $T19[rbp-224], xmm0
  00449	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  0044d	0f 29 8d f0 00
	00 00		 movaps	 XMMWORD PTR $T19[rbp-208], xmm1
  00454	48 8d 95 c0 00
	00 00		 lea	 rdx, QWORD PTR $T19[rbp-256]
  0045b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  00462	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 78   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::translate(-state->cam.pos.x, -state->cam.pos.y, -state->cam.pos.z));

  00467	f3 41 0f 10 5d
	08		 movss	 xmm3, DWORD PTR [r13+8]
  0046d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00475	0f 57 d8	 xorps	 xmm3, xmm0
  00478	f3 41 0f 10 55
	04		 movss	 xmm2, DWORD PTR [r13+4]
  0047e	0f 57 d0	 xorps	 xmm2, xmm0
  00481	f3 41 0f 10 4d
	00		 movss	 xmm1, DWORD PTR [r13]
  00487	0f 57 c8	 xorps	 xmm1, xmm0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  0048a	4c 89 a5 c0 03
	00 00		 mov	 QWORD PTR $T33[rbp-256], r12
  00491	4c 89 a5 c8 03
	00 00		 mov	 QWORD PTR $T33[rbp-248], r12
  00498	4c 89 a5 d0 03
	00 00		 mov	 QWORD PTR $T33[rbp-240], r12
  0049f	4c 89 a5 d8 03
	00 00		 mov	 QWORD PTR $T33[rbp-232], r12
  004a6	4c 89 a5 e0 03
	00 00		 mov	 QWORD PTR $T33[rbp-224], r12
  004ad	4c 89 a5 e8 03
	00 00		 mov	 QWORD PTR $T33[rbp-216], r12
  004b4	4c 89 a5 f0 03
	00 00		 mov	 QWORD PTR $T33[rbp-208], r12
  004bb	4c 89 a5 f8 03
	00 00		 mov	 QWORD PTR $T33[rbp-200], r12

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  004c2	c7 85 c0 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T33[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  004cc	c7 85 d4 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T33[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  004d6	c7 85 e8 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T33[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  004e0	c7 85 fc 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T33[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  004ea	f3 0f 11 8d cc
	03 00 00	 movss	 DWORD PTR $T33[rbp-244], xmm1

; 246  : 	result[7] = y;

  004f2	f3 0f 11 95 dc
	03 00 00	 movss	 DWORD PTR $T33[rbp-228], xmm2

; 247  : 	result[11] = z;

  004fa	f3 0f 11 9d ec
	03 00 00	 movss	 DWORD PTR $T33[rbp-212], xmm3
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 78   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::translate(-state->cam.pos.x, -state->cam.pos.y, -state->cam.pos.z));

  00502	0f 28 85 c0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T33[rbp-256]
  00509	0f 29 85 80 01
	00 00		 movaps	 XMMWORD PTR $T22[rbp-256], xmm0
  00510	0f 28 8d d0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T33[rbp-240]
  00517	0f 29 8d 90 01
	00 00		 movaps	 XMMWORD PTR $T22[rbp-240], xmm1
  0051e	0f 28 85 e0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T33[rbp-224]
  00525	0f 29 85 a0 01
	00 00		 movaps	 XMMWORD PTR $T22[rbp-224], xmm0
  0052c	0f 28 8d f0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T33[rbp-208]
  00533	0f 29 8d b0 01
	00 00		 movaps	 XMMWORD PTR $T22[rbp-208], xmm1
  0053a	48 8d 95 80 01
	00 00		 lea	 rdx, QWORD PTR $T22[rbp-256]
  00541	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  00548	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 79   : 
; 80   : 	float cScale = 1.0f + 90.0f / state->FOV;
; 81   : 	int xCam = floorf(state->cam.pos.x / 16.0f);

  0054d	f3 41 0f 10 45
	00		 movss	 xmm0, DWORD PTR [r13]
  00553	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3d800000
  0055b	f3 0f 59 c6	 mulss	 xmm0, xmm6
  0055f	e8 00 00 00 00	 call	 floorf
  00564	f3 0f 2c c0	 cvttss2si eax, xmm0
  00568	89 44 24 4c	 mov	 DWORD PTR xCam$[rsp], eax

; 82   : 	int yCam = floorf(state->cam.pos.y / 16.0f);

  0056c	f3 41 0f 10 45
	04		 movss	 xmm0, DWORD PTR [r13+4]
  00572	f3 0f 59 c6	 mulss	 xmm0, xmm6
  00576	e8 00 00 00 00	 call	 floorf
  0057b	f3 0f 2c c0	 cvttss2si eax, xmm0
  0057f	89 44 24 48	 mov	 DWORD PTR yCam$[rsp], eax

; 83   : 	int zCam = floorf(state->cam.pos.z / 16.0f);

  00583	f3 41 0f 10 45
	08		 movss	 xmm0, DWORD PTR [r13+8]
  00589	f3 0f 59 c6	 mulss	 xmm0, xmm6
  0058d	e8 00 00 00 00	 call	 floorf
  00592	f3 0f 2c c0	 cvttss2si eax, xmm0
  00596	89 44 24 50	 mov	 DWORD PTR zCam$[rsp], eax
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 562  : 	return topmost;

  0059a	0f 10 05 28 00
	00 00		 movups	 xmm0, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+40
  005a1	0f 29 85 40 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-256], xmm0
  005a8	0f 10 0d 38 00
	00 00		 movups	 xmm1, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+56
  005af	0f 29 8d 50 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-240], xmm1
  005b6	0f 10 05 48 00
	00 00		 movups	 xmm0, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+72
  005bd	0f 29 85 60 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-224], xmm0
  005c4	0f 10 0d 58 00
	00 00		 movups	 xmm1, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+88
  005cb	0f 29 8d 70 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-208], xmm1
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 312  : 	return write(queue, 0, size, data);

  005d2	48 8d 85 40 04
	00 00		 lea	 rax, QWORD PTR projectionMatrix$[rbp-256]
  005d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005de	4c 8b 0d 10 00
	00 00		 mov	 r9, QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+16
  005e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?commandQueue@@3VCommandQueue@cl@@A ; commandQueue
  005ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?projectionMatrixBuffer@@3VBuffer@cl@@A ; projectionMatrixBuffer
  005f3	e8 00 00 00 00	 call	 ?write@Buffer@cl@@QEAA_NAEAVCommandQueue@2@_K1PEBX@Z ; cl::Buffer::write
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 88   : 	const size_t global_ws_1[] = {renderDistance * 2 + 2, renderDistance * 2 + 2, renderDistance * 2 + 2};

  005f8	48 c7 85 98 05
	00 00 12 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-256], 18
  00603	48 c7 85 a0 05
	00 00 12 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-248], 18
  0060e	48 c7 85 a8 05
	00 00 12 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-240], 18

; 89   : 	const size_t local_ws_1[] = {1, 1, 1};

  00619	4c 89 b5 b0 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-256], r14
  00620	4c 89 b5 b8 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-248], r14
  00627	4c 89 b5 c0 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-240], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0062e	48 c7 45 38 0f
	00 00 00	 mov	 QWORD PTR $T12[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00636	4c 89 65 30	 mov	 QWORD PTR $T12[rbp-240], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0063a	44 88 65 20	 mov	 BYTE PTR $T12[rbp-256], r12b
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  0063e	41 b8 0d 00 00
	00		 mov	 r8d, 13
  00644	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294935983
  0064b	48 8d 4d 20	 lea	 rcx, QWORD PTR $T12[rbp-256]
  0064f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 91   : 	if(!program.prepare("gridTransform")) return false;

  00654	48 8d 55 20	 lea	 rdx, QWORD PTR $T12[rbp-256]
  00658	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  0065f	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  00664	84 c0		 test	 al, al
  00666	75 07		 jne	 SHORT $LN34@tick
$LN1092@tick:
  00668	32 c0		 xor	 al, al
  0066a	e9 f8 0d 00 00	 jmp	 $LN43@tick
$LN34@tick:

; 92   : 	if(!program.setArgument(sizeof(const unsigned int), &renderDistance)) return false;

  0066f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:renderDistance
  00676	ba 04 00 00 00	 mov	 edx, 4
  0067b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00682	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  00687	84 c0		 test	 al, al
  00689	74 dd		 je	 SHORT $LN1092@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  0068b	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:?projectionMatrixBuffer@@3VBuffer@cl@@A+8
  00692	ba 08 00 00 00	 mov	 edx, 8
  00697	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  0069e	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 93   : 	if(!program.setArgument(sizeof(cl_mem), &projectionMatrixBuffer)) return false;

  006a3	84 c0		 test	 al, al
  006a5	74 c1		 je	 SHORT $LN1092@tick

; 94   : 	if(!program.setArgument(sizeof(const int), &xCam)) return false;

  006a7	4c 8d 44 24 4c	 lea	 r8, QWORD PTR xCam$[rsp]
  006ac	ba 04 00 00 00	 mov	 edx, 4
  006b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  006b8	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  006bd	84 c0		 test	 al, al
  006bf	74 a7		 je	 SHORT $LN1092@tick

; 95   : 	if(!program.setArgument(sizeof(const int), &yCam)) return false;

  006c1	4c 8d 44 24 48	 lea	 r8, QWORD PTR yCam$[rsp]
  006c6	ba 04 00 00 00	 mov	 edx, 4
  006cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  006d2	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  006d7	84 c0		 test	 al, al
  006d9	74 8d		 je	 SHORT $LN1092@tick

; 96   : 	if(!program.setArgument(sizeof(const int), &zCam)) return false;

  006db	4c 8d 44 24 50	 lea	 r8, QWORD PTR zCam$[rsp]
  006e0	ba 04 00 00 00	 mov	 edx, 4
  006e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  006ec	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  006f1	84 c0		 test	 al, al
  006f3	0f 84 6f ff ff
	ff		 je	 $LN1092@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  006f9	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:?boolBuffer@@3VBuffer@cl@@A+8
  00700	ba 08 00 00 00	 mov	 edx, 8
  00705	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  0070c	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 97   : 	if(!program.setArgument(sizeof(cl_mem), &boolBuffer)) return false;

  00711	84 c0		 test	 al, al
  00713	0f 84 4f ff ff
	ff		 je	 $LN1092@tick

; 98   : 	if(!program.invoke(commandQueue, 3, global_ws_1, local_ws_1)) return false;

  00719	48 8d 85 b0 05
	00 00		 lea	 rax, QWORD PTR local_ws_1$[rbp-256]
  00720	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00725	4c 8d 8d 98 05
	00 00		 lea	 r9, QWORD PTR global_ws_1$[rbp-256]
  0072c	41 b8 03 00 00
	00		 mov	 r8d, 3
  00732	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?commandQueue@@3VCommandQueue@cl@@A ; commandQueue
  00739	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00740	e8 00 00 00 00	 call	 ?invoke@Program@cl@@QEAA_NAEAVCommandQueue@2@IPEB_K1@Z ; cl::Program::invoke
  00745	84 c0		 test	 al, al
  00747	0f 84 1b ff ff
	ff		 je	 $LN1092@tick

; 99   : 
; 100  : 	const size_t global_ws_2[] = {renderDistance * 2 + 1, renderDistance * 2 + 1, renderDistance * 2 + 1};

  0074d	48 c7 85 80 05
	00 00 11 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-256], 17
  00758	48 c7 85 88 05
	00 00 11 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-248], 17
  00763	48 c7 85 90 05
	00 00 11 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-240], 17

; 101  : 	const size_t local_ws_2[] = {1, 1, 1};

  0076e	4c 89 b5 c8 05
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-256], r14
  00775	4c 89 b5 d0 05
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-248], r14
  0077c	4c 89 b5 d8 05
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-240], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00783	48 c7 45 18 0f
	00 00 00	 mov	 QWORD PTR $T11[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0078b	4c 89 65 10	 mov	 QWORD PTR $T11[rbp-240], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  0078f	44 88 65 00	 mov	 BYTE PTR $T11[rbp-256], r12b
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00793	41 b8 10 00 00
	00		 mov	 r8d, 16
  00799	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294935982
  007a0	48 8d 4d 00	 lea	 rcx, QWORD PTR $T11[rbp-256]
  007a4	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 103  : 	if(!program.prepare("arrayInsideCheck")) return false;

  007a9	48 8d 55 00	 lea	 rdx, QWORD PTR $T11[rbp-256]
  007ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  007b4	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  007b9	84 c0		 test	 al, al
  007bb	0f 84 a7 fe ff
	ff		 je	 $LN1092@tick

; 104  : 	if(!program.setArgument(sizeof(const unsigned int), &renderDistance)) return false;

  007c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:renderDistance
  007c8	ba 04 00 00 00	 mov	 edx, 4
  007cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  007d4	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
  007d9	84 c0		 test	 al, al
  007db	0f 84 87 fe ff
	ff		 je	 $LN1092@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  007e1	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:?gridBuffer@@3VBuffer@cl@@A+8
  007e8	ba 08 00 00 00	 mov	 edx, 8
  007ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  007f4	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 105  : 	if(!program.setArgument(sizeof(cl_mem), &gridBuffer)) return false;

  007f9	84 c0		 test	 al, al
  007fb	0f 84 67 fe ff
	ff		 je	 $LN1092@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 230  : 	return setArgument(size, &value->mem);

  00801	4c 8d 05 08 00
	00 00		 lea	 r8, OFFSET FLAT:?boolBuffer@@3VBuffer@cl@@A+8
  00808	ba 08 00 00 00	 mov	 edx, 8
  0080d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00814	e8 00 00 00 00	 call	 ?setArgument@Program@cl@@QEAA_N_KPEBX@Z ; cl::Program::setArgument
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 106  : 	if(!program.setArgument(sizeof(cl_mem), &boolBuffer)) return false;

  00819	84 c0		 test	 al, al
  0081b	0f 84 47 fe ff
	ff		 je	 $LN1092@tick

; 107  : 	if(!program.invoke(commandQueue, 3, global_ws_2, local_ws_2)) return false;

  00821	48 8d 85 c8 05
	00 00		 lea	 rax, QWORD PTR local_ws_2$[rbp-256]
  00828	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0082d	4c 8d 8d 80 05
	00 00		 lea	 r9, QWORD PTR global_ws_2$[rbp-256]
  00834	41 b8 03 00 00
	00		 mov	 r8d, 3
  0083a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?commandQueue@@3VCommandQueue@cl@@A ; commandQueue
  00841	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00848	e8 00 00 00 00	 call	 ?invoke@Program@cl@@QEAA_NAEAVCommandQueue@2@IPEB_K1@Z ; cl::Program::invoke
  0084d	84 c0		 test	 al, al
  0084f	0f 84 13 fe ff
	ff		 je	 $LN1092@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 335  : 	return read(queue, 0, size, data);

  00855	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?bGrid@@3PAY1BB@BB@_NA ; bGrid
  0085c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00861	4c 8b 0d 10 00
	00 00		 mov	 r9, QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+16
  00868	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?commandQueue@@3VCommandQueue@cl@@A ; commandQueue
  0086f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gridBuffer@@3VBuffer@cl@@A ; gridBuffer
  00876	e8 00 00 00 00	 call	 ?read@Buffer@cl@@QEAA_NAEAVCommandQueue@2@_K1PEAX@Z ; cl::Buffer::read
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 109  : 	if(!gridBuffer.read(commandQueue, bGrid)) return false;

  0087b	84 c0		 test	 al, al
  0087d	0f 84 e5 fd ff
	ff		 je	 $LN1092@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 879  : 	int error = glGetError();

  00883	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 880  : 	if(error != GL_NO_ERROR)

  00889	85 c0		 test	 eax, eax
  0088b	74 1e		 je	 SHORT $LN230@tick

; 881  : 	{
; 882  : 		const char* errorString = (const char*)gluErrorString(error);

  0088d	8b c8		 mov	 ecx, eax
  0088f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 883  : 		GLWindow::instance->postError(errorString, caption);

  00895	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294935981
  0089c	48 8b d0	 mov	 rdx, rax
  0089f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  008a6	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN230@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  008ab	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  008b2	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  008b7	85 c0		 test	 eax, eax
  008b9	74 07		 je	 SHORT $LN237@tick

; 33   : 		_Throw_C_error(_Res);

  008bb	8b c8		 mov	 ecx, eax
  008bd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN237@tick:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  008c2	48 8d 0d 90 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+144
  008c9	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  008ce	85 c0		 test	 eax, eax
  008d0	74 07		 je	 SHORT $LN1047@tick

; 33   : 		_Throw_C_error(_Res);

  008d2	8b c8		 mov	 ecx, eax
  008d4	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN1047@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  008d9	4c 39 25 b8 00
	00 00		 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+184, r12
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 129  : 	while(!GlobalThread::world.additionQueue.empty())

  008e0	0f 84 c8 00 00
	00		 je	 $LN19@tick
  008e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL20@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  008f0	48 8d 95 d0 02
	00 00		 lea	 rdx, QWORD PTR $T28[rbp-256]
  008f7	48 8d 0d 98 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+152
  008fe	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  00903	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00906	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00909	48 85 c0	 test	 rax, rax
  0090c	75 05		 jne	 SHORT $LN261@tick
  0090e	49 8b c4	 mov	 rax, r12
  00911	eb 03		 jmp	 SHORT $LN262@tick
$LN261@tick:
  00913	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN262@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00916	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0091a	48 ff c9	 dec	 rcx
  0091d	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  00921	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00925	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00929	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  0092d	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00930	48 85 db	 test	 rbx, rbx
  00933	74 04		 je	 SHORT $LN282@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00935	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN282@tick:

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00939	48 89 5d 48	 mov	 QWORD PTR c$13[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  0093d	48 89 7d 40	 mov	 QWORD PTR c$13[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 160  : 		c.pop_front();

  00941	48 8d 0d 98 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+152
  00948	e8 00 00 00 00	 call	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0094d	4c 89 65 f0	 mov	 QWORD PTR $T10[rbp-256], r12
  00951	4c 89 65 f8	 mov	 QWORD PTR $T10[rbp-248], r12

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00955	48 85 db	 test	 rbx, rbx
  00958	74 04		 je	 SHORT $LN296@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0095a	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN296@tick:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0095e	4c 8b c3	 mov	 r8, rbx
  00961	48 8b d7	 mov	 rdx, rdi
  00964	48 8d 4d f0	 lea	 rcx, QWORD PTR $T10[rbp-256]
  00968	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 133  : 		GlobalThread::world.addChunk(c);

  0096d	48 8d 55 f0	 lea	 rdx, QWORD PTR $T10[rbp-256]
  00971	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00978	e8 00 00 00 00	 call	 ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; World::addChunk
  0097d	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  0097e	48 85 db	 test	 rbx, rbx
  00981	74 1d		 je	 SHORT $LN306@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00983	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00987	75 17		 jne	 SHORT $LN306@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00989	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0098c	48 8b cb	 mov	 rcx, rbx
  0098f	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00991	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00995	75 09		 jne	 SHORT $LN306@tick

; 128  : 			_Delete_this();

  00997	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0099a	48 8b cb	 mov	 rcx, rbx
  0099d	ff 50 08	 call	 QWORD PTR [rax+8]
$LN306@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  009a0	48 83 3d b8 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+184, 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 129  : 	while(!GlobalThread::world.additionQueue.empty())

  009a8	0f 85 42 ff ff
	ff		 jne	 $LL20@tick
$LN19@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  009ae	48 8d 0d 90 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+144
  009b5	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  009ba	85 c0		 test	 eax, eax
  009bc	74 07		 je	 SHORT $LN313@tick

; 33   : 		_Throw_C_error(_Res);

  009be	8b c8		 mov	 ecx, eax
  009c0	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN313@tick:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  009c5	48 8d 0d c0 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+192
  009cc	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  009d1	85 c0		 test	 eax, eax
  009d3	74 07		 je	 SHORT $LN1048@tick

; 33   : 		_Throw_C_error(_Res);

  009d5	8b c8		 mov	 ecx, eax
  009d7	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN1048@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  009dc	48 83 3d e8 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+232, 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 138  : 	while(!GlobalThread::world.removalQueue.empty())

  009e4	0f 84 df 00 00
	00		 je	 $LN17@tick
  009ea	66 0f 1f 44 00
	00		 npad	 6
$LL18@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  009f0	48 8d 95 e8 02
	00 00		 lea	 rdx, QWORD PTR $T29[rbp-256]
  009f7	48 8d 0d c8 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+200
  009fe	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  00a03	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00a06	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a09	48 85 c0	 test	 rax, rax
  00a0c	75 05		 jne	 SHORT $LN337@tick
  00a0e	49 8b c4	 mov	 rax, r12
  00a11	eb 03		 jmp	 SHORT $LN338@tick
$LN337@tick:
  00a13	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN338@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00a16	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00a1a	48 ff c9	 dec	 rcx
  00a1d	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  00a21	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00a25	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00a29	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00a2d	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00a30	48 85 db	 test	 rbx, rbx
  00a33	74 04		 je	 SHORT $LN358@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00a35	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN358@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\world.cpp

; 80   : 	unloaded = true;

  00a39	c6 47 0a 01	 mov	 BYTE PTR [rdi+10], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 160  : 		c.pop_front();

  00a3d	48 8d 0d c8 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+200
  00a44	e8 00 00 00 00	 call	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 143  : 		GlobalThread::world.removeChunk(c->pos);

  00a49	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00a4c	89 45 d0	 mov	 DWORD PTR $T8[rbp-256], eax
  00a4f	8b 47 1c	 mov	 eax, DWORD PTR [rdi+28]
  00a52	89 45 d4	 mov	 DWORD PTR $T8[rbp-252], eax
  00a55	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  00a58	89 45 d8	 mov	 DWORD PTR $T8[rbp-248], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 713  : 		_Pairii _Where = equal_range(_Keyval);

  00a5b	4c 8d 45 d0	 lea	 r8, QWORD PTR $T8[rbp-256]
  00a5f	48 8d 95 c0 02
	00 00		 lea	 rdx, QWORD PTR $T27[rbp-256]
  00a66	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+80
  00a6d	e8 00 00 00 00	 call	 ?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00a72	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00a75	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00a79	49 8b c0	 mov	 rax, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00a7c	4d 3b c1	 cmp	 r8, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00a7f	74 08		 je	 SHORT $LN387@tick
$LL394@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00a81	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00a84	49 3b c1	 cmp	 rax, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00a87	75 f8		 jne	 SHORT $LL394@tick
$LN387@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 716  : 		erase(_Where.first, _Where.second);

  00a89	48 8d 55 58	 lea	 rdx, QWORD PTR $T15[rbp-256]
  00a8d	48 8d 0d 50 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+80
  00a94	e8 00 00 00 00	 call	 ?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00a99	48 85 db	 test	 rbx, rbx
  00a9c	74 1d		 je	 SHORT $LN410@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00a9e	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00aa2	75 17		 jne	 SHORT $LN410@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00aa4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00aa7	48 8b cb	 mov	 rcx, rbx
  00aaa	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00aac	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00ab0	75 09		 jne	 SHORT $LN410@tick

; 128  : 			_Delete_this();

  00ab2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00ab5	48 8b cb	 mov	 rcx, rbx
  00ab8	ff 50 08	 call	 QWORD PTR [rax+8]
$LN410@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00abb	48 83 3d e8 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+232, 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 138  : 	while(!GlobalThread::world.removalQueue.empty())

  00ac3	0f 85 27 ff ff
	ff		 jne	 $LL18@tick
$LN17@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00ac9	48 8d 0d c0 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+192
  00ad0	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00ad5	85 c0		 test	 eax, eax
  00ad7	74 07		 je	 SHORT $LN417@tick

; 33   : 		_Throw_C_error(_Res);

  00ad9	8b c8		 mov	 ecx, eax
  00adb	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN417@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  00ae0	49 8b f4	 mov	 rsi, r12
  00ae3	4c 89 64 24 30	 mov	 QWORD PTR chunksToRender$[rsp], r12

; 487  : 		_Mylast = pointer();

  00ae8	49 8b fc	 mov	 rdi, r12
  00aeb	4c 89 64 24 38	 mov	 QWORD PTR chunksToRender$[rsp+8], r12

; 488  : 		_Myend = pointer();

  00af0	4c 89 64 24 40	 mov	 QWORD PTR chunksToRender$[rsp+16], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00af5	48 8b 05 50 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+80
  00afc	48 8b 18	 mov	 rbx, QWORD PTR [rax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00aff	48 3b d8	 cmp	 rbx, rax
$LN1091@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 148  : 	for(auto iter = GlobalThread::world.chunkMap.begin(); iter != GlobalThread::world.chunkMap.end(); ++iter)

  00b02	0f 84 a1 02 00
	00		 je	 $LN1088@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00b08	4c 8b 73 28	 mov	 r14, QWORD PTR [rbx+40]
  00b0c	4c 8b 7b 20	 mov	 r15, QWORD PTR [rbx+32]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00b10	4d 85 f6	 test	 r14, r14
  00b13	74 0f		 je	 SHORT $LN493@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00b15	f0 41 ff 46 08	 lock inc DWORD PTR [r14+8]
  00b1a	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00b1f	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN493@tick:

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00b24	4c 89 75 e8	 mov	 QWORD PTR chunk$9[rbp-248], r14

; 427  : 		_Ptr = _Other_ptr;

  00b28	4c 89 7d e0	 mov	 QWORD PTR chunk$9[rbp-256], r15
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 151  : 		if(!chunk->isEmpty())

  00b2c	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00b2f	49 8b cf	 mov	 rcx, r15
  00b32	ff 50 18	 call	 QWORD PTR [rax+24]
  00b35	84 c0		 test	 al, al
  00b37	0f 85 15 02 00
	00		 jne	 $LN537@tick

; 152  : 		{
; 153  : 			if(chunk->pos.x - renderDistance <= xCam && chunk->pos.x + renderDistance >= xCam && chunk->pos.y - renderDistance <= yCam && chunk->pos.y + renderDistance >= yCam && chunk->pos.z - renderDistance <= zCam && chunk->pos.z + renderDistance > zCam)

  00b3d	49 63 4f 18	 movsxd	 rcx, DWORD PTR [r15+24]
  00b41	8d 41 f8	 lea	 eax, DWORD PTR [rcx-8]
  00b44	48 63 54 24 4c	 movsxd	 rdx, DWORD PTR xCam$[rsp]
  00b49	3b c2		 cmp	 eax, edx
  00b4b	0f 8f 01 02 00
	00		 jg	 $LN537@tick
  00b51	8d 41 08	 lea	 eax, DWORD PTR [rcx+8]
  00b54	3b c2		 cmp	 eax, edx
  00b56	0f 8c f6 01 00
	00		 jl	 $LN537@tick
  00b5c	4d 63 47 1c	 movsxd	 r8, DWORD PTR [r15+28]
  00b60	41 8d 40 f8	 lea	 eax, DWORD PTR [r8-8]
  00b64	4c 63 4c 24 48	 movsxd	 r9, DWORD PTR yCam$[rsp]
  00b69	41 3b c1	 cmp	 eax, r9d
  00b6c	0f 8f e0 01 00
	00		 jg	 $LN537@tick
  00b72	41 8d 40 08	 lea	 eax, DWORD PTR [r8+8]
  00b76	41 3b c1	 cmp	 eax, r9d
  00b79	0f 8c d3 01 00
	00		 jl	 $LN537@tick
  00b7f	4d 63 57 20	 movsxd	 r10, DWORD PTR [r15+32]
  00b83	41 8d 42 f8	 lea	 eax, DWORD PTR [r10-8]
  00b87	4c 63 5c 24 50	 movsxd	 r11, DWORD PTR zCam$[rsp]
  00b8c	41 3b c3	 cmp	 eax, r11d
  00b8f	0f 8f bd 01 00
	00		 jg	 $LN537@tick
  00b95	41 8d 42 08	 lea	 eax, DWORD PTR [r10+8]
  00b99	41 3b c3	 cmp	 eax, r11d
  00b9c	0f 8e b0 01 00
	00		 jle	 $LN537@tick

; 154  : 			{
; 155  : 				if(bGrid[chunk->pos.x - xCam + renderDistance][chunk->pos.y - yCam + renderDistance][chunk->pos.z - zCam + renderDistance])

  00ba2	48 2b ca	 sub	 rcx, rdx
  00ba5	48 6b c9 11	 imul	 rcx, 17
  00ba9	49 2b c9	 sub	 rcx, r9
  00bac	49 03 c8	 add	 rcx, r8
  00baf	48 6b c9 11	 imul	 rcx, 17
  00bb3	49 2b cb	 sub	 rcx, r11
  00bb6	49 03 ca	 add	 rcx, r10
  00bb9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?bGrid@@3PAY1BB@BB@_NA ; bGrid
  00bc0	80 bc 01 98 09
	00 00 00	 cmp	 BYTE PTR [rcx+rax+2456], 0
  00bc8	0f 84 84 01 00
	00		 je	 $LN537@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00bce	48 8d 45 e0	 lea	 rax, QWORD PTR chunk$9[rbp-256]
  00bd2	48 3b c7	 cmp	 rax, rdi
  00bd5	0f 83 c7 00 00
	00		 jae	 $LN539@tick
  00bdb	48 8d 45 e0	 lea	 rax, QWORD PTR chunk$9[rbp-256]
  00bdf	48 3b f0	 cmp	 rsi, rax
  00be2	0f 87 ba 00 00
	00		 ja	 $LN539@tick

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00be8	4c 8d 7d e0	 lea	 r15, QWORD PTR chunk$9[rbp-256]
  00bec	4c 2b fe	 sub	 r15, rsi

; 1188 : 			if (this->_Mylast == this->_Myend)

  00bef	48 8b 54 24 40	 mov	 rdx, QWORD PTR chunksToRender$[rsp+16]
  00bf4	48 3b fa	 cmp	 rdi, rdx
  00bf7	75 6f		 jne	 SHORT $LN551@tick

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00bf9	48 8b c2	 mov	 rax, rdx
  00bfc	48 2b c7	 sub	 rax, rdi
  00bff	48 c1 f8 04	 sar	 rax, 4

; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)

  00c03	48 83 f8 01	 cmp	 rax, 1
  00c07	73 5f		 jae	 SHORT $LN551@tick

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00c09	48 2b fe	 sub	 rdi, rsi
  00c0c	48 c1 ff 04	 sar	 rdi, 4

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  00c10	49 b8 ff ff ff
	ff ff ff ff 0f	 mov	 r8, 1152921504606846975	; 0fffffffffffffffH
  00c1a	49 8b c0	 mov	 rax, r8
  00c1d	48 2b c7	 sub	 rax, rdi
  00c20	48 83 f8 01	 cmp	 rax, 1
  00c24	0f 82 65 01 00
	00		 jb	 $LN1058@tick

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00c2a	48 ff c7	 inc	 rdi

; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)
; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else
; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)
; 850  : 				_Reserve(1);
; 851  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 852  : 			this->_Getal().construct(this->_Mylast,
; 853  : 				_STD forward<value_type>(_Val));
; 854  : 			++this->_Mylast;
; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);

  00c2d	48 2b d6	 sub	 rdx, rsi
  00c30	48 c1 fa 04	 sar	 rdx, 4

; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00c34	48 8b ca	 mov	 rcx, rdx
  00c37	48 d1 e9	 shr	 rcx, 1
  00c3a	49 8b c0	 mov	 rax, r8
  00c3d	48 2b c1	 sub	 rax, rcx
  00c40	48 3b c2	 cmp	 rax, rdx
  00c43	73 05		 jae	 SHORT $LN576@tick
  00c45	49 8b d4	 mov	 rdx, r12
  00c48	eb 03		 jmp	 SHORT $LN577@tick
$LN576@tick:
  00c4a	48 03 d1	 add	 rdx, rcx
$LN577@tick:

; 1489 : 		if (_Capacity < _Count)

  00c4d	48 3b d7	 cmp	 rdx, rdi
  00c50	48 0f 42 d7	 cmovb	 rdx, rdi

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00c54	48 8d 4c 24 30	 lea	 rcx, QWORD PTR chunksToRender$[rsp]
  00c59	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
  00c5e	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00c63	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN551@tick:

; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

  00c68	49 83 e7 f0	 and	 r15, -16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00c6c	48 85 ff	 test	 rdi, rdi
  00c6f	0f 84 d4 00 00
	00		 je	 $LN676@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00c75	4c 89 27	 mov	 QWORD PTR [rdi], r12
  00c78	4c 89 67 08	 mov	 QWORD PTR [rdi+8], r12

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00c7c	4d 8b 44 37 08	 mov	 r8, QWORD PTR [r15+rsi+8]
  00c81	49 8b 14 37	 mov	 rdx, QWORD PTR [r15+rsi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00c85	4d 85 c0	 test	 r8, r8
  00c88	0f 84 b3 00 00
	00		 je	 $LN620@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00c8e	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
  00c93	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00c98	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1195 : 		else

  00c9d	e9 9f 00 00 00	 jmp	 $LN620@tick
$LN539@tick:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

  00ca2	48 8b 54 24 40	 mov	 rdx, QWORD PTR chunksToRender$[rsp+16]
  00ca7	48 3b fa	 cmp	 rdi, rdx
  00caa	75 6f		 jne	 SHORT $LN623@tick

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00cac	48 8b c2	 mov	 rax, rdx
  00caf	48 2b c7	 sub	 rax, rdi
  00cb2	48 c1 f8 04	 sar	 rax, 4

; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)

  00cb6	48 83 f8 01	 cmp	 rax, 1
  00cba	73 5f		 jae	 SHORT $LN623@tick

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00cbc	48 2b fe	 sub	 rdi, rsi
  00cbf	48 c1 ff 04	 sar	 rdi, 4

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  00cc3	49 b8 ff ff ff
	ff ff ff ff 0f	 mov	 r8, 1152921504606846975	; 0fffffffffffffffH
  00ccd	49 8b c0	 mov	 rax, r8
  00cd0	48 2b c7	 sub	 rax, rdi
  00cd3	48 83 f8 01	 cmp	 rax, 1
  00cd7	0f 82 bf 00 00
	00		 jb	 $LN1059@tick

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00cdd	48 ff c7	 inc	 rdi

; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)
; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else
; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)
; 850  : 				_Reserve(1);
; 851  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 852  : 			this->_Getal().construct(this->_Mylast,
; 853  : 				_STD forward<value_type>(_Val));
; 854  : 			++this->_Mylast;
; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);

  00ce0	48 2b d6	 sub	 rdx, rsi
  00ce3	48 c1 fa 04	 sar	 rdx, 4

; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00ce7	48 8b ca	 mov	 rcx, rdx
  00cea	48 d1 e9	 shr	 rcx, 1
  00ced	49 8b c0	 mov	 rax, r8
  00cf0	48 2b c1	 sub	 rax, rcx
  00cf3	48 3b c2	 cmp	 rax, rdx
  00cf6	73 05		 jae	 SHORT $LN648@tick
  00cf8	49 8b d4	 mov	 rdx, r12
  00cfb	eb 03		 jmp	 SHORT $LN649@tick
$LN648@tick:
  00cfd	48 03 d1	 add	 rdx, rcx
$LN649@tick:

; 1489 : 		if (_Capacity < _Count)

  00d00	48 3b d7	 cmp	 rdx, rdi
  00d03	48 0f 42 d7	 cmovb	 rdx, rdi

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00d07	48 8d 4c 24 30	 lea	 rcx, QWORD PTR chunksToRender$[rsp]
  00d0c	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
  00d11	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00d16	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN623@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00d1b	48 85 ff	 test	 rdi, rdi
  00d1e	74 29		 je	 SHORT $LN676@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00d20	4c 89 27	 mov	 QWORD PTR [rdi], r12
  00d23	4c 89 67 08	 mov	 QWORD PTR [rdi+8], r12

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00d27	4d 85 f6	 test	 r14, r14
  00d2a	74 0f		 je	 SHORT $LN689@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00d2c	f0 41 ff 46 08	 lock inc DWORD PTR [r14+8]
  00d31	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00d36	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN689@tick:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00d3b	4d 8b c6	 mov	 r8, r14
  00d3e	49 8b d7	 mov	 rdx, r15
$LN620@tick:
  00d41	48 8b cf	 mov	 rcx, rdi
  00d44	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN676@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1202 : 			++this->_Mylast;

  00d49	48 83 c7 10	 add	 rdi, 16
  00d4d	48 89 7c 24 38	 mov	 QWORD PTR chunksToRender$[rsp+8], rdi
$LN537@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00d52	4d 85 f6	 test	 r14, r14
  00d55	74 29		 je	 SHORT $LN15@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00d57	f0 41 ff 4e 08	 lock dec DWORD PTR [r14+8]
  00d5c	75 18		 jne	 SHORT $LN1086@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00d5e	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00d61	49 8b ce	 mov	 rcx, r14
  00d64	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00d66	f0 41 ff 4e 0c	 lock dec DWORD PTR [r14+12]
  00d6b	75 09		 jne	 SHORT $LN1086@tick

; 128  : 			_Delete_this();

  00d6d	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00d70	49 8b ce	 mov	 rcx, r14
  00d73	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1086@tick:
  00d76	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
  00d7b	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN15@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00d80	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00d83	48 3b 1d 50 00
	00 00		 cmp	 rbx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+80
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 148  : 	for(auto iter = GlobalThread::world.chunkMap.begin(); iter != GlobalThread::world.chunkMap.end(); ++iter)

  00d8a	e9 73 fd ff ff	 jmp	 $LN1091@tick
$LN1058@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1667 : 		_Xlength_error("vector<T> too long");

  00d8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00d96	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00d9b	cc		 int	 3
$LN1059@tick:
  00d9c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00da3	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00da8	90		 npad	 1
$LN1088@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00da9	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  00db0	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00db5	85 c0		 test	 eax, eax
  00db7	74 07		 je	 SHORT $LN707@tick

; 33   : 		_Throw_C_error(_Res);

  00db9	8b c8		 mov	 ecx, eax
  00dbb	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN707@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 164  : 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  00dc0	b9 00 41 00 00	 mov	 ecx, 16640		; 00004100H
  00dc5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClear
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 714  : 	if(!uploaded)

  00dcb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?blocksTexture@RenderThread@@2PEAVTiledTexture@gfxu@@EA ; RenderThread::blocksTexture
  00dd2	80 78 11 00	 cmp	 BYTE PTR [rax+17], 0
  00dd6	75 0a		 jne	 SHORT $LN712@tick

; 715  : 	{
; 716  : 		if(!upload())

  00dd8	48 8b c8	 mov	 rcx, rax
  00ddb	e8 00 00 00 00	 call	 ?upload@Texture2D@gfxu@@QEAA_NXZ ; gfxu::Texture2D::upload

; 717  : 		{
; 718  : 			return;
; 719  : 		}
; 720  : 	}
; 721  : 	else

  00de0	eb 0d		 jmp	 SHORT $LN710@tick
$LN712@tick:

; 722  : 	{
; 723  : 		glBindTexture(GL_TEXTURE_2D, object);

  00de2	8b 10		 mov	 edx, DWORD PTR [rax]
  00de4	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00de9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBindTexture
$LN710@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 167  : 	glEnable(GL_BLEND);

  00def	b9 e2 0b 00 00	 mov	 ecx, 3042		; 00000be2H
  00df4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 168  : 	for(int i = 0; i < chunksToRender.size(); i++)

  00dfa	45 8b fc	 mov	 r15d, r12d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00dfd	4c 8b f7	 mov	 r14, rdi
  00e00	4c 2b f6	 sub	 r14, rsi
  00e03	49 c1 fe 04	 sar	 r14, 4
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 168  : 	for(int i = 0; i < chunksToRender.size(); i++)

  00e07	4d 85 f6	 test	 r14, r14
  00e0a	0f 84 90 01 00
	00		 je	 $LN8@tick
$LL10@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00e10	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  00e14	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00e17	48 85 db	 test	 rbx, rbx
  00e1a	74 04		 je	 SHORT $LN736@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00e1c	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN736@tick:

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00e20	48 89 5d 78	 mov	 QWORD PTR chunk$17[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  00e24	48 89 7d 70	 mov	 QWORD PTR chunk$17[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00e28	48 8d 4f 30	 lea	 rcx, QWORD PTR [rdi+48]
  00e2c	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00e31	85 c0		 test	 eax, eax
  00e33	74 07		 je	 SHORT $LN747@tick

; 33   : 		_Throw_C_error(_Res);

  00e35	8b c8		 mov	 ecx, eax
  00e37	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN747@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 173  : 		if(chunk->isLoaded() && chunk->firstPass != nullptr)

  00e3c	80 7f 09 00	 cmp	 BYTE PTR [rdi+9], 0
  00e40	0f 84 03 01 00
	00		 je	 $LN7@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  00e46	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 173  : 		if(chunk->isLoaded() && chunk->firstPass != nullptr)

  00e4b	0f 84 f8 00 00
	00		 je	 $LN7@tick

; 175  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  00e51	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  00e54	c1 e0 04	 shl	 eax, 4
  00e57	66 0f 6e d0	 movd	 xmm2, eax
  00e5b	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00e5e	8b 47 1c	 mov	 eax, DWORD PTR [rdi+28]
  00e61	c1 e0 04	 shl	 eax, 4
  00e64	66 0f 6e c8	 movd	 xmm1, eax
  00e68	0f 5b c9	 cvtdq2ps xmm1, xmm1
  00e6b	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00e6e	c1 e0 04	 shl	 eax, 4
  00e71	66 0f 6e c0	 movd	 xmm0, eax
  00e75	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  00e78	33 c0		 xor	 eax, eax
  00e7a	48 89 85 80 03
	00 00		 mov	 QWORD PTR $T32[rbp-256], rax
  00e81	48 89 85 88 03
	00 00		 mov	 QWORD PTR $T32[rbp-248], rax
  00e88	48 89 85 90 03
	00 00		 mov	 QWORD PTR $T32[rbp-240], rax
  00e8f	48 89 85 98 03
	00 00		 mov	 QWORD PTR $T32[rbp-232], rax
  00e96	48 89 85 a0 03
	00 00		 mov	 QWORD PTR $T32[rbp-224], rax
  00e9d	48 89 85 a8 03
	00 00		 mov	 QWORD PTR $T32[rbp-216], rax
  00ea4	48 89 85 b0 03
	00 00		 mov	 QWORD PTR $T32[rbp-208], rax
  00eab	48 89 85 b8 03
	00 00		 mov	 QWORD PTR $T32[rbp-200], rax

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  00eb2	c7 85 80 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T32[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  00ebc	c7 85 94 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T32[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  00ec6	c7 85 a8 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T32[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  00ed0	c7 85 bc 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T32[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  00eda	f3 0f 11 85 8c
	03 00 00	 movss	 DWORD PTR $T32[rbp-244], xmm0

; 246  : 	result[7] = y;

  00ee2	f3 0f 11 8d 9c
	03 00 00	 movss	 DWORD PTR $T32[rbp-228], xmm1

; 247  : 	result[11] = z;

  00eea	f3 0f 11 95 ac
	03 00 00	 movss	 DWORD PTR $T32[rbp-212], xmm2
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 175  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  00ef2	0f 28 85 80 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T32[rbp-256]
  00ef9	0f 29 85 00 02
	00 00		 movaps	 XMMWORD PTR $T24[rbp-256], xmm0
  00f00	0f 28 8d 90 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T32[rbp-240]
  00f07	0f 29 8d 10 02
	00 00		 movaps	 XMMWORD PTR $T24[rbp-240], xmm1
  00f0e	0f 28 85 a0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T32[rbp-224]
  00f15	0f 29 85 20 02
	00 00		 movaps	 XMMWORD PTR $T24[rbp-224], xmm0
  00f1c	0f 28 8d b0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T32[rbp-208]
  00f23	0f 29 8d 30 02
	00 00		 movaps	 XMMWORD PTR $T24[rbp-208], xmm1
  00f2a	48 8d 95 00 02
	00 00		 lea	 rdx, QWORD PTR $T24[rbp-256]
  00f31	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push

; 176  : 			chunk->firstPass->draw();

  00f36	ba 04 00 00 00	 mov	 edx, 4
  00f3b	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00f3f	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 177  : 			gfxu::Uniforms::MMS.pop();

  00f44	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop
$LN7@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00f49	48 8d 4f 30	 lea	 rcx, QWORD PTR [rdi+48]
  00f4d	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00f52	85 c0		 test	 eax, eax
  00f54	74 08		 je	 SHORT $LN815@tick

; 33   : 		_Throw_C_error(_Res);

  00f56	8b c8		 mov	 ecx, eax
  00f58	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  00f5d	90		 npad	 1
$LN815@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00f5e	48 85 db	 test	 rbx, rbx
  00f61	74 1d		 je	 SHORT $LN9@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00f63	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00f67	75 17		 jne	 SHORT $LN9@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00f69	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00f6c	48 8b cb	 mov	 rcx, rbx
  00f6f	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00f71	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00f75	75 09		 jne	 SHORT $LN9@tick

; 128  : 			_Delete_this();

  00f77	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00f7a	48 8b cb	 mov	 rcx, rbx
  00f7d	ff 50 08	 call	 QWORD PTR [rax+8]
$LN9@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 168  : 	for(int i = 0; i < chunksToRender.size(); i++)

  00f80	41 ff c7	 inc	 r15d
  00f83	48 83 c6 10	 add	 rsi, 16
  00f87	49 63 c7	 movsxd	 rax, r15d
  00f8a	49 3b c6	 cmp	 rax, r14
  00f8d	0f 82 7d fe ff
	ff		 jb	 $LL10@tick
  00f93	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00f98	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
  00f9d	45 33 e4	 xor	 r12d, r12d
$LN8@tick:

; 182  : 	for(int i = 0; i < chunksToRender.size(); i++)

  00fa0	45 8b fc	 mov	 r15d, r12d
  00fa3	4d 85 f6	 test	 r14, r14
  00fa6	0f 84 8a 01 00
	00		 je	 $LN4@tick
  00fac	0f 1f 40 00	 npad	 4
$LL6@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00fb0	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  00fb4	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00fb7	48 85 db	 test	 rbx, rbx
  00fba	74 04		 je	 SHORT $LN850@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00fbc	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN850@tick:

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00fc0	48 89 5d 68	 mov	 QWORD PTR chunk$16[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  00fc4	48 89 7d 60	 mov	 QWORD PTR chunk$16[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00fc8	48 8d 4f 30	 lea	 rcx, QWORD PTR [rdi+48]
  00fcc	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00fd1	85 c0		 test	 eax, eax
  00fd3	74 07		 je	 SHORT $LN861@tick

; 33   : 		_Throw_C_error(_Res);

  00fd5	8b c8		 mov	 ecx, eax
  00fd7	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN861@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  00fdc	48 83 7f 48 00	 cmp	 QWORD PTR [rdi+72], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 187  : 		if(chunk->secondPass != nullptr)

  00fe1	0f 84 f8 00 00
	00		 je	 $LN3@tick

; 189  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  00fe7	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  00fea	c1 e0 04	 shl	 eax, 4
  00fed	66 0f 6e d0	 movd	 xmm2, eax
  00ff1	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00ff4	8b 47 1c	 mov	 eax, DWORD PTR [rdi+28]
  00ff7	c1 e0 04	 shl	 eax, 4
  00ffa	66 0f 6e c8	 movd	 xmm1, eax
  00ffe	0f 5b c9	 cvtdq2ps xmm1, xmm1
  01001	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  01004	c1 e0 04	 shl	 eax, 4
  01007	66 0f 6e c0	 movd	 xmm0, eax
  0100b	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  0100e	33 c0		 xor	 eax, eax
  01010	48 89 85 00 03
	00 00		 mov	 QWORD PTR $T30[rbp-256], rax
  01017	48 89 85 08 03
	00 00		 mov	 QWORD PTR $T30[rbp-248], rax
  0101e	48 89 85 10 03
	00 00		 mov	 QWORD PTR $T30[rbp-240], rax
  01025	48 89 85 18 03
	00 00		 mov	 QWORD PTR $T30[rbp-232], rax
  0102c	48 89 85 20 03
	00 00		 mov	 QWORD PTR $T30[rbp-224], rax
  01033	48 89 85 28 03
	00 00		 mov	 QWORD PTR $T30[rbp-216], rax
  0103a	48 89 85 30 03
	00 00		 mov	 QWORD PTR $T30[rbp-208], rax
  01041	48 89 85 38 03
	00 00		 mov	 QWORD PTR $T30[rbp-200], rax

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  01048	c7 85 00 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T30[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  01052	c7 85 14 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T30[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  0105c	c7 85 28 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T30[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  01066	c7 85 3c 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T30[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  01070	f3 0f 11 85 0c
	03 00 00	 movss	 DWORD PTR $T30[rbp-244], xmm0

; 246  : 	result[7] = y;

  01078	f3 0f 11 8d 1c
	03 00 00	 movss	 DWORD PTR $T30[rbp-228], xmm1

; 247  : 	result[11] = z;

  01080	f3 0f 11 95 2c
	03 00 00	 movss	 DWORD PTR $T30[rbp-212], xmm2
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 189  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  01088	0f 28 85 00 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T30[rbp-256]
  0108f	0f 29 85 80 02
	00 00		 movaps	 XMMWORD PTR $T26[rbp-256], xmm0
  01096	0f 28 8d 10 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T30[rbp-240]
  0109d	0f 29 8d 90 02
	00 00		 movaps	 XMMWORD PTR $T26[rbp-240], xmm1
  010a4	0f 28 85 20 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T30[rbp-224]
  010ab	0f 29 85 a0 02
	00 00		 movaps	 XMMWORD PTR $T26[rbp-224], xmm0
  010b2	0f 28 8d 30 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T30[rbp-208]
  010b9	0f 29 8d b0 02
	00 00		 movaps	 XMMWORD PTR $T26[rbp-208], xmm1
  010c0	48 8d 95 80 02
	00 00		 lea	 rdx, QWORD PTR $T26[rbp-256]
  010c7	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push

; 190  : 			chunk->secondPass->draw();

  010cc	ba 04 00 00 00	 mov	 edx, 4
  010d1	48 8b 4f 48	 mov	 rcx, QWORD PTR [rdi+72]
  010d5	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 191  : 			gfxu::Uniforms::MMS.pop();

  010da	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop
$LN3@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  010df	48 8d 4f 30	 lea	 rcx, QWORD PTR [rdi+48]
  010e3	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  010e8	85 c0		 test	 eax, eax
  010ea	74 08		 je	 SHORT $LN923@tick

; 33   : 		_Throw_C_error(_Res);

  010ec	8b c8		 mov	 ecx, eax
  010ee	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  010f3	90		 npad	 1
$LN923@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  010f4	48 85 db	 test	 rbx, rbx
  010f7	74 1d		 je	 SHORT $LN5@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  010f9	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  010fd	75 17		 jne	 SHORT $LN5@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  010ff	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01102	48 8b cb	 mov	 rcx, rbx
  01105	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01107	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0110b	75 09		 jne	 SHORT $LN5@tick

; 128  : 			_Delete_this();

  0110d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01110	48 8b cb	 mov	 rcx, rbx
  01113	ff 50 08	 call	 QWORD PTR [rax+8]
$LN5@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 182  : 	for(int i = 0; i < chunksToRender.size(); i++)

  01116	41 ff c7	 inc	 r15d
  01119	48 83 c6 10	 add	 rsi, 16
  0111d	49 63 c7	 movsxd	 rax, r15d
  01120	49 3b c6	 cmp	 rax, r14
  01123	0f 82 87 fe ff
	ff		 jb	 $LL6@tick
  01129	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  0112e	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
  01133	45 33 e4	 xor	 r12d, r12d
$LN4@tick:

; 192  : 		}
; 193  : 		chunk->renderMutex.unlock();
; 194  : 	}
; 195  : 
; 196  : 	noTexShaderProgram->bind();

  01136	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
  0113d	e8 00 00 00 00	 call	 ?bind@ShaderProgram@gfxu@@QEAAXXZ ; gfxu::ShaderProgram::bind

; 197  : 	/*gfxu::Uniforms::MMS.push(geom::Matrix::translate(state->cam.pos.x - renderDistance * 16.0f, -0.125f, state->cam.pos.z - renderDistance * 16.0f));
; 198  : 	gfxu::Uniforms::MMS.mult(geom::Matrix::scale(32.0f * renderDistance, 1.0f, 32.0f * renderDistance));
; 199  : 	gfxu::Uniforms::setColor(0.1f, 0.2f, 0.5f, 0.75f);
; 200  : 	square->draw();
; 201  : 	gfxu::Uniforms::MMS.pop();*/
; 202  : 	
; 203  : 	if(state->devEnabled)

  01142	41 80 7d 24 00	 cmp	 BYTE PTR [r13+36], 0
  01147	0f 84 74 02 00
	00		 je	 $LN2@tick
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  0114d	48 c7 45 b8 00
	00 80 3f	 mov	 QWORD PTR $T7[rbp-256], 1065353216 ; 3f800000H
  01155	48 c7 45 c0 00
	00 00 00	 mov	 QWORD PTR $T7[rbp-248], 0
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  0115d	48 8b 45 b8	 mov	 rax, QWORD PTR $T7[rbp-256]
  01161	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  01168	48 8b 45 c0	 mov	 rax, QWORD PTR $T7[rbp-248]
  0116c	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  01173	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, 1

; 304  : 			val = value;

  0117a	c7 05 00 00 00
	00 00 00 00 43	 mov	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, 1124073472 ; 43000000H

; 305  : 			changed = true;

  01184	c6 05 04 00 00
	00 01		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, 1
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  0118b	4c 89 a5 00 04
	00 00		 mov	 QWORD PTR $T34[rbp-256], r12
  01192	4c 89 a5 08 04
	00 00		 mov	 QWORD PTR $T34[rbp-248], r12
  01199	4c 89 a5 10 04
	00 00		 mov	 QWORD PTR $T34[rbp-240], r12
  011a0	4c 89 a5 18 04
	00 00		 mov	 QWORD PTR $T34[rbp-232], r12
  011a7	4c 89 a5 20 04
	00 00		 mov	 QWORD PTR $T34[rbp-224], r12
  011ae	4c 89 a5 28 04
	00 00		 mov	 QWORD PTR $T34[rbp-216], r12
  011b5	4c 89 a5 30 04
	00 00		 mov	 QWORD PTR $T34[rbp-208], r12
  011bc	4c 89 a5 38 04
	00 00		 mov	 QWORD PTR $T34[rbp-200], r12

; 227  : 
; 228  : 	return result;
; 229  : }
; 230  : 
; 231  : Matrix Matrix::scale(float x, float y, float z)
; 232  : {
; 233  : 	Matrix result;
; 234  : 	result[0] = x;

  011c3	c7 85 00 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T34[rbp-256], 1098907648 ; 41800000H

; 235  : 	result[5] = y;

  011cd	c7 85 14 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T34[rbp-236], 1098907648 ; 41800000H

; 236  : 	result[10] = z;

  011d7	c7 85 28 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T34[rbp-216], 1098907648 ; 41800000H

; 237  : 	result[15] = 1.0f;

  011e1	c7 85 3c 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T34[rbp-196], 1065353216 ; 3f800000H
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 207  : 		gfxu::Uniforms::MMS.push(geom::Matrix::scale(16.0f, 16.0f, 16.0f));

  011eb	0f 28 85 00 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T34[rbp-256]
  011f2	0f 29 85 40 01
	00 00		 movaps	 XMMWORD PTR $T21[rbp-256], xmm0
  011f9	0f 28 8d 10 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T34[rbp-240]
  01200	0f 29 8d 50 01
	00 00		 movaps	 XMMWORD PTR $T21[rbp-240], xmm1
  01207	0f 28 85 20 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T34[rbp-224]
  0120e	0f 29 85 60 01
	00 00		 movaps	 XMMWORD PTR $T21[rbp-224], xmm0
  01215	0f 28 8d 30 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T34[rbp-208]
  0121c	0f 29 8d 70 01
	00 00		 movaps	 XMMWORD PTR $T21[rbp-208], xmm1
  01223	48 8d 95 40 01
	00 00		 lea	 rdx, QWORD PTR $T21[rbp-256]
  0122a	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push
  0122f	66 0f 6e 54 24
	50		 movd	 xmm2, DWORD PTR zCam$[rsp]

; 208  : 		gfxu::Uniforms::MMS.mult(geom::Matrix::translate(xCam, yCam, zCam));

  01235	0f 5b d2	 cvtdq2ps xmm2, xmm2
  01238	66 0f 6e 4c 24
	48		 movd	 xmm1, DWORD PTR yCam$[rsp]
  0123e	0f 5b c9	 cvtdq2ps xmm1, xmm1
  01241	66 0f 6e 44 24
	4c		 movd	 xmm0, DWORD PTR xCam$[rsp]
  01247	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  0124a	4c 89 a5 40 03
	00 00		 mov	 QWORD PTR $T31[rbp-256], r12
  01251	4c 89 a5 48 03
	00 00		 mov	 QWORD PTR $T31[rbp-248], r12
  01258	4c 89 a5 50 03
	00 00		 mov	 QWORD PTR $T31[rbp-240], r12
  0125f	4c 89 a5 58 03
	00 00		 mov	 QWORD PTR $T31[rbp-232], r12
  01266	4c 89 a5 60 03
	00 00		 mov	 QWORD PTR $T31[rbp-224], r12
  0126d	4c 89 a5 68 03
	00 00		 mov	 QWORD PTR $T31[rbp-216], r12
  01274	4c 89 a5 70 03
	00 00		 mov	 QWORD PTR $T31[rbp-208], r12
  0127b	4c 89 a5 78 03
	00 00		 mov	 QWORD PTR $T31[rbp-200], r12

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  01282	c7 85 40 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T31[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  0128c	c7 85 54 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T31[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  01296	c7 85 68 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T31[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  012a0	c7 85 7c 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T31[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  012aa	f3 0f 11 85 4c
	03 00 00	 movss	 DWORD PTR $T31[rbp-244], xmm0

; 246  : 	result[7] = y;

  012b2	f3 0f 11 8d 5c
	03 00 00	 movss	 DWORD PTR $T31[rbp-228], xmm1

; 247  : 	result[11] = z;

  012ba	f3 0f 11 95 6c
	03 00 00	 movss	 DWORD PTR $T31[rbp-212], xmm2
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 208  : 		gfxu::Uniforms::MMS.mult(geom::Matrix::translate(xCam, yCam, zCam));

  012c2	0f 28 85 40 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T31[rbp-256]
  012c9	0f 29 85 00 01
	00 00		 movaps	 XMMWORD PTR $T20[rbp-256], xmm0
  012d0	0f 28 8d 50 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T31[rbp-240]
  012d7	0f 29 8d 10 01
	00 00		 movaps	 XMMWORD PTR $T20[rbp-240], xmm1
  012de	0f 28 85 60 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T31[rbp-224]
  012e5	0f 29 85 20 01
	00 00		 movaps	 XMMWORD PTR $T20[rbp-224], xmm0
  012ec	0f 28 8d 70 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T31[rbp-208]
  012f3	0f 29 8d 30 01
	00 00		 movaps	 XMMWORD PTR $T20[rbp-208], xmm1
  012fa	48 8d 95 00 01
	00 00		 lea	 rdx, QWORD PTR $T20[rbp-256]
  01301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  01308	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  0130d	48 c7 45 88 00
	00 80 3f	 mov	 QWORD PTR $T4[rbp-256], 1065353216 ; 3f800000H
  01315	c7 45 90 00 00
	00 00		 mov	 DWORD PTR $T4[rbp-248], 0
  0131c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e800000
  01324	f3 0f 11 45 94	 movss	 DWORD PTR $T4[rbp-244], xmm0
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  01329	48 8b 45 88	 mov	 rax, QWORD PTR $T4[rbp-256]
  0132d	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  01334	48 8b 45 90	 mov	 rax, QWORD PTR $T4[rbp-248]
  01338	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  0133f	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, 1
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 210  : 		grid->draw(GL_LINES);

  01346	ba 01 00 00 00	 mov	 edx, 1
  0134b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  01352	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 211  : 
; 212  : 		glDepthFunc(GL_GREATER);

  01357	b9 04 02 00 00	 mov	 ecx, 516		; 00000204H
  0135c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDepthFunc
; File c:\users\erlend\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  01362	48 c7 44 24 68
	00 00 80 3f	 mov	 QWORD PTR $T2[rsp], 1065353216 ; 3f800000H
  0136b	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR $T2[rsp+8], 0
  01373	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e000000
  0137b	f3 0f 11 44 24
	74		 movss	 DWORD PTR $T2[rsp+12], xmm0
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  01381	48 8b 44 24 68	 mov	 rax, QWORD PTR $T2[rsp]
  01386	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  0138d	48 8b 44 24 70	 mov	 rax, QWORD PTR $T2[rsp+8]
  01392	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  01399	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, 1
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 214  : 		grid->draw(GL_LINES);

  013a0	ba 01 00 00 00	 mov	 edx, 1
  013a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  013ac	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 215  : 		gfxu::Uniforms::MMS.pop();

  013b1	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop

; 216  : 		glDepthFunc(GL_LEQUAL);

  013b6	b9 03 02 00 00	 mov	 ecx, 515		; 00000203H
  013bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDepthFunc
$LN2@tick:

; 217  : 	}
; 218  : 	glDisable(GL_BLEND);

  013c1	b9 e2 0b 00 00	 mov	 ecx, 3042		; 00000be2H
  013c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDisable

; 219  : 
; 220  : 	glFlush();

  013cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glFlush
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 879  : 	int error = glGetError();

  013d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 880  : 	if(error != GL_NO_ERROR)

  013d8	85 c0		 test	 eax, eax
  013da	74 25		 je	 SHORT $LN1@tick

; 881  : 	{
; 882  : 		const char* errorString = (const char*)gluErrorString(error);

  013dc	8b c8		 mov	 ecx, eax
  013de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 883  : 		GLWindow::instance->postError(errorString, caption);

  013e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294935980
  013eb	48 8b d0	 mov	 rdx, rax
  013ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  013f5	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 221  : 	if(gfxu::getError("Graphics thread loop error")) GlobalThread::stop = true;

  013fa	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN1@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp

; 192  : 	SwapBuffers(hDC);

  01401	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  01408	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0140c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SwapBuffers
  01412	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  01413	48 85 f6	 test	 rsi, rsi
  01416	74 4d		 je	 SHORT $LN1003@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  01418	48 3b f7	 cmp	 rsi, rdi
  0141b	74 40		 je	 SHORT $LN1014@tick

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  0141d	48 83 c6 08	 add	 rsi, 8
$LL1016@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01421	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  01424	48 85 db	 test	 rbx, rbx
  01427	74 22		 je	 SHORT $LN1036@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01429	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0142d	75 17		 jne	 SHORT $LN1087@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0142f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01432	48 8b cb	 mov	 rcx, rbx
  01435	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01437	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0143b	75 09		 jne	 SHORT $LN1087@tick

; 128  : 			_Delete_this();

  0143d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01440	48 8b cb	 mov	 rcx, rbx
  01443	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1087@tick:
  01446	48 8b 7c 24 38	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN1036@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  0144b	48 83 c6 10	 add	 rsi, 16
  0144f	48 8d 46 f8	 lea	 rax, QWORD PTR [rsi-8]
  01453	48 3b c7	 cmp	 rax, rdi
  01456	75 c9		 jne	 SHORT $LL1016@tick
  01458	48 8b 74 24 30	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN1014@tick:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  0145d	48 8b ce	 mov	 rcx, rsi
  01460	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1003@tick:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 224  : 	return true;

  01465	b0 01		 mov	 al, 1
$LN43@tick:

; 225  : }

  01467	48 8b 8d e0 05
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  0146e	48 33 cc	 xor	 rcx, rsp
  01471	e8 00 00 00 00	 call	 __security_check_cookie
  01476	4c 8d 9c 24 20
	07 00 00	 lea	 r11, QWORD PTR [rsp+1824]
  0147e	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  01482	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  01486	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  0148a	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  0148f	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  01494	45 0f 28 4b d0	 movaps	 xmm9, XMMWORD PTR [r11-48]
  01499	49 8b e3	 mov	 rsp, r11
  0149c	41 5f		 pop	 r15
  0149e	41 5e		 pop	 r14
  014a0	41 5d		 pop	 r13
  014a2	41 5c		 pop	 r12
  014a4	5d		 pop	 rbp
  014a5	c3		 ret	 0
$LN1089@tick:
?tick@RenderThread@@EEAA_NXZ ENDP			; RenderThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 48
yCam$ = 72
xCam$ = 76
zCam$ = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 208
chunk$9 = 224
$T10 = 240
$T11 = 256
$T12 = 288
c$13 = 320
$T14 = 336
$T15 = 344
chunk$16 = 352
chunk$17 = 368
$T18 = 384
$T19 = 448
$T20 = 512
$T21 = 576
$T22 = 640
$T23 = 704
$T24 = 768
$T25 = 832
$T26 = 896
$T27 = 960
$T28 = 976
$T29 = 1000
$T30 = 1024
$T31 = 1088
$T32 = 1152
$T33 = 1216
$T34 = 1280
projectionMatrix$ = 1344
$T35 = 1408
$T36 = 1472
$T37 = 1536
$T38 = 1600
global_ws_2$ = 1664
global_ws_1$ = 1688
local_ws_1$ = 1712
local_ws_2$ = 1736
__$ArrayPad$ = 1760
this$ = 1872
?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$2
  00000	48 8d 8a 40 01
	00 00		 lea	 rcx, QWORD PTR c$13[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 48
yCam$ = 72
xCam$ = 76
zCam$ = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 208
chunk$9 = 224
$T10 = 240
$T11 = 256
$T12 = 288
c$13 = 320
$T14 = 336
$T15 = 344
chunk$16 = 352
chunk$17 = 368
$T18 = 384
$T19 = 448
$T20 = 512
$T21 = 576
$T22 = 640
$T23 = 704
$T24 = 768
$T25 = 832
$T26 = 896
$T27 = 960
$T28 = 976
$T29 = 1000
$T30 = 1024
$T31 = 1088
$T32 = 1152
$T33 = 1216
$T34 = 1280
projectionMatrix$ = 1344
$T35 = 1408
$T36 = 1472
$T37 = 1536
$T38 = 1600
global_ws_2$ = 1664
global_ws_1$ = 1688
local_ws_1$ = 1712
local_ws_2$ = 1736
__$ArrayPad$ = 1760
this$ = 1872
?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$5
  0000c	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR chunksToRender$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 48
yCam$ = 72
xCam$ = 76
zCam$ = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 208
chunk$9 = 224
$T10 = 240
$T11 = 256
$T12 = 288
c$13 = 320
$T14 = 336
$T15 = 344
chunk$16 = 352
chunk$17 = 368
$T18 = 384
$T19 = 448
$T20 = 512
$T21 = 576
$T22 = 640
$T23 = 704
$T24 = 768
$T25 = 832
$T26 = 896
$T27 = 960
$T28 = 976
$T29 = 1000
$T30 = 1024
$T31 = 1088
$T32 = 1152
$T33 = 1216
$T34 = 1280
projectionMatrix$ = 1344
$T35 = 1408
$T36 = 1472
$T37 = 1536
$T38 = 1600
global_ws_2$ = 1664
global_ws_1$ = 1688
local_ws_1$ = 1712
local_ws_2$ = 1736
__$ArrayPad$ = 1760
this$ = 1872
?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$6
  00018	48 8d 8a e0 00
	00 00		 lea	 rcx, QWORD PTR chunk$9[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 48
yCam$ = 72
xCam$ = 76
zCam$ = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 208
chunk$9 = 224
$T10 = 240
$T11 = 256
$T12 = 288
c$13 = 320
$T14 = 336
$T15 = 344
chunk$16 = 352
chunk$17 = 368
$T18 = 384
$T19 = 448
$T20 = 512
$T21 = 576
$T22 = 640
$T23 = 704
$T24 = 768
$T25 = 832
$T26 = 896
$T27 = 960
$T28 = 976
$T29 = 1000
$T30 = 1024
$T31 = 1088
$T32 = 1152
$T33 = 1216
$T34 = 1280
projectionMatrix$ = 1344
$T35 = 1408
$T36 = 1472
$T37 = 1536
$T38 = 1600
global_ws_2$ = 1664
global_ws_1$ = 1688
local_ws_1$ = 1712
local_ws_2$ = 1736
__$ArrayPad$ = 1760
this$ = 1872
?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$7
  00024	48 8d 8a 70 01
	00 00		 lea	 rcx, QWORD PTR chunk$17[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 48
yCam$ = 72
xCam$ = 76
zCam$ = 80
$T1 = 88
$T2 = 104
$T3 = 120
$T4 = 136
$T5 = 152
$T6 = 168
$T7 = 184
$T8 = 208
chunk$9 = 224
$T10 = 240
$T11 = 256
$T12 = 288
c$13 = 320
$T14 = 336
$T15 = 344
chunk$16 = 352
chunk$17 = 368
$T18 = 384
$T19 = 448
$T20 = 512
$T21 = 576
$T22 = 640
$T23 = 704
$T24 = 768
$T25 = 832
$T26 = 896
$T27 = 960
$T28 = 976
$T29 = 1000
$T30 = 1024
$T31 = 1088
$T32 = 1152
$T33 = 1216
$T34 = 1280
projectionMatrix$ = 1344
$T35 = 1408
$T36 = 1472
$T37 = 1536
$T38 = 1600
global_ws_2$ = 1664
global_ws_1$ = 1688
local_ws_1$ = 1712
local_ws_2$ = 1736
__$ArrayPad$ = 1760
this$ = 1872
?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$8
  00030	48 8d 8a 60 01
	00 00		 lea	 rcx, QWORD PTR chunk$16[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?preStart@RenderThread@@UEAAXXZ
_TEXT	SEGMENT
error$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
$T12 = 40
$T13 = 72
filePath$ = 80
__$ArrayPad$ = 112
this$ = 192
?preStart@RenderThread@@UEAAXXZ PROC			; RenderThread::preStart, COMDAT

; 228  : {

$LN762:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  00008	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  0000f	48 c7 45 ef fe
	ff ff ff	 mov	 QWORD PTR $T13[rbp-89], -2
  00017	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0001b	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0001f	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  00023	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  00027	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  0002b	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 45 17	 mov	 QWORD PTR __$ArrayPad$[rbp-89], rax
; File c:\users\erlend\documents\github\wind\project\wind\wind\opencl.cpp

; 54   : 	cl_int error = 0;

  0003e	33 f6		 xor	 esi, esi
  00040	89 75 c7	 mov	 DWORD PTR error$1[rbp-89], esi

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00043	4c 8d 4d c7	 lea	 r9, QWORD PTR error$1[rbp-89]
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?device@cl@@3PEAU_cl_device_id@@EA ; cl::device
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateCommandQueue
  0005e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A, rax

; 56   : 	if(error != CL_SUCCESS)

  00065	39 75 c7	 cmp	 DWORD PTR error$1[rbp-89], esi
  00068	74 0b		 je	 SHORT $LN41@preStart
  0006a	48 8d 4d c7	 lea	 rcx, QWORD PTR error$1[rbp-89]
  0006e	e8 00 00 00 00	 call	 ?create@CommandQueue@cl@@QEAA_NXZ ; cl::CommandQueue::create
  00073	eb 07		 jmp	 SHORT $LN42@preStart
$LN41@preStart:

; 57   : 	{
; 58   : 		GLWindow::instance->postError("Could not create command queue: " + to_string(error), "Command queue creation error");
; 59   : 		return false;
; 60   : 	}
; 61   : 
; 62   : 	okay = true;

  00075	c6 05 20 00 00
	00 01		 mov	 BYTE PTR ?commandQueue@@3VCommandQueue@cl@@A+32, 1
$LN42@preStart:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 232  : 	projectionMatrixBuffer.create(sizeof(float) * 16, CL_MEM_READ_ONLY);

  0007c	45 33 c9	 xor	 r9d, r9d
  0007f	41 8d 51 40	 lea	 edx, QWORD PTR [r9+64]
  00083	45 8d 41 04	 lea	 r8d, QWORD PTR [r9+4]
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?projectionMatrixBuffer@@3VBuffer@cl@@A ; projectionMatrixBuffer
  0008e	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 233  : 	gridBuffer.create(gridSize, CL_MEM_WRITE_ONLY);

  00093	45 33 c9	 xor	 r9d, r9d
  00096	ba 31 13 00 00	 mov	 edx, 4913		; 00001331H
  0009b	45 8d 41 02	 lea	 r8d, QWORD PTR [r9+2]
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?gridBuffer@@3VBuffer@cl@@A ; gridBuffer
  000a6	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create

; 234  : 	boolBuffer.create(sizeof(unsigned char) * (renderDistance * 2 + 2) * (renderDistance * 2 + 2) * (renderDistance * 2 + 2), CL_MEM_READ_WRITE);

  000ab	45 33 c9	 xor	 r9d, r9d
  000ae	ba c8 16 00 00	 mov	 edx, 5832		; 000016c8H
  000b3	45 8d 41 01	 lea	 r8d, QWORD PTR [r9+1]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?boolBuffer@@3VBuffer@cl@@A ; boolBuffer
  000be	e8 00 00 00 00	 call	 ?create@Buffer@cl@@QEAA_N_KHPEAX@Z ; cl::Buffer::create
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  000c3	48 c7 45 0f 07
	00 00 00	 mov	 QWORD PTR filePath$[rbp-65], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  000cb	48 89 75 07	 mov	 QWORD PTR filePath$[rbp-73], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  000cf	66 89 75 f7	 mov	 WORD PTR filePath$[rbp-89], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  000d3	49 83 c9 ff	 or	 r9, -1
  000d7	45 33 c0	 xor	 r8d, r8d
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  000e1	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  000e5	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  000ea	90		 npad	 1

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  000eb	41 b8 18 00 00
	00		 mov	 r8d, 24
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294935979
  000f8	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00101	48 c7 45 e7 07
	00 00 00	 mov	 QWORD PTR $T12[rbp-65], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00109	48 89 75 df	 mov	 QWORD PTR $T12[rbp-73], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0010d	66 89 75 cf	 mov	 WORD PTR $T12[rbp-89], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  00111	49 83 c9 ff	 or	 r9, -1
  00115	45 33 c0	 xor	 r8d, r8d
  00118	48 8d 55 f7	 lea	 rdx, QWORD PTR filePath$[rbp-89]
  0011c	48 8d 4d cf	 lea	 rcx, QWORD PTR $T12[rbp-89]
  00120	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 238  : 	program.create(filePath);

  00125	48 8d 55 cf	 lea	 rdx, QWORD PTR $T12[rbp-89]
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00130	e8 00 00 00 00	 call	 ?create@Program@cl@@QEAA_NV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; cl::Program::create

; 239  : 
; 240  : 	grid = new VertexStream();

  00135	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  0013a	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  0013f	48 85 c0	 test	 rax, rax
  00142	74 0a		 je	 SHORT $LN10@preStart
  00144	48 8b c8	 mov	 rcx, rax
  00147	e8 00 00 00 00	 call	 ??0VertexStream@gfxu@@QEAA@XZ ; gfxu::VertexStream::VertexStream
  0014c	eb 03		 jmp	 SHORT $LN11@preStart
$LN10@preStart:
  0014e	48 8b c6	 mov	 rax, rsi
$LN11@preStart:
  00151	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA, rax ; grid

; 241  : 	for(int i = -8; i <= 8; i++)

  00158	bb f8 ff ff ff	 mov	 ebx, -8
  0015d	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@41000000
  00166	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL7@preStart:

; 243  : 		for(int j = -8; j <= 8; j++)

  00170	bf f8 ff ff ff	 mov	 edi, -8
  00175	66 0f 6e fb	 movd	 xmm7, ebx
  00179	0f 5b ff	 cvtdq2ps xmm7, xmm7
  0017c	0f 1f 40 00	 npad	 4
$LL4@preStart:
  00180	66 0f 6e f7	 movd	 xmm6, edi

; 244  : 		{
; 245  : 			grid->put(Vertex(i, j, -8));

  00184	0f 5b f6	 cvtdq2ps xmm6, xmm6
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x + translation.x;

  00187	48 8d 50 38	 lea	 rdx, QWORD PTR [rax+56]
  0018b	0f 28 c7	 movaps	 xmm0, xmm7
  0018e	f3 0f 58 40 20	 addss	 xmm0, DWORD PTR [rax+32]
  00193	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00197	0f 28 ce	 movaps	 xmm1, xmm6
  0019a	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [rax+36]
  0019f	f3 0f 11 48 3c	 movss	 DWORD PTR [rax+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  001a4	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [rax+40]
  001a9	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  001ae	f3 0f 11 40 40	 movss	 DWORD PTR [rax+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  001b3	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  001b7	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  001bc	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  001c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  001c9	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  001cd	0f 28 c7	 movaps	 xmm0, xmm7
  001d0	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  001d5	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  001d9	0f 28 ce	 movaps	 xmm1, xmm6
  001dc	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  001e1	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  001e6	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  001eb	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  001f0	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  001f5	48 83 c1 08	 add	 rcx, 8
  001f9	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  001fe	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00204	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0020b	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  0020f	0f 28 c7	 movaps	 xmm0, xmm7
  00212	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  00217	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  0021b	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00220	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  00225	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  0022a	0f 28 c6	 movaps	 xmm0, xmm6
  0022d	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  00232	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00237	48 83 c1 08	 add	 rcx, 8
  0023b	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00240	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00246	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0024d	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00251	0f 28 c7	 movaps	 xmm0, xmm7
  00254	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  00259	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  0025d	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00262	f3 41 0f 58 c8	 addss	 xmm1, xmm8
  00267	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  0026c	0f 28 c6	 movaps	 xmm0, xmm6
  0026f	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  00274	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00279	48 83 c1 08	 add	 rcx, 8
  0027d	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00282	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00288	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0028f	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00293	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  00298	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  0029d	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  002a1	0f 28 cf	 movaps	 xmm1, xmm7
  002a4	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  002a9	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  002ae	0f 28 c6	 movaps	 xmm0, xmm6
  002b1	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  002b6	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  002bb	48 83 c1 08	 add	 rcx, 8
  002bf	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  002c4	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  002ca	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  002d1	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  002d5	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  002da	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  002df	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  002e3	0f 28 cf	 movaps	 xmm1, xmm7
  002e6	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  002eb	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  002f0	f3 0f 58 71 28	 addss	 xmm6, DWORD PTR [rcx+40]
  002f5	f3 0f 11 71 40	 movss	 DWORD PTR [rcx+64], xmm6

; 111  : 
; 112  : 	vertices.push_back(vertex);

  002fa	48 83 c1 08	 add	 rcx, 8
  002fe	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00303	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 243  : 		for(int j = -8; j <= 8; j++)

  00309	ff c7		 inc	 edi
  0030b	83 ff 08	 cmp	 edi, 8
  0030e	7f 0c		 jg	 SHORT $LN760@preStart
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 19   : {}

  00310	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  00317	e9 64 fe ff ff	 jmp	 $LL4@preStart
$LN760@preStart:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 241  : 	for(int i = -8; i <= 8; i++)

  0031c	ff c3		 inc	 ebx
  0031e	83 fb 08	 cmp	 ebx, 8
  00321	7f 0c		 jg	 SHORT $LN761@preStart
  00323	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0032a	e9 41 fe ff ff	 jmp	 $LL7@preStart
$LN761@preStart:

; 254  : 	square = new VertexStream();

  0032f	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  00334	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00339	48 8b d8	 mov	 rbx, rax
  0033c	48 85 c0	 test	 rax, rax
  0033f	74 54		 je	 SHORT $LN12@preStart
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 91   : {

  00341	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7VertexStream@gfxu@@6B@
  00348	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  0034b	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi

; 487  : 		_Mylast = pointer();

  0034f	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 488  : 		_Myend = pointer();

  00353	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 19   : {}

  00357	48 89 73 20	 mov	 QWORD PTR [rbx+32], rsi
  0035b	89 73 28	 mov	 DWORD PTR [rbx+40], esi

; 20   : Vertex::Vertex(const Vertex& v)
; 21   : 	: x(v.x), y(v.y), z(v.z)
; 22   : {}
; 23   : Vertex::Vertex(const VertexUV& v)
; 24   : 	: x(v.x), y(v.y), z(v.z)
; 25   : {}
; 26   : Vertex::Vertex(const VertexRGBA& v)
; 27   : 	: x(v.x), y(v.y), z(v.z)
; 28   : {}
; 29   : Vertex::Vertex(const VertexUVRGBA& v)
; 30   : 	: x(v.x), y(v.y), z(v.z)
; 31   : {}
; 32   : 
; 33   : VertexUV::VertexUV(float x, float y, float z, float u, float v)
; 34   : 	: x(x), y(y), z(z), u(u), v(v)
; 35   : {}
; 36   : VertexUV::VertexUV(const Vertex& v)
; 37   : 	: x(v.x), y(v.y), z(v.z), u(0.0f), v(0.0f)
; 38   : {}
; 39   : VertexUV::VertexUV(const VertexUV& v)
; 40   : 	: x(v.x), y(v.y), z(v.z), u(v.u), v(v.v)
; 41   : {}
; 42   : VertexUV::VertexUV(const VertexRGBA& v)
; 43   : 	: x(v.x), y(v.y), z(v.z), u(0.0f), v(0.0f)
; 44   : {}
; 45   : VertexUV::VertexUV(const VertexUVRGBA& v)
; 46   : 	: x(v.x), y(v.y), z(v.z), u(v.u), v(v.v)
; 47   : {}
; 48   : 
; 49   : VertexRGBA::VertexRGBA(float x, float y, float z, float r, float g, float b, float a)
; 50   : 	: x(x), y(y), z(z), r(r * 255.0f), g(g * 255.0f), b(b * 255.0f), a(a * 255.0f)
; 51   : {}
; 52   : VertexRGBA::VertexRGBA(float x, float y, float z, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
; 53   : 	: x(x), y(y), z(z), r(r), g(g), b(b), a(a)
; 54   : {}
; 55   : VertexRGBA::VertexRGBA(const Vertex& v)
; 56   : 	: x(v.x), y(v.y), z(v.z), r(255), g(255), b(255), a(255)
; 57   : {}
; 58   : VertexRGBA::VertexRGBA(const VertexUV& v)
; 59   : 	: x(v.x), y(v.y), z(v.z), r(255), g(255), b(255), a(255)
; 60   : {}
; 61   : VertexRGBA::VertexRGBA(const VertexRGBA& v)
; 62   : 	: x(v.x), y(v.y), z(v.z), r(v.r), g(v.g), b(v.b), a(v.a)
; 63   : {}
; 64   : VertexRGBA::VertexRGBA(const VertexUVRGBA& v)
; 65   : 	: x(v.x), y(v.y), z(v.z), r(v.r), g(v.g), b(v.b), a(v.a)
; 66   : {}
; 67   : 
; 68   : VertexUVRGBA::VertexUVRGBA(float x, float y, float z, float u, float v, float r, float g, float b, float a)
; 69   : 	: x(x), y(y), z(z), u(u), v(v), r(r * 255.0f), g(g * 255.0f), b(b * 255.0f), a(a * 255.0f)
; 70   : {}

  0035e	48 89 73 38	 mov	 QWORD PTR [rbx+56], rsi
  00362	48 89 73 40	 mov	 QWORD PTR [rbx+64], rsi
  00366	89 73 48	 mov	 DWORD PTR [rbx+72], esi
  00369	c7 43 4c ff ff
	ff ff		 mov	 DWORD PTR [rbx+76], -1	; ffffffffH

; 91   : {

  00370	66 c7 43 58 00
	00		 mov	 WORD PTR [rbx+88], 0
  00376	c6 43 5a 00	 mov	 BYTE PTR [rbx+90], 0
  0037a	48 8d 4b 60	 lea	 rcx, QWORD PTR [rbx+96]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0037e	ba 02 00 00 00	 mov	 edx, 2
  00383	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00388	85 c0		 test	 eax, eax
  0038a	74 0c		 je	 SHORT $LN13@preStart

; 33   : 		_Throw_C_error(_Res);

  0038c	8b c8		 mov	 ecx, eax
  0038e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 254  : 	square = new VertexStream();

  00393	eb 03		 jmp	 SHORT $LN13@preStart
$LN12@preStart:
  00395	48 8b de	 mov	 rbx, rsi
$LN13@preStart:
  00398	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA, rbx ; square
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x + translation.x;

  0039f	48 8d 53 38	 lea	 rdx, QWORD PTR [rbx+56]
  003a3	f3 0f 10 43 20	 movss	 xmm0, DWORD PTR [rbx+32]
  003a8	0f 57 ff	 xorps	 xmm7, xmm7
  003ab	f3 0f 58 c7	 addss	 xmm0, xmm7
  003af	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  003b3	f3 0f 10 43 24	 movss	 xmm0, DWORD PTR [rbx+36]
  003b8	f3 0f 58 c7	 addss	 xmm0, xmm7
  003bc	f3 0f 11 43 3c	 movss	 DWORD PTR [rbx+60], xmm0

; 110  : 	vertex.z = z + translation.z;

  003c1	f3 0f 10 4b 28	 movss	 xmm1, DWORD PTR [rbx+40]
  003c6	f3 0f 58 cf	 addss	 xmm1, xmm7
  003ca	f3 0f 11 4b 40	 movss	 DWORD PTR [rbx+64], xmm1

; 111  : 
; 112  : 	vertices.push_back(vertex);

  003cf	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  003d3	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  003d8	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  003de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  003e5	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  003e9	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  003ee	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3f800000
  003f6	f3 0f 58 c6	 addss	 xmm0, xmm6
  003fa	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  003fe	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00403	f3 0f 58 cf	 addss	 xmm1, xmm7
  00407	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  0040c	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  00411	f3 0f 58 c7	 addss	 xmm0, xmm7
  00415	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  0041a	48 83 c1 08	 add	 rcx, 8
  0041e	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00423	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00429	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  00430	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00434	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  00439	f3 0f 58 c6	 addss	 xmm0, xmm6
  0043d	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00441	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00446	f3 0f 58 cf	 addss	 xmm1, xmm7
  0044a	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  0044f	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  00454	f3 0f 58 c6	 addss	 xmm0, xmm6
  00458	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  0045d	48 83 c1 08	 add	 rcx, 8
  00461	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00466	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  0046c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  00473	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00477	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  0047c	f3 0f 58 c6	 addss	 xmm0, xmm6
  00480	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00484	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00489	f3 0f 58 cf	 addss	 xmm1, xmm7
  0048d	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  00492	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  00497	f3 0f 58 c6	 addss	 xmm0, xmm6
  0049b	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  004a0	48 83 c1 08	 add	 rcx, 8
  004a4	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  004a9	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  004af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  004b6	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  004ba	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  004bf	f3 0f 58 c7	 addss	 xmm0, xmm7
  004c3	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  004c7	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  004cc	f3 0f 58 cf	 addss	 xmm1, xmm7
  004d0	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  004d5	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  004da	f3 0f 58 c6	 addss	 xmm0, xmm6
  004de	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  004e3	48 83 c1 08	 add	 rcx, 8
  004e7	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  004ec	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  004f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  004f9	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  004fd	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  00502	f3 0f 58 c7	 addss	 xmm0, xmm7
  00506	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  0050a	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  0050f	f3 0f 58 cf	 addss	 xmm1, xmm7
  00513	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  00518	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  0051d	f3 0f 58 c7	 addss	 xmm0, xmm7
  00521	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00526	48 83 c1 08	 add	 rcx, 8
  0052a	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  0052f	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 262  : 	GLWindow::instance->initGL();

  00535	e8 00 00 00 00	 call	 ?initGL@GLWindow@@QEAAXXZ ; GLWindow::initGL
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp

; 202  : 	return OK;

  0053a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 264  : 	if(!GLWindow::instance->isOK())

  00541	80 38 00	 cmp	 BYTE PTR [rax], 0
  00544	0f 84 c7 02 00
	00		 je	 $LN40@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  0054a	49 83 c9 ff	 or	 r9, -1
  0054e	45 33 c0	 xor	 r8d, r8d
  00551	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  00558	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  0055c	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00561	41 b8 14 00 00
	00		 mov	 r8d, 20
  00567	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294935978
  0056e	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  00572	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 271  : 	normalVShader = new gfxu::VertexShader(filePath);

  00577	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0057c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00581	48 8b d8	 mov	 rbx, rax
  00584	48 89 45 c7	 mov	 QWORD PTR $T7[rbp-89], rax
  00588	48 85 c0	 test	 rax, rax
  0058b	74 32		 je	 SHORT $LN14@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0058d	48 c7 45 e7 07
	00 00 00	 mov	 QWORD PTR $T11[rbp-65], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00595	48 89 75 df	 mov	 QWORD PTR $T11[rbp-73], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00599	66 89 75 cf	 mov	 WORD PTR $T11[rbp-89], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  0059d	49 83 c9 ff	 or	 r9, -1
  005a1	45 33 c0	 xor	 r8d, r8d
  005a4	48 8d 55 f7	 lea	 rdx, QWORD PTR filePath$[rbp-89]
  005a8	48 8d 4d cf	 lea	 rcx, QWORD PTR $T11[rbp-89]
  005ac	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 271  : 	normalVShader = new gfxu::VertexShader(filePath);

  005b1	48 8d 55 cf	 lea	 rdx, QWORD PTR $T11[rbp-89]
  005b5	48 8b cb	 mov	 rcx, rbx
  005b8	e8 00 00 00 00	 call	 ??0VertexShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::VertexShader::VertexShader
  005bd	eb 03		 jmp	 SHORT $LN15@preStart
$LN14@preStart:
  005bf	48 8b c6	 mov	 rax, rsi
$LN15@preStart:
  005c2	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA, rax ; normalVShader
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  005c9	49 83 c9 ff	 or	 r9, -1
  005cd	45 33 c0	 xor	 r8d, r8d
  005d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  005d7	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  005db	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  005e0	41 b8 14 00 00
	00		 mov	 r8d, 20
  005e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294935977
  005ed	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  005f1	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 275  : 	normalFShader = new gfxu::FragmentShader(filePath);

  005f6	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  005fb	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00600	48 8b d8	 mov	 rbx, rax
  00603	48 89 45 c7	 mov	 QWORD PTR $T6[rbp-89], rax
  00607	48 85 c0	 test	 rax, rax
  0060a	74 32		 je	 SHORT $LN16@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0060c	48 c7 45 e7 07
	00 00 00	 mov	 QWORD PTR $T10[rbp-65], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00614	48 89 75 df	 mov	 QWORD PTR $T10[rbp-73], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00618	66 89 75 cf	 mov	 WORD PTR $T10[rbp-89], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  0061c	49 83 c9 ff	 or	 r9, -1
  00620	45 33 c0	 xor	 r8d, r8d
  00623	48 8d 55 f7	 lea	 rdx, QWORD PTR filePath$[rbp-89]
  00627	48 8d 4d cf	 lea	 rcx, QWORD PTR $T10[rbp-89]
  0062b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 275  : 	normalFShader = new gfxu::FragmentShader(filePath);

  00630	48 8d 55 cf	 lea	 rdx, QWORD PTR $T10[rbp-89]
  00634	48 8b cb	 mov	 rcx, rbx
  00637	e8 00 00 00 00	 call	 ??0FragmentShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::FragmentShader::FragmentShader
  0063c	eb 03		 jmp	 SHORT $LN17@preStart
$LN16@preStart:
  0063e	48 8b c6	 mov	 rax, rsi
$LN17@preStart:
  00641	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA, rax ; normalFShader

; 277  : 	normalShaderProgram = new gfxu::ShaderProgram(normalVShader, nullptr, normalFShader);

  00648	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0064d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00652	48 8b d8	 mov	 rbx, rax
  00655	48 89 45 c7	 mov	 QWORD PTR $T5[rbp-89], rax
  00659	48 85 c0	 test	 rax, rax
  0065c	74 27		 je	 SHORT $LN18@preStart
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 397  : {

  0065e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA ; normalVShader
  00665	48 89 08	 mov	 QWORD PTR [rax], rcx
  00668	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
  0066c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA ; normalFShader
  00673	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00677	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 398  : 	create();

  0067b	48 8b c8	 mov	 rcx, rax
  0067e	e8 00 00 00 00	 call	 ?create@ShaderProgram@gfxu@@AEAA_NXZ ; gfxu::ShaderProgram::create
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 277  : 	normalShaderProgram = new gfxu::ShaderProgram(normalVShader, nullptr, normalFShader);

  00683	eb 03		 jmp	 SHORT $LN19@preStart
$LN18@preStart:
  00685	48 8b de	 mov	 rbx, rsi
$LN19@preStart:
  00688	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA, rbx ; normalShaderProgram
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  0068f	49 83 c9 ff	 or	 r9, -1
  00693	45 33 c0	 xor	 r8d, r8d
  00696	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  0069d	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  006a1	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  006a6	41 b8 13 00 00
	00		 mov	 r8d, 19
  006ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294935976
  006b3	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  006b7	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 281  : 	noTexVShader = new gfxu::VertexShader(filePath);

  006bc	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  006c1	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  006c6	48 8b d8	 mov	 rbx, rax
  006c9	48 89 45 c7	 mov	 QWORD PTR $T4[rbp-89], rax
  006cd	48 85 c0	 test	 rax, rax
  006d0	74 32		 je	 SHORT $LN20@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  006d2	48 c7 45 e7 07
	00 00 00	 mov	 QWORD PTR $T9[rbp-65], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  006da	48 89 75 df	 mov	 QWORD PTR $T9[rbp-73], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  006de	66 89 75 cf	 mov	 WORD PTR $T9[rbp-89], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  006e2	49 83 c9 ff	 or	 r9, -1
  006e6	45 33 c0	 xor	 r8d, r8d
  006e9	48 8d 55 f7	 lea	 rdx, QWORD PTR filePath$[rbp-89]
  006ed	48 8d 4d cf	 lea	 rcx, QWORD PTR $T9[rbp-89]
  006f1	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 281  : 	noTexVShader = new gfxu::VertexShader(filePath);

  006f6	48 8d 55 cf	 lea	 rdx, QWORD PTR $T9[rbp-89]
  006fa	48 8b cb	 mov	 rcx, rbx
  006fd	e8 00 00 00 00	 call	 ??0VertexShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::VertexShader::VertexShader
  00702	eb 03		 jmp	 SHORT $LN21@preStart
$LN20@preStart:
  00704	48 8b c6	 mov	 rax, rsi
$LN21@preStart:
  00707	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA, rax ; noTexVShader
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  0070e	49 83 c9 ff	 or	 r9, -1
  00712	45 33 c0	 xor	 r8d, r8d
  00715	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  0071c	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  00720	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00725	41 b8 13 00 00
	00		 mov	 r8d, 19
  0072b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294935975
  00732	48 8d 4d f7	 lea	 rcx, QWORD PTR filePath$[rbp-89]
  00736	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 285  : 	noTexFShader = new gfxu::FragmentShader(filePath);

  0073b	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00740	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00745	48 8b d8	 mov	 rbx, rax
  00748	48 89 45 c7	 mov	 QWORD PTR $T3[rbp-89], rax
  0074c	48 85 c0	 test	 rax, rax
  0074f	74 32		 je	 SHORT $LN22@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00751	48 c7 45 e7 07
	00 00 00	 mov	 QWORD PTR $T8[rbp-65], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00759	48 89 75 df	 mov	 QWORD PTR $T8[rbp-73], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0075d	66 89 75 cf	 mov	 WORD PTR $T8[rbp-89], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  00761	49 83 c9 ff	 or	 r9, -1
  00765	45 33 c0	 xor	 r8d, r8d
  00768	48 8d 55 f7	 lea	 rdx, QWORD PTR filePath$[rbp-89]
  0076c	48 8d 4d cf	 lea	 rcx, QWORD PTR $T8[rbp-89]
  00770	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 285  : 	noTexFShader = new gfxu::FragmentShader(filePath);

  00775	48 8d 55 cf	 lea	 rdx, QWORD PTR $T8[rbp-89]
  00779	48 8b cb	 mov	 rcx, rbx
  0077c	e8 00 00 00 00	 call	 ??0FragmentShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::FragmentShader::FragmentShader
  00781	eb 03		 jmp	 SHORT $LN23@preStart
$LN22@preStart:
  00783	48 8b c6	 mov	 rax, rsi
$LN23@preStart:
  00786	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA, rax ; noTexFShader

; 287  : 	noTexShaderProgram = new gfxu::ShaderProgram(noTexVShader, nullptr, noTexFShader);

  0078d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00792	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00797	48 8b d8	 mov	 rbx, rax
  0079a	48 89 45 c7	 mov	 QWORD PTR $T2[rbp-89], rax
  0079e	48 85 c0	 test	 rax, rax
  007a1	74 27		 je	 SHORT $LN24@preStart
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 397  : {

  007a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA ; noTexVShader
  007aa	48 89 08	 mov	 QWORD PTR [rax], rcx
  007ad	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
  007b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA ; noTexFShader
  007b8	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  007bc	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 398  : 	create();

  007c0	48 8b c8	 mov	 rcx, rax
  007c3	e8 00 00 00 00	 call	 ?create@ShaderProgram@gfxu@@AEAA_NXZ ; gfxu::ShaderProgram::create
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 287  : 	noTexShaderProgram = new gfxu::ShaderProgram(noTexVShader, nullptr, noTexFShader);

  007c8	eb 03		 jmp	 SHORT $LN25@preStart
$LN24@preStart:
  007ca	48 8b de	 mov	 rbx, rsi
$LN25@preStart:
  007cd	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA, rbx ; noTexShaderProgram
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 617  : 	MMS.clear();

  007d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  007db	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear

; 618  : 	PMS.clear();

  007e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  007e7	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 291  : 	glEnable(GL_DEPTH_TEST);

  007ec	b9 71 0b 00 00	 mov	 ecx, 2929		; 00000b71H
  007f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 292  : 	glEnable(GL_CULL_FACE);

  007f7	b9 44 0b 00 00	 mov	 ecx, 2884		; 00000b44H
  007fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 293  : 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

  00802	ba 03 03 00 00	 mov	 edx, 771		; 00000303H
  00807	8d 4a ff	 lea	 ecx, QWORD PTR [rdx-1]
  0080a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBlendFunc
  00810	90		 npad	 1
$LN40@preStart:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00811	48 83 7d 0f 08	 cmp	 QWORD PTR filePath$[rbp-65], 8
  00816	72 09		 jb	 SHORT $LN736@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00818	48 8b 4d f7	 mov	 rcx, QWORD PTR filePath$[rbp-89]
  0081c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN736@preStart:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 294  : }

  00821	48 8b 4d 17	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-89]
  00825	48 33 cc	 xor	 rcx, rsp
  00828	e8 00 00 00 00	 call	 __security_check_cookie
  0082d	4c 8d 9c 24 b0
	00 00 00	 lea	 r11, QWORD PTR [rsp+176]
  00835	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00839	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0083d	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00841	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00846	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  0084b	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  00850	49 8b e3	 mov	 rsp, r11
  00853	5d		 pop	 rbp
  00854	c3		 ret	 0
?preStart@RenderThread@@UEAAXXZ ENDP			; RenderThread::preStart
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
$T12 = 40
$T13 = 72
filePath$ = 80
__$ArrayPad$ = 112
this$ = 192
?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$0
  00000	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR filePath$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
$T12 = 40
$T13 = 72
filePath$ = 80
__$ArrayPad$ = 112
this$ = 192
?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$4
  0000c	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  00013	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
$T12 = 40
$T13 = 72
filePath$ = 80
__$ArrayPad$ = 112
this$ = 192
?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$6
  00018	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR $T6[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
$T12 = 40
$T13 = 72
filePath$ = 80
__$ArrayPad$ = 112
this$ = 192
?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$8
  00024	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR $T5[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
$T12 = 40
$T13 = 72
filePath$ = 80
__$ArrayPad$ = 112
this$ = 192
?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$9
  00030	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR $T4[rdx]
  00037	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
$T12 = 40
$T13 = 72
filePath$ = 80
__$ArrayPad$ = 112
this$ = 192
?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$11
  0003c	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR $T3[rdx]
  00043	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 32
$T2 = 32
$T3 = 32
$T4 = 32
$T5 = 32
$T6 = 32
$T7 = 32
$T8 = 40
$T9 = 40
$T10 = 40
$T11 = 40
$T12 = 40
$T13 = 72
filePath$ = 80
__$ArrayPad$ = 112
this$ = 192
?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$13
  00048	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR $T2[rdx]
  0004f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?postStop@RenderThread@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
$T1 = 56
?postStop@RenderThread@@UEAAXXZ PROC			; RenderThread::postStop, COMDAT

; 297  : {

$LN108:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 298  : 	delete grid;

  0000a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  00011	48 85 c9	 test	 rcx, rcx
  00014	74 0a		 je	 SHORT $LN3@postStop
  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	ba 01 00 00 00	 mov	 edx, 1
  0001e	ff 10		 call	 QWORD PTR [rax]
$LN3@postStop:

; 299  : 	delete square;

  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  00027	48 85 c9	 test	 rcx, rcx
  0002a	74 0a		 je	 SHORT $LN5@postStop
  0002c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0002f	ba 01 00 00 00	 mov	 edx, 1
  00034	ff 10		 call	 QWORD PTR [rax]
$LN5@postStop:

; 300  : 	delete normalVShader;

  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA ; normalVShader
  0003d	48 85 c9	 test	 rcx, rcx
  00040	74 05		 je	 SHORT $LN7@postStop
  00042	e8 00 00 00 00	 call	 ??_GVertexShader@gfxu@@QEAAPEAXI@Z
$LN7@postStop:

; 301  : 	delete normalFShader;

  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA ; normalFShader
  0004e	48 85 c9	 test	 rcx, rcx
  00051	74 05		 je	 SHORT $LN9@postStop
  00053	e8 00 00 00 00	 call	 ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
$LN9@postStop:

; 302  : 	delete normalShaderProgram;

  00058	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
  0005f	48 85 db	 test	 rbx, rbx
  00062	74 19		 je	 SHORT $LN21@postStop
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 403  : 	glUseProgram(0);

  00064	33 c9		 xor	 ecx, ecx
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 404  : 	glDeleteProgram(object);

  0006c	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  00075	48 8b cb	 mov	 rcx, rbx
  00078	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN21@postStop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 303  : 	delete noTexVShader;

  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA ; noTexVShader
  00084	48 85 c9	 test	 rcx, rcx
  00087	74 05		 je	 SHORT $LN13@postStop
  00089	e8 00 00 00 00	 call	 ??_GVertexShader@gfxu@@QEAAPEAXI@Z
$LN13@postStop:

; 304  : 	delete noTexFShader;

  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA ; noTexFShader
  00095	48 85 c9	 test	 rcx, rcx
  00098	74 05		 je	 SHORT $LN15@postStop
  0009a	e8 00 00 00 00	 call	 ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
$LN15@postStop:

; 305  : 	delete noTexShaderProgram;

  0009f	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
  000a6	48 85 db	 test	 rbx, rbx
  000a9	74 19		 je	 SHORT $LN26@postStop
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 403  : 	glUseProgram(0);

  000ab	33 c9		 xor	 ecx, ecx
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 404  : 	glDeleteProgram(object);

  000b3	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN26@postStop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 306  : 	delete blocksTexture;

  000c4	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?blocksTexture@RenderThread@@2PEAVTiledTexture@gfxu@@EA ; RenderThread::blocksTexture
  000cb	48 85 ff	 test	 rdi, rdi
  000ce	74 4b		 je	 SHORT $LN31@postStop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  000d0	4c 8b 47 28	 mov	 r8, QWORD PTR [rdi+40]
  000d4	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T1[rsp]
  000d9	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  000dd	4d 8b c8	 mov	 r9, r8
  000e0	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  000e3	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@U?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,gfxu::TiledTexture::Icon * __ptr64,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,gfxu::TiledTexture::Icon * __ptr64> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  000e8	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  000ec	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 682  : 	if(data != nullptr)

  000f1	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  000f5	48 85 c9	 test	 rcx, rcx
  000f8	74 05		 je	 SHORT $LN99@postStop

; 683  : 	{
; 684  : 		delete[] data;

  000fa	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN99@postStop:

; 685  : 	}
; 686  : 
; 687  : 	if(uploaded)

  000ff	80 7f 11 00	 cmp	 BYTE PTR [rdi+17], 0
  00103	74 0e		 je	 SHORT $LN98@postStop

; 688  : 	{
; 689  : 		glDeleteTextures(1, &object);

  00105	48 8b d7	 mov	 rdx, rdi
  00108	b9 01 00 00 00	 mov	 ecx, 1
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDeleteTextures
$LN98@postStop:
  00113	48 8b cf	 mov	 rcx, rdi
  00116	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN31@postStop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\window.cpp

; 246  : 	if(hRC)

  0011b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00122	48 83 7b 20 00	 cmp	 QWORD PTR [rbx+32], 0
  00127	74 14		 je	 SHORT $LN102@postStop

; 247  : 	{
; 248  : 		if(!wglMakeCurrent(NULL, NULL))

  00129	33 d2		 xor	 edx, edx
  0012b	33 c9		 xor	 ecx, ecx
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglMakeCurrent

; 249  : 		{
; 250  : 			error = true;
; 251  : 		}
; 252  : 
; 253  : 		if(!wglDeleteContext(hRC))

  00133	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglDeleteContext
$LN102@postStop:
; File c:\users\erlend\documents\github\wind\project\wind\wind\renderthread.cpp

; 309  : }

  0013d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00142	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00146	5f		 pop	 rdi
  00147	c3		 ret	 0
?postStop@RenderThread@@UEAAXXZ ENDP			; RenderThread::postStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??_GVertexShader@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
??_GVertexShader@gfxu@@QEAAPEAXI@Z PROC			; gfxu::VertexShader::`scalar deleting destructor', COMDAT
$LN45:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 354  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 355  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN7@scalar

; 356  : 	{
; 357  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN7@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN33@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN33@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0005a	48 8b c3	 mov	 rax, rbx
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
??_GVertexShader@gfxu@@QEAAPEAXI@Z ENDP			; gfxu::VertexShader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA PROC	; `gfxu::VertexShader::`scalar deleting destructor''::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA ENDP	; `gfxu::VertexShader::`scalar deleting destructor''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
??_GFragmentShader@gfxu@@QEAAPEAXI@Z PROC		; gfxu::FragmentShader::`scalar deleting destructor', COMDAT
$LN45:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 354  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 355  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN7@scalar

; 356  : 	{
; 357  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN7@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN33@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN33@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0005a	48 8b c3	 mov	 rax, rbx
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
??_GFragmentShader@gfxu@@QEAAPEAXI@Z ENDP		; gfxu::FragmentShader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA PROC ; `gfxu::FragmentShader::`scalar deleting destructor''::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA ENDP ; `gfxu::FragmentShader::`scalar deleting destructor''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
;	COMDAT ??_GShaderProgram@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GShaderProgram@gfxu@@QEAAPEAXI@Z PROC		; gfxu::ShaderProgram::`scalar deleting destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 403  : 	glUseProgram(0);

  00009	33 c9		 xor	 ecx, ecx
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 404  : 	glDeleteProgram(object);

  00011	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00022	48 8b c3	 mov	 rax, rbx
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
??_GShaderProgram@gfxu@@QEAAPEAXI@Z ENDP		; gfxu::ShaderProgram::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
;	COMDAT ??_GTiledTexture@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
__flags$dead$ = 56
??_GTiledTexture@gfxu@@QEAAPEAXI@Z PROC			; gfxu::TiledTexture::`scalar deleting destructor', COMDAT
$LN73:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  0000a	4c 8b 41 28	 mov	 r8, QWORD PTR [rcx+40]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00016	4d 8b c8	 mov	 r9, r8
  00019	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0001c	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00020	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@U?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,gfxu::TiledTexture::Icon * __ptr64,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,gfxu::TiledTexture::Icon * __ptr64> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00025	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00029	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 682  : 	if(data != nullptr)

  0002e	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00032	48 85 c9	 test	 rcx, rcx
  00035	74 05		 je	 SHORT $LN69@scalar

; 683  : 	{
; 684  : 		delete[] data;

  00037	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN69@scalar:

; 685  : 	}
; 686  : 
; 687  : 	if(uploaded)

  0003c	80 7f 11 00	 cmp	 BYTE PTR [rdi+17], 0
  00040	74 0e		 je	 SHORT $LN68@scalar

; 688  : 	{
; 689  : 		glDeleteTextures(1, &object);

  00042	48 8b d7	 mov	 rdx, rdi
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDeleteTextures
$LN68@scalar:
  00050	48 8b cf	 mov	 rcx, rdi
  00053	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00058	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005d	48 8b c7	 mov	 rax, rdi
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
??_GTiledTexture@gfxu@@QEAAPEAXI@Z ENDP			; gfxu::TiledTexture::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??1VertexShader@gfxu@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1VertexShader@gfxu@@QEAA@XZ PROC			; gfxu::VertexShader::~VertexShader, COMDAT
$LN42:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 354  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 355  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN4@VertexShad

; 356  : 	{
; 357  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN4@VertexShad:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN30@VertexShad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN30@VertexShad:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
??1VertexShader@gfxu@@QEAA@XZ ENDP			; gfxu::VertexShader::~VertexShader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA PROC	; `gfxu::VertexShader::~VertexShader'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA ENDP	; `gfxu::VertexShader::~VertexShader'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??1FragmentShader@gfxu@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1FragmentShader@gfxu@@QEAA@XZ PROC			; gfxu::FragmentShader::~FragmentShader, COMDAT
$LN42:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.cpp

; 354  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 355  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN4@FragmentSh

; 356  : 	{
; 357  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN4@FragmentSh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN30@FragmentSh
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN30@FragmentSh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
??1FragmentShader@gfxu@@QEAA@XZ ENDP			; gfxu::FragmentShader::~FragmentShader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA PROC	; `gfxu::FragmentShader::~FragmentShader'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA ENDP	; `gfxu::FragmentShader::~FragmentShader'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT

; 970  : 		{	// assign _Right

$LN59:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 971  : 		if (this != &_Right)

  00009	48 3b ca	 cmp	 rcx, rdx
  0000c	74 0c		 je	 SHORT $LN57@operator

; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));

  0000e	49 83 c9 ff	 or	 r9, -1
  00012	45 33 c0	 xor	 r8d, r8d
  00015	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN57@operator:

; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);

  0001a	48 8b c3	 mov	 rax, rbx

; 985  : 		}

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
;	COMDAT ?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z PROC ; gfxu::Uniform<geom::Vector>::set, COMDAT

; 304  : 			val = value;

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	89 01		 mov	 DWORD PTR [rcx], eax
  00004	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00007	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0000a	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  0000d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00010	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]

; 305  : 			changed = true;

  00013	c6 41 10 01	 mov	 BYTE PTR [rcx+16], 1
  00017	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 306  : 		}

  0001a	c3		 ret	 0
?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z ENDP ; gfxu::Uniform<geom::Vector>::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\graphics.h
;	COMDAT ?set@?$Uniform@M@gfxu@@QEAAXM@Z
_TEXT	SEGMENT
this$dead$ = 8
value$ = 16
?set@?$Uniform@M@gfxu@@QEAAXM@Z PROC			; gfxu::Uniform<float>::set, COMDAT

; 304  : 			val = value;

  00000	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, xmm1

; 305  : 			changed = true;

  00008	c6 05 04 00 00
	00 01		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, 1

; 306  : 		}

  0000f	c3		 ret	 0
?set@?$Uniform@M@gfxu@@QEAAXM@Z ENDP			; gfxu::Uniform<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ PROC ; std::shared_ptr<gfxu::VertexStream>::operator->, COMDAT

; 691  : 		return (this->_Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 692  : 		}

  00003	c3		 ret	 0
??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ENDP ; std::shared_ptr<gfxu::VertexStream>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ
_TEXT	SEGMENT
this$ = 8
??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ PROC ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64, COMDAT

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 f7 d8	 neg	 rax
  00006	1b c0		 sbb	 eax, eax
  00008	f7 d8		 neg	 eax
  0000a	ff c8		 dec	 eax

; 704  : 		}

  0000c	c3		 ret	 0
??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ ENDP ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 44   : 		{	// construct with node pointer _Pnode

  00003	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 429  : 		return (_List.begin());

  00006	48 8b c2	 mov	 rax, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00009	48 89 0a	 mov	 QWORD PTR [rdx], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 430  : 		}

  0000c	c3		 ret	 0
?begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 439  : 		return (_List.end());

  00006	48 8b c2	 mov	 rax, rdx

; 440  : 		}

  00009	c3		 ret	 0
?end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z PROC ; VirtualList<Tasks::Task,256,4098>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 63 c2	 movsxd	 rax, edx

; 53   : 		return List::operator[](index);

  00003	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 54   : 	}

  00007	c3		 ret	 0
??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z ENDP ; VirtualList<Tasks::Task,256,4098>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ PROC ; VirtualList<Tasks::Task,256,4098>::getSize, COMDAT

; 66   : 		return List::getSize();

  00000	8b 81 00 08 00
	00		 mov	 eax, DWORD PTR [rcx+2048]

; 67   : 	}

  00006	c3		 ret	 0
?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ ENDP ; VirtualList<Tasks::Task,256,4098>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ PROC ; VirtualList<Tasks::Task,256,4098>::clear, COMDAT

; 37   : 		count = 0;

  00000	33 c0		 xor	 eax, eax
  00002	89 81 00 08 00
	00		 mov	 DWORD PTR [rcx+2048], eax
; File c:\users\erlend\documents\github\wind\project\wind\wind\memutil.cpp

; 18   : 	pos = 0;

  00008	89 81 14 08 00
	00		 mov	 DWORD PTR [rcx+2068], eax
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h

; 73   : 	}

  0000e	c3		 ret	 0
?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ ENDP ; VirtualList<Tasks::Task,256,4098>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 686  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 900  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size, COMDAT

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 04	 sar	 rax, 4

; 1088 : 		}

  0000b	c3		 ret	 0
?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[], COMDAT

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

  00000	48 c1 e2 04	 shl	 rdx, 4
  00004	48 03 11	 add	 rdx, QWORD PTR [rcx]
  00007	48 8b c2	 mov	 rax, rdx

; 1149 : 		}

  0000a	c3		 ret	 0
??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back, COMDAT

; 1184 : 		{	// insert element at end

$LN80:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1184 : 		{	// insert element at end

  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx

; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00014	48 3b d0	 cmp	 rdx, rax
  00017	73 22		 jae	 SHORT $LN4@push_back
  00019	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001c	48 3b ca	 cmp	 rcx, rdx
  0001f	77 1a		 ja	 SHORT $LN4@push_back

; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)

  00021	48 2b f9	 sub	 rdi, rcx
  00024	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  00028	75 08		 jne	 SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

  0002a	48 8b cb	 mov	 rcx, rbx
  0002d	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

  00032	48 83 e7 f0	 and	 rdi, -16
  00036	48 03 3b	 add	 rdi, QWORD PTR [rbx]

; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else

  00039	eb 0e		 jmp	 SHORT $LN1@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

  0003b	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  0003f	75 08		 jne	 SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

  00041	48 8b cb	 mov	 rcx, rbx
  00044	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00049	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0004d	48 85 c9	 test	 rcx, rcx
  00050	74 1f		 je	 SHORT $LN60@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00052	33 c0		 xor	 eax, eax
  00054	48 89 01	 mov	 QWORD PTR [rcx], rax
  00057	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  0005b	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  0005f	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00062	4d 85 c0	 test	 r8, r8
  00065	74 05		 je	 SHORT $LN73@push_back

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00067	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN73@push_back:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0006c	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN60@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1202 : 			++this->_Mylast;

  00071	48 83 43 08 10	 add	 QWORD PTR [rbx+8], 16

; 1203 : 			}
; 1204 : 		}

  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->, COMDAT

; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}

  00007	c3		 ret	 0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00003	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);

  00006	48 8b c1	 mov	 rax, rcx

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00009	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 375  : 		}

  0000c	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=, COMDAT

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx

; 303  : 		return (!(*this == _Right));

  00006	0f 95 c0	 setne	 al

; 304  : 		}

  00009	c3		 ret	 0
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT

; 1099 : 		return (assign(_Right, 0, npos));

  00000	49 83 c9 ff	 or	 r9, -1
  00004	45 33 c0	 xor	 r8d, r8d
  00007	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc, COMDAT

; 641  : 		}

  00000	c2 00 00	 ret	 0
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ PROC ; std::_Ptr_base<gfxu::VertexStream>::_Get, COMDAT

; 335  : 		return (_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 336  : 		}

  00003	c3		 ret	 0
?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::begin, COMDAT

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 44   : 		{	// construct with node pointer _Pnode

  00003	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));

  00006	48 8b c2	 mov	 rax, rdx

; 44   : 		{	// construct with node pointer _Pnode

  00009	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 1116 : 		}

  0000c	c3		 ret	 0
?begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::end, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1125 : 		return (iterator(this->_Myhead, this));

  00006	48 8b c2	 mov	 rax, rdx

; 1126 : 		}

  00009	c3		 ret	 0
?end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z PROC ; List<Tasks::Task * __ptr64,256>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 63 c2	 movsxd	 rax, edx
  00003	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]

; 20   : 	}

  00007	c3		 ret	 0
??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z ENDP ; List<Tasks::Task * __ptr64,256>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ PROC	; List<Tasks::Task * __ptr64,256>::getSize, COMDAT

; 32   : 		return count;

  00000	8b 81 00 08 00
	00		 mov	 eax, DWORD PTR [rcx+2048]

; 33   : 	}

  00006	c3		 ret	 0
?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ ENDP	; List<Tasks::Task * __ptr64,256>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\erlend\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ PROC	; List<Tasks::Task * __ptr64,256>::clear, COMDAT

; 37   : 		count = 0;

  00000	c7 81 00 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rcx+2048], 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ ENDP	; List<Tasks::Task * __ptr64,256>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside, COMDAT

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00000	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00004	73 08		 jae	 SHORT $LN3@Inside
  00006	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00009	77 03		 ja	 SHORT $LN3@Inside
  0000b	b0 01		 mov	 al, 1

; 1497 : 		}

  0000d	c3		 ret	 0
$LN3@Inside:

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000e	32 c0		 xor	 al, al

; 1497 : 		}

  00010	c3		 ret	 0
?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve, COMDAT

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

$LN44:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00004	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  00008	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	49 2b c0	 sub	 rax, r8
  00012	48 c1 f8 04	 sar	 rax, 4

; 1526 : 		if (_Unused_capacity() < _Count)

  00016	48 83 f8 01	 cmp	 rax, 1
  0001a	73 5d		 jae	 SHORT $LN2@Reserve

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0001c	4c 8b 11	 mov	 r10, QWORD PTR [rcx]

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0001f	49 b9 ff ff ff
	ff ff ff ff 0f	 mov	 r9, 1152921504606846975	; 0fffffffffffffffH

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00029	4d 2b c2	 sub	 r8, r10

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0002c	49 8b c1	 mov	 rax, r9

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0002f	49 c1 f8 04	 sar	 r8, 4

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  00033	49 2b c0	 sub	 rax, r8
  00036	48 83 f8 01	 cmp	 rax, 1
  0003a	72 42		 jb	 SHORT $LN42@Reserve

; 967  : 		return (this->_Myend - this->_Myfirst);

  0003c	49 2b d2	 sub	 rdx, r10

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  0003f	49 ff c0	 inc	 r8

; 967  : 		return (this->_Myend - this->_Myfirst);

  00042	48 c1 fa 04	 sar	 rdx, 4

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00046	48 8b c2	 mov	 rax, rdx
  00049	48 d1 e8	 shr	 rax, 1
  0004c	4c 2b c8	 sub	 r9, rax
  0004f	4c 3b ca	 cmp	 r9, rdx
  00052	73 12		 jae	 SHORT $LN27@Reserve
  00054	33 d2		 xor	 edx, edx

; 1489 : 		if (_Capacity < _Count)

  00056	49 3b d0	 cmp	 rdx, r8
  00059	49 0f 42 d0	 cmovb	 rdx, r8

; 1531 : 			}
; 1532 : 		}

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00061	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
$LN27@Reserve:

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00066	48 03 d0	 add	 rdx, rax

; 1489 : 		if (_Capacity < _Count)

  00069	49 3b d0	 cmp	 rdx, r8
  0006c	49 0f 42 d0	 cmovb	 rdx, r8

; 1531 : 			}
; 1532 : 		}

  00070	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00074	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
$LN2@Reserve:

; 1531 : 			}
; 1532 : 		}

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	c3		 ret	 0
$LN42@Reserve:

; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())
; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);
; 1542 : 			this->_Myfirst = pointer();
; 1543 : 			this->_Mylast = pointer();
; 1544 : 			this->_Myend = pointer();
; 1545 : 			}
; 1546 : 		}
; 1547 : 
; 1548 : 	template<class _Iter>
; 1549 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1550 : 		{	// copy initializing [_First, _Last), using allocator
; 1551 : 		_Alty _Alval(this->_Getal());
; 1552 : 		return (_Uninitialized_copy(_First, _Last,
; 1553 : 			_Ptr, _Alval));
; 1554 : 		}
; 1555 : 
; 1556 : 	template<class _Iter>
; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());
; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));
; 1562 : 		}
; 1563 : 
; 1564 : 	iterator _Insert_n(const_iterator _Where,
; 1565 : 		size_type _Count, const value_type& _Val)
; 1566 : 		{	// insert _Count * _Val at _Where
; 1567 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1568 : 		if (_VICONT(_Where) != this
; 1569 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1570 : 			|| this->_Mylast < _VIPTR(_Where))
; 1571 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1572 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 
; 1574 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1575 : 		if (_Count == 0)
; 1576 : 			;
; 1577 : 		else if (_Unused_capacity() < _Count)
; 1578 : 			{	// not enough room, reallocate
; 1579 : 			if (max_size() - size() < _Count)
; 1580 : 				_Xlen();	// result too long
; 1581 : 
; 1582 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1583 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1584 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1585 : 			int _Ncopied = 0;
; 1586 : 
; 1587 : 			_TRY_BEGIN
; 1588 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1589 : 				_STD addressof(_Val));	// add new stuff
; 1590 : 			++_Ncopied;
; 1591 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1592 : 				_Newvec);	// copy prefix
; 1593 : 			++_Ncopied;
; 1594 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1595 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1596 : 			_CATCH_ALL
; 1597 : 			if (1 < _Ncopied)
; 1598 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1599 : 			if (0 < _Ncopied)
; 1600 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1601 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1602 : 			_RERAISE;
; 1603 : 			_CATCH_END
; 1604 : 
; 1605 : 			_Count += size();
; 1606 : 			if (this->_Myfirst != pointer())
; 1607 : 				{	// destroy and deallocate old array
; 1608 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1609 : 				this->_Getal().deallocate(this->_Myfirst,
; 1610 : 					this->_Myend - this->_Myfirst);
; 1611 : 				}
; 1612 : 
; 1613 : 			this->_Orphan_all();
; 1614 : 			this->_Myend = _Newvec + _Capacity;
; 1615 : 			this->_Mylast = _Newvec + _Count;
; 1616 : 			this->_Myfirst = _Newvec;
; 1617 : 			}
; 1618 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1619 : 			< _Count)
; 1620 : 			{	// new stuff spills off end
; 1621 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1622 : 
; 1623 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1624 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1625 : 
; 1626 : 			_TRY_BEGIN
; 1627 : 			_Ufill(this->_Mylast,
; 1628 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1629 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1630 : 			_CATCH_ALL
; 1631 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1632 : 				this->_Mylast + _Count);
; 1633 : 			_RERAISE;
; 1634 : 			_CATCH_END
; 1635 : 
; 1636 : 			this->_Mylast += _Count;
; 1637 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1638 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1639 : 				_Tmp);	// insert up to old end
; 1640 : 			}
; 1641 : 		else
; 1642 : 			{	// new stuff can all be assigned
; 1643 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1644 : 
; 1645 : 			pointer _Oldend = this->_Mylast;
; 1646 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1647 : 				this->_Mylast);	// copy suffix
; 1648 : 
; 1649 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1650 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1651 : 				_Oldend);	// copy hole
; 1652 : 			_STD fill(_VIPTR(_Where),
; 1653 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1654 : 			}
; 1655 : 		return (begin() + _Off);
; 1656 : 		}
; 1657 : 
; 1658 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1659 : 		{	// copy initializing _Count * _Val, using allocator
; 1660 : 		_Alty _Alval(this->_Getal());
; 1661 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1662 : 		return (_Ptr + _Count);
; 1663 : 		}
; 1664 : 
; 1665 : 	__declspec(noreturn) void _Xlen() const
; 1666 : 		{	// report a length_error
; 1667 : 		_Xlength_error("vector<T> too long");

  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00085	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0008a	cc		 int	 3
$LN41@Reserve:
?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy, COMDAT

; 1535 : 		{	// free all storage

$LN47:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1536 : 		if (this->_Myfirst != pointer())

  0000a	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  0000d	48 8b f1	 mov	 rsi, rcx
  00010	48 85 ff	 test	 rdi, rdi
  00013	74 69		 je	 SHORT $LN1@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00015	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0001a	48 8b 69 08	 mov	 rbp, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  0001e	48 3b fd	 cmp	 rdi, rbp
  00021	74 41		 je	 SHORT $LN12@Tidy
  00023	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL14@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00030	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00034	48 85 db	 test	 rbx, rbx
  00037	74 1d		 je	 SHORT $LN34@Tidy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00039	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0003d	75 17		 jne	 SHORT $LN34@Tidy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00047	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004b	75 09		 jne	 SHORT $LN34@Tidy

; 128  : 			_Delete_this();

  0004d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00050	48 8b cb	 mov	 rcx, rbx
  00053	ff 50 08	 call	 QWORD PTR [rax+8]
$LN34@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00056	48 83 c7 10	 add	 rdi, 16
  0005a	48 3b fd	 cmp	 rdi, rbp
  0005d	75 d1		 jne	 SHORT $LL14@Tidy
  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN12@Tidy:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  00064	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00067	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0006c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00071	33 c0		 xor	 eax, eax
  00073	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1543 : 			this->_Mylast = pointer();

  00076	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 1544 : 			this->_Myend = pointer();

  0007a	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
$LN1@Tidy:

; 1545 : 			}
; 1546 : 		}

  0007e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range, COMDAT

; 1694 : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 594  : 		{	// construct allocator from _Al
; 595  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal, COMDAT

; 647  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 648  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*, COMDAT

; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}

  00007	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00003	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 241  : 		return (*this);

  00006	48 8b c1	 mov	 rax, rcx
  00009	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 242  : 		}

  0000c	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==, COMDAT

; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00006	0f 94 c0	 sete	 al

; 299  : 		}

  00009	c3		 ret	 0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to, COMDAT

; 233  : 		return (_STD addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 234  : 		}

  00003	c3		 ret	 0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Nextnode, COMDAT

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b c1	 mov	 rax, rcx

; 538  : 		}

  00003	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity, COMDAT

; 972  : 		return (this->_Myend - this->_Mylast);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 41 08	 sub	 rax, QWORD PTR [rcx+8]
  00008	48 c1 f8 04	 sar	 rax, 4

; 973  : 		}

  0000c	c3		 ret	 0
?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 1092 : 		return (this->_Getal().max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 1093 : 		}

  0000a	c3		 ret	 0
?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy, COMDAT

; 1478 : 		{	// destroy [_First, _Last) using allocator

$LN37:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00000	49 3b d0	 cmp	 rdx, r8
  00003	74 5c		 je	 SHORT $LN35@Destroy
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1478 : 		{	// destroy [_First, _Last) using allocator

  00014	49 8b f0	 mov	 rsi, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	48 8d 7a 08	 lea	 rdi, QWORD PTR [rdx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL9@Destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN29@Destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN29@Destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN29@Destroy

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL9@Destroy
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1481 : 		}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN35@Destroy:
  00061	f3 c3		 fatret	 0
?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00004	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 967  : 		return (this->_Myend - this->_Myfirst);

  0000e	4c 2b 01	 sub	 r8, QWORD PTR [rcx]
  00011	49 c1 f8 04	 sar	 r8, 4

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00015	49 8b c8	 mov	 rcx, r8
  00018	48 d1 e9	 shr	 rcx, 1
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	49 3b c0	 cmp	 rax, r8
  00021	73 0e		 jae	 SHORT $LN4@Grow_to
  00023	45 33 c0	 xor	 r8d, r8d

; 1489 : 		if (_Capacity < _Count)

  00026	4c 3b c2	 cmp	 r8, rdx
  00029	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0002d	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  00030	c3		 ret	 0
$LN4@Grow_to:

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00031	4c 03 c1	 add	 r8, rcx

; 1489 : 		if (_Capacity < _Count)

  00034	4c 3b c2	 cmp	 r8, rdx
  00037	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0003b	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  0003e	c3		 ret	 0
?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate, COMDAT

; 1500 : 		{	// move to array of exactly _Count elements

$LN85:
  00000	40 56		 push	 rsi
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  0000a	45 33 ff	 xor	 r15d, r15d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1500 : 		{	// move to array of exactly _Count elements

  0000d	48 8b f2	 mov	 rsi, rdx
  00010	4c 8b f1	 mov	 r14, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00013	48 85 d2	 test	 rdx, rdx
  00016	74 2b		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00018	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00022	48 3b d0	 cmp	 rdx, rax
  00025	0f 87 c3 00 00
	00		 ja	 $LN83@Reallocate
  0002b	48 8b ca	 mov	 rcx, rdx
  0002e	48 c1 e1 04	 shl	 rcx, 4
  00032	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00037	4c 8b f8	 mov	 r15, rax
  0003a	48 85 c0	 test	 rax, rax
  0003d	0f 84 ab 00 00
	00		 je	 $LN83@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00043	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  00047	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  0004a	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0004f	4d 8b c7	 mov	 r8, r15
  00052	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00057	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  0005c	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00061	49 8b 3e	 mov	 rdi, QWORD PTR [r14]
  00064	4d 8b 66 08	 mov	 r12, QWORD PTR [r14+8]
  00068	49 8b ec	 mov	 rbp, r12
  0006b	48 2b ef	 sub	 rbp, rdi

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())

  0006e	48 85 ff	 test	 rdi, rdi
  00071	74 49		 je	 SHORT $LN75@Reallocate
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00073	49 3b fc	 cmp	 rdi, r12
  00076	74 3c		 je	 SHORT $LN46@Reallocate
  00078	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0007d	0f 1f 00	 npad	 3
$LL48@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00080	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00084	48 85 db	 test	 rbx, rbx
  00087	74 1d		 je	 SHORT $LN68@Reallocate

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00089	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0008d	75 17		 jne	 SHORT $LN68@Reallocate

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0008f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00092	48 8b cb	 mov	 rcx, rbx
  00095	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00097	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0009b	75 09		 jne	 SHORT $LN68@Reallocate

; 128  : 			_Delete_this();

  0009d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	ff 50 08	 call	 QWORD PTR [rax+8]
$LN68@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  000a6	48 83 c7 10	 add	 rdi, 16
  000aa	49 3b fc	 cmp	 rdi, r12
  000ad	75 d1		 jne	 SHORT $LL48@Reallocate
  000af	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN46@Reallocate:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  000b4	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000b7	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN75@Reallocate:
  000bc	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  000c1	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1519 : 		this->_Myend = _Ptr + _Count;

  000c6	48 c1 e6 04	 shl	 rsi, 4

; 1520 : 		this->_Mylast = _Ptr + _Size;

  000ca	48 83 e5 f0	 and	 rbp, -16
  000ce	49 03 f7	 add	 rsi, r15

; 1521 : 		this->_Myfirst = _Ptr;

  000d1	4d 89 3e	 mov	 QWORD PTR [r14], r15
  000d4	49 03 ef	 add	 rbp, r15
  000d7	49 89 76 10	 mov	 QWORD PTR [r14+16], rsi
  000db	49 89 6e 08	 mov	 QWORD PTR [r14+8], rbp
  000df	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 1522 : 		}

  000e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e8	41 5f		 pop	 r15
  000ea	41 5e		 pop	 r14
  000ec	5e		 pop	 rsi
  000ed	c3		 ret	 0
$LN83@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  000ee	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000f3	cc		 int	 3
$LN82@Reallocate:
?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen, COMDAT

; 1666 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1667 : 		_Xlength_error("vector<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >, COMDAT

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 489  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 346  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*, COMDAT

; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}

  00007	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval, COMDAT

; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8d 41 10	 lea	 rax, QWORD PTR [rcx+16]

; 548  : 		}

  00004	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 04	 sar	 rax, 4

; 968  : 		}

  0000b	c3		 ret	 0
?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 188  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 931  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 932  : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z PROC ; std::addressof<std::shared_ptr<ChunkBase> const >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ENDP ; std::addressof<std::shared_ptr<ChunkBase> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN26@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN26@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

$LN35:

; 88   : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5c		 je	 SHORT $LN33@Destroy_ra
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 79   : 	{	// destroy [_First, _Last)

  00014	48 8b f2	 mov	 rsi, rdx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL7@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN27@Destroy_ra

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN27@Destroy_ra

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN27@Destroy_ra

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN27@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL7@Destroy_ra
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 81   : 	}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN33@Destroy_ra:
  00061	f3 c3		 fatret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	49 8b c0	 mov	 rax, r8
  00007	48 8b ca	 mov	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0000a	4d 8b c1	 mov	 r8, r9
  0000d	48 8b d0	 mov	 rdx, rax
  00010	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1562 : 		}

  00015	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00019	c3		 ret	 0
??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 923  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

  00000	b0 01		 mov	 al, 1

; 924  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN22@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN22@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z PROC	; std::operator==<wchar_t,wchar_t>, COMDAT

; 677  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 678  : 	}

  00002	c3		 ret	 0
??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z ENDP	; std::operator==<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z PROC ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00005	0f b6 44 24 10	 movzx	 eax, BYTE PTR _Cat$[rsp]

; 440  : 	}

  0000a	c3		 ret	 0
??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z ENDP ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
__formal$dead$ = 72
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 87   : 	{	// destroy [_First, _Last), arbitrary type

$LN31:

; 88   : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5c		 je	 SHORT $LN29@Destroy_ra
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 87   : 	{	// destroy [_First, _Last), arbitrary type

  00014	48 8b f2	 mov	 rsi, rdx

; 88   : 	for (; _First != _Last; ++_First)

  00017	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL3@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN23@Destroy_ra

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN23@Destroy_ra

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN23@Destroy_ra

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN23@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL3@Destroy_ra
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 89   : 		_Al.destroy(_First);
; 90   : 	}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN29@Destroy_ra:
  00061	f3 c3		 fatret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >

; 474  : 	}

  00009	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000d	c3		 ret	 0
??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx
  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN18@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN18@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z PROC ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 711  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 712  : 	}

  00002	c3		 ret	 0
??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z ENDP ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >, COMDAT

; 426  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	4c 8b c9	 mov	 r9, rcx

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	48 3b ca	 cmp	 rcx, rdx
  00006	74 3e		 je	 SHORT $LN4@Uninit_mov
  00008	45 33 d2	 xor	 r10d, r10d
  0000b	0f 1f 44 00 00	 npad	 5
$LL6@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00010	4d 85 c0	 test	 r8, r8
  00013	74 24		 je	 SHORT $LN51@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00015	4d 89 10	 mov	 QWORD PTR [r8], r10
  00018	4d 89 50 08	 mov	 QWORD PTR [r8+8], r10

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0001c	4d 3b c1	 cmp	 r8, r9
  0001f	74 18		 je	 SHORT $LN51@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00021	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  00025	49 89 40 08	 mov	 QWORD PTR [r8+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00029	4d 89 51 08	 mov	 QWORD PTR [r9+8], r10

; 48   : 	_Left = _Move(_Right);

  0002d	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00030	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00033	49 89 00	 mov	 QWORD PTR [r8], rax

; 49   : 	_Right = _Move(_Tmp);

  00036	49 89 09	 mov	 QWORD PTR [r9], rcx
$LN51@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00039	49 83 c1 10	 add	 r9, 16
  0003d	49 83 c0 10	 add	 r8, 16
  00041	4c 3b ca	 cmp	 r9, rdx
  00044	75 ca		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 433  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 434  : 	_CATCH_ALL
; 435  : 	for (; _Next != _Dest; ++_Next)
; 436  : 		_Al.destroy(_Next);
; 437  : 	_RERAISE;
; 438  : 	_CATCH_END
; 439  : 	return (_Dest);

  00046	49 8b c0	 mov	 rax, r8

; 440  : 	}

  00049	c3		 ret	 0
??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN38@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN38@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN38@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN34@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN34@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN34@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN30@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN30@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN30@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z PROC	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 89 01	 mov	 QWORD PTR [rcx], r8
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000a	48 3b ca	 cmp	 rcx, rdx
  0000d	74 18		 je	 SHORT $LN30@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00013	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00017	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  0001b	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0001e	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00021	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00024	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN30@shared_ptr:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 581  : 		}

  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ENDP	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z PROC	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>, COMDAT

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 89 01	 mov	 QWORD PTR [rcx], r8
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000a	48 3b ca	 cmp	 rcx, rdx
  0000d	74 18		 je	 SHORT $LN26@Ptr_base
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00013	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00017	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  0001b	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0001e	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00021	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00024	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN26@Ptr_base:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 289  : 		}

  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ENDP	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z PROC ; std::_Ptr_base<ChunkBase>::_Assign_rv, COMDAT

; 307  : 		if (this != &_Right)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 1c		 je	 SHORT $LN14@Assign_rv
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00005	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00009	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0000d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00011	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00015	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00018	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  0001b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  0001e	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN14@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 309  : 		}

  00021	f3 c3		 fatret	 0
?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z PROC ; std::_Ptr_base<ChunkBase>::_Swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 320  : 		}

  0001c	c3		 ret	 0
?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::_Ptr_base<ChunkBase> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::_Ptr_base<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z PROC ; std::swap<ChunkBase * __ptr64>, COMDAT

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00009	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 50   : 	}

  0000c	c3		 ret	 0
??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z ENDP ; std::swap<ChunkBase * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z PROC ; std::_Move<ChunkBase * __ptr64 & __ptr64>, COMDAT

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1800 : 	}

  00003	c3		 ret	 0
??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z ENDP ; std::_Move<ChunkBase * __ptr64 & __ptr64>
_TEXT	ENDS
END
