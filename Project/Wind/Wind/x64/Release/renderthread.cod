; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.61030.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	?blocksTexture@RenderThread@@2PEAVTiledTexture@gfxu@@EA ; RenderThread::blocksTexture
PUBLIC	?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
PUBLIC	?bGrid@@3PAY1BF@BF@_NA				; bGrid
PUBLIC	?normalFShader@@3PEAVFragmentShader@gfxu@@EA	; normalFShader
PUBLIC	?noTexFShader@@3PEAVFragmentShader@gfxu@@EA	; noTexFShader
PUBLIC	?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
PUBLIC	?grid@@3PEAVVertexStream@gfxu@@EA		; grid
PUBLIC	?normalVShader@@3PEAVVertexShader@gfxu@@EA	; normalVShader
PUBLIC	?noTexVShader@@3PEAVVertexShader@gfxu@@EA	; noTexVShader
PUBLIC	?square@@3PEAVVertexStream@gfxu@@EA		; square
PUBLIC	?skipRender@RenderThread@@2_NA			; RenderThread::skipRender
EXTRN	__imp_glFlush:PROC
EXTRN	__imp_glEnable:PROC
EXTRN	__imp_glViewport:PROC
EXTRN	__imp_glBlendFunc:PROC
EXTRN	__imp_glDisable:PROC
EXTRN	__imp_glClearColor:PROC
EXTRN	__imp_glClear:PROC
EXTRN	__imp_glDepthFunc:PROC
?blocksTexture@RenderThread@@2PEAVTiledTexture@gfxu@@EA DQ 01H DUP (?) ; RenderThread::blocksTexture
?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA DQ 01H DUP (?) ; normalShaderProgram
?bGrid@@3PAY1BF@BF@_NA DB 0242dH DUP (?)		; bGrid
	ALIGN	8

?normalFShader@@3PEAVFragmentShader@gfxu@@EA DQ 01H DUP (?) ; normalFShader
?noTexFShader@@3PEAVFragmentShader@gfxu@@EA DQ 01H DUP (?) ; noTexFShader
?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA DQ 01H DUP (?) ; noTexShaderProgram
?grid@@3PEAVVertexStream@gfxu@@EA DQ 01H DUP (?)	; grid
?normalVShader@@3PEAVVertexShader@gfxu@@EA DQ 01H DUP (?) ; normalVShader
?noTexVShader@@3PEAVVertexShader@gfxu@@EA DQ 01H DUP (?) ; noTexVShader
?square@@3PEAVVertexStream@gfxu@@EA DQ 01H DUP (?)	; square
_BSS	ENDS
?skipRender@RenderThread@@2_NA DB 01H			; RenderThread::skipRender
renderDistance DD 0aH
	ORG $+2
$SG4294945226 DB 'gridTransform', 00H
	ORG $+2
$SG4294945225 DB 'arrayInsideCheck', 00H
	ORG $+7
$SG4294945224 DB 'OpenGL error', 00H
	ORG $+3
$SG4294945223 DB 'Graphics thread loop error', 00H
	ORG $+5
$SG4294945222 DB '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H, 'r', 00H
	DB	'a', 00H, 'm', 00H, 's', 00H, '\', 00H, 'f', 00H, 'r', 00H, 'u'
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'm', 00H, 'c', 00H, 'l', 00H
	DB	'i', 00H, 'p', 00H, '.', 00H, 'c', 00H, 'l', 00H, 00H, 00H
	ORG $+6
$SG4294945221 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 'l', 00H, '.', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	't', 00H, 00H, 00H
	ORG $+6
$SG4294945220 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'r', 00H, 'm'
	DB	00H, 'a', 00H, 'l', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'a', 00H
	DB	'g', 00H, 00H, 00H
	ORG $+6
$SG4294945219 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'T', 00H, 'e'
	DB	00H, 'x', 00H, '.', 00H, 'v', 00H, 'e', 00H, 'r', 00H, 't', 00H
	DB	00H, 00H
$SG4294945218 DB '\', 00H, 's', 00H, 'h', 00H, 'a', 00H, 'd', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 'n', 00H, 'o', 00H, 'T', 00H, 'e'
	DB	00H, 'x', 00H, '.', 00H, 'f', 00H, 'r', 00H, 'a', 00H, 'g', 00H
	DB	00H, 00H
PUBLIC	??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z ; std::_Move<ChunkBase * __ptr64 & __ptr64>
PUBLIC	??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z ; std::swap<ChunkBase * __ptr64>
PUBLIC	??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::_Ptr_base<ChunkBase> >
PUBLIC	?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z ; std::_Ptr_base<ChunkBase>::_Swap
PUBLIC	?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z ; std::_Ptr_base<ChunkBase>::_Assign_rv
PUBLIC	??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
PUBLIC	??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::shared_ptr<ChunkBase> >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
PUBLIC	??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
PUBLIC	??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z	; std::operator==<wchar_t,wchar_t>
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>
PUBLIC	??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
PUBLIC	??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
PUBLIC	??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ; std::addressof<std::shared_ptr<ChunkBase> const >
PUBLIC	??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
PUBLIC	??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity
PUBLIC	?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate
PUBLIC	?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval
PUBLIC	??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
PUBLIC	??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >
PUBLIC	?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
PUBLIC	?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
PUBLIC	?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to
PUBLIC	?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy
PUBLIC	?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
PUBLIC	?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate
PUBLIC	?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Nextnode
PUBLIC	?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to
PUBLIC	??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==
PUBLIC	??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
PUBLIC	?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
PUBLIC	??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
PUBLIC	?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range
PUBLIC	?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
PUBLIC	?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
PUBLIC	?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside
PUBLIC	?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ	; List<Tasks::Task * __ptr64,256>::clear
PUBLIC	?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ	; List<Tasks::Task * __ptr64,256>::getSize
PUBLIC	??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z ; List<Tasks::Task * __ptr64,256>::operator[]
PUBLIC	?end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::end
PUBLIC	?begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::begin
PUBLIC	?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ; std::_Ptr_base<gfxu::VertexStream>::_Get
PUBLIC	?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=
PUBLIC	??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
PUBLIC	??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
PUBLIC	?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
PUBLIC	??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[]
PUBLIC	?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
PUBLIC	??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
PUBLIC	?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ ; VirtualList<Tasks::Task,256,4098>::clear
PUBLIC	?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ ; VirtualList<Tasks::Task,256,4098>::getSize
PUBLIC	??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z ; VirtualList<Tasks::Task,256,4098>::operator[]
PUBLIC	?end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end
PUBLIC	?begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin
PUBLIC	??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64
PUBLIC	??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ; std::shared_ptr<gfxu::VertexStream>::operator->
PUBLIC	?set@?$Uniform@M@gfxu@@QEAAXM@Z			; gfxu::Uniform<float>::set
PUBLIC	?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z ; gfxu::Uniform<geom::Vector>::set
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	??1FragmentShader@gfxu@@QEAA@XZ			; gfxu::FragmentShader::~FragmentShader
PUBLIC	??1VertexShader@gfxu@@QEAA@XZ			; gfxu::VertexShader::~VertexShader
PUBLIC	??_GTiledTexture@gfxu@@QEAAPEAXI@Z		; gfxu::TiledTexture::`scalar deleting destructor'
PUBLIC	??_GShaderProgram@gfxu@@QEAAPEAXI@Z		; gfxu::ShaderProgram::`scalar deleting destructor'
PUBLIC	??_GFragmentShader@gfxu@@QEAAPEAXI@Z		; gfxu::FragmentShader::`scalar deleting destructor'
PUBLIC	??_GVertexShader@gfxu@@QEAAPEAXI@Z		; gfxu::VertexShader::`scalar deleting destructor'
PUBLIC	?postStop@RenderThread@@UEAAXXZ			; RenderThread::postStop
PUBLIC	?preStart@RenderThread@@UEAAXXZ			; RenderThread::preStart
PUBLIC	?tick@RenderThread@@EEAA_NXZ			; RenderThread::tick
PUBLIC	?program@@3VProgram@cl@@A			; program
PUBLIC	?gridBuffer@@3VBuffer@cl@@A			; gridBuffer
PUBLIC	?projectionMatrixBuffer@@3VBuffer@cl@@A		; projectionMatrixBuffer
PUBLIC	?commandQueue@@3VCommandQueue@cl@@A		; commandQueue
PUBLIC	?boolBuffer@@3VBuffer@cl@@A			; boolBuffer
	ALIGN	4

_Tuple_alloc DB	01H DUP (?)
	ALIGN	4

ignore	DB	01H DUP (?)
	ALIGN	4

?program@@3VProgram@cl@@A DB 038H DUP (?)		; program
allocator_arg DB 01H DUP (?)
	ALIGN	4

?gridBuffer@@3VBuffer@cl@@A DB 018H DUP (?)		; gridBuffer
?projectionMatrixBuffer@@3VBuffer@cl@@A DB 018H DUP (?)	; projectionMatrixBuffer
piecewise_construct DB 01H DUP (?)
	ALIGN	4

?commandQueue@@3VCommandQueue@cl@@A DB 028H DUP (?)	; commandQueue
?boolBuffer@@3VBuffer@cl@@A DB 018H DUP (?)		; boolBuffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+14
	DD	imagerel $unwind$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31+10
	DD	imagerel $LN31+97
	DD	imagerel $chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD imagerel $LN31+97
	DD	imagerel $LN31+99
	DD	imagerel $chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z DD imagerel $LN10
	DD	imagerel $LN10+26
	DD	imagerel $unwind$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35+10
	DD	imagerel $LN35+97
	DD	imagerel $chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD imagerel $LN35+97
	DD	imagerel $LN35+99
	DD	imagerel $chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+17
	DD	imagerel $unwind$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+120
	DD	imagerel $LN85+180
	DD	imagerel $chain$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+180
	DD	imagerel $LN85+238
	DD	imagerel $chain$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN85+238
	DD	imagerel $LN85+244
	DD	imagerel $chain$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37+10
	DD	imagerel $LN37+97
	DD	imagerel $chain$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD imagerel $LN37+97
	DD	imagerel $LN37+99
	DD	imagerel $chain$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+35
	DD	imagerel $LN47+100
	DD	imagerel $chain$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+100
	DD	imagerel $LN47+126
	DD	imagerel $chain$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD imagerel $LN47+126
	DD	imagerel $LN47+137
	DD	imagerel $chain$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD imagerel $LN44
	DD	imagerel $LN44+139
	DD	imagerel $unwind$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD imagerel $LN80
	DD	imagerel $LN80+129
	DD	imagerel $unwind$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN59
	DD	imagerel $LN59+35
	DD	imagerel $unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1FragmentShader@gfxu@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+88
	DD	imagerel $unwind$??1FragmentShader@gfxu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1VertexShader@gfxu@@QEAA@XZ DD imagerel $LN42
	DD	imagerel $LN42+88
	DD	imagerel $unwind$??1VertexShader@gfxu@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GTiledTexture@gfxu@@QEAAPEAXI@Z DD imagerel $LN73
	DD	imagerel $LN73+102
	DD	imagerel $unwind$??_GTiledTexture@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GShaderProgram@gfxu@@QEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+43
	DD	imagerel $unwind$??_GShaderProgram@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD imagerel $LN45
	DD	imagerel $LN45+99
	DD	imagerel $unwind$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD imagerel $LN45
	DD	imagerel $LN45+99
	DD	imagerel $unwind$??_GVertexShader@gfxu@@QEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?postStop@RenderThread@@UEAAXXZ DD imagerel $LN108
	DD	imagerel $LN108+328
	DD	imagerel $unwind$?postStop@RenderThread@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?preStart@RenderThread@@UEAAXXZ DD imagerel $LN766
	DD	imagerel $LN766+2353
	DD	imagerel $unwind$?preStart@RenderThread@@UEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?tick@RenderThread@@EEAA_NXZ DD imagerel $LN1174
	DD	imagerel $LN1174+5740
	DD	imagerel $unwind$?tick@RenderThread@@EEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FgridBuffer@@YAXXZ DD imagerel ??__FgridBuffer@@YAXXZ
	DD	imagerel ??__FgridBuffer@@YAXXZ+58
	DD	imagerel $unwind$??__FgridBuffer@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FboolBuffer@@YAXXZ DD imagerel ??__FboolBuffer@@YAXXZ
	DD	imagerel ??__FboolBuffer@@YAXXZ+58
	DD	imagerel $unwind$??__FboolBuffer@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FprojectionMatrixBuffer@@YAXXZ DD imagerel ??__FprojectionMatrixBuffer@@YAXXZ
	DD	imagerel ??__FprojectionMatrixBuffer@@YAXXZ+58
	DD	imagerel $unwind$??__FprojectionMatrixBuffer@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__Eprogram@@YAXXZ DD imagerel ??__Eprogram@@YAXXZ
	DD	imagerel ??__Eprogram@@YAXXZ+76
	DD	imagerel $unwind$??__Eprogram@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FcommandQueue@@YAXXZ DD imagerel ??__FcommandQueue@@YAXXZ
	DD	imagerel ??__FcommandQueue@@YAXXZ+91
	DD	imagerel $unwind$??__FcommandQueue@@YAXXZ
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FcommandQueue@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??__Eprogram@@YAXXZ DD imagerel ??__Eprogram@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ??__Eprogram@@YAXXZ+25
	DD	00H
	DD	imagerel ??__Eprogram@@YAXXZ+60
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??__Eprogram@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???__Eprogram@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??__Eprogram@@YAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??__Eprogram@@YAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??__Eprogram@@YAXXZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__Eprogram@@YAXXZ DD 010d11H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??__Eprogram@@YAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FprojectionMatrixBuffer@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FboolBuffer@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FgridBuffer@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?tick@RenderThread@@EEAA_NXZ DD imagerel ?tick@RenderThread@@EEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+2818
	DD	00H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+2879
	DD	0ffffffffH
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3256
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3311
	DD	02H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3861
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3922
	DD	02H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+3948
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+4078
	DD	03H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+4388
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+4496
	DD	04H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+4796
	DD	01H
	DD	imagerel ?tick@RenderThread@@EEAA_NXZ+5589
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?tick@RenderThread@@EEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?tick@RenderThread@@EEAA_NXZ DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?tick@RenderThread@@EEAA_NXZ
	DD	00H
	DD	00H
	DD	0dH
	DD	imagerel $ip2state$?tick@RenderThread@@EEAA_NXZ
	DD	0188H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?tick@RenderThread@@EEAA_NXZ DD 0114a19H
	DD	0727839H
	DD	0736835H
	DD	0f17431H
	DD	0f0642dH
	DD	0ef3429H
	DD	0e8011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?tick@RenderThread@@EEAA_NXZ
	DD	0712H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?preStart@RenderThread@@UEAAXXZ DD imagerel ?preStart@RenderThread@@UEAAXXZ
	DD	0ffffffffH
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+430
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1608
	DD	01H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1666
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1735
	DD	02H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1793
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1817
	DD	03H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1864
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1933
	DD	04H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+1991
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2060
	DD	05H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2118
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2142
	DD	06H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2189
	DD	00H
	DD	imagerel ?preStart@RenderThread@@UEAAXXZ+2285
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?preStart@RenderThread@@UEAAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?preStart@RenderThread@@UEAAXXZ DD 019930522H
	DD	07H
	DD	imagerel $stateUnwindMap$?preStart@RenderThread@@UEAAXXZ
	DD	00H
	DD	00H
	DD	0fH
	DD	imagerel $ip2state$?preStart@RenderThread@@UEAAXXZ
	DD	060H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?preStart@RenderThread@@UEAAXXZ DD 0f3e19H
	DD	098830H
	DD	0a782bH
	DD	0b6827H
	DD	01c7423H
	DD	01b641fH
	DD	01a341bH
	DD	018010fH
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?preStart@RenderThread@@UEAAXXZ
	DD	08aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?postStop@RenderThread@@UEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z+32
	DD	00H
	DD	imagerel ??_GVertexShader@gfxu@@QEAAPEAXI@Z+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_GVertexShader@gfxu@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GVertexShader@gfxu@@QEAAPEAXI@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GVertexShader@gfxu@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z+32
	DD	00H
	DD	imagerel ??_GFragmentShader@gfxu@@QEAAPEAXI@Z+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GFragmentShader@gfxu@@QEAAPEAXI@Z DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_GFragmentShader@gfxu@@QEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GShaderProgram@gfxu@@QEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_GTiledTexture@gfxu@@QEAAPEAXI@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1VertexShader@gfxu@@QEAA@XZ DD imagerel ??1VertexShader@gfxu@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1VertexShader@gfxu@@QEAA@XZ+32
	DD	00H
	DD	imagerel ??1VertexShader@gfxu@@QEAA@XZ+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1VertexShader@gfxu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1VertexShader@gfxu@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1VertexShader@gfxu@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1VertexShader@gfxu@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1VertexShader@gfxu@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1VertexShader@gfxu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1FragmentShader@gfxu@@QEAA@XZ DD imagerel ??1FragmentShader@gfxu@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1FragmentShader@gfxu@@QEAA@XZ+32
	DD	00H
	DD	imagerel ??1FragmentShader@gfxu@@QEAA@XZ+48
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1FragmentShader@gfxu@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1FragmentShader@gfxu@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1FragmentShader@gfxu@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1FragmentShader@gfxu@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1FragmentShader@gfxu@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1FragmentShader@gfxu@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 021H
	DD	imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 020521H
	DD	063405H
	DD	imagerel $LN47+21
	DD	imagerel $LN47+35
	DD	imagerel $chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 020521H
	DD	075405H
	DD	imagerel $LN47
	DD	imagerel $LN47+21
	DD	imagerel $unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+10
	DD	imagerel $unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 021H
	DD	imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 020521H
	DD	0a3405H
	DD	imagerel $LN85+74
	DD	imagerel $LN85+120
	DD	imagerel $chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 061221H
	DD	0dc412H
	DD	0c740dH
	DD	0b5405H
	DD	imagerel $LN85
	DD	imagerel $LN85+74
	DD	imagerel $unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z DD 040a01H
	DD	0f006520aH
	DD	06002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN35
	DD	imagerel $LN35+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 021H
	DD	imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 040a21H
	DD	07740aH
	DD	063405H
	DD	imagerel $LN31
	DD	imagerel $LN31+10
	DD	imagerel $unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z DD 020a01H
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z DD 010401H
	DD	06204H
commandQueue$initializer$ DQ FLAT:??__EcommandQueue@@YAXXZ
program$initializer$ DQ FLAT:??__Eprogram@@YAXXZ
projectionMatrixBuffer$initializer$ DQ FLAT:??__EprojectionMatrixBuffer@@YAXXZ
boolBuffer$initializer$ DQ FLAT:??__EboolBuffer@@YAXXZ
gridBuffer$initializer$ DQ FLAT:??__EgridBuffer@@YAXXZ
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EcommandQueue@@YAXXZ
text$yc	SEGMENT
??__EcommandQueue@@YAXXZ PROC				; `dynamic initializer for 'commandQueue'', COMDAT

; 13   : cl::CommandQueue commandQueue;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FcommandQueue@@YAXXZ ; `dynamic atexit destructor for 'commandQueue''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EcommandQueue@@YAXXZ ENDP				; `dynamic initializer for 'commandQueue''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??__FcommandQueue@@YAXXZ
text$yd	SEGMENT
$T1 = 48
??__FcommandQueue@@YAXXZ PROC				; `dynamic atexit destructor for 'commandQueue'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 49   : 	if(okay) clReleaseCommandQueue(queue);

  00004	80 3d 20 00 00
	00 00		 cmp	 BYTE PTR ?commandQueue@@3VCommandQueue@cl@@A+32, 0
  0000b	74 0d		 je	 SHORT $LN3@dynamic
  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseCommandQueue
$LN3@dynamic:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  0001a	48 83 3d 08 00
	00 00 00	 cmp	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+8, 0
  00022	74 32		 je	 SHORT $LN8@dynamic

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00024	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PEAU_cl_event@@V?$allocator@PEAU_cl_event@@@std@@@std@@IEAAXPEAPEAU_cl_event@@0@Z ; std::vector<_cl_event * __ptr64,std::allocator<_cl_event * __ptr64> >::_Destroy

; 647  : 		return (_Alty());

  00029	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0002e	e8 00 00 00 00	 call	 ??0?$_Wrap_alloc@V?$allocator@PEAU_cl_event@@@std@@@std@@QEAA@XZ ; std::_Wrap_alloc<std::allocator<_cl_event * __ptr64> >::_Wrap_alloc<std::allocator<_cl_event * __ptr64> >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00033	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+8
  0003a	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  0003f	33 c0		 xor	 eax, eax
  00041	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+8, rax

; 1543 : 			this->_Mylast = pointer();

  00048	48 89 05 10 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+16, rax

; 1544 : 			this->_Myend = pointer();

  0004f	48 89 05 18 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A+24, rax
$LN8@dynamic:
  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
??__FcommandQueue@@YAXXZ ENDP				; `dynamic atexit destructor for 'commandQueue''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__Eprogram@@YAXXZ
text$yc	SEGMENT
$T1 = 32
??__Eprogram@@YAXXZ PROC				; `dynamic initializer for 'program'', COMDAT

; 14   : cl::Program program;

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 778  : 		this->_Myhead = _Buyheadnode();

  0000d	e8 00 00 00 00	 call	 ?_Buyheadnode@?$_Tree_alloc@$0A@U?$_Tree_base_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@@std@@QEAAPEAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@PEAX@2@XZ ; std::_Tree_alloc<0,std::_Tree_base_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64>,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,_cl_kernel * __ptr64> > > >::_Buyheadnode
  00012	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?program@@3VProgram@cl@@A+8, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  00019	ba 02 00 00 00	 mov	 edx, 2
  0001e	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A+24
  00025	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  0002a	85 c0		 test	 eax, eax
  0002c	74 07		 je	 SHORT $LN31@dynamic

; 33   : 		_Throw_C_error(_Res);

  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN31@dynamic:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 97   : {

  00035	c6 05 30 00 00
	00 00		 mov	 BYTE PTR ?program@@3VProgram@cl@@A+48, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 14   : cl::Program program;

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__Fprogram@@YAXXZ ; `dynamic atexit destructor for 'program''
  00043	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00047	e9 00 00 00 00	 jmp	 atexit
??__Eprogram@@YAXXZ ENDP				; `dynamic initializer for 'program''
text$yc	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
?dtor$0@?0???__Eprogram@@YAXXZ@4HA PROC			; ``dynamic initializer for 'program'''::`1'::dtor$0
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAU_cl_kernel@@@std@@@2@@std@@QEAA@XZ
?dtor$0@?0???__Eprogram@@YAXXZ@4HA ENDP			; ``dynamic initializer for 'program'''::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??__Fprogram@@YAXXZ
text$yd	SEGMENT
??__Fprogram@@YAXXZ PROC				; `dynamic atexit destructor for 'program'', COMDAT
  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00007	e9 00 00 00 00	 jmp	 ??1Program@cl@@QEAA@XZ	; cl::Program::~Program
??__Fprogram@@YAXXZ ENDP				; `dynamic atexit destructor for 'program''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EprojectionMatrixBuffer@@YAXXZ
text$yc	SEGMENT
??__EprojectionMatrixBuffer@@YAXXZ PROC			; `dynamic initializer for 'projectionMatrixBuffer'', COMDAT

; 15   : cl::Buffer projectionMatrixBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FprojectionMatrixBuffer@@YAXXZ ; `dynamic atexit destructor for 'projectionMatrixBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EprojectionMatrixBuffer@@YAXXZ ENDP			; `dynamic initializer for 'projectionMatrixBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__FprojectionMatrixBuffer@@YAXXZ
text$yd	SEGMENT
??__FprojectionMatrixBuffer@@YAXXZ PROC			; `dynamic atexit destructor for 'projectionMatrixBuffer'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 267  : 	if(okay)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A, 0
  0000b	74 28		 je	 SHORT $LN3@dynamic

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  0000d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  0001a	85 c0		 test	 eax, eax
  0001c	74 17		 je	 SHORT $LN3@dynamic

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN3@dynamic:
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??__FprojectionMatrixBuffer@@YAXXZ ENDP			; `dynamic atexit destructor for 'projectionMatrixBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EboolBuffer@@YAXXZ
text$yc	SEGMENT
??__EboolBuffer@@YAXXZ PROC				; `dynamic initializer for 'boolBuffer'', COMDAT

; 16   : cl::Buffer boolBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FboolBuffer@@YAXXZ ; `dynamic atexit destructor for 'boolBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EboolBuffer@@YAXXZ ENDP				; `dynamic initializer for 'boolBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__FboolBuffer@@YAXXZ
text$yd	SEGMENT
??__FboolBuffer@@YAXXZ PROC				; `dynamic atexit destructor for 'boolBuffer'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 267  : 	if(okay)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?boolBuffer@@3VBuffer@cl@@A, 0
  0000b	74 28		 je	 SHORT $LN3@dynamic

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  0000d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?boolBuffer@@3VBuffer@cl@@A+8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  0001a	85 c0		 test	 eax, eax
  0001c	74 17		 je	 SHORT $LN3@dynamic

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN3@dynamic:
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??__FboolBuffer@@YAXXZ ENDP				; `dynamic atexit destructor for 'boolBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ??__EgridBuffer@@YAXXZ
text$yc	SEGMENT
??__EgridBuffer@@YAXXZ PROC				; `dynamic initializer for 'gridBuffer'', COMDAT

; 17   : cl::Buffer gridBuffer;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FgridBuffer@@YAXXZ ; `dynamic atexit destructor for 'gridBuffer''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EgridBuffer@@YAXXZ ENDP				; `dynamic initializer for 'gridBuffer''
text$yc	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
;	COMDAT ??__FgridBuffer@@YAXXZ
text$yd	SEGMENT
??__FgridBuffer@@YAXXZ PROC				; `dynamic atexit destructor for 'gridBuffer'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 267  : 	if(okay)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?gridBuffer@@3VBuffer@cl@@A, 0
  0000b	74 28		 je	 SHORT $LN3@dynamic

; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);

  0000d	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+8
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clReleaseMemObject

; 270  : 		if(error != CL_SUCCESS)

  0001a	85 c0		 test	 eax, eax
  0001c	74 17		 je	 SHORT $LN3@dynamic

; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");

  0001e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952791
  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952790
  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	e9 00 00 00 00	 jmp	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN3@dynamic:
  00035	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00039	c3		 ret	 0
??__FgridBuffer@@YAXXZ ENDP				; `dynamic atexit destructor for 'gridBuffer''
text$yd	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?tick@RenderThread@@EEAA_NXZ
_TEXT	SEGMENT
chunksToRender$ = 80
zCam$ = 104
yCam$ = 108
xCam$ = 112
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
$T6 = 200
$T7 = 224
chunk$8 = 240
event$9 = 256
$T10 = 264
event$11 = 280
event$12 = 288
event$13 = 296
$T14 = 304
$T15 = 336
c$16 = 368
$T17 = 384
$T18 = 392
chunk$19 = 400
chunk$20 = 416
$T21 = 432
$T22 = 496
$T23 = 560
$T24 = 624
$T25 = 688
$T26 = 752
$T27 = 816
$T28 = 880
$T29 = 944
$T30 = 1008
$T31 = 1024
$T32 = 1048
$T33 = 1072
$T34 = 1136
$T35 = 1200
$T36 = 1264
$T37 = 1328
projectionMatrix$ = 1392
$T38 = 1456
$T39 = 1520
$T40 = 1584
$T41 = 1648
global_ws_1$ = 1712
local_ws_1$ = 1736
global_ws_2$ = 1760
local_ws_2$ = 1784
__$ArrayPad$ = 1808
this$ = 1904
?tick@RenderThread@@EEAA_NXZ PROC			; RenderThread::tick, COMDAT

; 32   : {

$LN1174:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d a8 98 f9
	ff ff		 lea	 rbp, QWORD PTR [rax-1640]
  00013	48 81 ec 40 07
	00 00		 sub	 rsp, 1856		; 00000740H
  0001a	48 c7 85 88 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T18[rbp-256], -2
  00025	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00029	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0002d	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00031	0f 29 70 c8	 movaps	 XMMWORD PTR [rax-56], xmm6
  00035	0f 29 78 b8	 movaps	 XMMWORD PTR [rax-72], xmm7
  00039	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00040	48 33 c4	 xor	 rax, rsp
  00043	48 89 85 10 06
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0004a	48 8b f1	 mov	 rsi, rcx

; 33   : 	for(int i = 0; i < RenderThread::taskList.getSize(); i++)

  0004d	45 33 e4	 xor	 r12d, r12d
  00050	41 8b fc	 mov	 edi, r12d
  00053	45 8d 74 24 01	 lea	 r14d, QWORD PTR [r12+1]
  00058	44 39 a1 20 08
	00 00		 cmp	 DWORD PTR [rcx+2080], r12d
  0005f	7e 2d		 jle	 SHORT $LN38@tick
  00061	48 8d 59 20	 lea	 rbx, QWORD PTR [rcx+32]
$LL40@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 53   : 		return List::operator[](index);

  00065	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 35   : 		if(!RenderThread::taskList[i]->invoke())

  00068	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0006b	ff 10		 call	 QWORD PTR [rax]
  0006d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?stop@GlobalThread@@3_NA ; GlobalThread::stop
  00074	84 c0		 test	 al, al
  00076	41 0f 44 ce	 cmove	 ecx, r14d
  0007a	88 0d 00 00 00
	00		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, cl ; GlobalThread::stop

; 33   : 	for(int i = 0; i < RenderThread::taskList.getSize(); i++)

  00080	ff c7		 inc	 edi
  00082	48 8d 5b 08	 lea	 rbx, QWORD PTR [rbx+8]
  00086	3b be 20 08 00
	00		 cmp	 edi, DWORD PTR [rsi+2080]
  0008c	7c d7		 jl	 SHORT $LL40@tick
$LN38@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 37   : 		count = 0;

  0008e	44 89 a6 20 08
	00 00		 mov	 DWORD PTR [rsi+2080], r12d
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 18   : 	pos = 0;

  00095	44 89 a6 34 08
	00 00		 mov	 DWORD PTR [rsi+2100], r12d
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 43   : 	if(RenderThread::skipRender)

  0009c	44 38 25 00 00
	00 00		 cmp	 BYTE PTR ?skipRender@RenderThread@@2_NA, r12b ; RenderThread::skipRender
  000a3	74 09		 je	 SHORT $LN36@tick

; 44   : 	{
; 45   : 		return true;

  000a5	41 0f b6 c6	 movzx	 eax, r14b
  000a9	e9 84 15 00 00	 jmp	 $LN41@tick
$LN36@tick:

; 46   : 	}
; 47   : 
; 48   : 	GameStates::swapPendingRendering();

  000ae	e8 00 00 00 00	 call	 ?swapPendingRendering@GameStates@@YAXXZ ; GameStates::swapPendingRendering

; 49   : 
; 50   : 	GameStates::GameState* state = GameStates::renderingState;

  000b3	4c 8b 2d 00 00
	00 00		 mov	 r13, QWORD PTR ?renderingState@GameStates@@3PEAVGameState@1@EA ; GameStates::renderingState

; 51   : 
; 52   : 	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  000ba	b9 00 41 00 00	 mov	 ecx, 16640		; 00004100H
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClear

; 53   : 
; 54   : 	if(GLWindow::instance->rescaled)

  000c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  000cc	44 38 60 50	 cmp	 BYTE PTR [rax+80], r12b
  000d0	74 1d		 je	 SHORT $LN35@tick

; 55   : 	{
; 56   : 		glViewport(0, 0, GLWindow::instance->width, GLWindow::instance->height);

  000d2	44 8b 48 58	 mov	 r9d, DWORD PTR [rax+88]
  000d6	44 8b 40 54	 mov	 r8d, DWORD PTR [rax+84]
  000da	33 d2		 xor	 edx, edx
  000dc	33 c9		 xor	 ecx, ecx
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glViewport

; 57   : 		GLWindow::instance->rescaled = false;

  000e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  000eb	44 88 60 50	 mov	 BYTE PTR [rax+80], r12b
$LN35@tick:

; 58   : 	}
; 59   : 		
; 60   : 	normalShaderProgram->bind();

  000ef	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 492  : 	glUseProgram(object);

  000f6	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 879  : 	int error = glGetError();

  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 880  : 	if(error != GL_NO_ERROR)

  00105	85 c0		 test	 eax, eax
  00107	74 17		 je	 SHORT $LN69@tick

; 881  : 	{
; 882  : 		const char* errorString = (const char*)gluErrorString(error);

  00109	8b c8		 mov	 ecx, eax
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 883  : 		GLWindow::instance->postError(errorString, caption);

  00111	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294921882
  00118	48 8b d0	 mov	 rdx, rax
  0011b	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN69@tick:

; 493  : 	gfxu::getError();
; 494  : 	current = this;

  00120	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?current@ShaderProgram@gfxu@@2PEAV12@EA, rbx ; gfxu::ShaderProgram::current

; 619  : }
; 620  : 
; 621  : void Uniforms::setForceUpload()
; 622  : {
; 623  : 	MMS.changed = PMS.changed = true;

  00127	44 88 35 68 00
	00 00		 mov	 BYTE PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+104, r14b
  0012e	44 88 35 68 00
	00 00		 mov	 BYTE PTR ?MMS@Uniforms@gfxu@@2VMatrixStack@2@A+104, r14b
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 10   : {

  00135	f3 41 0f 10 45
	00		 movss	 xmm0, DWORD PTR [r13]
  0013b	f3 0f 11 45 b8	 movss	 DWORD PTR $T5[rbp-256], xmm0
  00140	f3 41 0f 10 4d
	04		 movss	 xmm1, DWORD PTR [r13+4]
  00146	f3 0f 11 4d bc	 movss	 DWORD PTR $T5[rbp-252], xmm1
  0014b	f3 41 0f 10 45
	08		 movss	 xmm0, DWORD PTR [r13+8]
  00151	f3 0f 11 45 c0	 movss	 DWORD PTR $T5[rbp-248], xmm0
  00156	f3 41 0f 10 4d
	0c		 movss	 xmm1, DWORD PTR [r13+12]
  0015c	f3 0f 11 4d c4	 movss	 DWORD PTR $T5[rbp-244], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  00161	48 8b 45 b8	 mov	 rax, QWORD PTR $T5[rbp-256]
  00165	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  0016c	48 8b 45 c0	 mov	 rax, QWORD PTR $T5[rbp-248]
  00170	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  00177	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?camPos@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  0017e	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f800000
  00186	c7 45 a8 00 00
	80 3f		 mov	 DWORD PTR $T4[rbp-256], 1065353216 ; 3f800000H
  0018d	c7 45 ac 00 00
	80 3f		 mov	 DWORD PTR $T4[rbp-252], 1065353216 ; 3f800000H
  00194	c7 45 b0 00 00
	80 3f		 mov	 DWORD PTR $T4[rbp-248], 1065353216 ; 3f800000H
  0019b	c7 45 b4 00 00
	80 3f		 mov	 DWORD PTR $T4[rbp-244], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  001a2	48 8b 45 a8	 mov	 rax, QWORD PTR $T4[rbp-256]
  001a6	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  001ad	48 8b 45 b0	 mov	 rax, QWORD PTR $T4[rbp-248]
  001b1	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  001b8	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  001bf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  001c7	f3 0f 11 44 24
	78		 movss	 DWORD PTR $T1[rsp], xmm0
  001cd	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f600000
  001d5	f3 0f 11 4c 24
	7c		 movss	 DWORD PTR $T1[rsp+4], xmm1
  001db	c7 45 80 00 00
	80 3f		 mov	 DWORD PTR $T1[rbp-248], 1065353216 ; 3f800000H
  001e2	c7 45 84 00 00
	80 3f		 mov	 DWORD PTR $T1[rbp-244], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  001e9	48 8b 44 24 78	 mov	 rax, QWORD PTR $T1[rsp]
  001ee	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  001f5	48 8b 45 80	 mov	 rax, QWORD PTR $T1[rbp-248]
  001f9	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  00200	44 88 35 10 00
	00 00		 mov	 BYTE PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, r14b

; 304  : 			val = value;

  00207	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@43200000
  0020f	c7 05 00 00 00
	00 00 00 20 43	 mov	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, 1126170624 ; 43200000H

; 305  : 			changed = true;

  00219	44 88 35 04 00
	00 00		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, r14b
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 617  : 	MMS.clear();

  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  00227	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear

; 618  : 	PMS.clear();

  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  00233	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 66   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::perspective(state->FOV, (float)GLWindow::instance->width / (float)GLWindow::instance->height, 0.1f, 16.0f * renderDistance));

  00238	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  0023f	66 0f 6e 50 54	 movd	 xmm2, DWORD PTR [rax+84]
  00244	0f 5b d2	 cvtdq2ps xmm2, xmm2
  00247	66 0f 6e 40 58	 movd	 xmm0, DWORD PTR [rax+88]
  0024c	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0024f	f3 0f 5e d0	 divss	 xmm2, xmm0
  00253	66 41 0f 6e 4d
	20		 movd	 xmm1, DWORD PTR [r13+32]
  00259	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0025c	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  00262	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@3dcccccd
  0026a	48 8d 8d b0 04
	00 00		 lea	 rcx, QWORD PTR $T38[rbp-256]
  00271	e8 00 00 00 00	 call	 ?perspective@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::perspective
  00276	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00279	0f 29 85 b0 00
	00 00		 movaps	 XMMWORD PTR $T21[rbp-256], xmm0
  00280	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00284	0f 29 8d c0 00
	00 00		 movaps	 XMMWORD PTR $T21[rbp-240], xmm1
  0028b	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  0028f	0f 29 85 d0 00
	00 00		 movaps	 XMMWORD PTR $T21[rbp-224], xmm0
  00296	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  0029a	0f 29 8d e0 00
	00 00		 movaps	 XMMWORD PTR $T21[rbp-208], xmm1
  002a1	48 8d 95 b0 00
	00 00		 lea	 rdx, QWORD PTR $T21[rbp-256]
  002a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  002af	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult
  002b4	0f 57 f6	 xorps	 xmm6, xmm6

; 67   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.x, 1.0f, 0.0f, 0.0f));

  002b7	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  002bd	0f 28 de	 movaps	 xmm3, xmm6
  002c0	0f 28 d7	 movaps	 xmm2, xmm7
  002c3	f3 41 0f 10 4d
	10		 movss	 xmm1, DWORD PTR [r13+16]
  002c9	48 8d 8d f0 04
	00 00		 lea	 rcx, QWORD PTR $T39[rbp-256]
  002d0	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  002d5	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  002d8	0f 29 85 70 02
	00 00		 movaps	 XMMWORD PTR $T28[rbp-256], xmm0
  002df	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  002e3	0f 29 8d 80 02
	00 00		 movaps	 XMMWORD PTR $T28[rbp-240], xmm1
  002ea	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  002ee	0f 29 85 90 02
	00 00		 movaps	 XMMWORD PTR $T28[rbp-224], xmm0
  002f5	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  002f9	0f 29 8d a0 02
	00 00		 movaps	 XMMWORD PTR $T28[rbp-208], xmm1
  00300	48 8d 95 70 02
	00 00		 lea	 rdx, QWORD PTR $T28[rbp-256]
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  0030e	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 68   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.y, 0.0f, 1.0f, 0.0f));

  00313	f3 0f 11 74 24
	20		 movss	 DWORD PTR [rsp+32], xmm6
  00319	0f 28 df	 movaps	 xmm3, xmm7
  0031c	0f 28 d6	 movaps	 xmm2, xmm6
  0031f	f3 41 0f 10 4d
	14		 movss	 xmm1, DWORD PTR [r13+20]
  00325	48 8d 8d 70 05
	00 00		 lea	 rcx, QWORD PTR $T41[rbp-256]
  0032c	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  00331	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00334	0f 29 85 f0 01
	00 00		 movaps	 XMMWORD PTR $T26[rbp-256], xmm0
  0033b	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0033f	0f 29 8d 00 02
	00 00		 movaps	 XMMWORD PTR $T26[rbp-240], xmm1
  00346	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  0034a	0f 29 85 10 02
	00 00		 movaps	 XMMWORD PTR $T26[rbp-224], xmm0
  00351	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  00355	0f 29 8d 20 02
	00 00		 movaps	 XMMWORD PTR $T26[rbp-208], xmm1
  0035c	48 8d 95 f0 01
	00 00		 lea	 rdx, QWORD PTR $T26[rbp-256]
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  0036a	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 69   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::rotate(state->cam.rot.z, 0.0f, 0.0f, 1.0f));

  0036f	f3 0f 11 7c 24
	20		 movss	 DWORD PTR [rsp+32], xmm7
  00375	0f 28 de	 movaps	 xmm3, xmm6
  00378	0f 28 d6	 movaps	 xmm2, xmm6
  0037b	f3 41 0f 10 4d
	18		 movss	 xmm1, DWORD PTR [r13+24]
  00381	48 8d 8d 30 05
	00 00		 lea	 rcx, QWORD PTR $T40[rbp-256]
  00388	e8 00 00 00 00	 call	 ?rotate@Matrix@geom@@SA?AV12@MMMM@Z ; geom::Matrix::rotate
  0038d	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00390	0f 29 85 f0 00
	00 00		 movaps	 XMMWORD PTR $T22[rbp-256], xmm0
  00397	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0039b	0f 29 8d 00 01
	00 00		 movaps	 XMMWORD PTR $T22[rbp-240], xmm1
  003a2	0f 10 40 20	 movups	 xmm0, XMMWORD PTR [rax+32]
  003a6	0f 29 85 10 01
	00 00		 movaps	 XMMWORD PTR $T22[rbp-224], xmm0
  003ad	0f 10 48 30	 movups	 xmm1, XMMWORD PTR [rax+48]
  003b1	0f 29 8d 20 01
	00 00		 movaps	 XMMWORD PTR $T22[rbp-208], xmm1
  003b8	48 8d 95 f0 00
	00 00		 lea	 rdx, QWORD PTR $T22[rbp-256]
  003bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  003c6	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 70   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::translate(-state->cam.pos.x, -state->cam.pos.y, -state->cam.pos.z));

  003cb	f3 41 0f 10 5d
	08		 movss	 xmm3, DWORD PTR [r13+8]
  003d1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003d9	0f 57 d8	 xorps	 xmm3, xmm0
  003dc	f3 41 0f 10 55
	04		 movss	 xmm2, DWORD PTR [r13+4]
  003e2	0f 57 d0	 xorps	 xmm2, xmm0
  003e5	f3 41 0f 10 4d
	00		 movss	 xmm1, DWORD PTR [r13]
  003eb	0f 57 c8	 xorps	 xmm1, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  003ee	4c 89 a5 f0 03
	00 00		 mov	 QWORD PTR $T36[rbp-256], r12
  003f5	4c 89 a5 f8 03
	00 00		 mov	 QWORD PTR $T36[rbp-248], r12
  003fc	4c 89 a5 00 04
	00 00		 mov	 QWORD PTR $T36[rbp-240], r12
  00403	4c 89 a5 08 04
	00 00		 mov	 QWORD PTR $T36[rbp-232], r12
  0040a	4c 89 a5 10 04
	00 00		 mov	 QWORD PTR $T36[rbp-224], r12
  00411	4c 89 a5 18 04
	00 00		 mov	 QWORD PTR $T36[rbp-216], r12
  00418	4c 89 a5 20 04
	00 00		 mov	 QWORD PTR $T36[rbp-208], r12
  0041f	4c 89 a5 28 04
	00 00		 mov	 QWORD PTR $T36[rbp-200], r12

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  00426	c7 85 f0 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T36[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  00430	c7 85 04 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T36[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  0043a	c7 85 18 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T36[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  00444	c7 85 2c 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T36[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  0044e	f3 0f 11 8d fc
	03 00 00	 movss	 DWORD PTR $T36[rbp-244], xmm1

; 246  : 	result[7] = y;

  00456	f3 0f 11 95 0c
	04 00 00	 movss	 DWORD PTR $T36[rbp-228], xmm2

; 247  : 	result[11] = z;

  0045e	f3 0f 11 9d 1c
	04 00 00	 movss	 DWORD PTR $T36[rbp-212], xmm3
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 70   : 	gfxu::Uniforms::PMS.mult(geom::Matrix::translate(-state->cam.pos.x, -state->cam.pos.y, -state->cam.pos.z));

  00466	0f 28 85 f0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T36[rbp-256]
  0046d	0f 29 85 b0 01
	00 00		 movaps	 XMMWORD PTR $T25[rbp-256], xmm0
  00474	0f 28 8d 00 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T36[rbp-240]
  0047b	0f 29 8d c0 01
	00 00		 movaps	 XMMWORD PTR $T25[rbp-240], xmm1
  00482	0f 28 85 10 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T36[rbp-224]
  00489	0f 29 85 d0 01
	00 00		 movaps	 XMMWORD PTR $T25[rbp-224], xmm0
  00490	0f 28 8d 20 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T36[rbp-208]
  00497	0f 29 8d e0 01
	00 00		 movaps	 XMMWORD PTR $T25[rbp-208], xmm1
  0049e	48 8d 95 b0 01
	00 00		 lea	 rdx, QWORD PTR $T25[rbp-256]
  004a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  004ac	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult

; 71   : 
; 72   : 	float cScale = 1.0f + 90.0f / state->FOV;
; 73   : 	int xCam = floorf(state->cam.pos.x / 16.0f);

  004b1	f3 41 0f 10 45
	00		 movss	 xmm0, DWORD PTR [r13]
  004b7	f3 0f 10 35 00
	00 00 00	 movss	 xmm6, DWORD PTR __real@3d800000
  004bf	f3 0f 59 c6	 mulss	 xmm0, xmm6
  004c3	e8 00 00 00 00	 call	 floorf
  004c8	f3 0f 2c c0	 cvttss2si eax, xmm0
  004cc	89 44 24 70	 mov	 DWORD PTR xCam$[rsp], eax

; 74   : 	int yCam = floorf(state->cam.pos.y / 16.0f);

  004d0	f3 41 0f 10 45
	04		 movss	 xmm0, DWORD PTR [r13+4]
  004d6	f3 0f 59 c6	 mulss	 xmm0, xmm6
  004da	e8 00 00 00 00	 call	 floorf
  004df	f3 0f 2c c0	 cvttss2si eax, xmm0
  004e3	89 44 24 6c	 mov	 DWORD PTR yCam$[rsp], eax

; 75   : 	int zCam = floorf(state->cam.pos.z / 16.0f);

  004e7	f3 41 0f 10 45
	08		 movss	 xmm0, DWORD PTR [r13+8]
  004ed	f3 0f 59 c6	 mulss	 xmm0, xmm6
  004f1	e8 00 00 00 00	 call	 floorf
  004f6	f3 0f 2c c0	 cvttss2si eax, xmm0
  004fa	89 44 24 68	 mov	 DWORD PTR zCam$[rsp], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 562  : 	return topmost;

  004fe	0f 10 05 28 00
	00 00		 movups	 xmm0, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+40
  00505	0f 29 85 70 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-256], xmm0
  0050c	0f 10 0d 38 00
	00 00		 movups	 xmm1, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+56
  00513	0f 29 8d 80 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-240], xmm1
  0051a	0f 10 05 48 00
	00 00		 movups	 xmm0, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+72
  00521	0f 29 85 90 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-224], xmm0
  00528	0f 10 0d 58 00
	00 00		 movups	 xmm1, XMMWORD PTR ?PMS@Uniforms@gfxu@@2VMatrixStack@2@A+88
  0052f	0f 29 8d a0 04
	00 00		 movaps	 XMMWORD PTR projectionMatrix$[rbp-208], xmm1
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 294  : 	if(!okay) return false;

  00536	44 38 25 00 00
	00 00		 cmp	 BYTE PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A, r12b
  0053d	74 6e		 je	 SHORT $LN123@tick

; 295  : 
; 296  : 	cl_event event;
; 297  : 
; 298  : 	cl_int error = clEnqueueWriteBuffer(queue.queue, mem, CL_TRUE, offset, cb, data, 0, NULL, &event);

  0053f	48 8d 45 20	 lea	 rax, QWORD PTR event$12[rbp-256]
  00543	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00548	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  0054d	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  00552	48 8d 85 70 04
	00 00		 lea	 rax, QWORD PTR projectionMatrix$[rbp-256]
  00559	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0055e	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+16
  00565	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056a	45 33 c9	 xor	 r9d, r9d
  0056d	45 8b c6	 mov	 r8d, r14d
  00570	48 8b 15 08 00
	00 00		 mov	 rdx, QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+8
  00577	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  0057e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueWriteBuffer

; 299  : 	if(error != CL_SUCCESS)

  00584	85 c0		 test	 eax, eax
  00586	74 15		 je	 SHORT $LN121@tick

; 300  : 	{
; 301  : 		GLWindow::instance->postError("Failed to write to buffer", "OpenCL buffer write error");

  00588	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952787
  0058f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952786
  00596	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 302  : 		return false;

  0059b	eb 10		 jmp	 SHORT $LN123@tick
$LN121@tick:

; 303  : 	}
; 304  : 
; 305  : 	queue.addSyncEvent(event);

  0059d	48 8b 55 20	 mov	 rdx, QWORD PTR event$12[rbp-256]
  005a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?commandQueue@@3VCommandQueue@cl@@A ; commandQueue
  005a8	e8 00 00 00 00	 call	 ?addSyncEvent@CommandQueue@cl@@QEAAXPEAU_cl_event@@@Z ; cl::CommandQueue::addSyncEvent
$LN123@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 80   : 	const size_t global_ws_1[] = {renderDistance * 2 + 2, renderDistance * 2 + 2, renderDistance * 2 + 2};

  005ad	48 c7 85 b0 05
	00 00 16 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-256], 22
  005b8	48 c7 85 b8 05
	00 00 16 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-248], 22
  005c3	48 c7 85 c0 05
	00 00 16 00 00
	00		 mov	 QWORD PTR global_ws_1$[rbp-240], 22

; 81   : 	const size_t local_ws_1[] = {1, 1, 1};

  005ce	4c 89 b5 c8 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-256], r14
  005d5	4c 89 b5 d0 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-248], r14
  005dc	4c 89 b5 d8 05
	00 00		 mov	 QWORD PTR local_ws_1$[rbp-240], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  005e3	48 c7 45 68 0f
	00 00 00	 mov	 QWORD PTR $T15[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  005eb	4c 89 65 60	 mov	 QWORD PTR $T15[rbp-240], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  005ef	44 88 65 50	 mov	 BYTE PTR $T15[rbp-256], r12b
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  005f3	41 b8 0d 00 00
	00		 mov	 r8d, 13
  005f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294945226
  00600	48 8d 4d 50	 lea	 rcx, QWORD PTR $T15[rbp-256]
  00604	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 83   : 	if(!program.prepare("gridTransform")) return false;

  00609	48 8d 55 50	 lea	 rdx, QWORD PTR $T15[rbp-256]
  0060d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00614	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  00619	84 c0		 test	 al, al
  0061b	0f 84 0f 10 00
	00		 je	 $LN1151@tick
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  00621	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  00628	48 85 c9	 test	 rcx, rcx
  0062b	75 13		 jne	 SHORT $LN170@tick
$LN1172@tick:

; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");

  0062d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952799
  00634	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952798

; 217  : 		return false;

  0063b	e9 eb 0f 00 00	 jmp	 $LN1158@tick
$LN170@tick:

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00640	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  00646	8b d0		 mov	 edx, eax
  00648	ff c0		 inc	 eax
  0064a	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  00650	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:renderDistance
  00657	41 b8 04 00 00
	00		 mov	 r8d, 4
  0065d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  00663	85 c0		 test	 eax, eax
  00665	74 13		 je	 SHORT $LN33@tick
$LN1170@tick:

; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  00667	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952797
  0066e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952796
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 84   : 	if(!program.setArgument(sizeof(const unsigned int), &renderDistance)) return false;

  00675	e9 b1 0f 00 00	 jmp	 $LN1158@tick
$LN33@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  0067a	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  00681	48 85 c9	 test	 rcx, rcx
  00684	74 a7		 je	 SHORT $LN1172@tick

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00686	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  0068c	8b d0		 mov	 edx, eax
  0068e	ff c0		 inc	 eax
  00690	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  00696	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?projectionMatrixBuffer@@3VBuffer@cl@@A+8
  0069d	41 b8 08 00 00
	00		 mov	 r8d, 8
  006a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  006a9	85 c0		 test	 eax, eax
  006ab	75 ba		 jne	 SHORT $LN1170@tick

; 214  : 	if(!preparedKernel)

  006ad	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  006b4	48 85 c9	 test	 rcx, rcx
  006b7	0f 84 70 ff ff
	ff		 je	 $LN1172@tick

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  006bd	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  006c3	8b d0		 mov	 edx, eax
  006c5	ff c0		 inc	 eax
  006c7	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  006cd	4c 8d 4c 24 70	 lea	 r9, QWORD PTR xCam$[rsp]
  006d2	41 b8 04 00 00
	00		 mov	 r8d, 4
  006d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  006de	85 c0		 test	 eax, eax
  006e0	75 85		 jne	 SHORT $LN1170@tick

; 214  : 	if(!preparedKernel)

  006e2	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  006e9	48 85 c9	 test	 rcx, rcx
  006ec	0f 84 3b ff ff
	ff		 je	 $LN1172@tick

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  006f2	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  006f8	8b d0		 mov	 edx, eax
  006fa	ff c0		 inc	 eax
  006fc	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  00702	4c 8d 4c 24 6c	 lea	 r9, QWORD PTR yCam$[rsp]
  00707	41 b8 04 00 00
	00		 mov	 r8d, 4
  0070d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  00713	85 c0		 test	 eax, eax
  00715	0f 85 4c ff ff
	ff		 jne	 $LN1170@tick

; 214  : 	if(!preparedKernel)

  0071b	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  00722	48 85 c9	 test	 rcx, rcx
  00725	0f 84 02 ff ff
	ff		 je	 $LN1172@tick

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  0072b	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  00731	8b d0		 mov	 edx, eax
  00733	ff c0		 inc	 eax
  00735	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  0073b	4c 8d 4c 24 68	 lea	 r9, QWORD PTR zCam$[rsp]
  00740	41 b8 04 00 00
	00		 mov	 r8d, 4
  00746	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  0074c	85 c0		 test	 eax, eax
  0074e	0f 85 13 ff ff
	ff		 jne	 $LN1170@tick

; 214  : 	if(!preparedKernel)

  00754	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  0075b	48 85 c9	 test	 rcx, rcx
  0075e	0f 84 c9 fe ff
	ff		 je	 $LN1172@tick

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  00764	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  0076a	8b d0		 mov	 edx, eax
  0076c	ff c0		 inc	 eax
  0076e	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  00774	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?boolBuffer@@3VBuffer@cl@@A+8
  0077b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00781	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  00787	85 c0		 test	 eax, eax
  00789	0f 85 d8 fe ff
	ff		 jne	 $LN1170@tick

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)

  0078f	48 8b 15 28 00
	00 00		 mov	 rdx, QWORD PTR ?program@@3VProgram@cl@@A+40
  00796	48 85 d2	 test	 rdx, rdx
  00799	75 13		 jne	 SHORT $LN198@tick
$LN1173@tick:

; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");

  0079b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952795
  007a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952794

; 238  : 		return false;

  007a9	e9 7d 0e 00 00	 jmp	 $LN1158@tick
$LN198@tick:

; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);

  007ae	48 8d 45 18	 lea	 rax, QWORD PTR event$11[rbp-256]
  007b2	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  007b7	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  007bc	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  007c1	48 8d 85 c8 05
	00 00		 lea	 rax, QWORD PTR local_ws_1$[rbp-256]
  007c8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007cd	48 8d 85 b0 05
	00 00		 lea	 rax, QWORD PTR global_ws_1$[rbp-256]
  007d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d9	45 33 c9	 xor	 r9d, r9d
  007dc	45 8d 41 03	 lea	 r8d, QWORD PTR [r9+3]
  007e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  007e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueNDRangeKernel

; 245  : 	if(error != CL_SUCCESS)

  007ed	85 c0		 test	 eax, eax
  007ef	74 13		 je	 SHORT $LN197@tick
$LN1171@tick:

; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");

  007f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952793
  007f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952792
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 90   : 	if(!program.invoke(commandQueue, 3, global_ws_1, local_ws_1)) return false;

  007ff	e9 27 0e 00 00	 jmp	 $LN1158@tick
$LN197@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 251  : 	queue.addSyncEvent(event);

  00804	48 8b 55 18	 mov	 rdx, QWORD PTR event$11[rbp-256]
  00808	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?commandQueue@@3VCommandQueue@cl@@A ; commandQueue
  0080f	e8 00 00 00 00	 call	 ?addSyncEvent@CommandQueue@cl@@QEAAXPEAU_cl_event@@@Z ; cl::CommandQueue::addSyncEvent

; 252  : 
; 253  : 	preparedKernel = 0;

  00814	4c 89 25 28 00
	00 00		 mov	 QWORD PTR ?program@@3VProgram@cl@@A+40, r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0081b	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A+24
  00822	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00827	85 c0		 test	 eax, eax
  00829	74 07		 je	 SHORT $LN27@tick

; 33   : 		_Throw_C_error(_Res);

  0082b	8b c8		 mov	 ecx, eax
  0082d	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN27@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 92   : 	const size_t global_ws_2[] = {renderDistance * 2 + 1, renderDistance * 2 + 1, renderDistance * 2 + 1};

  00832	48 c7 85 e0 05
	00 00 15 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-256], 21
  0083d	48 c7 85 e8 05
	00 00 15 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-248], 21
  00848	48 c7 85 f0 05
	00 00 15 00 00
	00		 mov	 QWORD PTR global_ws_2$[rbp-240], 21

; 93   : 	const size_t local_ws_2[] = {1, 1, 1};

  00853	4c 89 b5 f8 05
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-256], r14
  0085a	4c 89 b5 00 06
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-248], r14
  00861	4c 89 b5 08 06
	00 00		 mov	 QWORD PTR local_ws_2$[rbp-240], r14
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00868	48 c7 45 48 0f
	00 00 00	 mov	 QWORD PTR $T14[rbp-232], 15

; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00870	4c 89 65 40	 mov	 QWORD PTR $T14[rbp-240], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 564  : 		_Left = _Right;

  00874	44 88 65 30	 mov	 BYTE PTR $T14[rbp-256], r12b
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

  00878	41 b8 10 00 00
	00		 mov	 r8d, 16
  0087e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294945225
  00885	48 8d 4d 30	 lea	 rcx, QWORD PTR $T14[rbp-256]
  00889	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 95   : 	if(!program.prepare("arrayInsideCheck")) return false;

  0088e	48 8d 55 30	 lea	 rdx, QWORD PTR $T14[rbp-256]
  00892	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  00899	e8 00 00 00 00	 call	 ?prepare@Program@cl@@QEAA_NV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; cl::Program::prepare
  0089e	84 c0		 test	 al, al
  008a0	0f 84 8a 0d 00
	00		 je	 $LN1151@tick
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 214  : 	if(!preparedKernel)

  008a6	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  008ad	48 85 c9	 test	 rcx, rcx
  008b0	0f 84 77 fd ff
	ff		 je	 $LN1172@tick

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  008b6	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  008bc	8b d0		 mov	 edx, eax
  008be	ff c0		 inc	 eax
  008c0	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  008c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:renderDistance
  008cd	41 b8 04 00 00
	00		 mov	 r8d, 4
  008d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  008d9	85 c0		 test	 eax, eax
  008db	0f 85 86 fd ff
	ff		 jne	 $LN1170@tick

; 214  : 	if(!preparedKernel)

  008e1	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  008e8	48 85 c9	 test	 rcx, rcx
  008eb	0f 84 3c fd ff
	ff		 je	 $LN1172@tick

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  008f1	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  008f7	8b d0		 mov	 edx, eax
  008f9	ff c0		 inc	 eax
  008fb	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  00901	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?gridBuffer@@3VBuffer@cl@@A+8
  00908	41 b8 08 00 00
	00		 mov	 r8d, 8
  0090e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  00914	85 c0		 test	 eax, eax
  00916	0f 85 4b fd ff
	ff		 jne	 $LN1170@tick

; 214  : 	if(!preparedKernel)

  0091c	48 8b 0d 28 00
	00 00		 mov	 rcx, QWORD PTR ?program@@3VProgram@cl@@A+40
  00923	48 85 c9	 test	 rcx, rcx
  00926	0f 84 01 fd ff
	ff		 je	 $LN1172@tick

; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);

  0092c	8b 05 20 00 00
	00		 mov	 eax, DWORD PTR ?program@@3VProgram@cl@@A+32
  00932	8b d0		 mov	 edx, eax
  00934	ff c0		 inc	 eax
  00936	89 05 20 00 00
	00		 mov	 DWORD PTR ?program@@3VProgram@cl@@A+32, eax
  0093c	4c 8d 0d 08 00
	00 00		 lea	 r9, OFFSET FLAT:?boolBuffer@@3VBuffer@cl@@A+8
  00943	41 b8 08 00 00
	00		 mov	 r8d, 8
  00949	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clSetKernelArg

; 220  : 	if(error != CL_SUCCESS)

  0094f	85 c0		 test	 eax, eax
  00951	0f 85 10 fd ff
	ff		 jne	 $LN1170@tick

; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)

  00957	48 8b 15 28 00
	00 00		 mov	 rdx, QWORD PTR ?program@@3VProgram@cl@@A+40
  0095e	48 85 d2	 test	 rdx, rdx
  00961	0f 84 34 fe ff
	ff		 je	 $LN1173@tick

; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);

  00967	48 8d 45 28	 lea	 rax, QWORD PTR event$13[rbp-256]
  0096b	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00970	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  00975	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  0097a	48 8d 85 f8 05
	00 00		 lea	 rax, QWORD PTR local_ws_2$[rbp-256]
  00981	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00986	48 8d 85 e0 05
	00 00		 lea	 rax, QWORD PTR global_ws_2$[rbp-256]
  0098d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00992	45 33 c9	 xor	 r9d, r9d
  00995	45 8d 41 03	 lea	 r8d, QWORD PTR [r9+3]
  00999	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  009a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueNDRangeKernel

; 245  : 	if(error != CL_SUCCESS)

  009a6	85 c0		 test	 eax, eax
  009a8	0f 85 43 fe ff
	ff		 jne	 $LN1171@tick

; 251  : 	queue.addSyncEvent(event);

  009ae	48 8b 55 28	 mov	 rdx, QWORD PTR event$13[rbp-256]
  009b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?commandQueue@@3VCommandQueue@cl@@A ; commandQueue
  009b9	e8 00 00 00 00	 call	 ?addSyncEvent@CommandQueue@cl@@QEAAXPEAU_cl_event@@@Z ; cl::CommandQueue::addSyncEvent

; 252  : 
; 253  : 	preparedKernel = 0;

  009be	4c 89 25 28 00
	00 00		 mov	 QWORD PTR ?program@@3VProgram@cl@@A+40, r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  009c5	48 8d 0d 18 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A+24
  009cc	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  009d1	85 c0		 test	 eax, eax
  009d3	74 07		 je	 SHORT $LN22@tick

; 33   : 		_Throw_C_error(_Res);

  009d5	8b c8		 mov	 ecx, eax
  009d7	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN22@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 317  : 	if(!okay) return false;

  009dc	44 38 25 00 00
	00 00		 cmp	 BYTE PTR ?gridBuffer@@3VBuffer@cl@@A, r12b
  009e3	0f 84 47 0c 00
	00		 je	 $LN1151@tick

; 318  : 
; 319  : 	cl_event event;
; 320  : 
; 321  : 	cl_int error = clEnqueueReadBuffer(queue.queue, mem, CL_TRUE, offset, cb, data, 0, NULL, &event);

  009e9	48 8d 45 00	 lea	 rax, QWORD PTR event$9[rbp-256]
  009ed	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  009f2	4c 89 64 24 38	 mov	 QWORD PTR [rsp+56], r12
  009f7	44 89 64 24 30	 mov	 DWORD PTR [rsp+48], r12d
  009fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?bGrid@@3PAY1BF@BF@_NA ; bGrid
  00a03	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a08	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+16
  00a0f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a14	45 33 c9	 xor	 r9d, r9d
  00a17	45 8b c6	 mov	 r8d, r14d
  00a1a	48 8b 15 08 00
	00 00		 mov	 rdx, QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+8
  00a21	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A
  00a28	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clEnqueueReadBuffer

; 322  : 	if(error)

  00a2e	85 c0		 test	 eax, eax
  00a30	74 13		 je	 SHORT $LN281@tick

; 323  : 	{
; 324  : 		GLWindow::instance->postError("Failed to read buffer", "OpenCL buffer read error");

  00a32	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952785
  00a39	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952784

; 325  : 		return false;

  00a40	e9 e6 0b 00 00	 jmp	 $LN1158@tick
$LN281@tick:

; 326  : 	}
; 327  : 
; 328  : 	queue.addSyncEvent(event);

  00a45	48 8b 55 00	 mov	 rdx, QWORD PTR event$9[rbp-256]
  00a49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?commandQueue@@3VCommandQueue@cl@@A ; commandQueue
  00a50	e8 00 00 00 00	 call	 ?addSyncEvent@CommandQueue@cl@@QEAAXPEAU_cl_event@@@Z ; cl::CommandQueue::addSyncEvent
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 879  : 	int error = glGetError();

  00a55	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 880  : 	if(error != GL_NO_ERROR)

  00a5b	85 c0		 test	 eax, eax
  00a5d	74 17		 je	 SHORT $LN286@tick

; 881  : 	{
; 882  : 		const char* errorString = (const char*)gluErrorString(error);

  00a5f	8b c8		 mov	 ecx, eax
  00a61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 883  : 		GLWindow::instance->postError(errorString, caption);

  00a67	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294945224
  00a6e	48 8b d0	 mov	 rdx, rax
  00a71	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN286@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00a76	48 8d 0d 40 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+64
  00a7d	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00a82	85 c0		 test	 eax, eax
  00a84	74 07		 je	 SHORT $LN293@tick

; 33   : 		_Throw_C_error(_Res);

  00a86	8b c8		 mov	 ecx, eax
  00a88	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN293@tick:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00a8d	48 8d 0d 88 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+136
  00a94	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00a99	85 c0		 test	 eax, eax
  00a9b	74 07		 je	 SHORT $LN1103@tick

; 33   : 		_Throw_C_error(_Res);

  00a9d	8b c8		 mov	 ecx, eax
  00a9f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN1103@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00aa4	4c 39 25 b0 00
	00 00		 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+176, r12
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 121  : 	while(!GlobalThread::world.additionQueue.empty())

  00aab	0f 84 be 00 00
	00		 je	 $LN19@tick
$LL20@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  00ab1	48 8d 95 00 03
	00 00		 lea	 rdx, QWORD PTR $T31[rbp-256]
  00ab8	48 8d 0d 90 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+144
  00abf	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  00ac4	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00ac7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00aca	48 85 c0	 test	 rax, rax
  00acd	75 05		 jne	 SHORT $LN317@tick
  00acf	49 8b c4	 mov	 rax, r12
  00ad2	eb 03		 jmp	 SHORT $LN318@tick
$LN317@tick:
  00ad4	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN318@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00ad7	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00adb	48 ff c9	 dec	 rcx
  00ade	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  00ae2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00ae6	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00aea	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00aee	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00af1	48 85 db	 test	 rbx, rbx
  00af4	74 04		 je	 SHORT $LN338@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00af6	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN338@tick:

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00afa	48 89 5d 78	 mov	 QWORD PTR c$16[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  00afe	48 89 7d 70	 mov	 QWORD PTR c$16[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 160  : 		c.pop_front();

  00b02	48 8d 0d 90 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+144
  00b09	e8 00 00 00 00	 call	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00b0e	4c 89 65 08	 mov	 QWORD PTR $T10[rbp-256], r12
  00b12	4c 89 65 10	 mov	 QWORD PTR $T10[rbp-248], r12

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00b16	48 85 db	 test	 rbx, rbx
  00b19	74 04		 je	 SHORT $LN352@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00b1b	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN352@tick:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00b1f	4c 8b c3	 mov	 r8, rbx
  00b22	48 8b d7	 mov	 rdx, rdi
  00b25	48 8d 4d 08	 lea	 rcx, QWORD PTR $T10[rbp-256]
  00b29	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 125  : 		GlobalThread::world.addChunk(c);

  00b2e	48 8d 55 08	 lea	 rdx, QWORD PTR $T10[rbp-256]
  00b32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A ; GlobalThread::world
  00b39	e8 00 00 00 00	 call	 ?addChunk@World@@QEAA_NV?$shared_ptr@VChunkBase@@@std@@@Z ; World::addChunk
  00b3e	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00b3f	48 85 db	 test	 rbx, rbx
  00b42	74 1d		 je	 SHORT $LN362@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00b44	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00b48	75 17		 jne	 SHORT $LN362@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00b4a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00b4d	48 8b cb	 mov	 rcx, rbx
  00b50	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00b52	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00b56	75 09		 jne	 SHORT $LN362@tick

; 128  : 			_Delete_this();

  00b58	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00b5b	48 8b cb	 mov	 rcx, rbx
  00b5e	ff 50 08	 call	 QWORD PTR [rax+8]
$LN362@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00b61	48 83 3d b0 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+176, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 121  : 	while(!GlobalThread::world.additionQueue.empty())

  00b69	0f 85 42 ff ff
	ff		 jne	 $LL20@tick
$LN19@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00b6f	48 8d 0d 88 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+136
  00b76	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00b7b	85 c0		 test	 eax, eax
  00b7d	74 07		 je	 SHORT $LN369@tick

; 33   : 		_Throw_C_error(_Res);

  00b7f	8b c8		 mov	 ecx, eax
  00b81	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN369@tick:

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00b86	48 8d 0d b8 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+184
  00b8d	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00b92	85 c0		 test	 eax, eax
  00b94	74 07		 je	 SHORT $LN1104@tick

; 33   : 		_Throw_C_error(_Res);

  00b96	8b c8		 mov	 ecx, eax
  00b98	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN1104@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00b9d	48 83 3d e0 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+224, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 130  : 	while(!GlobalThread::world.removalQueue.empty())

  00ba5	0f 84 e1 00 00
	00		 je	 $LN17@tick
  00bab	0f 1f 44 00 00	 npad	 5
$LL18@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1426 : 		return (*begin());

  00bb0	48 8d 95 18 03
	00 00		 lea	 rdx, QWORD PTR $T32[rbp-256]
  00bb7	48 8d 0d c0 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+192
  00bbe	e8 00 00 00 00	 call	 ?begin@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@2@XZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::begin
  00bc3	48 8b d0	 mov	 rdx, rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 178  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00bc6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bc9	48 85 c0	 test	 rax, rax
  00bcc	75 05		 jne	 SHORT $LN393@tick
  00bce	49 8b c4	 mov	 rax, r12
  00bd1	eb 03		 jmp	 SHORT $LN394@tick
$LN393@tick:
  00bd3	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN394@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 787  : 		return ((_Off / _DEQUESIZ) & (this->_Mapsize - 1));

  00bd6	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00bda	48 ff c9	 dec	 rcx
  00bdd	48 23 4a 10	 and	 rcx, QWORD PTR [rdx+16]

; 1426 : 		return (*begin());

  00be1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00be5	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00be9	48 8b 59 08	 mov	 rbx, QWORD PTR [rcx+8]
  00bed	48 8b 39	 mov	 rdi, QWORD PTR [rcx]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00bf0	48 85 db	 test	 rbx, rbx
  00bf3	74 04		 je	 SHORT $LN414@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00bf5	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN414@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\world.cpp

; 80   : 	unloaded = true;

  00bf9	c6 47 0a 01	 mov	 BYTE PTR [rdi+10], 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\queue

; 160  : 		c.pop_front();

  00bfd	48 8d 0d c0 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+192
  00c04	e8 00 00 00 00	 call	 ?pop_front@?$deque@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXXZ ; std::deque<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::pop_front
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 135  : 		GlobalThread::world.removeChunk(c->pos);

  00c09	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00c0c	89 45 e0	 mov	 DWORD PTR $T7[rbp-256], eax
  00c0f	8b 47 1c	 mov	 eax, DWORD PTR [rdi+28]
  00c12	89 45 e4	 mov	 DWORD PTR $T7[rbp-252], eax
  00c15	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  00c18	89 45 e8	 mov	 DWORD PTR $T7[rbp-248], eax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 713  : 		_Pairii _Where = equal_range(_Keyval);

  00c1b	4c 8d 45 e0	 lea	 r8, QWORD PTR $T7[rbp-256]
  00c1f	48 8d 95 f0 02
	00 00		 lea	 rdx, QWORD PTR $T30[rbp-256]
  00c26	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  00c2d	e8 00 00 00 00	 call	 ?equal_range@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AU?$pair@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@V12@@2@AEBVChunkPosition@@@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::equal_range
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 182  : 		{	// construct from moved compatible pair

  00c32	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00c35	4c 8b 48 08	 mov	 r9, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 831  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

  00c39	49 8b c0	 mov	 rax, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00c3c	4d 3b c1	 cmp	 r8, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00c3f	74 08		 je	 SHORT $LN443@tick
$LL450@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00c41	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00c44	49 3b c1	 cmp	 rax, r9
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility

; 798  : 	for (; _First != _Last; ++_First)

  00c47	75 f8		 jne	 SHORT $LL450@tick
$LN443@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 716  : 		erase(_Where.first, _Where.second);

  00c49	48 8d 95 80 00
	00 00		 lea	 rdx, QWORD PTR $T17[rbp-256]
  00c50	48 8d 0d 48 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+72
  00c57	e8 00 00 00 00	 call	 ?erase@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@0@Z ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00c5c	48 85 db	 test	 rbx, rbx
  00c5f	74 1d		 je	 SHORT $LN466@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00c61	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  00c65	75 17		 jne	 SHORT $LN466@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00c67	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00c6a	48 8b cb	 mov	 rcx, rbx
  00c6d	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00c6f	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  00c73	75 09		 jne	 SHORT $LN466@tick

; 128  : 			_Delete_this();

  00c75	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00c78	48 8b cb	 mov	 rcx, rbx
  00c7b	ff 50 08	 call	 QWORD PTR [rax+8]
$LN466@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\deque

; 1382 : 		return (this->_Mysize == 0);

  00c7e	48 83 3d e0 00
	00 00 00	 cmp	 QWORD PTR ?world@GlobalThread@@3VWorld@@A+224, 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 130  : 	while(!GlobalThread::world.removalQueue.empty())

  00c86	0f 85 24 ff ff
	ff		 jne	 $LL18@tick
$LN17@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00c8c	48 8d 0d b8 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+184
  00c93	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00c98	85 c0		 test	 eax, eax
  00c9a	74 07		 je	 SHORT $LN473@tick

; 33   : 		_Throw_C_error(_Res);

  00c9c	8b c8		 mov	 ecx, eax
  00c9e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN473@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  00ca3	49 8b f4	 mov	 rsi, r12
  00ca6	4c 89 64 24 50	 mov	 QWORD PTR chunksToRender$[rsp], r12

; 487  : 		_Mylast = pointer();

  00cab	49 8b fc	 mov	 rdi, r12
  00cae	4c 89 64 24 58	 mov	 QWORD PTR chunksToRender$[rsp+8], r12

; 488  : 		_Myend = pointer();

  00cb3	4c 89 64 24 60	 mov	 QWORD PTR chunksToRender$[rsp+16], r12
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00cb8	48 8b 05 48 00
	00 00		 mov	 rax, QWORD PTR ?world@GlobalThread@@3VWorld@@A+72
  00cbf	48 8b 18	 mov	 rbx, QWORD PTR [rax]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00cc2	48 3b d8	 cmp	 rbx, rax
$LN1169@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 140  : 	for(auto iter = GlobalThread::world.chunkMap.begin(); iter != GlobalThread::world.chunkMap.end(); ++iter)

  00cc5	0f 84 a1 02 00
	00		 je	 $LN1156@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00ccb	4c 8b 73 28	 mov	 r14, QWORD PTR [rbx+40]
  00ccf	4c 8b 7b 20	 mov	 r15, QWORD PTR [rbx+32]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00cd3	4d 85 f6	 test	 r14, r14
  00cd6	74 0f		 je	 SHORT $LN549@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00cd8	f0 41 ff 46 08	 lock inc DWORD PTR [r14+8]
  00cdd	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00ce2	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN549@tick:

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00ce7	4c 89 75 f8	 mov	 QWORD PTR chunk$8[rbp-248], r14

; 427  : 		_Ptr = _Other_ptr;

  00ceb	4c 89 7d f0	 mov	 QWORD PTR chunk$8[rbp-256], r15
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 143  : 		if(!chunk->isEmpty())

  00cef	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00cf2	49 8b cf	 mov	 rcx, r15
  00cf5	ff 50 18	 call	 QWORD PTR [rax+24]
  00cf8	84 c0		 test	 al, al
  00cfa	0f 85 15 02 00
	00		 jne	 $LN593@tick

; 144  : 		{
; 145  : 			if(chunk->pos.x - renderDistance <= xCam && chunk->pos.x + renderDistance >= xCam && chunk->pos.y - renderDistance <= yCam && chunk->pos.y + renderDistance >= yCam && chunk->pos.z - renderDistance <= zCam && chunk->pos.z + renderDistance > zCam)

  00d00	49 63 4f 18	 movsxd	 rcx, DWORD PTR [r15+24]
  00d04	8d 41 f6	 lea	 eax, DWORD PTR [rcx-10]
  00d07	48 63 54 24 70	 movsxd	 rdx, DWORD PTR xCam$[rsp]
  00d0c	3b c2		 cmp	 eax, edx
  00d0e	0f 8f 01 02 00
	00		 jg	 $LN593@tick
  00d14	8d 41 0a	 lea	 eax, DWORD PTR [rcx+10]
  00d17	3b c2		 cmp	 eax, edx
  00d19	0f 8c f6 01 00
	00		 jl	 $LN593@tick
  00d1f	4d 63 47 1c	 movsxd	 r8, DWORD PTR [r15+28]
  00d23	41 8d 40 f6	 lea	 eax, DWORD PTR [r8-10]
  00d27	4c 63 4c 24 6c	 movsxd	 r9, DWORD PTR yCam$[rsp]
  00d2c	41 3b c1	 cmp	 eax, r9d
  00d2f	0f 8f e0 01 00
	00		 jg	 $LN593@tick
  00d35	41 8d 40 0a	 lea	 eax, DWORD PTR [r8+10]
  00d39	41 3b c1	 cmp	 eax, r9d
  00d3c	0f 8c d3 01 00
	00		 jl	 $LN593@tick
  00d42	4d 63 57 20	 movsxd	 r10, DWORD PTR [r15+32]
  00d46	41 8d 42 f6	 lea	 eax, DWORD PTR [r10-10]
  00d4a	4c 63 5c 24 68	 movsxd	 r11, DWORD PTR zCam$[rsp]
  00d4f	41 3b c3	 cmp	 eax, r11d
  00d52	0f 8f bd 01 00
	00		 jg	 $LN593@tick
  00d58	41 8d 42 0a	 lea	 eax, DWORD PTR [r10+10]
  00d5c	41 3b c3	 cmp	 eax, r11d
  00d5f	0f 8e b0 01 00
	00		 jle	 $LN593@tick

; 146  : 			{
; 147  : 				if(bGrid[chunk->pos.x - xCam + renderDistance][chunk->pos.y - yCam + renderDistance][chunk->pos.z - zCam + renderDistance])

  00d65	48 2b ca	 sub	 rcx, rdx
  00d68	48 6b c9 15	 imul	 rcx, 21
  00d6c	49 2b c9	 sub	 rcx, r9
  00d6f	49 03 c8	 add	 rcx, r8
  00d72	48 6b c9 15	 imul	 rcx, 21
  00d76	49 2b cb	 sub	 rcx, r11
  00d79	49 03 ca	 add	 rcx, r10
  00d7c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?bGrid@@3PAY1BF@BF@_NA ; bGrid
  00d83	80 bc 01 16 12
	00 00 00	 cmp	 BYTE PTR [rcx+rax+4630], 0
  00d8b	0f 84 84 01 00
	00		 je	 $LN593@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00d91	48 8d 45 f0	 lea	 rax, QWORD PTR chunk$8[rbp-256]
  00d95	48 3b c7	 cmp	 rax, rdi
  00d98	0f 83 c7 00 00
	00		 jae	 $LN595@tick
  00d9e	48 8d 45 f0	 lea	 rax, QWORD PTR chunk$8[rbp-256]
  00da2	48 3b f0	 cmp	 rsi, rax
  00da5	0f 87 ba 00 00
	00		 ja	 $LN595@tick

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;

  00dab	4c 8d 7d f0	 lea	 r15, QWORD PTR chunk$8[rbp-256]
  00daf	4c 2b fe	 sub	 r15, rsi

; 1188 : 			if (this->_Mylast == this->_Myend)

  00db2	48 8b 54 24 60	 mov	 rdx, QWORD PTR chunksToRender$[rsp+16]
  00db7	48 3b fa	 cmp	 rdi, rdx
  00dba	75 6f		 jne	 SHORT $LN607@tick

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00dbc	48 8b c2	 mov	 rax, rdx
  00dbf	48 2b c7	 sub	 rax, rdi
  00dc2	48 c1 f8 04	 sar	 rax, 4

; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)

  00dc6	48 83 f8 01	 cmp	 rax, 1
  00dca	73 5f		 jae	 SHORT $LN607@tick

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00dcc	48 2b fe	 sub	 rdi, rsi
  00dcf	48 c1 ff 04	 sar	 rdi, 4

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  00dd3	49 b8 ff ff ff
	ff ff ff ff 0f	 mov	 r8, 1152921504606846975	; 0fffffffffffffffH
  00ddd	49 8b c0	 mov	 rax, r8
  00de0	48 2b c7	 sub	 rax, rdi
  00de3	48 83 f8 01	 cmp	 rax, 1
  00de7	0f 82 65 01 00
	00		 jb	 $LN1114@tick

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00ded	48 ff c7	 inc	 rdi

; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)
; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else
; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)
; 850  : 				_Reserve(1);
; 851  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 852  : 			this->_Getal().construct(this->_Mylast,
; 853  : 				_STD forward<value_type>(_Val));
; 854  : 			++this->_Mylast;
; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);

  00df0	48 2b d6	 sub	 rdx, rsi
  00df3	48 c1 fa 04	 sar	 rdx, 4

; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00df7	48 8b ca	 mov	 rcx, rdx
  00dfa	48 d1 e9	 shr	 rcx, 1
  00dfd	49 8b c0	 mov	 rax, r8
  00e00	48 2b c1	 sub	 rax, rcx
  00e03	48 3b c2	 cmp	 rax, rdx
  00e06	73 05		 jae	 SHORT $LN632@tick
  00e08	49 8b d4	 mov	 rdx, r12
  00e0b	eb 03		 jmp	 SHORT $LN633@tick
$LN632@tick:
  00e0d	48 03 d1	 add	 rdx, rcx
$LN633@tick:

; 1489 : 		if (_Capacity < _Count)

  00e10	48 3b d7	 cmp	 rdx, rdi
  00e13	48 0f 42 d7	 cmovb	 rdx, rdi

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00e17	48 8d 4c 24 50	 lea	 rcx, QWORD PTR chunksToRender$[rsp]
  00e1c	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
  00e21	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00e26	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN607@tick:

; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

  00e2b	49 83 e7 f0	 and	 r15, -16
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00e2f	48 85 ff	 test	 rdi, rdi
  00e32	0f 84 d4 00 00
	00		 je	 $LN732@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00e38	4c 89 27	 mov	 QWORD PTR [rdi], r12
  00e3b	4c 89 67 08	 mov	 QWORD PTR [rdi+8], r12

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00e3f	4d 8b 44 37 08	 mov	 r8, QWORD PTR [r15+rsi+8]
  00e44	49 8b 14 37	 mov	 rdx, QWORD PTR [r15+rsi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00e48	4d 85 c0	 test	 r8, r8
  00e4b	0f 84 b3 00 00
	00		 je	 $LN676@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00e51	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
  00e56	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00e5b	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1195 : 		else

  00e60	e9 9f 00 00 00	 jmp	 $LN676@tick
$LN595@tick:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

  00e65	48 8b 54 24 60	 mov	 rdx, QWORD PTR chunksToRender$[rsp+16]
  00e6a	48 3b fa	 cmp	 rdi, rdx
  00e6d	75 6f		 jne	 SHORT $LN679@tick

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00e6f	48 8b c2	 mov	 rax, rdx
  00e72	48 2b c7	 sub	 rax, rdi
  00e75	48 c1 f8 04	 sar	 rax, 4

; 1497 : 		}
; 1498 : 
; 1499 : 	void _Reallocate(size_type _Count)
; 1500 : 		{	// move to array of exactly _Count elements
; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())
; 1512 : 			{	// destroy and deallocate old array
; 1513 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1514 : 			this->_Getal().deallocate(this->_Myfirst,
; 1515 : 				this->_Myend - this->_Myfirst);
; 1516 : 			}
; 1517 : 
; 1518 : 		this->_Orphan_all();
; 1519 : 		this->_Myend = _Ptr + _Count;
; 1520 : 		this->_Mylast = _Ptr + _Size;
; 1521 : 		this->_Myfirst = _Ptr;
; 1522 : 		}
; 1523 : 
; 1524 : 	void _Reserve(size_type _Count)
; 1525 : 		{	// ensure room for _Count new elements, grow exponentially
; 1526 : 		if (_Unused_capacity() < _Count)

  00e79	48 83 f8 01	 cmp	 rax, 1
  00e7d	73 5f		 jae	 SHORT $LN679@tick

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00e7f	48 2b fe	 sub	 rdi, rsi
  00e82	48 c1 ff 04	 sar	 rdi, 4

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  00e86	49 b8 ff ff ff
	ff ff ff ff 0f	 mov	 r8, 1152921504606846975	; 0fffffffffffffffH
  00e90	49 8b c0	 mov	 rax, r8
  00e93	48 2b c7	 sub	 rax, rdi
  00e96	48 83 f8 01	 cmp	 rax, 1
  00e9a	0f 82 bf 00 00
	00		 jb	 $LN1115@tick

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00ea0	48 ff c7	 inc	 rdi

; 489  : 		}
; 490  : 
; 491  : 	pointer _Myfirst;	// pointer to beginning of array
; 492  : 	pointer _Mylast;	// pointer to current end of sequence
; 493  : 	pointer _Myend;	// pointer to end of array
; 494  : 	};
; 495  : 
; 496  : 		// TEMPLATE CLASS _Vector_alloc
; 497  : template<bool _Al_has_storage,
; 498  : 	class _Alloc_types>
; 499  : 	class _Vector_alloc
; 500  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 501  : 	{	// base class for vector to hold allocator with storage
; 502  : public:
; 503  : 	typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
; 504  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 505  : 
; 506  : 	typedef typename _Alloc_types::_Alty _Alty;
; 507  : 
; 508  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 509  : 	_Vector_alloc(const _Alloc& _Al = _Alloc())
; 510  : 		: _Alval(_Al)
; 511  : 		{	// construct allocator from _Al
; 512  : 		}
; 513  : 
; 514  : 	void _Change_alloc(const _Alty& _Al)
; 515  : 		{	// replace old allocator
; 516  : 		_Alval = _Al;
; 517  : 		}
; 518  : 
; 519  : 	void _Swap_alloc(_Myt& _Right)
; 520  : 		{	// swap allocators
; 521  : 		_Swap_adl(this->_Alval, _Right._Alval);
; 522  : 		}
; 523  : 
; 524  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 525  : 	_Vector_alloc(const _Alty& _Al = _Alty())
; 526  : 		: _Alval(_Al)
; 527  : 		{	// construct allocator from _Al
; 528  : 		_Alloc_proxy();
; 529  : 		}
; 530  : 
; 531  : 	~_Vector_alloc() _NOEXCEPT
; 532  : 		{	// destroy proxy
; 533  : 		_Free_proxy();
; 534  : 		}
; 535  : 
; 536  : 	void _Change_alloc(const _Alty& _Al)
; 537  : 		{	// replace old allocator
; 538  : 		_Free_proxy();
; 539  : 		_Alval = _Al;
; 540  : 		_Alloc_proxy();
; 541  : 		}
; 542  : 
; 543  : 	void _Swap_alloc(_Myt& _Right)
; 544  : 		{	// swap allocators
; 545  : 		_Swap_adl(_Alval, _Right._Alval);
; 546  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 547  : 		}
; 548  : 
; 549  : 	void _Alloc_proxy()
; 550  : 		{	// construct proxy from _Alval
; 551  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 552  : 			_Alproxy(_Alval);
; 553  : 		this->_Myproxy = _Alproxy.allocate(1);
; 554  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 555  : 		this->_Myproxy->_Mycont = this;
; 556  : 		}
; 557  : 
; 558  : 	void _Free_proxy()
; 559  : 		{	// destroy proxy
; 560  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 561  : 			_Alproxy(_Alval);
; 562  : 		this->_Orphan_all();
; 563  : 		_Alproxy.destroy(this->_Myproxy);
; 564  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 565  : 		this->_Myproxy = 0;
; 566  : 		}
; 567  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 568  : 
; 569  : 	_Alty& _Getal()
; 570  : 		{	// get reference to allocator
; 571  : 		return (_Alval);
; 572  : 		}
; 573  : 
; 574  : 	const _Alty& _Getal() const
; 575  : 		{	// get reference to allocator
; 576  : 		return (_Alval);
; 577  : 		}
; 578  : 
; 579  : 	_Alty _Alval;	// allocator object for values
; 580  : 	};
; 581  : 
; 582  : template<class _Alloc_types>
; 583  : 	class _Vector_alloc<false, _Alloc_types>
; 584  : 		: public _Vector_val<typename _Alloc_types::_Val_types>
; 585  : 	{	// base class for vector to hold allocator with no storage
; 586  : public:
; 587  : 	typedef _Vector_alloc<false, _Alloc_types> _Myt;
; 588  : 	typedef typename _Alloc_types::_Alloc _Alloc;
; 589  : 
; 590  : 	typedef typename _Alloc_types::_Alty _Alty;
; 591  : 
; 592  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 593  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 594  : 		{	// construct allocator from _Al
; 595  : 		}
; 596  : 
; 597  : 	void _Change_alloc(const _Alty&)
; 598  : 		{	// replace old allocator
; 599  : 		}
; 600  : 
; 601  : 	void _Swap_alloc(_Myt&)
; 602  : 		{	// swap allocators
; 603  : 		}
; 604  : 
; 605  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 606  : 	_Vector_alloc(const _Alloc& = _Alloc())
; 607  : 		{	// construct allocator from _Al
; 608  : 		_Alloc_proxy();
; 609  : 		}
; 610  : 
; 611  : 	~_Vector_alloc() _NOEXCEPT
; 612  : 		{	// destroy proxy
; 613  : 		_Free_proxy();
; 614  : 		}
; 615  : 
; 616  : 	void _Change_alloc(const _Alty&)
; 617  : 		{	// replace old allocator
; 618  : 		}
; 619  : 
; 620  : 	void _Swap_alloc(_Myt& _Right)
; 621  : 		{	// swap allocators
; 622  : 		_Swap_adl(this->_Myproxy, _Right._Myproxy);
; 623  : 		}
; 624  : 
; 625  : 	void _Alloc_proxy()
; 626  : 		{	// construct proxy from _Alval
; 627  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 628  : 			_Alproxy;
; 629  : 		this->_Myproxy = _Alproxy.allocate(1);
; 630  : 		_Alproxy.construct(this->_Myproxy, _Container_proxy());
; 631  : 		this->_Myproxy->_Mycont = this;
; 632  : 		}
; 633  : 
; 634  : 	void _Free_proxy()
; 635  : 		{	// destroy proxy
; 636  : 		typename _Alloc::template rebind<_Container_proxy>::other
; 637  : 			_Alproxy;
; 638  : 		this->_Orphan_all();
; 639  : 		_Alproxy.destroy(this->_Myproxy);
; 640  : 		_Alproxy.deallocate(this->_Myproxy, 1);
; 641  : 		this->_Myproxy = 0;
; 642  : 		}
; 643  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 644  : 
; 645  : 	_Alty _Getal() const
; 646  : 		{	// get reference to allocator
; 647  : 		return (_Alty());
; 648  : 		}
; 649  : 	};
; 650  : 
; 651  : 		// TEMPLATE CLASS vector
; 652  : template<class _Ty,
; 653  : 	class _Alloc = allocator<_Ty> >
; 654  : 	class vector
; 655  : 		: public _Vector_alloc<!is_empty<_Alloc>::value,
; 656  : 			_Vec_base_types<_Ty, _Alloc> >
; 657  : 	{	// varying size array of values
; 658  : public:
; 659  : 	typedef vector<_Ty, _Alloc> _Myt;
; 660  : 	typedef _Vector_alloc<!is_empty<_Alloc>::value,
; 661  : 		_Vec_base_types<_Ty, _Alloc> > _Mybase;
; 662  : 	typedef _Alloc allocator_type;
; 663  : 
; 664  : 	typedef typename _Mybase::_Alty _Alty;
; 665  : 
; 666  : 	typedef typename _Mybase::value_type value_type;
; 667  : 	typedef typename _Mybase::size_type size_type;
; 668  : 	typedef typename _Mybase::difference_type difference_type;
; 669  : 	typedef typename _Mybase::pointer pointer;
; 670  : 	typedef typename _Mybase::const_pointer const_pointer;
; 671  : 	typedef typename _Mybase::reference reference;
; 672  : 	typedef typename _Mybase::const_reference const_reference;
; 673  : 
; 674  :  #define _VICONT(it)	it._Getcont()
; 675  :  #define _VIPTR(it)	(it)._Ptr
; 676  : 
; 677  : 	typedef typename _Mybase::iterator iterator;
; 678  : 	typedef typename _Mybase::const_iterator const_iterator;
; 679  : 
; 680  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 681  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 682  : 
; 683  : 	vector()
; 684  : 		: _Mybase()
; 685  : 		{	// construct empty vector
; 686  : 		}
; 687  : 
; 688  : 	explicit vector(const _Alloc& _Al)
; 689  : 		: _Mybase(_Al)
; 690  : 		{	// construct empty vector, allocator
; 691  : 		}
; 692  : 
; 693  : 	explicit vector(size_type _Count)
; 694  : 		: _Mybase()
; 695  : 		{	// construct from _Count * value_type()
; 696  : 		resize(_Count);
; 697  : 		}
; 698  : 
; 699  : 	vector(size_type _Count, const value_type& _Val)
; 700  : 		: _Mybase()
; 701  : 		{	// construct from _Count * _Val
; 702  : 		_Construct_n(_Count, _STD addressof(_Val));
; 703  : 		}
; 704  : 
; 705  : 	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
; 706  : 		: _Mybase(_Al)
; 707  : 		{	// construct from _Count * _Val, allocator
; 708  : 		_Construct_n(_Count, _STD addressof(_Val));
; 709  : 		}
; 710  : 
; 711  : 	vector(const _Myt& _Right)
; 712  : 
; 713  :  #if _HAS_CPP0X
; 714  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 715  : 
; 716  :  #else /* _HAS_CPP0X */
; 717  : 		: _Mybase(_Right._Getal())
; 718  :  #endif /* _HAS_CPP0X */
; 719  : 
; 720  : 		{	// construct by copying _Right
; 721  : 		if (_Buy(_Right.size()))
; 722  : 			_TRY_BEGIN
; 723  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 724  : 				this->_Myfirst);
; 725  : 			_CATCH_ALL
; 726  : 			_Tidy();
; 727  : 			_RERAISE;
; 728  : 			_CATCH_END
; 729  : 		}
; 730  : 
; 731  : 	vector(const _Myt& _Right, const _Alloc& _Al)
; 732  : 		: _Mybase(_Al)
; 733  : 		{	// construct by copying _Right, allocator
; 734  : 		if (_Buy(_Right.size()))
; 735  : 			_TRY_BEGIN
; 736  : 			this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
; 737  : 				this->_Myfirst);
; 738  : 			_CATCH_ALL
; 739  : 			_Tidy();
; 740  : 			_RERAISE;
; 741  : 			_CATCH_END
; 742  : 		}
; 743  : 
; 744  : 	template<class _Iter>
; 745  : 		vector(_Iter _First, _Iter _Last,
; 746  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 747  : 				void>:: type ** = 0)
; 748  : 		: _Mybase()
; 749  : 		{	// construct from [_First, _Last)
; 750  : 		_Construct(_First, _Last);
; 751  : 		}
; 752  : 
; 753  : 	template<class _Iter>
; 754  : 		vector(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 755  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 756  : 				void>:: type ** = 0)
; 757  : 		: _Mybase(_Al)
; 758  : 		{	// construct from [_First, _Last) with allocator
; 759  : 		_Construct(_First, _Last);
; 760  : 		}
; 761  : 
; 762  : 	template<class _Iter>
; 763  : 		void _Construct(_Iter _First, _Iter _Last)
; 764  : 		{	// initialize with [_First, _Last), input iterators
; 765  : 		_TRY_BEGIN
; 766  : 		insert(begin(), _First, _Last);
; 767  : 		_CATCH_ALL
; 768  : 		_Tidy();
; 769  : 		_RERAISE;
; 770  : 		_CATCH_END
; 771  : 		}
; 772  : 
; 773  : 	void _Construct_n(size_type _Count, const value_type *_Pval)
; 774  : 		{	// construct from _Count * *_Pval
; 775  : 		if (_Buy(_Count))
; 776  : 			{	// nonzero, fill it
; 777  : 			_TRY_BEGIN
; 778  : 			this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
; 779  : 			_CATCH_ALL
; 780  : 			_Tidy();
; 781  : 			_RERAISE;
; 782  : 			_CATCH_END
; 783  : 			}
; 784  : 		}
; 785  : 
; 786  : 	vector(_Myt&& _Right)
; 787  : 		: _Mybase(_Right._Getal())
; 788  : 		{	// construct by moving _Right
; 789  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 790  : 		}
; 791  : 
; 792  : 	vector(_Myt&& _Right, const _Alloc& _Al)
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct by moving _Right, allocator
; 795  : 		if (this->_Getal() != _Right._Getal())
; 796  : 			assign(_STD make_move_iterator(_Right.begin()),
; 797  : 				_STD make_move_iterator(_Right.end()));
; 798  : 		else
; 799  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 800  : 		}
; 801  : 
; 802  : 	_Myt& operator=(_Myt&& _Right)
; 803  : 		{	// assign by moving _Right
; 804  : 		if (this != &_Right)
; 805  : 			{	// different, assign it
; 806  : 			_Tidy();
; 807  : 
; 808  :  #if _HAS_CPP0X
; 809  : 			if (this->_Getal() != _Right._Getal()
; 810  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 811  : 				this->_Change_alloc(_Right._Getal());
; 812  :  #endif /* _HAS_CPP0X */
; 813  : 
; 814  : 			if (this->_Getal() != _Right._Getal())
; 815  : 				assign(_STD make_move_iterator(_Right.begin()),
; 816  : 					_STD make_move_iterator(_Right.end()));
; 817  : 			else
; 818  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 819  : 			}
; 820  : 		return (*this);
; 821  : 		}
; 822  : 
; 823  : 	void _Assign_rv(_Myt&& _Right)
; 824  : 		{	// assign by moving _Right
; 825  : 		this->_Swap_all((_Myt&)_Right);
; 826  : 		this->_Myfirst = _Right._Myfirst;
; 827  : 		this->_Mylast = _Right._Mylast;
; 828  : 		this->_Myend = _Right._Myend;
; 829  : 
; 830  : 		_Right._Myfirst = pointer();
; 831  : 		_Right._Mylast = pointer();
; 832  : 		_Right._Myend = pointer();
; 833  : 		}
; 834  : 
; 835  : 	void push_back(value_type&& _Val)
; 836  : 		{	// insert by moving into element at end
; 837  : 		if (_Inside(_STD addressof(_Val)))
; 838  : 			{	// push back an element
; 839  : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 840  : 			if (this->_Mylast == this->_Myend)
; 841  : 				_Reserve(1);
; 842  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 843  : 			this->_Getal().construct(this->_Mylast,
; 844  : 				_STD forward<value_type>(this->_Myfirst[_Idx]));
; 845  : 			++this->_Mylast;
; 846  : 			}
; 847  : 		else
; 848  : 			{	// push back a non-element
; 849  : 			if (this->_Mylast == this->_Myend)
; 850  : 				_Reserve(1);
; 851  : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 852  : 			this->_Getal().construct(this->_Mylast,
; 853  : 				_STD forward<value_type>(_Val));
; 854  : 			++this->_Mylast;
; 855  : 			}
; 856  : 		}
; 857  : 
; 858  : 	iterator insert(const_iterator _Where, _Ty&& _Val)
; 859  : 		{	// insert by moving _Val at _Where
; 860  : 		return (emplace(_Where, _STD move(_Val)));
; 861  : 		}
; 862  : 
; 863  : #define _VECTOR_EMPLACE( \
; 864  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, X1, X2, X3, X4) \
; 865  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 866  : 		void emplace_back(LIST(_TYPE_REFREF_ARG)) \
; 867  : 		{	/* insert by moving into element at end */ \
; 868  : 		if (this->_Mylast == this->_Myend) \
; 869  : 			_Reserve(1); \
; 870  : 		_Orphan_range(this->_Mylast, this->_Mylast); \
; 871  : 		this->_Getal().construct(this->_Mylast COMMA LIST(_FORWARD_ARG)); \
; 872  : 		++this->_Mylast; \
; 873  : 		} \
; 874  : 	TEMPLATE_LIST(_CLASS_TYPE) \
; 875  : 		iterator emplace(const_iterator _Where \
; 876  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 877  : 		{	/* insert by moving _Val at _Where */ \
; 878  : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst; \
; 879  : 		_VECTOR_EMPLACE_CHECK \
; 880  : 		emplace_back(LIST(_FORWARD_ARG)); \
; 881  : 		_STD rotate(begin() + _Off, end() - 1, end()); \
; 882  : 		return (begin() + _Off); \
; 883  : 		}
; 884  : 
; 885  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 886  : #define _VECTOR_EMPLACE_CHECK \
; 887  : 		if (size() < _Off) \
; 888  : 			_DEBUG_ERROR("vector emplace iterator outside range");
; 889  : 
; 890  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 891  : #define _VECTOR_EMPLACE_CHECK
; 892  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 893  : 
; 894  : _VARIADIC_EXPAND_0X(_VECTOR_EMPLACE, , , , )
; 895  : #undef _VECTOR_EMPLACE_CHECK
; 896  : #undef _VECTOR_EMPLACE
; 897  : 
; 898  : 	~vector() _NOEXCEPT
; 899  : 		{	// destroy the object
; 900  : 		_Tidy();
; 901  : 		}
; 902  : 
; 903  : 	_Myt& operator=(const _Myt& _Right)
; 904  : 		{	// assign _Right
; 905  : 		if (this != &_Right)
; 906  : 			{	// different, assign it
; 907  :  #if _HAS_CPP0X
; 908  : 			if (this->_Getal() != _Right._Getal()
; 909  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 910  : 				{	// change allocator before copying
; 911  : 				_Tidy();
; 912  : 				this->_Change_alloc(_Right._Getal());
; 913  : 				}
; 914  :  #endif /* _HAS_CPP0X */
; 915  : 
; 916  : 			this->_Orphan_all();
; 917  : 
; 918  : 			if (_Right.empty())
; 919  : 				clear();	// new sequence empty, erase existing sequence
; 920  : 			else if (_Right.size() <= size())
; 921  : 				{	// enough elements, copy new and destroy old
; 922  : 				pointer _Ptr = _Copy_impl(_Right._Myfirst,
; 923  : 					_Right._Mylast, this->_Myfirst);	// copy new
; 924  : 				_Destroy(_Ptr, this->_Mylast);	// destroy old
; 925  : 				this->_Mylast = this->_Myfirst + _Right.size();
; 926  : 				}
; 927  : 			else if (_Right.size() <= capacity())
; 928  : 				{	// enough room, copy and construct new
; 929  : 				pointer _Ptr = _Right._Myfirst + size();
; 930  : 				_Copy_impl(_Right._Myfirst,
; 931  : 					_Ptr, this->_Myfirst);
; 932  : 				this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
; 933  : 				}
; 934  : 			else
; 935  : 				{	// not enough room, allocate new array and construct new
; 936  : 				if (this->_Myfirst != pointer())
; 937  : 					{	// discard old array
; 938  : 					_Destroy(this->_Myfirst, this->_Mylast);
; 939  : 					this->_Getal().deallocate(this->_Myfirst,
; 940  : 						this->_Myend - this->_Myfirst);
; 941  : 					}
; 942  : 				if (_Buy(_Right.size()))
; 943  : 					_TRY_BEGIN
; 944  : 					this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 945  : 						this->_Myfirst);
; 946  : 					_CATCH_ALL
; 947  : 					_Tidy();
; 948  : 					_RERAISE;
; 949  : 					_CATCH_END
; 950  : 				}
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void reserve(size_type _Count)
; 956  : 		{	// determine new minimum length of allocated storage
; 957  : 		if (capacity() < _Count)
; 958  : 			{	// something to do, check and reallocate
; 959  : 			if (max_size() < _Count)
; 960  : 				_Xlen();
; 961  : 			_Reallocate(_Count);
; 962  : 			}
; 963  : 		}
; 964  : 
; 965  : 	size_type capacity() const _NOEXCEPT
; 966  : 		{	// return current length of allocated storage
; 967  : 		return (this->_Myend - this->_Myfirst);

  00ea3	48 2b d6	 sub	 rdx, rsi
  00ea6	48 c1 fa 04	 sar	 rdx, 4

; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00eaa	48 8b ca	 mov	 rcx, rdx
  00ead	48 d1 e9	 shr	 rcx, 1
  00eb0	49 8b c0	 mov	 rax, r8
  00eb3	48 2b c1	 sub	 rax, rcx
  00eb6	48 3b c2	 cmp	 rax, rdx
  00eb9	73 05		 jae	 SHORT $LN704@tick
  00ebb	49 8b d4	 mov	 rdx, r12
  00ebe	eb 03		 jmp	 SHORT $LN705@tick
$LN704@tick:
  00ec0	48 03 d1	 add	 rdx, rcx
$LN705@tick:

; 1489 : 		if (_Capacity < _Count)

  00ec3	48 3b d7	 cmp	 rdx, rdi
  00ec6	48 0f 42 d7	 cmovb	 rdx, rdi

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00eca	48 8d 4c 24 50	 lea	 rcx, QWORD PTR chunksToRender$[rsp]
  00ecf	e8 00 00 00 00	 call	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
  00ed4	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00ed9	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN679@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00ede	48 85 ff	 test	 rdi, rdi
  00ee1	74 29		 je	 SHORT $LN732@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00ee3	4c 89 27	 mov	 QWORD PTR [rdi], r12
  00ee6	4c 89 67 08	 mov	 QWORD PTR [rdi+8], r12

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00eea	4d 85 f6	 test	 r14, r14
  00eed	74 0f		 je	 SHORT $LN745@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00eef	f0 41 ff 46 08	 lock inc DWORD PTR [r14+8]
  00ef4	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  00ef9	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN745@tick:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00efe	4d 8b c6	 mov	 r8, r14
  00f01	49 8b d7	 mov	 rdx, r15
$LN676@tick:
  00f04	48 8b cf	 mov	 rcx, rdi
  00f07	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN732@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1202 : 			++this->_Mylast;

  00f0c	48 83 c7 10	 add	 rdi, 16
  00f10	48 89 7c 24 58	 mov	 QWORD PTR chunksToRender$[rsp+8], rdi
$LN593@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00f15	4d 85 f6	 test	 r14, r14
  00f18	74 29		 je	 SHORT $LN15@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00f1a	f0 41 ff 4e 08	 lock dec DWORD PTR [r14+8]
  00f1f	75 18		 jne	 SHORT $LN1154@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  00f21	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00f24	49 8b ce	 mov	 rcx, r14
  00f27	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00f29	f0 41 ff 4e 0c	 lock dec DWORD PTR [r14+12]
  00f2e	75 09		 jne	 SHORT $LN1154@tick

; 128  : 			_Delete_this();

  00f30	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00f33	49 8b ce	 mov	 rcx, r14
  00f36	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1154@tick:
  00f39	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
  00f3e	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN15@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00f43	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00f46	48 3b 1d 48 00
	00 00		 cmp	 rbx, QWORD PTR ?world@GlobalThread@@3VWorld@@A+72
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 140  : 	for(auto iter = GlobalThread::world.chunkMap.begin(); iter != GlobalThread::world.chunkMap.end(); ++iter)

  00f4d	e9 73 fd ff ff	 jmp	 $LN1169@tick
$LN1114@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1667 : 		_Xlength_error("vector<T> too long");

  00f52	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00f59	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00f5e	cc		 int	 3
$LN1115@tick:
  00f5f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00f66	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00f6b	90		 npad	 1
$LN1156@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  00f6c	48 8d 0d 40 00
	00 00		 lea	 rcx, OFFSET FLAT:?world@GlobalThread@@3VWorld@@A+64
  00f73	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  00f78	85 c0		 test	 eax, eax
  00f7a	74 07		 je	 SHORT $LN763@tick

; 33   : 		_Throw_C_error(_Res);

  00f7c	8b c8		 mov	 ecx, eax
  00f7e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN763@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 714  : 	if(!uploaded)

  00f83	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?blocksTexture@RenderThread@@2PEAVTiledTexture@gfxu@@EA ; RenderThread::blocksTexture
  00f8a	80 78 11 00	 cmp	 BYTE PTR [rax+17], 0
  00f8e	75 0a		 jne	 SHORT $LN768@tick

; 715  : 	{
; 716  : 		if(!upload())

  00f90	48 8b c8	 mov	 rcx, rax
  00f93	e8 00 00 00 00	 call	 ?upload@Texture2D@gfxu@@QEAA_NXZ ; gfxu::Texture2D::upload

; 717  : 		{
; 718  : 			return;
; 719  : 		}
; 720  : 	}
; 721  : 	else

  00f98	eb 0d		 jmp	 SHORT $LN766@tick
$LN768@tick:

; 722  : 	{
; 723  : 		glBindTexture(GL_TEXTURE_2D, object);

  00f9a	8b 10		 mov	 edx, DWORD PTR [rax]
  00f9c	b9 e1 0d 00 00	 mov	 ecx, 3553		; 00000de1H
  00fa1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBindTexture
$LN766@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 158  : 	glEnable(GL_BLEND);

  00fa7	b9 e2 0b 00 00	 mov	 ecx, 3042		; 00000be2H
  00fac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 159  : 	for(int i = 0; i < chunksToRender.size(); i++)

  00fb2	45 8b fc	 mov	 r15d, r12d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00fb5	4c 8b f7	 mov	 r14, rdi
  00fb8	4c 2b f6	 sub	 r14, rsi
  00fbb	49 c1 fe 04	 sar	 r14, 4
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 159  : 	for(int i = 0; i < chunksToRender.size(); i++)

  00fbf	4d 85 f6	 test	 r14, r14
  00fc2	0f 84 9e 01 00
	00		 je	 $LN8@tick
  00fc8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL10@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00fd0	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  00fd4	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00fd7	48 85 db	 test	 rbx, rbx
  00fda	74 04		 je	 SHORT $LN792@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00fdc	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN792@tick:

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  00fe0	48 89 9d a8 00
	00 00		 mov	 QWORD PTR chunk$20[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  00fe7	48 89 bd a0 00
	00 00		 mov	 QWORD PTR chunk$20[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  00fee	48 8d 4f 30	 lea	 rcx, QWORD PTR [rdi+48]
  00ff2	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  00ff7	85 c0		 test	 eax, eax
  00ff9	74 07		 je	 SHORT $LN803@tick

; 33   : 		_Throw_C_error(_Res);

  00ffb	8b c8		 mov	 ecx, eax
  00ffd	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN803@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 164  : 		if(chunk->isLoaded() && chunk->firstPass != nullptr)

  01002	80 7f 09 00	 cmp	 BYTE PTR [rdi+9], 0
  01006	0f 84 03 01 00
	00		 je	 $LN7@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  0100c	48 83 7f 38 00	 cmp	 QWORD PTR [rdi+56], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 164  : 		if(chunk->isLoaded() && chunk->firstPass != nullptr)

  01011	0f 84 f8 00 00
	00		 je	 $LN7@tick

; 166  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  01017	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  0101a	c1 e0 04	 shl	 eax, 4
  0101d	66 0f 6e d0	 movd	 xmm2, eax
  01021	0f 5b d2	 cvtdq2ps xmm2, xmm2
  01024	8b 47 1c	 mov	 eax, DWORD PTR [rdi+28]
  01027	c1 e0 04	 shl	 eax, 4
  0102a	66 0f 6e c8	 movd	 xmm1, eax
  0102e	0f 5b c9	 cvtdq2ps xmm1, xmm1
  01031	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  01034	c1 e0 04	 shl	 eax, 4
  01037	66 0f 6e c0	 movd	 xmm0, eax
  0103b	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  0103e	33 c0		 xor	 eax, eax
  01040	48 89 85 b0 03
	00 00		 mov	 QWORD PTR $T35[rbp-256], rax
  01047	48 89 85 b8 03
	00 00		 mov	 QWORD PTR $T35[rbp-248], rax
  0104e	48 89 85 c0 03
	00 00		 mov	 QWORD PTR $T35[rbp-240], rax
  01055	48 89 85 c8 03
	00 00		 mov	 QWORD PTR $T35[rbp-232], rax
  0105c	48 89 85 d0 03
	00 00		 mov	 QWORD PTR $T35[rbp-224], rax
  01063	48 89 85 d8 03
	00 00		 mov	 QWORD PTR $T35[rbp-216], rax
  0106a	48 89 85 e0 03
	00 00		 mov	 QWORD PTR $T35[rbp-208], rax
  01071	48 89 85 e8 03
	00 00		 mov	 QWORD PTR $T35[rbp-200], rax

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  01078	c7 85 b0 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T35[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  01082	c7 85 c4 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T35[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  0108c	c7 85 d8 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T35[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  01096	c7 85 ec 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T35[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  010a0	f3 0f 11 85 bc
	03 00 00	 movss	 DWORD PTR $T35[rbp-244], xmm0

; 246  : 	result[7] = y;

  010a8	f3 0f 11 8d cc
	03 00 00	 movss	 DWORD PTR $T35[rbp-228], xmm1

; 247  : 	result[11] = z;

  010b0	f3 0f 11 95 dc
	03 00 00	 movss	 DWORD PTR $T35[rbp-212], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 166  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  010b8	0f 28 85 b0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T35[rbp-256]
  010bf	0f 29 85 30 02
	00 00		 movaps	 XMMWORD PTR $T27[rbp-256], xmm0
  010c6	0f 28 8d c0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T35[rbp-240]
  010cd	0f 29 8d 40 02
	00 00		 movaps	 XMMWORD PTR $T27[rbp-240], xmm1
  010d4	0f 28 85 d0 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T35[rbp-224]
  010db	0f 29 85 50 02
	00 00		 movaps	 XMMWORD PTR $T27[rbp-224], xmm0
  010e2	0f 28 8d e0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T35[rbp-208]
  010e9	0f 29 8d 60 02
	00 00		 movaps	 XMMWORD PTR $T27[rbp-208], xmm1
  010f0	48 8d 95 30 02
	00 00		 lea	 rdx, QWORD PTR $T27[rbp-256]
  010f7	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push

; 167  : 			chunk->firstPass->draw();

  010fc	ba 04 00 00 00	 mov	 edx, 4
  01101	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  01105	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 168  : 			gfxu::Uniforms::MMS.pop();

  0110a	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop
$LN7@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  0110f	48 8d 4f 30	 lea	 rcx, QWORD PTR [rdi+48]
  01113	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  01118	85 c0		 test	 eax, eax
  0111a	74 08		 je	 SHORT $LN871@tick

; 33   : 		_Throw_C_error(_Res);

  0111c	8b c8		 mov	 ecx, eax
  0111e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  01123	90		 npad	 1
$LN871@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  01124	48 85 db	 test	 rbx, rbx
  01127	74 1d		 je	 SHORT $LN9@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  01129	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0112d	75 17		 jne	 SHORT $LN9@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0112f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01132	48 8b cb	 mov	 rcx, rbx
  01135	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  01137	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0113b	75 09		 jne	 SHORT $LN9@tick

; 128  : 			_Delete_this();

  0113d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01140	48 8b cb	 mov	 rcx, rbx
  01143	ff 50 08	 call	 QWORD PTR [rax+8]
$LN9@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 159  : 	for(int i = 0; i < chunksToRender.size(); i++)

  01146	41 ff c7	 inc	 r15d
  01149	48 83 c6 10	 add	 rsi, 16
  0114d	49 63 c7	 movsxd	 rax, r15d
  01150	49 3b c6	 cmp	 rax, r14
  01153	0f 82 77 fe ff
	ff		 jb	 $LL10@tick
  01159	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  0115e	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
  01163	45 33 e4	 xor	 r12d, r12d
$LN8@tick:

; 173  : 	for(int i = 0; i < chunksToRender.size(); i++)

  01166	45 8b fc	 mov	 r15d, r12d
  01169	4d 85 f6	 test	 r14, r14
  0116c	0f 84 8c 01 00
	00		 je	 $LN4@tick
$LL6@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  01172	48 8b 5e 08	 mov	 rbx, QWORD PTR [rsi+8]
  01176	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  01179	48 85 db	 test	 rbx, rbx
  0117c	74 04		 je	 SHORT $LN906@tick

; 108  : 		_MT_INCR(_Ignored, _Uses);

  0117e	f0 ff 43 08	 lock inc DWORD PTR [rbx+8]
$LN906@tick:

; 410  : 		}
; 411  : 
; 412  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
; 413  : 		{	// take _Other_ptr through _Other_rep from weak_ptr if not expired
; 414  : 			// otherwise, leave in default state if !_Throw,
; 415  : 			// otherwise throw exception
; 416  : 		if (_Other_rep && _Other_rep->_Incref_nz())
; 417  : 			_Reset0(_Other_ptr, _Other_rep);
; 418  : 		else if (_Throw)
; 419  : 			_THROW_NCEE(bad_weak_ptr, 0);
; 420  : 		}
; 421  : 
; 422  : 	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 423  : 		{	// release resource and take new resource
; 424  : 		if (_Rep != 0)
; 425  : 			_Rep->_Decref();
; 426  : 		_Rep = _Other_rep;

  01182	48 89 9d 98 00
	00 00		 mov	 QWORD PTR chunk$19[rbp-248], rbx

; 427  : 		_Ptr = _Other_ptr;

  01189	48 89 bd 90 00
	00 00		 mov	 QWORD PTR chunk$19[rbp-256], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 68   : 	return (_Check_C_return(_Mtx_lock(_Mtx)));

  01190	48 8d 4f 30	 lea	 rcx, QWORD PTR [rdi+48]
  01194	e8 00 00 00 00	 call	 _Mtx_lock

; 32   : 	if (_Res != _Thrd_success)

  01199	85 c0		 test	 eax, eax
  0119b	74 07		 je	 SHORT $LN917@tick

; 33   : 		_Throw_C_error(_Res);

  0119d	8b c8		 mov	 ecx, eax
  0119f	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
$LN917@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  011a4	48 83 7f 48 00	 cmp	 QWORD PTR [rdi+72], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 178  : 		if(chunk->secondPass != nullptr)

  011a9	0f 84 f8 00 00
	00		 je	 $LN3@tick

; 180  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  011af	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  011b2	c1 e0 04	 shl	 eax, 4
  011b5	66 0f 6e d0	 movd	 xmm2, eax
  011b9	0f 5b d2	 cvtdq2ps xmm2, xmm2
  011bc	8b 47 1c	 mov	 eax, DWORD PTR [rdi+28]
  011bf	c1 e0 04	 shl	 eax, 4
  011c2	66 0f 6e c8	 movd	 xmm1, eax
  011c6	0f 5b c9	 cvtdq2ps xmm1, xmm1
  011c9	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  011cc	c1 e0 04	 shl	 eax, 4
  011cf	66 0f 6e c0	 movd	 xmm0, eax
  011d3	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  011d6	33 c0		 xor	 eax, eax
  011d8	48 89 85 30 03
	00 00		 mov	 QWORD PTR $T33[rbp-256], rax
  011df	48 89 85 38 03
	00 00		 mov	 QWORD PTR $T33[rbp-248], rax
  011e6	48 89 85 40 03
	00 00		 mov	 QWORD PTR $T33[rbp-240], rax
  011ed	48 89 85 48 03
	00 00		 mov	 QWORD PTR $T33[rbp-232], rax
  011f4	48 89 85 50 03
	00 00		 mov	 QWORD PTR $T33[rbp-224], rax
  011fb	48 89 85 58 03
	00 00		 mov	 QWORD PTR $T33[rbp-216], rax
  01202	48 89 85 60 03
	00 00		 mov	 QWORD PTR $T33[rbp-208], rax
  01209	48 89 85 68 03
	00 00		 mov	 QWORD PTR $T33[rbp-200], rax

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  01210	c7 85 30 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T33[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  0121a	c7 85 44 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T33[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  01224	c7 85 58 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T33[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  0122e	c7 85 6c 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T33[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  01238	f3 0f 11 85 3c
	03 00 00	 movss	 DWORD PTR $T33[rbp-244], xmm0

; 246  : 	result[7] = y;

  01240	f3 0f 11 8d 4c
	03 00 00	 movss	 DWORD PTR $T33[rbp-228], xmm1

; 247  : 	result[11] = z;

  01248	f3 0f 11 95 5c
	03 00 00	 movss	 DWORD PTR $T33[rbp-212], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 180  : 			gfxu::Uniforms::MMS.push(geom::Matrix::translate(chunk->pos.x * 16, chunk->pos.y * 16, chunk->pos.z * 16));

  01250	0f 28 85 30 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T33[rbp-256]
  01257	0f 29 85 b0 02
	00 00		 movaps	 XMMWORD PTR $T29[rbp-256], xmm0
  0125e	0f 28 8d 40 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T33[rbp-240]
  01265	0f 29 8d c0 02
	00 00		 movaps	 XMMWORD PTR $T29[rbp-240], xmm1
  0126c	0f 28 85 50 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T33[rbp-224]
  01273	0f 29 85 d0 02
	00 00		 movaps	 XMMWORD PTR $T29[rbp-224], xmm0
  0127a	0f 28 8d 60 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T33[rbp-208]
  01281	0f 29 8d e0 02
	00 00		 movaps	 XMMWORD PTR $T29[rbp-208], xmm1
  01288	48 8d 95 b0 02
	00 00		 lea	 rdx, QWORD PTR $T29[rbp-256]
  0128f	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push

; 181  : 			chunk->secondPass->draw();

  01294	ba 04 00 00 00	 mov	 edx, 4
  01299	48 8b 4f 48	 mov	 rcx, QWORD PTR [rdi+72]
  0129d	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 182  : 			gfxu::Uniforms::MMS.pop();

  012a2	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop
$LN3@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 83   : 	return (_Check_C_return(_Mtx_unlock(_Mtx)));

  012a7	48 8d 4f 30	 lea	 rcx, QWORD PTR [rdi+48]
  012ab	e8 00 00 00 00	 call	 _Mtx_unlock

; 32   : 	if (_Res != _Thrd_success)

  012b0	85 c0		 test	 eax, eax
  012b2	74 08		 je	 SHORT $LN979@tick

; 33   : 		_Throw_C_error(_Res);

  012b4	8b c8		 mov	 ecx, eax
  012b6	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
  012bb	90		 npad	 1
$LN979@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  012bc	48 85 db	 test	 rbx, rbx
  012bf	74 1d		 je	 SHORT $LN5@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  012c1	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  012c5	75 17		 jne	 SHORT $LN5@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  012c7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  012ca	48 8b cb	 mov	 rcx, rbx
  012cd	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  012cf	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  012d3	75 09		 jne	 SHORT $LN5@tick

; 128  : 			_Delete_this();

  012d5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  012d8	48 8b cb	 mov	 rcx, rbx
  012db	ff 50 08	 call	 QWORD PTR [rax+8]
$LN5@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 173  : 	for(int i = 0; i < chunksToRender.size(); i++)

  012de	41 ff c7	 inc	 r15d
  012e1	48 83 c6 10	 add	 rsi, 16
  012e5	49 63 c7	 movsxd	 rax, r15d
  012e8	49 3b c6	 cmp	 rax, r14
  012eb	0f 82 81 fe ff
	ff		 jb	 $LL6@tick
  012f1	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
  012f6	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
  012fb	45 33 e4	 xor	 r12d, r12d
$LN4@tick:

; 183  : 		}
; 184  : 		chunk->renderMutex.unlock();
; 185  : 	}
; 186  : 
; 187  : 	noTexShaderProgram->bind();

  012fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
  01305	e8 00 00 00 00	 call	 ?bind@ShaderProgram@gfxu@@QEAAXXZ ; gfxu::ShaderProgram::bind

; 188  : 	/*gfxu::Uniforms::MMS.push(geom::Matrix::translate(state->cam.pos.x - renderDistance * 16.0f, -0.125f, state->cam.pos.z - renderDistance * 16.0f));
; 189  : 	gfxu::Uniforms::MMS.mult(geom::Matrix::scale(32.0f * renderDistance, 1.0f, 32.0f * renderDistance));
; 190  : 	gfxu::Uniforms::setColor(0.1f, 0.2f, 0.5f, 0.75f);
; 191  : 	square->draw();
; 192  : 	gfxu::Uniforms::MMS.pop();*/
; 193  : 	
; 194  : 	if(state->devEnabled)

  0130a	41 80 7d 24 00	 cmp	 BYTE PTR [r13+36], 0
  0130f	0f 84 75 02 00
	00		 je	 $LN2@tick
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  01315	48 c7 45 88 00
	00 80 3f	 mov	 QWORD PTR $T2[rbp-256], 1065353216 ; 3f800000H
  0131d	48 c7 45 90 00
	00 00 00	 mov	 QWORD PTR $T2[rbp-248], 0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  01325	48 8b 45 88	 mov	 rax, QWORD PTR $T2[rbp-256]
  01329	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  01330	48 8b 45 90	 mov	 rax, QWORD PTR $T2[rbp-248]
  01334	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  0133b	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?fogColor@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, 1

; 304  : 			val = value;

  01342	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43000000
  0134a	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, xmm0

; 305  : 			changed = true;

  01352	c6 05 04 00 00
	00 01		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  01359	4c 89 a5 30 04
	00 00		 mov	 QWORD PTR $T37[rbp-256], r12
  01360	4c 89 a5 38 04
	00 00		 mov	 QWORD PTR $T37[rbp-248], r12
  01367	4c 89 a5 40 04
	00 00		 mov	 QWORD PTR $T37[rbp-240], r12
  0136e	4c 89 a5 48 04
	00 00		 mov	 QWORD PTR $T37[rbp-232], r12
  01375	4c 89 a5 50 04
	00 00		 mov	 QWORD PTR $T37[rbp-224], r12
  0137c	4c 89 a5 58 04
	00 00		 mov	 QWORD PTR $T37[rbp-216], r12
  01383	4c 89 a5 60 04
	00 00		 mov	 QWORD PTR $T37[rbp-208], r12
  0138a	4c 89 a5 68 04
	00 00		 mov	 QWORD PTR $T37[rbp-200], r12

; 227  : 
; 228  : 	return result;
; 229  : }
; 230  : 
; 231  : Matrix Matrix::scale(float x, float y, float z)
; 232  : {
; 233  : 	Matrix result;
; 234  : 	result[0] = x;

  01391	c7 85 30 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T37[rbp-256], 1098907648 ; 41800000H

; 235  : 	result[5] = y;

  0139b	c7 85 44 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T37[rbp-236], 1098907648 ; 41800000H

; 236  : 	result[10] = z;

  013a5	c7 85 58 04 00
	00 00 00 80 41	 mov	 DWORD PTR $T37[rbp-216], 1098907648 ; 41800000H

; 237  : 	result[15] = 1.0f;

  013af	c7 85 6c 04 00
	00 00 00 80 3f	 mov	 DWORD PTR $T37[rbp-196], 1065353216 ; 3f800000H
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 198  : 		gfxu::Uniforms::MMS.push(geom::Matrix::scale(16.0f, 16.0f, 16.0f));

  013b9	0f 28 85 30 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T37[rbp-256]
  013c0	0f 29 85 70 01
	00 00		 movaps	 XMMWORD PTR $T24[rbp-256], xmm0
  013c7	0f 28 8d 40 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T37[rbp-240]
  013ce	0f 29 8d 80 01
	00 00		 movaps	 XMMWORD PTR $T24[rbp-240], xmm1
  013d5	0f 28 85 50 04
	00 00		 movaps	 xmm0, XMMWORD PTR $T37[rbp-224]
  013dc	0f 29 85 90 01
	00 00		 movaps	 XMMWORD PTR $T24[rbp-224], xmm0
  013e3	0f 28 8d 60 04
	00 00		 movaps	 xmm1, XMMWORD PTR $T37[rbp-208]
  013ea	0f 29 8d a0 01
	00 00		 movaps	 XMMWORD PTR $T24[rbp-208], xmm1
  013f1	48 8d 95 70 01
	00 00		 lea	 rdx, QWORD PTR $T24[rbp-256]
  013f8	e8 00 00 00 00	 call	 ?push@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::push
  013fd	66 0f 6e 54 24
	68		 movd	 xmm2, DWORD PTR zCam$[rsp]

; 199  : 		gfxu::Uniforms::MMS.mult(geom::Matrix::translate(xCam, yCam, zCam));

  01403	0f 5b d2	 cvtdq2ps xmm2, xmm2
  01406	66 0f 6e 4c 24
	6c		 movd	 xmm1, DWORD PTR yCam$[rsp]
  0140c	0f 5b c9	 cvtdq2ps xmm1, xmm1
  0140f	66 0f 6e 44 24
	70		 movd	 xmm0, DWORD PTR xCam$[rsp]
  01415	0f 5b c0	 cvtdq2ps xmm0, xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 143  : 		data[i] = 0.0f;

  01418	4c 89 a5 70 03
	00 00		 mov	 QWORD PTR $T34[rbp-256], r12
  0141f	4c 89 a5 78 03
	00 00		 mov	 QWORD PTR $T34[rbp-248], r12
  01426	4c 89 a5 80 03
	00 00		 mov	 QWORD PTR $T34[rbp-240], r12
  0142d	4c 89 a5 88 03
	00 00		 mov	 QWORD PTR $T34[rbp-232], r12
  01434	4c 89 a5 90 03
	00 00		 mov	 QWORD PTR $T34[rbp-224], r12
  0143b	4c 89 a5 98 03
	00 00		 mov	 QWORD PTR $T34[rbp-216], r12
  01442	4c 89 a5 a0 03
	00 00		 mov	 QWORD PTR $T34[rbp-208], r12
  01449	4c 89 a5 a8 03
	00 00		 mov	 QWORD PTR $T34[rbp-200], r12

; 144  : 	}
; 145  : }
; 146  : 
; 147  : Matrix::Matrix(float* data)
; 148  : {
; 149  : 	for(int i = 0; i < 16; i++)
; 150  : 	{
; 151  : 		this->data[i] = data[i];
; 152  : 	}
; 153  : }
; 154  : 
; 155  : const float& Matrix::operator[](int index) const
; 156  : {
; 157  : 	return data[index];
; 158  : }
; 159  : 
; 160  : float& Matrix::operator[](int index)
; 161  : {
; 162  : 	return data[index];
; 163  : }
; 164  : 
; 165  : 
; 166  : Matrix Matrix::operator*(const Matrix& mat) const
; 167  : {
; 168  : 	Matrix result;
; 169  : 
; 170  : 	for(int i = 0; i < 4; i++)
; 171  : 	{
; 172  : 		for(int j = 0; j < 4; j++)
; 173  : 		{
; 174  : 			float value = 0.0f;
; 175  : 			for(int k = 0; k < 4; k++)
; 176  : 			{
; 177  : 				value += data[index(k, j)] * mat.data[index(i, k)];
; 178  : 			}
; 179  : 			result[index(i, j)] = value;
; 180  : 		}
; 181  : 	}
; 182  : 
; 183  : 	return result;
; 184  : }
; 185  : 
; 186  : Matrix Matrix::operator*(const float& scalar) const
; 187  : {
; 188  : 	Matrix result;
; 189  : 
; 190  : 	for(int i = 0; i < 16; i++)
; 191  : 	{
; 192  : 		result[i] = data[i] * scalar;
; 193  : 	}
; 194  : 
; 195  : 	return result;
; 196  : }
; 197  : 
; 198  : Vector Matrix::operator*(const Vector& vert) const
; 199  : {
; 200  : 	Vector result;
; 201  : 
; 202  : 	result.x = vert.x * data[0] + vert.y * data[1] + vert.z * data[2] + vert.w * data[3];
; 203  : 	result.y = vert.x * data[4] + vert.y * data[5] + vert.z * data[6] + vert.w * data[7];
; 204  : 	result.z = vert.x * data[8] + vert.y * data[9] + vert.z * data[10] + vert.w * data[11];
; 205  : 	result.w = vert.x * data[12] + vert.y * data[13] + vert.z * data[14] + vert.w * data[15];
; 206  : 
; 207  : 	return result;
; 208  : }
; 209  : 
; 210  : Matrix& Matrix::operator=(const Matrix& mat)
; 211  : {
; 212  : 	for(int i = 0; i < 16; i++)
; 213  : 	{
; 214  : 		data[i] = mat.data[i];
; 215  : 	}
; 216  : 
; 217  : 	return *this;
; 218  : }
; 219  : 
; 220  : Matrix Matrix::identity()
; 221  : {
; 222  : 	Matrix result;
; 223  : 	result[0] = 1.0f;

  01450	c7 85 70 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T34[rbp-256], 1065353216 ; 3f800000H

; 224  : 	result[5] = 1.0f;

  0145a	c7 85 84 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T34[rbp-236], 1065353216 ; 3f800000H

; 225  : 	result[10] = 1.0f;

  01464	c7 85 98 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T34[rbp-216], 1065353216 ; 3f800000H

; 226  : 	result[15] = 1.0f;

  0146e	c7 85 ac 03 00
	00 00 00 80 3f	 mov	 DWORD PTR $T34[rbp-196], 1065353216 ; 3f800000H

; 238  : 
; 239  : 	return result;
; 240  : }
; 241  : 
; 242  : Matrix Matrix::translate(float x, float y, float z)
; 243  : {
; 244  : 	Matrix result = identity();
; 245  : 	result[3] = x;

  01478	f3 0f 11 85 7c
	03 00 00	 movss	 DWORD PTR $T34[rbp-244], xmm0

; 246  : 	result[7] = y;

  01480	f3 0f 11 8d 8c
	03 00 00	 movss	 DWORD PTR $T34[rbp-228], xmm1

; 247  : 	result[11] = z;

  01488	f3 0f 11 95 9c
	03 00 00	 movss	 DWORD PTR $T34[rbp-212], xmm2
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 199  : 		gfxu::Uniforms::MMS.mult(geom::Matrix::translate(xCam, yCam, zCam));

  01490	0f 28 85 70 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T34[rbp-256]
  01497	0f 29 85 30 01
	00 00		 movaps	 XMMWORD PTR $T23[rbp-256], xmm0
  0149e	0f 28 8d 80 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T34[rbp-240]
  014a5	0f 29 8d 40 01
	00 00		 movaps	 XMMWORD PTR $T23[rbp-240], xmm1
  014ac	0f 28 85 90 03
	00 00		 movaps	 xmm0, XMMWORD PTR $T34[rbp-224]
  014b3	0f 29 85 50 01
	00 00		 movaps	 XMMWORD PTR $T23[rbp-224], xmm0
  014ba	0f 28 8d a0 03
	00 00		 movaps	 xmm1, XMMWORD PTR $T34[rbp-208]
  014c1	0f 29 8d 60 01
	00 00		 movaps	 XMMWORD PTR $T23[rbp-208], xmm1
  014c8	48 8d 95 30 01
	00 00		 lea	 rdx, QWORD PTR $T23[rbp-256]
  014cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  014d6	e8 00 00 00 00	 call	 ?mult@MatrixStack@gfxu@@QEAAXVMatrix@geom@@@Z ; gfxu::MatrixStack::mult
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  014db	48 c7 45 98 00
	00 80 3f	 mov	 QWORD PTR $T3[rbp-256], 1065353216 ; 3f800000H
  014e3	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR $T3[rbp-248], 0
  014ea	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e800000
  014f2	f3 0f 11 45 a4	 movss	 DWORD PTR $T3[rbp-244], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  014f7	48 8b 45 98	 mov	 rax, QWORD PTR $T3[rbp-256]
  014fb	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  01502	48 8b 45 a0	 mov	 rax, QWORD PTR $T3[rbp-248]
  01506	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  0150d	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 201  : 		grid->draw(GL_LINES);

  01514	ba 01 00 00 00	 mov	 edx, 1
  01519	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  01520	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 202  : 
; 203  : 		glDepthFunc(GL_GREATER);

  01525	b9 04 02 00 00	 mov	 ecx, 516		; 00000204H
  0152a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDepthFunc
; File c:\users\glenn\documents\github\wind\project\wind\wind\geometry.cpp

; 16   : {

  01530	48 c7 45 c8 00
	00 80 3f	 mov	 QWORD PTR $T6[rbp-256], 1065353216 ; 3f800000H
  01538	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T6[rbp-248], 0
  0153f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e000000
  01547	f3 0f 11 45 d4	 movss	 DWORD PTR $T6[rbp-244], xmm0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h

; 304  : 			val = value;

  0154c	48 8b 45 c8	 mov	 rax, QWORD PTR $T6[rbp-256]
  01550	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A, rax
  01557	48 8b 45 d0	 mov	 rax, QWORD PTR $T6[rbp-248]
  0155b	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+8, rax

; 305  : 			changed = true;

  01562	c6 05 10 00 00
	00 01		 mov	 BYTE PTR ?color@Uniforms@gfxu@@2V?$Uniform@VVector@geom@@@2@A+16, 1
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 205  : 		grid->draw(GL_LINES);

  01569	ba 01 00 00 00	 mov	 edx, 1
  0156e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  01575	e8 00 00 00 00	 call	 ?draw@VertexStream@gfxu@@QEAAXI@Z ; gfxu::VertexStream::draw

; 206  : 		gfxu::Uniforms::MMS.pop();

  0157a	e8 00 00 00 00	 call	 ?pop@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::pop

; 207  : 		glDepthFunc(GL_LEQUAL);

  0157f	b9 03 02 00 00	 mov	 ecx, 515		; 00000203H
  01584	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDepthFunc
$LN2@tick:

; 208  : 	}
; 209  : 	glDisable(GL_BLEND);

  0158a	b9 e2 0b 00 00	 mov	 ecx, 3042		; 00000be2H
  0158f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDisable

; 210  : 
; 211  : 	glFlush();

  01595	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glFlush
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 879  : 	int error = glGetError();

  0159b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glGetError

; 880  : 	if(error != GL_NO_ERROR)

  015a1	85 c0		 test	 eax, eax
  015a3	74 1e		 je	 SHORT $LN1@tick

; 881  : 	{
; 882  : 		const char* errorString = (const char*)gluErrorString(error);

  015a5	8b c8		 mov	 ecx, eax
  015a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gluErrorString

; 883  : 		GLWindow::instance->postError(errorString, caption);

  015ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294945223
  015b4	48 8b d0	 mov	 rdx, rax
  015b7	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 212  : 	if(gfxu::getError("Graphics thread loop error")) GlobalThread::stop = true;

  015bc	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?stop@GlobalThread@@3_NA, 1 ; GlobalThread::stop
$LN1@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 192  : 	SwapBuffers(hDC);

  015c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  015ca	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  015ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SwapBuffers
  015d4	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1536 : 		if (this->_Myfirst != pointer())

  015d5	48 85 f6	 test	 rsi, rsi
  015d8	74 4d		 je	 SHORT $LN1059@tick
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  015da	48 3b f7	 cmp	 rsi, rdi
  015dd	74 40		 je	 SHORT $LN1070@tick

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  015df	48 83 c6 08	 add	 rsi, 8
$LL1072@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  015e3	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
  015e6	48 85 db	 test	 rbx, rbx
  015e9	74 22		 je	 SHORT $LN1092@tick

; 109  : 		}
; 110  : 
; 111  : 	void _Incwref()
; 112  : 		{	// increment weak reference count
; 113  : 		_MT_INCR(_Ignored, _Weaks);
; 114  : 		}
; 115  : 
; 116  : 	void _Decref()
; 117  : 		{	// decrement use count
; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  015eb	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  015ef	75 17		 jne	 SHORT $LN1155@tick

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  015f1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  015f4	48 8b cb	 mov	 rcx, rbx
  015f7	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  015f9	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  015fd	75 09		 jne	 SHORT $LN1155@tick

; 128  : 			_Delete_this();

  015ff	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  01602	48 8b cb	 mov	 rcx, rbx
  01605	ff 50 08	 call	 QWORD PTR [rax+8]
$LN1155@tick:
  01608	48 8b 7c 24 58	 mov	 rdi, QWORD PTR chunksToRender$[rsp+8]
$LN1092@tick:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  0160d	48 83 c6 10	 add	 rsi, 16
  01611	48 8d 46 f8	 lea	 rax, QWORD PTR [rsi-8]
  01615	48 3b c7	 cmp	 rax, rdi
  01618	75 c9		 jne	 SHORT $LL1072@tick
  0161a	48 8b 74 24 50	 mov	 rsi, QWORD PTR chunksToRender$[rsp]
$LN1070@tick:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  0161f	48 8b ce	 mov	 rcx, rsi
  01622	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1059@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 215  : 	return true;

  01627	b0 01		 mov	 al, 1
  01629	eb 07		 jmp	 SHORT $LN41@tick
$LN1158@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");

  0162b	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError
$LN1151@tick:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 101  : 	if(!gridBuffer.read(commandQueue, bGrid)) return false;

  01630	32 c0		 xor	 al, al
$LN41@tick:

; 216  : }

  01632	48 8b 8d 10 06
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  01639	48 33 cc	 xor	 rcx, rsp
  0163c	e8 00 00 00 00	 call	 __security_check_cookie
  01641	4c 8d 9c 24 40
	07 00 00	 lea	 r11, QWORD PTR [rsp+1856]
  01649	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  0164d	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  01651	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  01655	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  0165a	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  0165f	49 8b e3	 mov	 rsp, r11
  01662	41 5f		 pop	 r15
  01664	41 5e		 pop	 r14
  01666	41 5d		 pop	 r13
  01668	41 5c		 pop	 r12
  0166a	5d		 pop	 rbp
  0166b	c3		 ret	 0
$LN1157@tick:
?tick@RenderThread@@EEAA_NXZ ENDP			; RenderThread::tick
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 80
zCam$ = 104
yCam$ = 108
xCam$ = 112
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
$T6 = 200
$T7 = 224
chunk$8 = 240
event$9 = 256
$T10 = 264
event$11 = 280
event$12 = 288
event$13 = 296
$T14 = 304
$T15 = 336
c$16 = 368
$T17 = 384
$T18 = 392
chunk$19 = 400
chunk$20 = 416
$T21 = 432
$T22 = 496
$T23 = 560
$T24 = 624
$T25 = 688
$T26 = 752
$T27 = 816
$T28 = 880
$T29 = 944
$T30 = 1008
$T31 = 1024
$T32 = 1048
$T33 = 1072
$T34 = 1136
$T35 = 1200
$T36 = 1264
$T37 = 1328
projectionMatrix$ = 1392
$T38 = 1456
$T39 = 1520
$T40 = 1584
$T41 = 1648
global_ws_1$ = 1712
local_ws_1$ = 1736
global_ws_2$ = 1760
local_ws_2$ = 1784
__$ArrayPad$ = 1808
this$ = 1904
?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$2
  00000	48 8d 8a 70 01
	00 00		 lea	 rcx, QWORD PTR c$16[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$2@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 80
zCam$ = 104
yCam$ = 108
xCam$ = 112
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
$T6 = 200
$T7 = 224
chunk$8 = 240
event$9 = 256
$T10 = 264
event$11 = 280
event$12 = 288
event$13 = 296
$T14 = 304
$T15 = 336
c$16 = 368
$T17 = 384
$T18 = 392
chunk$19 = 400
chunk$20 = 416
$T21 = 432
$T22 = 496
$T23 = 560
$T24 = 624
$T25 = 688
$T26 = 752
$T27 = 816
$T28 = 880
$T29 = 944
$T30 = 1008
$T31 = 1024
$T32 = 1048
$T33 = 1072
$T34 = 1136
$T35 = 1200
$T36 = 1264
$T37 = 1328
projectionMatrix$ = 1392
$T38 = 1456
$T39 = 1520
$T40 = 1584
$T41 = 1648
global_ws_1$ = 1712
local_ws_1$ = 1736
global_ws_2$ = 1760
local_ws_2$ = 1784
__$ArrayPad$ = 1808
this$ = 1904
?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$5
  0000c	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR chunksToRender$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
?dtor$5@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 80
zCam$ = 104
yCam$ = 108
xCam$ = 112
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
$T6 = 200
$T7 = 224
chunk$8 = 240
event$9 = 256
$T10 = 264
event$11 = 280
event$12 = 288
event$13 = 296
$T14 = 304
$T15 = 336
c$16 = 368
$T17 = 384
$T18 = 392
chunk$19 = 400
chunk$20 = 416
$T21 = 432
$T22 = 496
$T23 = 560
$T24 = 624
$T25 = 688
$T26 = 752
$T27 = 816
$T28 = 880
$T29 = 944
$T30 = 1008
$T31 = 1024
$T32 = 1048
$T33 = 1072
$T34 = 1136
$T35 = 1200
$T36 = 1264
$T37 = 1328
projectionMatrix$ = 1392
$T38 = 1456
$T39 = 1520
$T40 = 1584
$T41 = 1648
global_ws_1$ = 1712
local_ws_1$ = 1736
global_ws_2$ = 1760
local_ws_2$ = 1784
__$ArrayPad$ = 1808
this$ = 1904
?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$6
  00018	48 8d 8a f0 00
	00 00		 lea	 rcx, QWORD PTR chunk$8[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$6@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 80
zCam$ = 104
yCam$ = 108
xCam$ = 112
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
$T6 = 200
$T7 = 224
chunk$8 = 240
event$9 = 256
$T10 = 264
event$11 = 280
event$12 = 288
event$13 = 296
$T14 = 304
$T15 = 336
c$16 = 368
$T17 = 384
$T18 = 392
chunk$19 = 400
chunk$20 = 416
$T21 = 432
$T22 = 496
$T23 = 560
$T24 = 624
$T25 = 688
$T26 = 752
$T27 = 816
$T28 = 880
$T29 = 944
$T30 = 1008
$T31 = 1024
$T32 = 1048
$T33 = 1072
$T34 = 1136
$T35 = 1200
$T36 = 1264
$T37 = 1328
projectionMatrix$ = 1392
$T38 = 1456
$T39 = 1520
$T40 = 1584
$T41 = 1648
global_ws_1$ = 1712
local_ws_1$ = 1736
global_ws_2$ = 1760
local_ws_2$ = 1784
__$ArrayPad$ = 1808
this$ = 1904
?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$7
  00024	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR chunk$20[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$7@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
chunksToRender$ = 80
zCam$ = 104
yCam$ = 108
xCam$ = 112
$T1 = 120
$T2 = 136
$T3 = 152
$T4 = 168
$T5 = 184
$T6 = 200
$T7 = 224
chunk$8 = 240
event$9 = 256
$T10 = 264
event$11 = 280
event$12 = 288
event$13 = 296
$T14 = 304
$T15 = 336
c$16 = 368
$T17 = 384
$T18 = 392
chunk$19 = 400
chunk$20 = 416
$T21 = 432
$T22 = 496
$T23 = 560
$T24 = 624
$T25 = 688
$T26 = 752
$T27 = 816
$T28 = 880
$T29 = 944
$T30 = 1008
$T31 = 1024
$T32 = 1048
$T33 = 1072
$T34 = 1136
$T35 = 1200
$T36 = 1264
$T37 = 1328
projectionMatrix$ = 1392
$T38 = 1456
$T39 = 1520
$T40 = 1584
$T41 = 1648
global_ws_1$ = 1712
local_ws_1$ = 1736
global_ws_2$ = 1760
local_ws_2$ = 1784
__$ArrayPad$ = 1808
this$ = 1904
?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA PROC	; `RenderThread::tick'::`1'::dtor$8
  00030	48 8d 8a 90 01
	00 00		 lea	 rcx, QWORD PTR chunk$19[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$shared_ptr@VChunkBase@@@std@@QEAA@XZ ; std::shared_ptr<ChunkBase>::~shared_ptr<ChunkBase>
?dtor$8@?0??tick@RenderThread@@EEAA_NXZ@4HA ENDP	; `RenderThread::tick'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?preStart@RenderThread@@UEAAXXZ
_TEXT	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
error$9 = 56
error$10 = 56
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 208
?preStart@RenderThread@@UEAAXXZ PROC			; RenderThread::preStart, COMDAT

; 219  : {

$LN766:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  00008	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  0000f	48 c7 45 f7 fe
	ff ff ff	 mov	 QWORD PTR $T16[rbp-105], -2
  00017	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0001b	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0001f	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  00023	0f 29 70 e8	 movaps	 XMMWORD PTR [rax-24], xmm6
  00027	0f 29 78 d8	 movaps	 XMMWORD PTR [rax-40], xmm7
  0002b	44 0f 29 40 c8	 movaps	 XMMWORD PTR [rax-56], xmm8
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00037	48 33 c4	 xor	 rax, rsp
  0003a	48 89 45 1f	 mov	 QWORD PTR __$ArrayPad$[rbp-105], rax
; File c:\users\glenn\documents\github\wind\project\wind\wind\opencl.cpp

; 54   : 	cl_int error = 0;

  0003e	33 f6		 xor	 esi, esi
  00040	89 75 cf	 mov	 DWORD PTR error$10[rbp-105], esi

; 55   : 	queue = clCreateCommandQueue(cl::context, cl::device, 0, &error);

  00043	4c 8d 4d cf	 lea	 r9, QWORD PTR error$10[rbp-105]
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?device@cl@@3PEAU_cl_device_id@@EA ; cl::device
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateCommandQueue
  0005e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?commandQueue@@3VCommandQueue@cl@@A, rax

; 56   : 	if(error != CL_SUCCESS)

  00065	39 75 cf	 cmp	 DWORD PTR error$10[rbp-105], esi
  00068	74 15		 je	 SHORT $LN41@preStart

; 57   : 	{
; 58   : 		GLWindow::instance->postError("Could not create command queue", "Command queue creation error");

  0006a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952818
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952817
  00078	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 59   : 		return false;

  0007d	eb 07		 jmp	 SHORT $LN42@preStart
$LN41@preStart:

; 60   : 	}
; 61   : 
; 62   : 	okay = true;

  0007f	c6 05 20 00 00
	00 01		 mov	 BYTE PTR ?commandQueue@@3VCommandQueue@cl@@A+32, 1
$LN42@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00086	48 8d 45 c7	 lea	 rax, QWORD PTR error$2[rbp-105]
  0008a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008f	45 33 c9	 xor	 r9d, r9d
  00092	41 8d 51 04	 lea	 edx, QWORD PTR [r9+4]
  00096	45 8d 41 40	 lea	 r8d, QWORD PTR [r9+64]
  0009a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer
  000a7	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+8, rax

; 281  : 	if(error != CL_SUCCESS)

  000ae	39 75 c7	 cmp	 DWORD PTR error$2[rbp-105], esi
  000b1	74 15		 je	 SHORT $LN44@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  000c1	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  000c6	eb 12		 jmp	 SHORT $LN45@preStart
$LN44@preStart:

; 285  : 	}
; 286  : 
; 287  : 	this->size = size;

  000c8	48 c7 05 10 00
	00 00 40 00 00
	00		 mov	 QWORD PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A+16, 64 ; 00000040H

; 288  : 	okay = true;

  000d3	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?projectionMatrixBuffer@@3VBuffer@cl@@A, 1
$LN45@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  000da	48 8d 45 cf	 lea	 rax, QWORD PTR error$9[rbp-105]
  000de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e3	45 33 c9	 xor	 r9d, r9d
  000e6	41 8d 51 02	 lea	 edx, QWORD PTR [r9+2]
  000ea	41 b8 2d 24 00
	00		 mov	 r8d, 9261		; 0000242dH
  000f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer
  000fd	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+8, rax

; 281  : 	if(error != CL_SUCCESS)

  00104	39 75 cf	 cmp	 DWORD PTR error$9[rbp-105], esi
  00107	74 15		 je	 SHORT $LN47@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  00109	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  00117	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  0011c	eb 12		 jmp	 SHORT $LN48@preStart
$LN47@preStart:

; 285  : 	}
; 286  : 
; 287  : 	this->size = size;

  0011e	48 c7 05 10 00
	00 00 2d 24 00
	00		 mov	 QWORD PTR ?gridBuffer@@3VBuffer@cl@@A+16, 9261 ; 0000242dH

; 288  : 	okay = true;

  00129	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gridBuffer@@3VBuffer@cl@@A, 1
$LN48@preStart:

; 63   : 	return true;
; 64   : }
; 65   : 
; 66   : bool cl::CommandQueue::sync()
; 67   : {
; 68   : 	cl_int error = clWaitForEvents(lastEvents.size(), &lastEvents[0]);
; 69   : 	if(error != CL_SUCCESS)
; 70   : 	{
; 71   : 		GLWindow::instance->postError("Failed to wait for events to finish", "OpenCL sync error");
; 72   : 		return false;
; 73   : 	}
; 74   : 
; 75   : 	for(auto iter = lastEvents.begin(); iter != lastEvents.end(); ++iter)
; 76   : 	{
; 77   : 		error = clReleaseEvent(*iter);
; 78   : 		if(error != CL_SUCCESS)
; 79   : 		{
; 80   : 			GLWindow::instance->postError("Failed to release event", "OpenCL sync error");
; 81   : 			return false;
; 82   : 		}
; 83   : 	}
; 84   : 
; 85   : 	lastEvents.clear();
; 86   : 
; 87   : 	return true;
; 88   : }
; 89   : 
; 90   : void cl::CommandQueue::addSyncEvent(cl_event event)
; 91   : {
; 92   : 	lastEvents.push_back(event);
; 93   : }
; 94   : 
; 95   : cl::Program::Program()
; 96   : 	: okay(false)
; 97   : {
; 98   : 
; 99   : }
; 100  : 
; 101  : cl::Program::Program(std::wstring fileName)
; 102  : 	: okay(false), preparedKernel(0), argIndex(0)
; 103  : {
; 104  : 	create(fileName);
; 105  : }
; 106  : 
; 107  : bool cl::Program::create(std::wstring fileName)
; 108  : {
; 109  : 	cl_int error = 0;
; 110  : 
; 111  : 	std::ifstream file(fileName);
; 112  : 
; 113  : 	if(!file.good())
; 114  : 	{
; 115  : 		GLWindow::instance->postError("Invalid/missing file", "OpenCL program creation error");
; 116  : 		file.close();
; 117  : 		return false;
; 118  : 	}
; 119  : 
; 120  : 	std::string source_str = std::string((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());
; 121  : 	file.close();
; 122  : 	const char* source = source_str.c_str();
; 123  : 
; 124  : 	program = clCreateProgramWithSource(context, 1, &source, NULL, &error);
; 125  : 	if(error != CL_SUCCESS)
; 126  : 	{
; 127  : 		GLWindow::instance->postError("Could not create program", "OpenCL program creation error");
; 128  : 		return false;
; 129  : 	}
; 130  : 
; 131  : 	error = clBuildProgram(program, 1, &device, NULL, NULL, NULL);
; 132  : 	if(error != CL_SUCCESS)
; 133  : 	{
; 134  : 		size_t log_size;
; 135  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &log_size);
; 136  : 		char* log_msg = new char[log_size + 1];
; 137  : 		clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, log_size, log_msg, NULL);
; 138  : 
; 139  : 		GLWindow::instance->postError(log_msg, "OpenCL program compilation error");
; 140  : 
; 141  : 		delete[] log_msg;
; 142  : 		return false;
; 143  : 	}
; 144  : 
; 145  : 	okay = true;
; 146  : 	return true;
; 147  : }
; 148  : 
; 149  : cl::Program::~Program()
; 150  : {
; 151  : 	if(okay)
; 152  : 	{
; 153  : 		cl_int error;
; 154  : 
; 155  : 		for(map<std::string, cl_kernel>::const_iterator iter = kernels.begin(); iter != kernels.end(); ++iter)
; 156  : 		{
; 157  : 			error = clReleaseKernel(iter->second);
; 158  : 			if(error != CL_SUCCESS)
; 159  : 			{
; 160  : 				GLWindow::instance->postError("Could not release kernel", "OpenCL program deletion error");
; 161  : 				return;
; 162  : 			}
; 163  : 		}
; 164  : 		error = clReleaseProgram(program);
; 165  : 		if(error != CL_SUCCESS)
; 166  : 		{
; 167  : 			GLWindow::instance->postError("Could not release program", "OpenCL program deletion error");
; 168  : 		}
; 169  : 	}
; 170  : }
; 171  : 
; 172  : cl_kernel cl::Program::getKernel(std::string kernel)
; 173  : {
; 174  : 	if(!okay) return 0;
; 175  : 	map<std::string, cl_kernel>::iterator it = kernels.find(kernel);
; 176  : 	if(it != kernels.end())
; 177  : 	{
; 178  : 		return it->second;
; 179  : 	}
; 180  : 
; 181  : 	cl_int error = 0;
; 182  : 	cl_kernel k = clCreateKernel(program, kernel.c_str(), &error);
; 183  : 
; 184  : 	if(error == CL_SUCCESS)
; 185  : 	{
; 186  : 		kernels[kernel] = k;
; 187  : 		return k;
; 188  : 	}
; 189  : 
; 190  : 	GLWindow::instance->postError("Tried to use nonexistant kernel", "OpenCL kernel error");
; 191  : 	return 0;
; 192  : }
; 193  : 
; 194  : bool cl::Program::prepare(std::string kernel)
; 195  : {
; 196  : 	cl_kernel k = getKernel(kernel);
; 197  : 
; 198  : 	if(k)
; 199  : 	{
; 200  : 		mut.lock();
; 201  : 		preparedKernel = k;
; 202  : 		argIndex = 0;
; 203  : 		return true;
; 204  : 	}
; 205  : 	else
; 206  : 	{
; 207  : 		GLWindow::instance->postError("Could not prepare kernel for execution", "OpenCL kernel error");
; 208  : 		return false;
; 209  : 	}
; 210  : }
; 211  : 
; 212  : bool cl::Program::setArgument(size_t size, const void* value)
; 213  : {
; 214  : 	if(!preparedKernel)
; 215  : 	{
; 216  : 		GLWindow::instance->postError("Tried to set argument for unprepared kernel", "OpenCL kernel argument error");
; 217  : 		return false;
; 218  : 	}
; 219  : 	cl_int error = clSetKernelArg(preparedKernel, argIndex++, size, value);
; 220  : 	if(error != CL_SUCCESS)
; 221  : 	{
; 222  : 		GLWindow::instance->postError("Failed to set kernel argument", "OpenCL kernel argument error");
; 223  : 		return false;
; 224  : 	}
; 225  : 	return true;
; 226  : }
; 227  : 
; 228  : bool cl::Program::setArgument(size_t size, Buffer* value)
; 229  : {
; 230  : 	return setArgument(size, &value->mem);
; 231  : }
; 232  : 
; 233  : bool cl::Program::invoke(CommandQueue& queue, cl_uint dimensions, const size_t* globalWorkSize, const size_t* localWorkSize)
; 234  : {
; 235  : 	if(!preparedKernel)
; 236  : 	{
; 237  : 		GLWindow::instance->postError("Tried to execute unprepared kernel", "OpenCL program execution error");
; 238  : 		return false;
; 239  : 	}
; 240  : 
; 241  : 	cl_int error;
; 242  : 	cl_event event;
; 243  : 
; 244  : 	error = clEnqueueNDRangeKernel(queue.queue, preparedKernel, dimensions, NULL, globalWorkSize, localWorkSize, 0, NULL, &event);
; 245  : 	if(error != CL_SUCCESS)
; 246  : 	{
; 247  : 		GLWindow::instance->postError("Failed to exectue kernel", "OpenCL program execution error");
; 248  : 		return false;
; 249  : 	}
; 250  : 
; 251  : 	queue.addSyncEvent(event);
; 252  : 
; 253  : 	preparedKernel = 0;
; 254  : 	mut.unlock();
; 255  : 
; 256  : 	return true;
; 257  : }
; 258  : 
; 259  : cl::Buffer::Buffer()
; 260  : 	: okay(false)
; 261  : {
; 262  : 
; 263  : }
; 264  : 
; 265  : cl::Buffer::~Buffer()
; 266  : {
; 267  : 	if(okay)
; 268  : 	{
; 269  : 		cl_int error = clReleaseMemObject(mem);
; 270  : 		if(error != CL_SUCCESS)
; 271  : 		{
; 272  : 			GLWindow::instance->postError("Failed to delete buffer", "OpenCL buffer deletion error");
; 273  : 		}
; 274  : 	}
; 275  : }
; 276  : 
; 277  : bool cl::Buffer::create(size_t size, int flags, void* data)
; 278  : {
; 279  : 	cl_int error;
; 280  : 	mem = clCreateBuffer(context, flags, size, data, &error);

  00130	48 8d 45 c7	 lea	 rax, QWORD PTR error$1[rbp-105]
  00134	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00139	45 33 c9	 xor	 r9d, r9d
  0013c	41 8d 51 01	 lea	 edx, QWORD PTR [r9+1]
  00140	41 b8 98 29 00
	00		 mov	 r8d, 10648		; 00002998H
  00146	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?context@cl@@3PEAU_cl_context@@EA ; cl::context
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clCreateBuffer
  00153	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?boolBuffer@@3VBuffer@cl@@A+8, rax

; 281  : 	if(error != CL_SUCCESS)

  0015a	39 75 c7	 cmp	 DWORD PTR error$1[rbp-105], esi
  0015d	74 15		 je	 SHORT $LN50@preStart

; 282  : 	{
; 283  : 		GLWindow::instance->postError("Failed to create buffer", "OpenCL buffer creation error");

  0015f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG4294952789
  00166	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294952788
  0016d	e8 00 00 00 00	 call	 ?postError@GLWindow@@QEAAXPEBD0@Z ; GLWindow::postError

; 284  : 		return false;

  00172	eb 12		 jmp	 SHORT $LN51@preStart
$LN50@preStart:

; 285  : 	}
; 286  : 
; 287  : 	this->size = size;

  00174	48 c7 05 10 00
	00 00 98 29 00
	00		 mov	 QWORD PTR ?boolBuffer@@3VBuffer@cl@@A+16, 10648 ; 00002998H

; 288  : 	okay = true;

  0017f	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?boolBuffer@@3VBuffer@cl@@A, 1
$LN51@preStart:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00186	48 c7 45 17 07
	00 00 00	 mov	 QWORD PTR filePath$[rbp-81], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0018e	48 89 75 0f	 mov	 QWORD PTR filePath$[rbp-89], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00192	66 89 75 ff	 mov	 WORD PTR filePath$[rbp-105], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  00196	49 83 c9 ff	 or	 r9, -1
  0019a	45 33 c0	 xor	 r8d, r8d
  0019d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  001a4	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  001a8	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
  001ad	90		 npad	 1

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  001ae	41 b8 18 00 00
	00		 mov	 r8d, 24
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294945222
  001bb	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  001bf	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  001c4	48 c7 45 ef 07
	00 00 00	 mov	 QWORD PTR $T15[rbp-81], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  001cc	48 89 75 e7	 mov	 QWORD PTR $T15[rbp-89], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  001d0	66 89 75 d7	 mov	 WORD PTR $T15[rbp-105], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  001d4	49 83 c9 ff	 or	 r9, -1
  001d8	45 33 c0	 xor	 r8d, r8d
  001db	48 8d 55 ff	 lea	 rdx, QWORD PTR filePath$[rbp-105]
  001df	48 8d 4d d7	 lea	 rcx, QWORD PTR $T15[rbp-105]
  001e3	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 229  : 	program.create(filePath);

  001e8	48 8d 55 d7	 lea	 rdx, QWORD PTR $T15[rbp-105]
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?program@@3VProgram@cl@@A ; program
  001f3	e8 00 00 00 00	 call	 ?create@Program@cl@@QEAA_NV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; cl::Program::create

; 230  : 
; 231  : 	grid = new VertexStream();

  001f8	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  001fd	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00202	48 85 c0	 test	 rax, rax
  00205	74 0a		 je	 SHORT $LN10@preStart
  00207	48 8b c8	 mov	 rcx, rax
  0020a	e8 00 00 00 00	 call	 ??0VertexStream@gfxu@@QEAA@XZ ; gfxu::VertexStream::VertexStream
  0020f	eb 03		 jmp	 SHORT $LN11@preStart
$LN10@preStart:
  00211	48 8b c6	 mov	 rax, rsi
$LN11@preStart:
  00214	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA, rax ; grid

; 232  : 	for(int i = -8; i <= 8; i++)

  0021b	bb f8 ff ff ff	 mov	 ebx, -8
  00220	f3 44 0f 10 05
	00 00 00 00	 movss	 xmm8, DWORD PTR __real@41000000
  00229	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@preStart:

; 234  : 		for(int j = -8; j <= 8; j++)

  00230	bf f8 ff ff ff	 mov	 edi, -8
  00235	66 0f 6e fb	 movd	 xmm7, ebx
  00239	0f 5b ff	 cvtdq2ps xmm7, xmm7
  0023c	0f 1f 40 00	 npad	 4
$LL4@preStart:
  00240	66 0f 6e f7	 movd	 xmm6, edi

; 235  : 		{
; 236  : 			grid->put(Vertex(i, j, -8));

  00244	0f 5b f6	 cvtdq2ps xmm6, xmm6
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x + translation.x;

  00247	48 8d 50 38	 lea	 rdx, QWORD PTR [rax+56]
  0024b	0f 28 c7	 movaps	 xmm0, xmm7
  0024e	f3 0f 58 40 20	 addss	 xmm0, DWORD PTR [rax+32]
  00253	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00257	0f 28 ce	 movaps	 xmm1, xmm6
  0025a	f3 0f 58 48 24	 addss	 xmm1, DWORD PTR [rax+36]
  0025f	f3 0f 11 48 3c	 movss	 DWORD PTR [rax+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  00264	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [rax+40]
  00269	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  0026e	f3 0f 11 40 40	 movss	 DWORD PTR [rax+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00273	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00277	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  0027c	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00282	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  00289	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  0028d	0f 28 c7	 movaps	 xmm0, xmm7
  00290	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  00295	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00299	0f 28 ce	 movaps	 xmm1, xmm6
  0029c	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  002a1	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  002a6	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  002ab	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  002b0	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  002b5	48 83 c1 08	 add	 rcx, 8
  002b9	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  002be	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  002c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  002cb	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  002cf	0f 28 c7	 movaps	 xmm0, xmm7
  002d2	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  002d7	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  002db	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  002e0	f3 41 0f 5c c8	 subss	 xmm1, xmm8
  002e5	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  002ea	0f 28 c6	 movaps	 xmm0, xmm6
  002ed	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  002f2	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  002f7	48 83 c1 08	 add	 rcx, 8
  002fb	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00300	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00306	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0030d	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00311	0f 28 c7	 movaps	 xmm0, xmm7
  00314	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [rcx+32]
  00319	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  0031d	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00322	f3 41 0f 58 c8	 addss	 xmm1, xmm8
  00327	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  0032c	0f 28 c6	 movaps	 xmm0, xmm6
  0032f	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  00334	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00339	48 83 c1 08	 add	 rcx, 8
  0033d	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00342	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  00348	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  0034f	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00353	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  00358	f3 41 0f 5c c0	 subss	 xmm0, xmm8
  0035d	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00361	0f 28 cf	 movaps	 xmm1, xmm7
  00364	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  00369	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  0036e	0f 28 c6	 movaps	 xmm0, xmm6
  00371	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [rcx+40]
  00376	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  0037b	48 83 c1 08	 add	 rcx, 8
  0037f	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00384	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  0038a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  00391	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00395	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  0039a	f3 41 0f 58 c0	 addss	 xmm0, xmm8
  0039f	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  003a3	0f 28 cf	 movaps	 xmm1, xmm7
  003a6	f3 0f 58 49 24	 addss	 xmm1, DWORD PTR [rcx+36]
  003ab	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  003b0	f3 0f 58 71 28	 addss	 xmm6, DWORD PTR [rcx+40]
  003b5	f3 0f 11 71 40	 movss	 DWORD PTR [rcx+64], xmm6

; 111  : 
; 112  : 	vertices.push_back(vertex);

  003ba	48 83 c1 08	 add	 rcx, 8
  003be	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  003c3	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 234  : 		for(int j = -8; j <= 8; j++)

  003c9	ff c7		 inc	 edi
  003cb	83 ff 08	 cmp	 edi, 8
  003ce	7f 0c		 jg	 SHORT $LN764@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 19   : {}

  003d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  003d7	e9 64 fe ff ff	 jmp	 $LL4@preStart
$LN764@preStart:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 232  : 	for(int i = -8; i <= 8; i++)

  003dc	ff c3		 inc	 ebx
  003de	83 fb 08	 cmp	 ebx, 8
  003e1	7f 0c		 jg	 SHORT $LN765@preStart
  003e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  003ea	e9 41 fe ff ff	 jmp	 $LL7@preStart
$LN765@preStart:

; 245  : 	square = new VertexStream();

  003ef	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  003f4	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  003f9	48 8b d8	 mov	 rbx, rax
  003fc	48 85 c0	 test	 rax, rax
  003ff	74 54		 je	 SHORT $LN12@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 91   : {

  00401	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7VertexStream@gfxu@@6B@
  00408	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 486  : 		_Myfirst = pointer();

  0040b	48 89 73 08	 mov	 QWORD PTR [rbx+8], rsi

; 487  : 		_Mylast = pointer();

  0040f	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 488  : 		_Myend = pointer();

  00413	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 19   : {}

  00417	48 89 73 20	 mov	 QWORD PTR [rbx+32], rsi
  0041b	89 73 28	 mov	 DWORD PTR [rbx+40], esi

; 20   : Vertex::Vertex(const Vertex& v)
; 21   : 	: x(v.x), y(v.y), z(v.z)
; 22   : {}
; 23   : Vertex::Vertex(const VertexUV& v)
; 24   : 	: x(v.x), y(v.y), z(v.z)
; 25   : {}
; 26   : Vertex::Vertex(const VertexRGBA& v)
; 27   : 	: x(v.x), y(v.y), z(v.z)
; 28   : {}
; 29   : Vertex::Vertex(const VertexUVRGBA& v)
; 30   : 	: x(v.x), y(v.y), z(v.z)
; 31   : {}
; 32   : 
; 33   : VertexUV::VertexUV(float x, float y, float z, float u, float v)
; 34   : 	: x(x), y(y), z(z), u(u), v(v)
; 35   : {}
; 36   : VertexUV::VertexUV(const Vertex& v)
; 37   : 	: x(v.x), y(v.y), z(v.z), u(0.0f), v(0.0f)
; 38   : {}
; 39   : VertexUV::VertexUV(const VertexUV& v)
; 40   : 	: x(v.x), y(v.y), z(v.z), u(v.u), v(v.v)
; 41   : {}
; 42   : VertexUV::VertexUV(const VertexRGBA& v)
; 43   : 	: x(v.x), y(v.y), z(v.z), u(0.0f), v(0.0f)
; 44   : {}
; 45   : VertexUV::VertexUV(const VertexUVRGBA& v)
; 46   : 	: x(v.x), y(v.y), z(v.z), u(v.u), v(v.v)
; 47   : {}
; 48   : 
; 49   : VertexRGBA::VertexRGBA(float x, float y, float z, float r, float g, float b, float a)
; 50   : 	: x(x), y(y), z(z), r(r * 255.0f), g(g * 255.0f), b(b * 255.0f), a(a * 255.0f)
; 51   : {}
; 52   : VertexRGBA::VertexRGBA(float x, float y, float z, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
; 53   : 	: x(x), y(y), z(z), r(r), g(g), b(b), a(a)
; 54   : {}
; 55   : VertexRGBA::VertexRGBA(const Vertex& v)
; 56   : 	: x(v.x), y(v.y), z(v.z), r(255), g(255), b(255), a(255)
; 57   : {}
; 58   : VertexRGBA::VertexRGBA(const VertexUV& v)
; 59   : 	: x(v.x), y(v.y), z(v.z), r(255), g(255), b(255), a(255)
; 60   : {}
; 61   : VertexRGBA::VertexRGBA(const VertexRGBA& v)
; 62   : 	: x(v.x), y(v.y), z(v.z), r(v.r), g(v.g), b(v.b), a(v.a)
; 63   : {}
; 64   : VertexRGBA::VertexRGBA(const VertexUVRGBA& v)
; 65   : 	: x(v.x), y(v.y), z(v.z), r(v.r), g(v.g), b(v.b), a(v.a)
; 66   : {}
; 67   : 
; 68   : VertexUVRGBA::VertexUVRGBA(float x, float y, float z, float u, float v, float r, float g, float b, float a)
; 69   : 	: x(x), y(y), z(z), u(u), v(v), r(r * 255.0f), g(g * 255.0f), b(b * 255.0f), a(a * 255.0f)
; 70   : {}

  0041e	48 89 73 38	 mov	 QWORD PTR [rbx+56], rsi
  00422	48 89 73 40	 mov	 QWORD PTR [rbx+64], rsi
  00426	89 73 48	 mov	 DWORD PTR [rbx+72], esi
  00429	c7 43 4c ff ff
	ff ff		 mov	 DWORD PTR [rbx+76], -1	; ffffffffH

; 91   : {

  00430	66 c7 43 58 00
	00		 mov	 WORD PTR [rbx+88], 0
  00436	c6 43 5a 00	 mov	 BYTE PTR [rbx+90], 0
  0043a	48 8d 4b 60	 lea	 rcx, QWORD PTR [rbx+96]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\thr\xthread

; 63   : 	return (_Check_C_return(_Mtx_init(_Mtx, _Type)));

  0043e	ba 02 00 00 00	 mov	 edx, 2
  00443	e8 00 00 00 00	 call	 _Mtx_init

; 32   : 	if (_Res != _Thrd_success)

  00448	85 c0		 test	 eax, eax
  0044a	74 0c		 je	 SHORT $LN13@preStart

; 33   : 		_Throw_C_error(_Res);

  0044c	8b c8		 mov	 ecx, eax
  0044e	e8 00 00 00 00	 call	 ?_Throw_C_error@std@@YAXH@Z ; std::_Throw_C_error
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 245  : 	square = new VertexStream();

  00453	eb 03		 jmp	 SHORT $LN13@preStart
$LN12@preStart:
  00455	48 8b de	 mov	 rbx, rsi
$LN13@preStart:
  00458	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA, rbx ; square
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 108  : 	vertex.x = x + translation.x;

  0045f	48 8d 53 38	 lea	 rdx, QWORD PTR [rbx+56]
  00463	f3 0f 10 43 20	 movss	 xmm0, DWORD PTR [rbx+32]
  00468	0f 57 f6	 xorps	 xmm6, xmm6
  0046b	f3 0f 58 c6	 addss	 xmm0, xmm6
  0046f	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00473	f3 0f 10 43 24	 movss	 xmm0, DWORD PTR [rbx+36]
  00478	f3 0f 58 c6	 addss	 xmm0, xmm6
  0047c	f3 0f 11 43 3c	 movss	 DWORD PTR [rbx+60], xmm0

; 110  : 	vertex.z = z + translation.z;

  00481	f3 0f 10 4b 28	 movss	 xmm1, DWORD PTR [rbx+40]
  00486	f3 0f 58 ce	 addss	 xmm1, xmm6
  0048a	f3 0f 11 4b 40	 movss	 DWORD PTR [rbx+64], xmm1

; 111  : 
; 112  : 	vertices.push_back(vertex);

  0048f	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  00493	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00498	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  0049e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  004a5	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  004a9	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  004ae	f3 0f 10 3d 00
	00 00 00	 movss	 xmm7, DWORD PTR __real@3f800000
  004b6	f3 0f 58 c7	 addss	 xmm0, xmm7
  004ba	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  004be	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  004c3	f3 0f 58 ce	 addss	 xmm1, xmm6
  004c7	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  004cc	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  004d1	f3 0f 58 c6	 addss	 xmm0, xmm6
  004d5	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  004da	48 83 c1 08	 add	 rcx, 8
  004de	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  004e3	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  004e9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  004f0	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  004f4	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  004f9	f3 0f 58 c7	 addss	 xmm0, xmm7
  004fd	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00501	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00506	f3 0f 58 ce	 addss	 xmm1, xmm6
  0050a	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  0050f	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  00514	f3 0f 58 c7	 addss	 xmm0, xmm7
  00518	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  0051d	48 83 c1 08	 add	 rcx, 8
  00521	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00526	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  0052c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  00533	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  00537	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  0053c	f3 0f 58 c7	 addss	 xmm0, xmm7
  00540	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00544	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  00549	f3 0f 58 ce	 addss	 xmm1, xmm6
  0054d	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  00552	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  00557	f3 0f 58 c7	 addss	 xmm0, xmm7
  0055b	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  00560	48 83 c1 08	 add	 rcx, 8
  00564	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  00569	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  0056f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  00576	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  0057a	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  0057f	f3 0f 58 c6	 addss	 xmm0, xmm6
  00583	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  00587	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  0058c	f3 0f 58 ce	 addss	 xmm1, xmm6
  00590	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  00595	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  0059a	f3 0f 58 c7	 addss	 xmm0, xmm7
  0059e	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  005a3	48 83 c1 08	 add	 rcx, 8
  005a7	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  005ac	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs

; 108  : 	vertex.x = x + translation.x;

  005b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  005b9	48 8d 51 38	 lea	 rdx, QWORD PTR [rcx+56]
  005bd	f3 0f 10 41 20	 movss	 xmm0, DWORD PTR [rcx+32]
  005c2	f3 0f 58 c6	 addss	 xmm0, xmm6
  005c6	f3 0f 11 02	 movss	 DWORD PTR [rdx], xmm0

; 109  : 	vertex.y = y + translation.y;

  005ca	f3 0f 10 49 24	 movss	 xmm1, DWORD PTR [rcx+36]
  005cf	f3 0f 58 ce	 addss	 xmm1, xmm6
  005d3	f3 0f 11 49 3c	 movss	 DWORD PTR [rcx+60], xmm1

; 110  : 	vertex.z = z + translation.z;

  005d8	f3 0f 10 41 28	 movss	 xmm0, DWORD PTR [rcx+40]
  005dd	f3 0f 58 c6	 addss	 xmm0, xmm6
  005e1	f3 0f 11 41 40	 movss	 DWORD PTR [rcx+64], xmm0

; 111  : 
; 112  : 	vertices.push_back(vertex);

  005e6	48 83 c1 08	 add	 rcx, 8
  005ea	e8 00 00 00 00	 call	 ?push_back@?$vector@VVertexUVRGBA@gfxu@@V?$allocator@VVertexUVRGBA@gfxu@@@std@@@std@@QEAAXAEBVVertexUVRGBA@gfxu@@@Z ; std::vector<gfxu::VertexUVRGBA,std::allocator<gfxu::VertexUVRGBA> >::push_back

; 113  : 
; 114  : 	vs++;

  005ef	ff 05 00 00 00
	00		 inc	 DWORD PTR ?vs@@3HA	; vs
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 253  : 	GLWindow::instance->initGL();

  005f5	e8 00 00 00 00	 call	 ?initGL@GLWindow@@QEAAXXZ ; GLWindow::initGL
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 202  : 	return OK;

  005fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 255  : 	if(!GLWindow::instance->isOK())

  00601	80 38 00	 cmp	 BYTE PTR [rax], 0
  00604	0f 84 e3 02 00
	00		 je	 $LN40@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  0060a	49 83 c9 ff	 or	 r9, -1
  0060e	45 33 c0	 xor	 r8d, r8d
  00611	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  00618	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  0061c	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00621	41 b8 14 00 00
	00		 mov	 r8d, 20
  00627	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294945221
  0062e	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  00632	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 262  : 	normalVShader = new gfxu::VertexShader(filePath);

  00637	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0063c	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00641	48 8b d8	 mov	 rbx, rax
  00644	48 89 45 c7	 mov	 QWORD PTR $T8[rbp-105], rax
  00648	48 85 c0	 test	 rax, rax
  0064b	74 32		 je	 SHORT $LN14@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  0064d	48 c7 45 ef 07
	00 00 00	 mov	 QWORD PTR $T14[rbp-81], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00655	48 89 75 e7	 mov	 QWORD PTR $T14[rbp-89], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  00659	66 89 75 d7	 mov	 WORD PTR $T14[rbp-105], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  0065d	49 83 c9 ff	 or	 r9, -1
  00661	45 33 c0	 xor	 r8d, r8d
  00664	48 8d 55 ff	 lea	 rdx, QWORD PTR filePath$[rbp-105]
  00668	48 8d 4d d7	 lea	 rcx, QWORD PTR $T14[rbp-105]
  0066c	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 262  : 	normalVShader = new gfxu::VertexShader(filePath);

  00671	48 8d 55 d7	 lea	 rdx, QWORD PTR $T14[rbp-105]
  00675	48 8b cb	 mov	 rcx, rbx
  00678	e8 00 00 00 00	 call	 ??0VertexShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::VertexShader::VertexShader
  0067d	eb 03		 jmp	 SHORT $LN15@preStart
$LN14@preStart:
  0067f	48 8b c6	 mov	 rax, rsi
$LN15@preStart:
  00682	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA, rax ; normalVShader
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  00689	49 83 c9 ff	 or	 r9, -1
  0068d	45 33 c0	 xor	 r8d, r8d
  00690	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  00697	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  0069b	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  006a0	41 b8 14 00 00
	00		 mov	 r8d, 20
  006a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294945220
  006ad	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  006b1	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 266  : 	normalFShader = new gfxu::FragmentShader(filePath);

  006b6	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  006bb	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  006c0	48 8b d8	 mov	 rbx, rax
  006c3	48 89 45 c7	 mov	 QWORD PTR $T7[rbp-105], rax
  006c7	48 85 c0	 test	 rax, rax
  006ca	74 32		 je	 SHORT $LN16@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  006cc	48 c7 45 ef 07
	00 00 00	 mov	 QWORD PTR $T13[rbp-81], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  006d4	48 89 75 e7	 mov	 QWORD PTR $T13[rbp-89], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  006d8	66 89 75 d7	 mov	 WORD PTR $T13[rbp-105], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  006dc	49 83 c9 ff	 or	 r9, -1
  006e0	45 33 c0	 xor	 r8d, r8d
  006e3	48 8d 55 ff	 lea	 rdx, QWORD PTR filePath$[rbp-105]
  006e7	48 8d 4d d7	 lea	 rcx, QWORD PTR $T13[rbp-105]
  006eb	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 266  : 	normalFShader = new gfxu::FragmentShader(filePath);

  006f0	48 8d 55 d7	 lea	 rdx, QWORD PTR $T13[rbp-105]
  006f4	48 8b cb	 mov	 rcx, rbx
  006f7	e8 00 00 00 00	 call	 ??0FragmentShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::FragmentShader::FragmentShader
  006fc	eb 03		 jmp	 SHORT $LN17@preStart
$LN16@preStart:
  006fe	48 8b c6	 mov	 rax, rsi
$LN17@preStart:
  00701	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA, rax ; normalFShader

; 268  : 	normalShaderProgram = new gfxu::ShaderProgram(normalVShader, nullptr, normalFShader);

  00708	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0070d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00712	48 8b d8	 mov	 rbx, rax
  00715	48 89 45 c7	 mov	 QWORD PTR $T6[rbp-105], rax
  00719	48 85 c0	 test	 rax, rax
  0071c	74 27		 je	 SHORT $LN18@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 397  : {

  0071e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA ; normalVShader
  00725	48 89 08	 mov	 QWORD PTR [rax], rcx
  00728	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
  0072c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA ; normalFShader
  00733	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  00737	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 398  : 	create();

  0073b	48 8b c8	 mov	 rcx, rax
  0073e	e8 00 00 00 00	 call	 ?create@ShaderProgram@gfxu@@AEAA_NXZ ; gfxu::ShaderProgram::create
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 268  : 	normalShaderProgram = new gfxu::ShaderProgram(normalVShader, nullptr, normalFShader);

  00743	eb 03		 jmp	 SHORT $LN19@preStart
$LN18@preStart:
  00745	48 8b de	 mov	 rbx, rsi
$LN19@preStart:
  00748	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA, rbx ; normalShaderProgram
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  0074f	49 83 c9 ff	 or	 r9, -1
  00753	45 33 c0	 xor	 r8d, r8d
  00756	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  0075d	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  00761	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  00766	41 b8 13 00 00
	00		 mov	 r8d, 19
  0076c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294945219
  00773	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  00777	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 272  : 	noTexVShader = new gfxu::VertexShader(filePath);

  0077c	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00781	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00786	48 8b d8	 mov	 rbx, rax
  00789	48 89 45 c7	 mov	 QWORD PTR $T5[rbp-105], rax
  0078d	48 85 c0	 test	 rax, rax
  00790	74 32		 je	 SHORT $LN20@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00792	48 c7 45 ef 07
	00 00 00	 mov	 QWORD PTR $T12[rbp-81], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  0079a	48 89 75 e7	 mov	 QWORD PTR $T12[rbp-89], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0079e	66 89 75 d7	 mov	 WORD PTR $T12[rbp-105], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  007a2	49 83 c9 ff	 or	 r9, -1
  007a6	45 33 c0	 xor	 r8d, r8d
  007a9	48 8d 55 ff	 lea	 rdx, QWORD PTR filePath$[rbp-105]
  007ad	48 8d 4d d7	 lea	 rcx, QWORD PTR $T12[rbp-105]
  007b1	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 272  : 	noTexVShader = new gfxu::VertexShader(filePath);

  007b6	48 8d 55 d7	 lea	 rdx, QWORD PTR $T12[rbp-105]
  007ba	48 8b cb	 mov	 rcx, rbx
  007bd	e8 00 00 00 00	 call	 ??0VertexShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::VertexShader::VertexShader
  007c2	eb 03		 jmp	 SHORT $LN21@preStart
$LN20@preStart:
  007c4	48 8b c6	 mov	 rax, rsi
$LN21@preStart:
  007c7	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA, rax ; noTexVShader
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 1099 : 		return (assign(_Right, 0, npos));

  007ce	49 83 c9 ff	 or	 r9, -1
  007d2	45 33 c0	 xor	 r8d, r8d
  007d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?EXE_DIR@IOUtil@@3V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@A ; IOUtil::EXE_DIR
  007dc	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  007e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 736  : 		}
; 737  : 
; 738  :  #if _HAS_CPP0X
; 739  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 740  : 		: _Mybase(_Al)
; 741  : 		{	// construct by copying with allocator
; 742  : 		_Tidy();
; 743  : 		assign(_Right, 0, npos);
; 744  : 		}
; 745  :  #endif /* _HAS_CPP0X */
; 746  : 
; 747  : 	basic_string()
; 748  : 		: _Mybase()
; 749  : 		{	// construct empty string
; 750  : 		_Tidy();
; 751  : 		}
; 752  : 
; 753  : 	explicit basic_string(const _Alloc& _Al)
; 754  : 		: _Mybase(_Al)
; 755  : 		{	// construct empty string with allocator
; 756  : 		_Tidy();
; 757  : 		}
; 758  : 
; 759  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 760  : 		size_type _Count = npos)
; 761  : 		: _Mybase(_Right._Getal())
; 762  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 763  : 		_Tidy();
; 764  : 		assign(_Right, _Roff, _Count);
; 765  : 		}
; 766  : 
; 767  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 768  : 		const _Alloc& _Al)
; 769  : 		: _Mybase(_Al)
; 770  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 771  : 		_Tidy();
; 772  : 		assign(_Right, _Roff, _Count);
; 773  : 		}
; 774  : 
; 775  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 776  : 		: _Mybase()
; 777  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 778  : 		_Tidy();
; 779  : 		assign(_Ptr, _Count);
; 780  : 		}
; 781  : 
; 782  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 783  : 		: _Mybase(_Al)
; 784  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 785  : 		_Tidy();
; 786  : 		assign(_Ptr, _Count);
; 787  : 		}
; 788  : 
; 789  : 	basic_string(const _Elem *_Ptr)
; 790  : 		: _Mybase()
; 791  : 		{	// construct from [_Ptr, <null>)
; 792  : 		_Tidy();
; 793  : 		assign(_Ptr);
; 794  : 		}
; 795  : 
; 796  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 797  : 		: _Mybase(_Al)
; 798  : 		{	// construct from [_Ptr, <null>) with allocator
; 799  : 		_Tidy();
; 800  : 		assign(_Ptr);
; 801  : 		}
; 802  : 
; 803  : 	basic_string(size_type _Count, _Elem _Ch)
; 804  : 		: _Mybase()
; 805  : 		{	// construct from _Count * _Ch
; 806  : 		_Tidy();
; 807  : 		assign(_Count, _Ch);
; 808  : 		}
; 809  : 
; 810  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 811  : 		: _Mybase(_Al)
; 812  : 		{	// construct from _Count * _Ch with allocator
; 813  : 		_Tidy();
; 814  : 		assign(_Count, _Ch);
; 815  : 		}
; 816  : 
; 817  : 	template<class _Iter>
; 818  : 		basic_string(_Iter _First, _Iter _Last,
; 819  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 820  : 				void>::type ** = 0)
; 821  : 		: _Mybase()
; 822  : 		{	// construct from [_First, _Last)
; 823  : 		_Tidy();
; 824  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 825  : 		}
; 826  : 
; 827  : 	template<class _Iter>
; 828  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al,
; 829  : 			typename enable_if<_Is_iterator<_Iter>::value,
; 830  : 				void>::type ** = 0)
; 831  : 		: _Mybase(_Al)
; 832  : 		{	// construct from [_First, _Last) with allocator
; 833  : 		_Tidy();
; 834  : 		_Construct(_First, _Last, _Iter_cat(_First));
; 835  : 		}
; 836  : 
; 837  : 	template<class _Iter>
; 838  : 		void _Construct(_Iter _First,
; 839  : 			_Iter _Last, input_iterator_tag)
; 840  : 		{	// initialize from [_First, _Last), input iterators
; 841  : 		_TRY_BEGIN
; 842  : 		for (; _First != _Last; ++_First)
; 843  : 			append((size_type)1, (_Elem)*_First);
; 844  : 		_CATCH_ALL
; 845  : 		_Tidy(true);
; 846  : 		_RERAISE;
; 847  : 		_CATCH_END
; 848  : 		}
; 849  : 
; 850  : 	template<class _Iter>
; 851  : 		void _Construct(_Iter _First,
; 852  : 			_Iter _Last, forward_iterator_tag)
; 853  : 		{	// initialize from [_First, _Last), forward iterators
; 854  : 		_DEBUG_RANGE(_First, _Last);
; 855  : 		size_type _Count = 0;
; 856  : 		_Distance(_First, _Last, _Count);
; 857  : 		reserve(_Count);
; 858  : 
; 859  : 		_TRY_BEGIN
; 860  : 		for (; _First != _Last; ++_First)
; 861  : 			append((size_type)1, (_Elem)*_First);
; 862  : 		_CATCH_ALL
; 863  : 		_Tidy(true);
; 864  : 		_RERAISE;
; 865  : 		_CATCH_END
; 866  : 		}
; 867  : 
; 868  : 	basic_string(const_pointer _First, const_pointer _Last)
; 869  : 		: _Mybase()
; 870  : 		{	// construct from [_First, _Last), const pointers
; 871  : 		_DEBUG_RANGE(_First, _Last);
; 872  : 		_Tidy();
; 873  : 		if (_First != _Last)
; 874  : 			assign(&*_First, _Last - _First);
; 875  : 		}
; 876  : 
; 877  : 	basic_string(const_pointer _First, const_pointer _Last,
; 878  : 		const _Alloc& _Al)
; 879  : 		: _Mybase(_Al)
; 880  : 		{	// construct from [_First, _Last), const pointers
; 881  : 		_DEBUG_RANGE(_First, _Last);
; 882  : 		_Tidy();
; 883  : 		if (_First != _Last)
; 884  : 			assign(&*_First, _Last - _First);
; 885  : 		}
; 886  : 
; 887  : 	basic_string(const_iterator _First, const_iterator _Last)
; 888  : 		: _Mybase()
; 889  : 		{	// construct from [_First, _Last), const_iterators
; 890  : 		_DEBUG_RANGE(_First, _Last);
; 891  : 		_Tidy();
; 892  : 		if (_First != _Last)
; 893  : 			assign(&*_First, _Last - _First);
; 894  : 		}
; 895  : 
; 896  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 897  : 		: _Mybase(_Right._Getal())
; 898  : 		{	// construct by moving _Right
; 899  : 		_Tidy();
; 900  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 901  : 		}
; 902  : 
; 903  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 904  : 		: _Mybase(_Al)
; 905  : 		{	// construct by moving _Right, allocator
; 906  : 		if (this->_Getal() != _Right._Getal())
; 907  : 			assign(_Right.begin(), _Right.end());
; 908  : 		else
; 909  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 910  : 		}
; 911  : 
; 912  : 	_Myt& operator=(_Myt&& _Right) _NOEXCEPT
; 913  : 		{	// assign by moving _Right
; 914  : 		if (this != &_Right)
; 915  : 			{	// different, assign it
; 916  : 			_Tidy(true);
; 917  : 
; 918  :  #if _HAS_CPP0X
; 919  : 			if (this->_Getal() != _Right._Getal()
; 920  : 				&& _Alty::propagate_on_container_move_assignment::value)
; 921  : 				this->_Change_alloc(_Right._Getal());
; 922  :  #endif /* _HAS_CPP0X */
; 923  : 
; 924  : 			if (this->_Getal() != _Right._Getal())
; 925  : 				assign(_Right.begin(), _Right.end());
; 926  : 			else
; 927  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 928  : 			}
; 929  : 		return (*this);
; 930  : 		}
; 931  : 
; 932  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 933  : 		{	// assign by moving _Right
; 934  : 		if (this == &_Right)
; 935  : 			;
; 936  : 		else if (get_allocator() != _Right.get_allocator()
; 937  : 			&& this->_BUF_SIZE <= _Right._Myres)
; 938  : 			*this = _Right;
; 939  : 		else
; 940  : 			{	// not same, clear this and steal from _Right
; 941  : 			_Tidy(true);
; 942  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 943  : 			}
; 944  : 		return (*this);
; 945  : 		}
; 946  : 
; 947  : 	void _Assign_rv(_Myt&& _Right)
; 948  : 		{	// assign by moving _Right
; 949  : 		if (_Right._Myres < this->_BUF_SIZE)
; 950  : 			_Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
; 951  : 				_Right._Mysize + 1);
; 952  : 		else
; 953  : 			{	// copy pointer
; 954  : 			this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
; 955  : 			_Right._Bx._Ptr = pointer();
; 956  : 			}
; 957  : 		this->_Mysize = _Right._Mysize;
; 958  : 		this->_Myres = _Right._Myres;
; 959  : 		_Right._Tidy();
; 960  : 		}
; 961  : 
; 962  : 	~basic_string() _NOEXCEPT
; 963  : 		{	// destroy the string
; 964  : 		_Tidy(true);
; 965  : 		}
; 966  : 
; 967  : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 968  : 
; 969  : 	_Myt& operator=(const _Myt& _Right)
; 970  : 		{	// assign _Right
; 971  : 		if (this != &_Right)
; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);
; 985  : 		}
; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));

  007e5	41 b8 13 00 00
	00		 mov	 r8d, 19
  007eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG4294945218
  007f2	48 8d 4d ff	 lea	 rcx, QWORD PTR filePath$[rbp-105]
  007f6	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@PEB_W_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 276  : 	noTexFShader = new gfxu::FragmentShader(filePath);

  007fb	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00800	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00805	48 8b d8	 mov	 rbx, rax
  00808	48 89 45 c7	 mov	 QWORD PTR $T4[rbp-105], rax
  0080c	48 85 c0	 test	 rax, rax
  0080f	74 32		 je	 SHORT $LN22@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00811	48 c7 45 ef 07
	00 00 00	 mov	 QWORD PTR $T11[rbp-81], 7

; 1100 : 		}
; 1101 : 
; 1102 : 	_Myt& assign(const _Myt& _Right,
; 1103 : 		size_type _Roff, size_type _Count)
; 1104 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1105 : 		if (_Right.size() < _Roff)
; 1106 : 			_Xran();	// _Roff off end
; 1107 : 		size_type _Num = _Right.size() - _Roff;
; 1108 : 		if (_Count < _Num)
; 1109 : 			_Num = _Count;	// trim _Num to size
; 1110 : 
; 1111 : 		if (this == &_Right)
; 1112 : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring
; 1113 : 		else if (_Grow(_Num))
; 1114 : 			{	// make room and assign new stuff
; 1115 : 			_Traits::copy(this->_Myptr(),
; 1116 : 				_Right._Myptr() + _Roff, _Num);
; 1117 : 			_Eos(_Num);
; 1118 : 			}
; 1119 : 		return (*this);
; 1120 : 		}
; 1121 : 
; 1122 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1123 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1124 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1125 : 		if (_Count != 0)
; 1126 : 			_DEBUG_POINTER(_Ptr);
; 1127 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1128 : 
; 1129 : 		if (_Inside(_Ptr))
; 1130 : 			return (assign(*this,
; 1131 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1132 : 
; 1133 : 		if (_Grow(_Count))
; 1134 : 			{	// make room and assign new stuff
; 1135 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1136 : 			_Eos(_Count);
; 1137 : 			}
; 1138 : 		return (*this);
; 1139 : 		}
; 1140 : 
; 1141 : 	_Myt& assign(const _Elem *_Ptr)
; 1142 : 		{	// assign [_Ptr, <null>)
; 1143 : 		_DEBUG_POINTER(_Ptr);
; 1144 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1145 : 		}
; 1146 : 
; 1147 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1148 : 		{	// assign _Count * _Ch
; 1149 : 		if (_Count == npos)
; 1150 : 			_Xlen();	// result too long
; 1151 : 
; 1152 : 		if (_Grow(_Count))
; 1153 : 			{	// make room and assign new stuff
; 1154 : 			_Chassign(0, _Count, _Ch);
; 1155 : 			_Eos(_Count);
; 1156 : 			}
; 1157 : 		return (*this);
; 1158 : 		}
; 1159 : 
; 1160 : 	template<class _Iter>
; 1161 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1162 : 			_Myt&>::type
; 1163 : 		assign(_Iter _First, _Iter _Last)
; 1164 : 		{	// assign [First, _Last), input iterators
; 1165 : 		return (replace(begin(), end(), _First, _Last));
; 1166 : 		}
; 1167 : 
; 1168 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1169 : 		{	// assign [First, _Last), const pointers
; 1170 : 		return (replace(begin(), end(), _First, _Last));
; 1171 : 		}
; 1172 : 
; 1173 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1174 : 		{	// assign [First, _Last), const_iterators
; 1175 : 		return (replace(begin(), end(), _First, _Last));
; 1176 : 		}
; 1177 : 
; 1178 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1179 : 		{	// insert _Right at _Off
; 1180 : 		return (insert(_Off, _Right, 0, npos));
; 1181 : 		}
; 1182 : 
; 1183 : 	_Myt& insert(size_type _Off,
; 1184 : 		const _Myt& _Right, size_type _Roff, size_type _Count)
; 1185 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1186 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1187 : 			_Xran();	// _Off or _Roff off end
; 1188 : 		size_type _Num = _Right.size() - _Roff;
; 1189 : 		if (_Num < _Count)
; 1190 : 			_Count = _Num;	// trim _Count to size
; 1191 : 		if (npos - this->_Mysize <= _Count)
; 1192 : 			_Xlen();	// result too long
; 1193 : 
; 1194 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1195 : 			{	// make room and insert new stuff
; 1196 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1197 : 				this->_Myptr() + _Off,
; 1198 : 				this->_Mysize - _Off);	// empty out hole
; 1199 : 			if (this == &_Right)
; 1200 : 				_Traits::move(this->_Myptr() + _Off,
; 1201 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1202 : 						_Count);	// substring
; 1203 : 			else
; 1204 : 				_Traits::copy(this->_Myptr() + _Off,
; 1205 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1206 : 			_Eos(_Num);
; 1207 : 			}
; 1208 : 		return (*this);
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off,
; 1212 : 		const _Elem *_Ptr, size_type _Count)
; 1213 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1214 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1215 : 		if (_Count != 0)
; 1216 : 			_DEBUG_POINTER(_Ptr);
; 1217 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1218 : 
; 1219 : 		if (_Inside(_Ptr))
; 1220 : 			return (insert(_Off, *this,
; 1221 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1222 : 		if (this->_Mysize < _Off)
; 1223 : 			_Xran();	// _Off off end
; 1224 : 		if (npos - this->_Mysize <= _Count)
; 1225 : 			_Xlen();	// result too long
; 1226 : 		size_type _Num;
; 1227 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1228 : 			{	// make room and insert new stuff
; 1229 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1230 : 				this->_Myptr() + _Off,
; 1231 : 				this->_Mysize - _Off);	// empty out hole
; 1232 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1233 : 			_Eos(_Num);
; 1234 : 			}
; 1235 : 		return (*this);
; 1236 : 		}
; 1237 : 
; 1238 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1239 : 		{	// insert [_Ptr, <null>) at _Off
; 1240 : 		_DEBUG_POINTER(_Ptr);
; 1241 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1242 : 		}
; 1243 : 
; 1244 : 	_Myt& insert(size_type _Off,
; 1245 : 		size_type _Count, _Elem _Ch)
; 1246 : 		{	// insert _Count * _Ch at _Off
; 1247 : 		if (this->_Mysize < _Off)
; 1248 : 			_Xran();	// _Off off end
; 1249 : 		if (npos - this->_Mysize <= _Count)
; 1250 : 			_Xlen();	// result too long
; 1251 : 		size_type _Num;
; 1252 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1253 : 			{	// make room and insert new stuff
; 1254 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1255 : 				this->_Myptr() + _Off,
; 1256 : 				this->_Mysize - _Off);	// empty out hole
; 1257 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1258 : 			_Eos(_Num);
; 1259 : 			}
; 1260 : 		return (*this);
; 1261 : 		}
; 1262 : 
; 1263 : 	iterator insert(const_iterator _Where)
; 1264 : 		{	// insert <null> at _Where
; 1265 : 		return (insert(_Where, _Elem()));
; 1266 : 		}
; 1267 : 
; 1268 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1269 : 		{	// insert _Ch at _Where
; 1270 : 		size_type _Off = _Pdif(_Where, begin());
; 1271 : 		insert(_Off, 1, _Ch);
; 1272 : 		return (begin() + _Off);
; 1273 : 		}
; 1274 : 
; 1275 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1276 : 		{	// insert _Count * _Elem at _Where
; 1277 : 		size_type _Off = _Pdif(_Where, begin());
; 1278 : 		insert(_Off, _Count, _Ch);
; 1279 : 		return (begin() + _Off);
; 1280 : 		}
; 1281 : 
; 1282 : 	template<class _Iter>
; 1283 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1284 : 			iterator>::type
; 1285 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1286 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1287 : 		size_type _Off = _Pdif(_Where, begin());
; 1288 : 		replace(_Where, _Where, _First, _Last);
; 1289 : 		return (begin() + _Off);
; 1290 : 		}
; 1291 : 
; 1292 : 	iterator insert(const_iterator _Where,
; 1293 : 		const_pointer _First, const_pointer _Last)
; 1294 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1295 : 		size_type _Off = _Pdif(_Where, begin());
; 1296 : 		replace(_Where, _Where, _First, _Last);
; 1297 : 		return (begin() + _Off);
; 1298 : 		}
; 1299 : 
; 1300 : 	iterator insert(const_iterator _Where,
; 1301 : 		const_iterator _First, const_iterator _Last)
; 1302 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1303 : 		size_type _Off = _Pdif(_Where, begin());
; 1304 : 		replace(_Where, _Where, _First, _Last);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	_Myt& erase(size_type _Off = 0)
; 1309 : 		{	// erase elements [_Off, ...)
; 1310 : 		if (this->_Mysize < _Off)
; 1311 : 			_Xran();	// _Off off end
; 1312 : 		_Eos(_Off);
; 1313 : 		return (*this);
; 1314 : 		}
; 1315 : 
; 1316 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1317 : 		{	// erase elements [_Off, _Off + _Count)
; 1318 : 		if (this->_Mysize < _Off)
; 1319 : 			_Xran();	// _Off off end
; 1320 : 		if (this->_Mysize - _Off <= _Count)
; 1321 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1322 : 		else if (0 < _Count)
; 1323 : 			{	// move elements down
; 1324 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1325 : 			size_type _Newsize = this->_Mysize - _Count;
; 1326 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1327 : 			_Eos(_Newsize);
; 1328 : 			}
; 1329 : 		return (*this);
; 1330 : 		}
; 1331 : 
; 1332 : 	iterator erase(const_iterator _Where)
; 1333 : 		{	// erase element at _Where
; 1334 : 		size_type _Count = _Pdif(_Where, begin());
; 1335 : 		erase(_Count, 1);
; 1336 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1337 : 		}
; 1338 : 
; 1339 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1340 : 		{	// erase substring [_First, _Last)
; 1341 : 		_DEBUG_RANGE(_First, _Last);
; 1342 : 		size_type _Count = _Pdif(_First, begin());
; 1343 : 		erase(_Count, _Pdif(_Last, _First));
; 1344 : 		return (_STRING_ITERATOR(this->_Myptr() + _Count));
; 1345 : 		}
; 1346 : 
; 1347 : 	void clear() _NOEXCEPT
; 1348 : 		{	// erase all
; 1349 : 		_Eos(0);
; 1350 : 		}
; 1351 : 
; 1352 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1353 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1354 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1355 : 		}
; 1356 : 
; 1357 : 	_Myt& replace(size_type _Off,
; 1358 : 		size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
; 1359 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1360 : 		if (this->_Mysize < _Off || _Right.size() < _Roff)
; 1361 : 			_Xran();	// _Off or _Roff off end
; 1362 : 		if (this->_Mysize - _Off < _N0)
; 1363 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1364 : 		size_type _Num = _Right.size() - _Roff;
; 1365 : 		if (_Num < _Count)
; 1366 : 			_Count = _Num;	// trim _Count to size
; 1367 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1368 : 			_Xlen();	// result too long
; 1369 : 
; 1370 : 		size_type _Nm = this->_Mysize - _N0 - _Off;	// length of kept tail
; 1371 : 		size_type _Newsize = this->_Mysize + _Count - _N0;
; 1372 : 		if (this->_Mysize < _Newsize)
; 1373 : 			_Grow(_Newsize);
; 1374 : 
; 1375 : 		if (this != &_Right)
; 1376 : 			{	// no overlap, just move down and copy in new stuff
; 1377 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1378 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1379 : 			_Traits::copy(this->_Myptr() + _Off,
; 1380 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1381 : 			}
; 1382 : 		else if (_Count <= _N0)
; 1383 : 			{	// hole doesn't get larger, just copy in substring
; 1384 : 			_Traits::move(this->_Myptr() + _Off,
; 1385 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1386 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1387 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1388 : 			}
; 1389 : 		else if (_Roff <= _Off)
; 1390 : 			{	// hole gets larger, substring begins before hole
; 1391 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1392 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1393 : 			_Traits::move(this->_Myptr() + _Off,
; 1394 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1395 : 			}
; 1396 : 		else if (_Off + _N0 <= _Roff)
; 1397 : 			{	// hole gets larger, substring begins after hole
; 1398 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1399 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1400 : 			_Traits::move(this->_Myptr() + _Off,
; 1401 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1402 : 				_Count);	// fill hole
; 1403 : 			}
; 1404 : 		else
; 1405 : 			{	// hole gets larger, substring begins in hole
; 1406 : 			_Traits::move(this->_Myptr() + _Off,
; 1407 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1408 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1409 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1410 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1411 : 				this->_Myptr() + _Roff + _Count,
; 1412 : 				_Count - _N0);	// fill rest of new hole
; 1413 : 			}
; 1414 : 
; 1415 : 		_Eos(_Newsize);
; 1416 : 		return (*this);
; 1417 : 		}
; 1418 : 
; 1419 : 	_Myt& replace(size_type _Off,
; 1420 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1421 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1422 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1423 : 		if (_Count != 0)
; 1424 : 			_DEBUG_POINTER(_Ptr);
; 1425 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1426 : 
; 1427 : 		if (_Inside(_Ptr))
; 1428 : 			return (replace(_Off, _N0, *this,
; 1429 : 				_Ptr - this->_Myptr(),
; 1430 : 				_Count));	// substring, replace carefully
; 1431 : 		if (this->_Mysize < _Off)
; 1432 : 			_Xran();	// _Off off end
; 1433 : 		if (this->_Mysize - _Off < _N0)
; 1434 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1435 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1436 : 			_Xlen();	// result too long
; 1437 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1438 : 
; 1439 : 		if (_Count < _N0)
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1441 : 				this->_Myptr() + _Off + _N0,
; 1442 : 				_Nm);	// smaller hole, move tail up
; 1443 : 		size_type _Num;
; 1444 : 		if ((0 < _Count || 0 < _N0)
; 1445 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1446 : 			{	// make room and rearrange
; 1447 : 			if (_N0 < _Count)
; 1448 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1449 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1450 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1451 : 			_Eos(_Num);
; 1452 : 			}
; 1453 : 		return (*this);
; 1454 : 		}
; 1455 : 
; 1456 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1457 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1458 : 		_DEBUG_POINTER(_Ptr);
; 1459 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1460 : 		}
; 1461 : 
; 1462 : 	_Myt& replace(size_type _Off,
; 1463 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1464 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1465 : 		if (this->_Mysize < _Off)
; 1466 : 			_Xran();	// _Off off end
; 1467 : 		if (this->_Mysize - _Off < _N0)
; 1468 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 1469 : 		if (npos - _Count <= this->_Mysize - _N0)
; 1470 : 			_Xlen();	// result too long
; 1471 : 		size_type _Nm = this->_Mysize - _N0 - _Off;
; 1472 : 
; 1473 : 		if (_Count < _N0)
; 1474 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1475 : 				this->_Myptr() + _Off + _N0,
; 1476 : 				_Nm);	// smaller hole, move tail up
; 1477 : 		size_type _Num;
; 1478 : 		if ((0 < _Count || 0 < _N0)
; 1479 : 			&& _Grow(_Num = this->_Mysize + _Count - _N0))
; 1480 : 			{	// make room and rearrange
; 1481 : 			if (_N0 < _Count)
; 1482 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1483 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1484 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1485 : 			_Eos(_Num);
; 1486 : 			}
; 1487 : 		return (*this);
; 1488 : 		}
; 1489 : 
; 1490 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1491 : 		const _Myt& _Right)
; 1492 : 		{	// replace [_First, _Last) with _Right
; 1493 : 		return (replace(
; 1494 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
; 1495 : 		}
; 1496 : 
; 1497 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1498 : 		const _Elem *_Ptr, size_type _Count)
; 1499 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1500 : 		return (replace(
; 1501 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
; 1502 : 		}
; 1503 : 
; 1504 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1505 : 		const _Elem *_Ptr)
; 1506 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1507 : 		return (replace(
; 1508 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
; 1509 : 		}
; 1510 : 
; 1511 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1512 : 		size_type _Count, _Elem _Ch)
; 1513 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1514 : 		return (replace(
; 1515 : 			_Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
; 1516 : 		}
; 1517 : 
; 1518 : 	template<class _Iter>
; 1519 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1520 : 			_Myt&>::type
; 1521 : 		replace(const_iterator _First, const_iterator _Last,
; 1522 : 			_Iter _First2, _Iter _Last2)
; 1523 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1524 : 		_Myt _Right(_First2, _Last2);
; 1525 : 		replace(_First, _Last, _Right);
; 1526 : 		return (*this);
; 1527 : 		}
; 1528 : 
; 1529 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1530 : 		const_pointer _First2, const_pointer _Last2)
; 1531 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1532 : 		if (_First2 == _Last2)
; 1533 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1534 : 		else
; 1535 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1536 : 				&*_First2, _Last2 - _First2);
; 1537 : 		return (*this);
; 1538 : 		}
; 1539 : 
; 1540 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1541 : 		pointer _First2, pointer _Last2)
; 1542 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1543 : 		if (_First2 == _Last2)
; 1544 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1545 : 		else
; 1546 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1547 : 				&*_First2, _Last2 - _First2);
; 1548 : 		return (*this);
; 1549 : 		}
; 1550 : 
; 1551 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1552 : 		const_iterator _First2, const_iterator _Last2)
; 1553 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1554 : 		if (_First2 == _Last2)
; 1555 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1556 : 		else
; 1557 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1558 : 				&*_First2, _Last2 - _First2);
; 1559 : 		return (*this);
; 1560 : 		}
; 1561 : 
; 1562 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1563 : 		iterator _First2, iterator _Last2)
; 1564 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1565 : 		if (_First2 == _Last2)
; 1566 : 			erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
; 1567 : 		else
; 1568 : 			replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
; 1569 : 				&*_First2, _Last2 - _First2);
; 1570 : 		return (*this);
; 1571 : 		}
; 1572 : 
; 1573 : 	iterator begin() _NOEXCEPT
; 1574 : 		{	// return iterator for beginning of mutable sequence
; 1575 : 		return (_STRING_ITERATOR(this->_Myptr()));
; 1576 : 		}
; 1577 : 
; 1578 : 	const_iterator begin() const _NOEXCEPT
; 1579 : 		{	// return iterator for beginning of nonmutable sequence
; 1580 : 		return (_STRING_CONST_ITERATOR(this->_Myptr()));
; 1581 : 		}
; 1582 : 
; 1583 : 	iterator end() _NOEXCEPT
; 1584 : 		{	// return iterator for end of mutable sequence
; 1585 : 		return (_STRING_ITERATOR(this->_Myptr() + this->_Mysize));
; 1586 : 		}
; 1587 : 
; 1588 : 	const_iterator end() const _NOEXCEPT
; 1589 : 		{	// return iterator for end of nonmutable sequence
; 1590 : 		return (_STRING_CONST_ITERATOR(this->_Myptr() + this->_Mysize));
; 1591 : 		}
; 1592 : 
; 1593 : 	reverse_iterator rbegin() _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of reversed mutable sequence
; 1595 : 		return (reverse_iterator(end()));
; 1596 : 		}
; 1597 : 
; 1598 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1599 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1600 : 		return (const_reverse_iterator(end()));
; 1601 : 		}
; 1602 : 
; 1603 : 	reverse_iterator rend() _NOEXCEPT
; 1604 : 		{	// return iterator for end of reversed mutable sequence
; 1605 : 		return (reverse_iterator(begin()));
; 1606 : 		}
; 1607 : 
; 1608 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1609 : 		{	// return iterator for end of reversed nonmutable sequence
; 1610 : 		return (const_reverse_iterator(begin()));
; 1611 : 		}
; 1612 : 
; 1613 :  #if _HAS_CPP0X
; 1614 : 	const_iterator cbegin() const _NOEXCEPT
; 1615 : 		{	// return iterator for beginning of nonmutable sequence
; 1616 : 		return (((const _Myt *)this)->begin());
; 1617 : 		}
; 1618 : 
; 1619 : 	const_iterator cend() const _NOEXCEPT
; 1620 : 		{	// return iterator for end of nonmutable sequence
; 1621 : 		return (((const _Myt *)this)->end());
; 1622 : 		}
; 1623 : 
; 1624 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1625 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1626 : 		return (((const _Myt *)this)->rbegin());
; 1627 : 		}
; 1628 : 
; 1629 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1630 : 		{	// return iterator for end of reversed nonmutable sequence
; 1631 : 		return (((const _Myt *)this)->rend());
; 1632 : 		}
; 1633 : 
; 1634 : 	void shrink_to_fit()
; 1635 : 		{	// reduce capacity
; 1636 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1637 : 			{	// worth shrinking, do it
; 1638 : 			_Myt _Tmp(*this);
; 1639 : 			swap(_Tmp);
; 1640 : 			}
; 1641 : 		}
; 1642 :  #endif /* _HAS_CPP0X */
; 1643 : 
; 1644 : 	reference at(size_type _Off)
; 1645 : 		{	// subscript mutable sequence with checking
; 1646 : 		if (this->_Mysize <= _Off)
; 1647 : 			_Xran();	// _Off off end
; 1648 : 		return (this->_Myptr()[_Off]);
; 1649 : 		}
; 1650 : 
; 1651 : 	const_reference at(size_type _Off) const
; 1652 : 		{	// subscript nonmutable sequence with checking
; 1653 : 		if (this->_Mysize <= _Off)
; 1654 : 			_Xran();	// _Off off end
; 1655 : 		return (this->_Myptr()[_Off]);
; 1656 : 		}
; 1657 : 
; 1658 : 	reference operator[](size_type _Off)
; 1659 : 		{	// subscript mutable sequence
; 1660 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1661 : 		if (this->_Mysize < _Off)	// sic
; 1662 : 			_DEBUG_ERROR("string subscript out of range");
; 1663 : 
; 1664 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1665 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1666 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1667 : 
; 1668 : 		return (this->_Myptr()[_Off]);
; 1669 : 		}
; 1670 : 
; 1671 : 	const_reference operator[](size_type _Off) const
; 1672 : 		{	// subscript nonmutable sequence
; 1673 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1674 : 		if (this->_Mysize < _Off)	// sic
; 1675 : 			_DEBUG_ERROR("string subscript out of range");
; 1676 : 
; 1677 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1678 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize);	// sic
; 1679 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1680 : 
; 1681 : 		return (this->_Myptr()[_Off]);
; 1682 : 		}
; 1683 : 
; 1684 : 	void push_back(_Elem _Ch)
; 1685 : 		{	// insert element at end
; 1686 : 		insert(end(), _Ch);
; 1687 : 		}
; 1688 : 
; 1689 :  #if _HAS_CPP0X
; 1690 : 	void pop_back()
; 1691 : 		{	// erase element at end
; 1692 : 		erase(this->_Mysize - 1);	// throws if _Mysize == 0
; 1693 : 		}
; 1694 : 
; 1695 : 	reference front()
; 1696 : 		{	// return first element of mutable sequence
; 1697 : 		return (*begin());
; 1698 : 		}
; 1699 : 
; 1700 : 	const_reference front() const
; 1701 : 		{	// return first element of nonmutable sequence
; 1702 : 		return (*begin());
; 1703 : 		}
; 1704 : 
; 1705 : 	reference back()
; 1706 : 		{	// return last element of mutable sequence
; 1707 : 		return (*(end() - 1));
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference back() const
; 1711 : 		{	// return last element of nonmutable sequence
; 1712 : 		return (*(end() - 1));
; 1713 : 		}
; 1714 :  #endif /* _HAS_CPP0X */
; 1715 : 
; 1716 : 	const _Elem *c_str() const _NOEXCEPT
; 1717 : 		{	// return pointer to null-terminated nonmutable array
; 1718 : 		return (this->_Myptr());
; 1719 : 		}
; 1720 : 
; 1721 : 	const _Elem *data() const _NOEXCEPT
; 1722 : 		{	// return pointer to nonmutable array
; 1723 : 		return (c_str());
; 1724 : 		}
; 1725 : 
; 1726 : 	size_type length() const _NOEXCEPT
; 1727 : 		{	// return length of sequence
; 1728 : 		return (this->_Mysize);
; 1729 : 		}
; 1730 : 
; 1731 : 	size_type size() const _NOEXCEPT
; 1732 : 		{	// return length of sequence
; 1733 : 		return (this->_Mysize);
; 1734 : 		}
; 1735 : 
; 1736 : 	size_type max_size() const _NOEXCEPT
; 1737 : 		{	// return maximum possible length of sequence
; 1738 : 		size_type _Num = this->_Getal().max_size();
; 1739 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1740 : 		}
; 1741 : 
; 1742 : 	void resize(size_type _Newsize)
; 1743 : 		{	// determine new length, padding with null elements as needed
; 1744 : 		resize(_Newsize, _Elem());
; 1745 : 		}
; 1746 : 
; 1747 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1748 : 		{	// determine new length, padding with _Ch elements as needed
; 1749 : 		if (_Newsize <= this->_Mysize)
; 1750 : 			_Eos(_Newsize);
; 1751 : 		else
; 1752 : 			append(_Newsize - this->_Mysize, _Ch);
; 1753 : 		}
; 1754 : 
; 1755 : 	size_type capacity() const _NOEXCEPT
; 1756 : 		{	// return current length of allocated storage
; 1757 : 		return (this->_Myres);
; 1758 : 		}
; 1759 : 
; 1760 : 	void reserve(size_type _Newcap = 0)
; 1761 : 		{	// determine new minimum length of allocated storage
; 1762 : 		if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
; 1763 : 			{	// change reservation
; 1764 : 			size_type _Size = this->_Mysize;
; 1765 : 			if (_Grow(_Newcap, true))
; 1766 : 				_Eos(_Size);
; 1767 : 			}
; 1768 : 		}
; 1769 : 
; 1770 : 	bool empty() const _NOEXCEPT
; 1771 : 		{	// test if sequence is empty
; 1772 : 		return (this->_Mysize == 0);
; 1773 : 		}
; 1774 : 
; 1775 : 	_SCL_INSECURE_DEPRECATE
; 1776 : 
; 1777 : 	size_type copy(_Elem *_Ptr,
; 1778 : 		size_type _Count, size_type _Off = 0) const
; 1779 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1780 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1781 : 		if (_Count != 0)
; 1782 : 			_DEBUG_POINTER(_Ptr);
; 1783 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1784 : 
; 1785 : 		if (this->_Mysize < _Off)
; 1786 : 			_Xran();	// _Off off end
; 1787 : 		if (this->_Mysize - _Off < _Count)
; 1788 : 			_Count = this->_Mysize - _Off;
; 1789 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1790 : 		return (_Count);
; 1791 : 		}
; 1792 : 
; 1793 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1794 : 		size_type _Count, size_type _Off = 0) const
; 1795 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1796 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1797 : 		if (_Count != 0)
; 1798 : 			_DEBUG_POINTER(_Dest);
; 1799 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1800 : 
; 1801 : 		if (this->_Mysize < _Off)
; 1802 : 			_Xran();	// _Off off end
; 1803 : 		if (this->_Mysize - _Off < _Count)
; 1804 : 			_Count = this->_Mysize - _Off;
; 1805 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1806 : 		return (_Count);
; 1807 : 		}
; 1808 : 
; 1809 : 	void _Swap_bx(_Myt& _Right)
; 1810 : 		{	// exchange _Bx with _Right._Bx
; 1811 : 		if (this->_BUF_SIZE <= this->_Myres)
; 1812 : 			if (this->_BUF_SIZE <= _Right._Myres)
; 1813 : 				_Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
; 1814 : 			else
; 1815 : 				{	// swap large with small
; 1816 : 				pointer _Ptr = this->_Bx._Ptr;
; 1817 : 				this->_Getal().destroy(&this->_Bx._Ptr);
; 1818 : 				_Traits::copy(this->_Bx._Buf,
; 1819 : 					_Right._Bx._Buf, _Right._Mysize + 1);
; 1820 : 				this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
; 1821 : 				}
; 1822 : 		else
; 1823 : 			if (_Right._Myres < this->_BUF_SIZE)
; 1824 : 				_STD swap(this->_Bx._Buf, _Right._Bx._Buf);
; 1825 : 			else
; 1826 : 				{	// swap small with large
; 1827 : 				pointer _Ptr = _Right._Bx._Ptr;
; 1828 : 				this->_Getal().destroy(&_Right._Bx._Ptr);
; 1829 : 				_Traits::copy(_Right._Bx._Buf,
; 1830 : 					this->_Bx._Buf, this->_Mysize + 1);
; 1831 : 				this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 1832 : 				}
; 1833 : 		}
; 1834 : 
; 1835 : 	void swap(_Myt& _Right)
; 1836 : 		{	// exchange contents with _Right
; 1837 : 		if (this == &_Right)
; 1838 : 			;	// same object, do nothing
; 1839 : 		else if (this->_Getal() == _Right._Getal())
; 1840 : 			{	// same allocator, swap control information
; 1841 : 			this->_Swap_all(_Right);
; 1842 : 			_Swap_bx(_Right);
; 1843 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1844 : 			_STD swap(this->_Myres, _Right._Myres);
; 1845 : 			}
; 1846 : 
; 1847 :  #if _HAS_CPP0X
; 1848 : 		else if (_Alty::propagate_on_container_swap::value)
; 1849 : 			{	// swap allocators and control information
; 1850 : 			this->_Swap_alloc(_Right);
; 1851 : 			_Swap_bx(_Right);
; 1852 : 			_STD swap(this->_Bx, _Right._Bx);	// pointer bitwise copyable?
; 1853 : 			_STD swap(this->_Mysize, _Right._Mysize);
; 1854 : 			_STD swap(this->_Myres, _Right._Myres);
; 1855 : 			}
; 1856 :  #endif /* _HAS_CPP0X */
; 1857 : 
; 1858 : 		else
; 1859 : 			{	// different allocator, do multiple assigns
; 1860 : 			_Myt _Tmp = *this;
; 1861 : 
; 1862 : 			*this = _Right;
; 1863 : 			_Right = _Tmp;
; 1864 : 			}
; 1865 : 		}
; 1866 : 
; 1867 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1868 : 		{	// look for _Right beginning at or after _Off
; 1869 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1870 : 		}
; 1871 : 
; 1872 : 	size_type find(const _Elem *_Ptr,
; 1873 : 		size_type _Off, size_type _Count) const
; 1874 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1875 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1876 : 		if (_Count != 0)
; 1877 : 			_DEBUG_POINTER(_Ptr);
; 1878 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1879 : 
; 1880 : 		if (_Count == 0 && _Off <= this->_Mysize)
; 1881 : 			return (_Off);	// null string always matches (if inside string)
; 1882 : 
; 1883 : 		size_type _Nm;
; 1884 : 		if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
; 1885 : 			{	// room for match, look for it
; 1886 : 			const _Elem *_Uptr, *_Vptr;
; 1887 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1888 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1889 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1890 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1891 : 					return (_Uptr - this->_Myptr());	// found a match
; 1892 : 			}
; 1893 : 
; 1894 : 		return (npos);	// no match
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1898 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1899 : 		_DEBUG_POINTER(_Ptr);
; 1900 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1901 : 		}
; 1902 : 
; 1903 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1904 : 		{	// look for _Ch at or after _Off
; 1905 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1906 : 		}
; 1907 : 
; 1908 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1909 : 		{	// look for _Right beginning before _Off
; 1910 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1911 : 		}
; 1912 : 
; 1913 : 	size_type rfind(const _Elem *_Ptr,
; 1914 : 		size_type _Off, size_type _Count) const
; 1915 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1916 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1917 : 		if (_Count != 0)
; 1918 : 			_DEBUG_POINTER(_Ptr);
; 1919 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1920 : 
; 1921 : 		if (_Count == 0)
; 1922 : 			return (_Off < this->_Mysize ? _Off
; 1923 : 				: this->_Mysize);	// null always matches
; 1924 : 		if (_Count <= this->_Mysize)
; 1925 : 			{	// room for match, look for it
; 1926 : 			const _Elem *_Uptr = this->_Myptr() +
; 1927 : 				(_Off < this->_Mysize - _Count ? _Off
; 1928 : 					: this->_Mysize - _Count);
; 1929 : 			for (; ; --_Uptr)
; 1930 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1931 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1932 : 					return (_Uptr - this->_Myptr());	// found a match
; 1933 : 				else if (_Uptr == this->_Myptr())
; 1934 : 					break;	// at beginning, no more chance for match
; 1935 : 			}
; 1936 : 
; 1937 : 		return (npos);	// no match
; 1938 : 		}
; 1939 : 
; 1940 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1941 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1942 : 		_DEBUG_POINTER(_Ptr);
; 1943 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1944 : 		}
; 1945 : 
; 1946 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1947 : 		{	// look for _Ch before _Off
; 1948 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1949 : 		}
; 1950 : 
; 1951 : 	size_type find_first_of(const _Myt& _Right,
; 1952 : 		size_type _Off = 0) const _NOEXCEPT
; 1953 : 		{	// look for one of _Right at or after _Off
; 1954 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1955 : 		}
; 1956 : 
; 1957 : 	size_type find_first_of(const _Elem *_Ptr,
; 1958 : 		size_type _Off, size_type _Count) const
; 1959 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1960 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1961 : 		if (_Count != 0)
; 1962 : 			_DEBUG_POINTER(_Ptr);
; 1963 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1964 : 
; 1965 : 		if (0 < _Count && _Off < this->_Mysize)
; 1966 : 			{	// room for match, look for it
; 1967 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 1968 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1969 : 				_Uptr < _Vptr; ++_Uptr)
; 1970 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1971 : 					return (_Uptr - this->_Myptr());	// found a match
; 1972 : 			}
; 1973 : 
; 1974 : 		return (npos);	// no match
; 1975 : 		}
; 1976 : 
; 1977 : 	size_type find_first_of(const _Elem *_Ptr,
; 1978 : 		size_type _Off = 0) const
; 1979 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1980 : 		_DEBUG_POINTER(_Ptr);
; 1981 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1982 : 		}
; 1983 : 
; 1984 : 	size_type find_first_of(_Elem _Ch,
; 1985 : 		size_type _Off = 0) const
; 1986 : 		{	// look for _Ch at or after _Off
; 1987 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1988 : 		}
; 1989 : 
; 1990 : 	size_type find_last_of(const _Myt& _Right,
; 1991 : 		size_type _Off = npos) const _NOEXCEPT
; 1992 : 		{	// look for one of _Right before _Off
; 1993 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1994 : 		}
; 1995 : 
; 1996 : 	size_type find_last_of(const _Elem *_Ptr,
; 1997 : 		size_type _Off, size_type _Count) const
; 1998 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1999 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2000 : 		if (_Count != 0)
; 2001 : 			_DEBUG_POINTER(_Ptr);
; 2002 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2003 : 
; 2004 : 		if (0 < _Count && 0 < this->_Mysize)
; 2005 : 			{	// worth searching, do it
; 2006 : 			const _Elem *_Uptr = this->_Myptr()
; 2007 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2008 : 			for (; ; --_Uptr)
; 2009 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 2010 : 					return (_Uptr - this->_Myptr());	// found a match
; 2011 : 				else if (_Uptr == this->_Myptr())
; 2012 : 					break;	// at beginning, no more chance for match
; 2013 : 			}
; 2014 : 
; 2015 : 		return (npos);	// no match
; 2016 : 		}
; 2017 : 
; 2018 : 	size_type find_last_of(const _Elem *_Ptr,
; 2019 : 		size_type _Off = npos) const
; 2020 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2021 : 		_DEBUG_POINTER(_Ptr);
; 2022 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2023 : 		}
; 2024 : 
; 2025 : 	size_type find_last_of(_Elem _Ch,
; 2026 : 		size_type _Off = npos) const
; 2027 : 		{	// look for _Ch before _Off
; 2028 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2029 : 		}
; 2030 : 
; 2031 : 	size_type find_first_not_of(const _Myt& _Right,
; 2032 : 		size_type _Off = 0) const _NOEXCEPT
; 2033 : 		{	// look for none of _Right at or after _Off
; 2034 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2035 : 			_Right.size()));
; 2036 : 		}
; 2037 : 
; 2038 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2039 : 		size_type _Off, size_type _Count) const
; 2040 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2041 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2042 : 		if (_Count != 0)
; 2043 : 			_DEBUG_POINTER(_Ptr);
; 2044 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2045 : 
; 2046 : 		if (_Off < this->_Mysize)
; 2047 : 			{	// room for match, look for it
; 2048 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
; 2049 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2050 : 				_Uptr < _Vptr; ++_Uptr)
; 2051 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2052 : 					return (_Uptr - this->_Myptr());
; 2053 : 			}
; 2054 : 		return (npos);
; 2055 : 		}
; 2056 : 
; 2057 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2058 : 		size_type _Off = 0) const
; 2059 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2060 : 		_DEBUG_POINTER(_Ptr);
; 2061 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2062 : 		}
; 2063 : 
; 2064 : 	size_type find_first_not_of(_Elem _Ch,
; 2065 : 		size_type _Off = 0) const
; 2066 : 		{	// look for non _Ch at or after _Off
; 2067 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2068 : 		}
; 2069 : 
; 2070 : 	size_type find_last_not_of(const _Myt& _Right,
; 2071 : 		size_type _Off = npos) const _NOEXCEPT
; 2072 : 		{	// look for none of _Right before _Off
; 2073 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2074 : 		}
; 2075 : 
; 2076 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2077 : 		size_type _Off, size_type _Count) const
; 2078 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2079 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2080 : 		if (_Count != 0)
; 2081 : 			_DEBUG_POINTER(_Ptr);
; 2082 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2083 : 
; 2084 : 		if (0 < this->_Mysize)
; 2085 : 			{	// worth searching, do it
; 2086 : 			const _Elem *_Uptr = this->_Myptr()
; 2087 : 				+ (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
; 2088 : 			for (; ; --_Uptr)
; 2089 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2090 : 					return (_Uptr - this->_Myptr());
; 2091 : 				else if (_Uptr == this->_Myptr())
; 2092 : 					break;
; 2093 : 			}
; 2094 : 		return (npos);
; 2095 : 		}
; 2096 : 
; 2097 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2098 : 		size_type _Off = npos) const
; 2099 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2100 : 		_DEBUG_POINTER(_Ptr);
; 2101 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2102 : 		}
; 2103 : 
; 2104 : 	size_type find_last_not_of(_Elem _Ch,
; 2105 : 		size_type _Off = npos) const
; 2106 : 		{	// look for non _Ch before _Off
; 2107 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2108 : 		}
; 2109 : 
; 2110 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2111 : 		{	// return [_Off, _Off + _Count) as new string
; 2112 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2113 : 		}
; 2114 : 
; 2115 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2116 : 		{	// compare [0, _Mysize) with _Right
; 2117 : 		return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
; 2118 : 		}
; 2119 : 
; 2120 : 	int compare(size_type _Off, size_type _N0,
; 2121 : 		const _Myt& _Right) const
; 2122 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2123 : 		return (compare(_Off, _N0, _Right, 0, npos));
; 2124 : 		}
; 2125 : 
; 2126 : 	int compare(size_type _Off,
; 2127 : 		size_type _N0, const _Myt& _Right,
; 2128 : 		size_type _Roff, size_type _Count) const
; 2129 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2130 : 		if (_Right.size() < _Roff)
; 2131 : 			_Xran();	// _Off off end
; 2132 : 		if (_Right._Mysize - _Roff < _Count)
; 2133 : 			_Count = _Right._Mysize - _Roff;	// trim _Count to size
; 2134 : 		return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
; 2135 : 		}
; 2136 : 
; 2137 : 	int compare(const _Elem *_Ptr) const
; 2138 : 		{	// compare [0, _Mysize) with [_Ptr, <null>)
; 2139 : 		_DEBUG_POINTER(_Ptr);
; 2140 : 		return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
; 2141 : 		}
; 2142 : 
; 2143 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2144 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2145 : 		_DEBUG_POINTER(_Ptr);
; 2146 : 		return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 2147 : 		}
; 2148 : 
; 2149 : 	int compare(size_type _Off,
; 2150 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2151 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2152 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 2153 : 		if (_Count != 0)
; 2154 : 			_DEBUG_POINTER(_Ptr);
; 2155 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 2156 : 
; 2157 : 		if (this->_Mysize < _Off)
; 2158 : 			_Xran();	// _Off off end
; 2159 : 		if (this->_Mysize - _Off < _N0)
; 2160 : 			_N0 = this->_Mysize - _Off;	// trim _N0 to size
; 2161 : 
; 2162 : 		size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
; 2163 : 			_N0 < _Count ? _N0 : _Count);
; 2164 : 		return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
; 2165 : 			: _N0 == _Count ? 0 : +1);
; 2166 : 		}
; 2167 : 
; 2168 : 	allocator_type get_allocator() const _NOEXCEPT
; 2169 : 		{	// return allocator object for values
; 2170 : 		return (this->_Getal());
; 2171 : 		}
; 2172 : 
; 2173 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2175 : 		if (_Count == 1)
; 2176 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2177 : 		else
; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2179 : 		}
; 2180 : 
; 2181 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2184 : 		if (max_size() < _Newres)
; 2185 : 			_Newres = _Newsize;	// undo roundup if too big
; 2186 : 		else if (this->_Myres / 2 <= _Newres / 3)
; 2187 : 			;
; 2188 : 		else if (this->_Myres <= max_size() - this->_Myres / 2)
; 2189 : 			_Newres = this->_Myres
; 2190 : 				+ this->_Myres / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		_Elem *_Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 		_CATCH_ALL
; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2201 : 			_CATCH_ALL
; 2202 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2203 : 			_RERAISE;
; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END
; 2206 : 
; 2207 : 		if (0 < _Oldlen)
; 2208 : 			_Traits::copy(_Ptr, this->_Myptr(),
; 2209 : 				_Oldlen);	// copy existing elements
; 2210 : 		_Tidy(true);
; 2211 : 		this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
; 2212 : 		this->_Myres = _Newres;
; 2213 : 		_Eos(_Oldlen);
; 2214 : 		}
; 2215 : 
; 2216 : 	void _Eos(size_type _Newsize)
; 2217 : 		{	// set new length and null terminator
; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00819	48 89 75 e7	 mov	 QWORD PTR $T11[rbp-89], rsi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0081d	66 89 75 d7	 mov	 WORD PTR $T11[rbp-105], si
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 735  : 		assign(_Right, 0, npos);

  00821	49 83 c9 ff	 or	 r9, -1
  00825	45 33 c0	 xor	 r8d, r8d
  00828	48 8d 55 ff	 lea	 rdx, QWORD PTR filePath$[rbp-105]
  0082c	48 8d 4d d7	 lea	 rcx, QWORD PTR $T11[rbp-105]
  00830	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 276  : 	noTexFShader = new gfxu::FragmentShader(filePath);

  00835	48 8d 55 d7	 lea	 rdx, QWORD PTR $T11[rbp-105]
  00839	48 8b cb	 mov	 rcx, rbx
  0083c	e8 00 00 00 00	 call	 ??0FragmentShader@gfxu@@QEAA@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@Z ; gfxu::FragmentShader::FragmentShader
  00841	eb 03		 jmp	 SHORT $LN23@preStart
$LN22@preStart:
  00843	48 8b c6	 mov	 rax, rsi
$LN23@preStart:
  00846	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA, rax ; noTexFShader

; 278  : 	noTexShaderProgram = new gfxu::ShaderProgram(noTexVShader, nullptr, noTexFShader);

  0084d	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00852	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00857	48 8b d8	 mov	 rbx, rax
  0085a	48 89 45 c7	 mov	 QWORD PTR $T3[rbp-105], rax
  0085e	48 85 c0	 test	 rax, rax
  00861	74 27		 je	 SHORT $LN24@preStart
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 397  : {

  00863	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA ; noTexVShader
  0086a	48 89 08	 mov	 QWORD PTR [rax], rcx
  0086d	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi
  00871	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA ; noTexFShader
  00878	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx
  0087c	c6 40 1c 00	 mov	 BYTE PTR [rax+28], 0

; 398  : 	create();

  00880	48 8b c8	 mov	 rcx, rax
  00883	e8 00 00 00 00	 call	 ?create@ShaderProgram@gfxu@@AEAA_NXZ ; gfxu::ShaderProgram::create
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 278  : 	noTexShaderProgram = new gfxu::ShaderProgram(noTexVShader, nullptr, noTexFShader);

  00888	eb 03		 jmp	 SHORT $LN25@preStart
$LN24@preStart:
  0088a	48 8b de	 mov	 rbx, rsi
$LN25@preStart:
  0088d	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA, rbx ; noTexShaderProgram
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 617  : 	MMS.clear();

  00894	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?MMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::MMS
  0089b	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear

; 618  : 	PMS.clear();

  008a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?PMS@Uniforms@gfxu@@2VMatrixStack@2@A ; gfxu::Uniforms::PMS
  008a7	e8 00 00 00 00	 call	 ?clear@MatrixStack@gfxu@@QEAAXXZ ; gfxu::MatrixStack::clear
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 282  : 	glClearColor(0.5f, 0.875f, 1.0f, 1.0f);

  008ac	0f 28 df	 movaps	 xmm3, xmm7
  008af	0f 28 d7	 movaps	 xmm2, xmm7
  008b2	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f600000
  008ba	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  008c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glClearColor

; 283  : 	glEnable(GL_DEPTH_TEST);

  008c8	b9 71 0b 00 00	 mov	 ecx, 2929		; 00000b71H
  008cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 284  : 	glEnable(GL_CULL_FACE);

  008d3	b9 44 0b 00 00	 mov	 ecx, 2884		; 00000b44H
  008d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glEnable

; 285  : 	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

  008de	ba 03 03 00 00	 mov	 edx, 771		; 00000303H
  008e3	8d 4a ff	 lea	 ecx, QWORD PTR [rdx-1]
  008e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glBlendFunc
  008ec	90		 npad	 1
$LN40@preStart:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  008ed	48 83 7d 17 08	 cmp	 QWORD PTR filePath$[rbp-81], 8
  008f2	72 09		 jb	 SHORT $LN740@preStart
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  008f4	48 8b 4d ff	 mov	 rcx, QWORD PTR filePath$[rbp-105]
  008f8	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN740@preStart:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 286  : }

  008fd	48 8b 4d 1f	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-105]
  00901	48 33 cc	 xor	 rcx, rsp
  00904	e8 00 00 00 00	 call	 __security_check_cookie
  00909	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  00911	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00915	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00919	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  0091d	41 0f 28 73 f0	 movaps	 xmm6, XMMWORD PTR [r11-16]
  00922	41 0f 28 7b e0	 movaps	 xmm7, XMMWORD PTR [r11-32]
  00927	45 0f 28 43 d0	 movaps	 xmm8, XMMWORD PTR [r11-48]
  0092c	49 8b e3	 mov	 rsp, r11
  0092f	5d		 pop	 rbp
  00930	c3		 ret	 0
?preStart@RenderThread@@UEAAXXZ ENDP			; RenderThread::preStart
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
error$9 = 56
error$10 = 56
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 208
?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$0
  00000	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR filePath$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$0@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
error$9 = 56
error$10 = 56
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 208
?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$4
  0000c	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T8[rdx]
  00013	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$4@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
error$9 = 56
error$10 = 56
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 208
?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$6
  00018	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T7[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$6@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
error$9 = 56
error$10 = 56
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 208
?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$8
  00024	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T6[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$8@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$8
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
error$9 = 56
error$10 = 56
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 208
?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$9
  00030	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T5[rdx]
  00037	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$9@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$9
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
error$9 = 56
error$10 = 56
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 208
?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$11
  0003c	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T4[rdx]
  00043	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$11@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
error$1 = 48
error$2 = 48
$T3 = 48
$T4 = 48
$T5 = 48
$T6 = 48
$T7 = 48
$T8 = 48
error$9 = 56
error$10 = 56
$T11 = 64
$T12 = 64
$T13 = 64
$T14 = 64
$T15 = 64
$T16 = 96
filePath$ = 104
__$ArrayPad$ = 136
this$ = 208
?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA PROC	; `RenderThread::preStart'::`1'::dtor$13
  00048	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR $T3[rdx]
  0004f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?dtor$13@?0??preStart@RenderThread@@UEAAXXZ@4HA ENDP	; `RenderThread::preStart'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp
;	COMDAT ?postStop@RenderThread@@UEAAXXZ
_TEXT	SEGMENT
this$ = 48
$T1 = 56
?postStop@RenderThread@@UEAAXXZ PROC			; RenderThread::postStop, COMDAT

; 289  : {

$LN108:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 290  : 	delete grid;

  0000a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?grid@@3PEAVVertexStream@gfxu@@EA ; grid
  00011	48 85 c9	 test	 rcx, rcx
  00014	74 0a		 je	 SHORT $LN3@postStop
  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	ba 01 00 00 00	 mov	 edx, 1
  0001e	ff 10		 call	 QWORD PTR [rax]
$LN3@postStop:

; 291  : 	delete square;

  00020	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?square@@3PEAVVertexStream@gfxu@@EA ; square
  00027	48 85 c9	 test	 rcx, rcx
  0002a	74 0a		 je	 SHORT $LN5@postStop
  0002c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0002f	ba 01 00 00 00	 mov	 edx, 1
  00034	ff 10		 call	 QWORD PTR [rax]
$LN5@postStop:

; 292  : 	delete normalVShader;

  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalVShader@@3PEAVVertexShader@gfxu@@EA ; normalVShader
  0003d	48 85 c9	 test	 rcx, rcx
  00040	74 05		 je	 SHORT $LN7@postStop
  00042	e8 00 00 00 00	 call	 ??_GVertexShader@gfxu@@QEAAPEAXI@Z
$LN7@postStop:

; 293  : 	delete normalFShader;

  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?normalFShader@@3PEAVFragmentShader@gfxu@@EA ; normalFShader
  0004e	48 85 c9	 test	 rcx, rcx
  00051	74 05		 je	 SHORT $LN9@postStop
  00053	e8 00 00 00 00	 call	 ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
$LN9@postStop:

; 294  : 	delete normalShaderProgram;

  00058	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?normalShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; normalShaderProgram
  0005f	48 85 db	 test	 rbx, rbx
  00062	74 19		 je	 SHORT $LN21@postStop
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 403  : 	glUseProgram(0);

  00064	33 c9		 xor	 ecx, ecx
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 404  : 	glDeleteProgram(object);

  0006c	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  00075	48 8b cb	 mov	 rcx, rbx
  00078	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN21@postStop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 295  : 	delete noTexVShader;

  0007d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexVShader@@3PEAVVertexShader@gfxu@@EA ; noTexVShader
  00084	48 85 c9	 test	 rcx, rcx
  00087	74 05		 je	 SHORT $LN13@postStop
  00089	e8 00 00 00 00	 call	 ??_GVertexShader@gfxu@@QEAAPEAXI@Z
$LN13@postStop:

; 296  : 	delete noTexFShader;

  0008e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?noTexFShader@@3PEAVFragmentShader@gfxu@@EA ; noTexFShader
  00095	48 85 c9	 test	 rcx, rcx
  00098	74 05		 je	 SHORT $LN15@postStop
  0009a	e8 00 00 00 00	 call	 ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
$LN15@postStop:

; 297  : 	delete noTexShaderProgram;

  0009f	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?noTexShaderProgram@@3PEAVShaderProgram@gfxu@@EA ; noTexShaderProgram
  000a6	48 85 db	 test	 rbx, rbx
  000a9	74 19		 je	 SHORT $LN26@postStop
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 403  : 	glUseProgram(0);

  000ab	33 c9		 xor	 ecx, ecx
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 404  : 	glDeleteProgram(object);

  000b3	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  000bc	48 8b cb	 mov	 rcx, rbx
  000bf	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN26@postStop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 298  : 	delete blocksTexture;

  000c4	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ?blocksTexture@RenderThread@@2PEAVTiledTexture@gfxu@@EA ; RenderThread::blocksTexture
  000cb	48 85 ff	 test	 rdi, rdi
  000ce	74 4b		 je	 SHORT $LN31@postStop
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  000d0	4c 8b 47 28	 mov	 r8, QWORD PTR [rdi+40]
  000d4	48 8d 54 24 38	 lea	 rdx, QWORD PTR $T1[rsp]
  000d9	48 8d 4f 28	 lea	 rcx, QWORD PTR [rdi+40]
  000dd	4d 8b c8	 mov	 r9, r8
  000e0	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  000e3	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@U?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,gfxu::TiledTexture::Icon * __ptr64,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,gfxu::TiledTexture::Icon * __ptr64> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  000e8	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  000ec	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 682  : 	if(data != nullptr)

  000f1	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  000f5	48 85 c9	 test	 rcx, rcx
  000f8	74 05		 je	 SHORT $LN99@postStop

; 683  : 	{
; 684  : 		delete[] data;

  000fa	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN99@postStop:

; 685  : 	}
; 686  : 
; 687  : 	if(uploaded)

  000ff	80 7f 11 00	 cmp	 BYTE PTR [rdi+17], 0
  00103	74 0e		 je	 SHORT $LN98@postStop

; 688  : 	{
; 689  : 		glDeleteTextures(1, &object);

  00105	48 8b d7	 mov	 rdx, rdi
  00108	b9 01 00 00 00	 mov	 ecx, 1
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDeleteTextures
$LN98@postStop:
  00113	48 8b cf	 mov	 rcx, rdi
  00116	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN31@postStop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\window.cpp

; 239  : 	if(hRC)

  0011b	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR ?instance@GLWindow@@2PEAV1@EA ; GLWindow::instance
  00122	48 83 7b 20 00	 cmp	 QWORD PTR [rbx+32], 0
  00127	74 14		 je	 SHORT $LN102@postStop

; 240  : 	{
; 241  : 		if(!wglMakeCurrent(NULL, NULL))

  00129	33 d2		 xor	 edx, edx
  0012b	33 c9		 xor	 ecx, ecx
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglMakeCurrent

; 242  : 		{
; 243  : 			error = true;
; 244  : 		}
; 245  : 
; 246  : 		if(!wglDeleteContext(hRC))

  00133	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_wglDeleteContext
$LN102@postStop:
; File c:\users\glenn\documents\github\wind\project\wind\wind\renderthread.cpp

; 301  : }

  0013d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00142	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00146	5f		 pop	 rdi
  00147	c3		 ret	 0
?postStop@RenderThread@@UEAAXXZ ENDP			; RenderThread::postStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??_GVertexShader@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
??_GVertexShader@gfxu@@QEAAPEAXI@Z PROC			; gfxu::VertexShader::`scalar deleting destructor', COMDAT
$LN45:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 354  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 355  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN7@scalar

; 356  : 	{
; 357  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN7@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN33@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN33@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0005a	48 8b c3	 mov	 rax, rbx
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
??_GVertexShader@gfxu@@QEAAPEAXI@Z ENDP			; gfxu::VertexShader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA PROC	; `gfxu::VertexShader::`scalar deleting destructor''::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???_GVertexShader@gfxu@@QEAAPEAXI@Z@4HA ENDP	; `gfxu::VertexShader::`scalar deleting destructor''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??_GFragmentShader@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
??_GFragmentShader@gfxu@@QEAAPEAXI@Z PROC		; gfxu::FragmentShader::`scalar deleting destructor', COMDAT
$LN45:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 354  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 355  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN7@scalar

; 356  : 	{
; 357  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN7@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN33@scalar
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN33@scalar:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 8b cb	 mov	 rcx, rbx
  00055	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0005a	48 8b c3	 mov	 rax, rbx
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
??_GFragmentShader@gfxu@@QEAAPEAXI@Z ENDP		; gfxu::FragmentShader::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__flags$dead$ = 72
?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA PROC ; `gfxu::FragmentShader::`scalar deleting destructor''::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???_GFragmentShader@gfxu@@QEAAPEAXI@Z@4HA ENDP ; `gfxu::FragmentShader::`scalar deleting destructor''::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
;	COMDAT ??_GShaderProgram@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$dead$ = 56
??_GShaderProgram@gfxu@@QEAAPEAXI@Z PROC		; gfxu::ShaderProgram::`scalar deleting destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 403  : 	glUseProgram(0);

  00009	33 c9		 xor	 ecx, ecx
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __glewUseProgram

; 404  : 	glDeleteProgram(object);

  00011	8b 4b 18	 mov	 ecx, DWORD PTR [rbx+24]
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteProgram
  0001a	48 8b cb	 mov	 rcx, rbx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00022	48 8b c3	 mov	 rax, rbx
  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
??_GShaderProgram@gfxu@@QEAAPEAXI@Z ENDP		; gfxu::ShaderProgram::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
;	COMDAT ??_GTiledTexture@gfxu@@QEAAPEAXI@Z
_TEXT	SEGMENT
$T1 = 48
this$ = 48
__flags$dead$ = 56
??_GTiledTexture@gfxu@@QEAAPEAXI@Z PROC			; gfxu::TiledTexture::`scalar deleting destructor', COMDAT
$LN73:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xtree

; 2216 : 		erase(begin(), end());

  0000a	4c 8b 41 28	 mov	 r8, QWORD PTR [rcx+40]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T1[rsp]
  00016	4d 8b c8	 mov	 r9, r8
  00019	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0001c	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00020	e8 00 00 00 00	 call	 ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@U?$less@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@2@$0A@@std@@@std@@QEAA?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PEAVIcon@TiledTexture@gfxu@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,gfxu::TiledTexture::Icon * __ptr64,std::less<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >,std::allocator<std::pair<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const ,gfxu::TiledTexture::Icon * __ptr64> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00025	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00029	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 682  : 	if(data != nullptr)

  0002e	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00032	48 85 c9	 test	 rcx, rcx
  00035	74 05		 je	 SHORT $LN69@scalar

; 683  : 	{
; 684  : 		delete[] data;

  00037	e8 00 00 00 00	 call	 ??_V@YAXPEAX@Z		; operator delete[]
$LN69@scalar:

; 685  : 	}
; 686  : 
; 687  : 	if(uploaded)

  0003c	80 7f 11 00	 cmp	 BYTE PTR [rdi+17], 0
  00040	74 0e		 je	 SHORT $LN68@scalar

; 688  : 	{
; 689  : 		glDeleteTextures(1, &object);

  00042	48 8b d7	 mov	 rdx, rdi
  00045	b9 01 00 00 00	 mov	 ecx, 1
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_glDeleteTextures
$LN68@scalar:
  00050	48 8b cf	 mov	 rcx, rdi
  00053	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00058	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005d	48 8b c7	 mov	 rax, rdi
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
??_GTiledTexture@gfxu@@QEAAPEAXI@Z ENDP			; gfxu::TiledTexture::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??1VertexShader@gfxu@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1VertexShader@gfxu@@QEAA@XZ PROC			; gfxu::VertexShader::~VertexShader, COMDAT
$LN42:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 354  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 355  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN4@VertexShad

; 356  : 	{
; 357  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN4@VertexShad:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN30@VertexShad
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN30@VertexShad:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
??1VertexShader@gfxu@@QEAA@XZ ENDP			; gfxu::VertexShader::~VertexShader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA PROC	; `gfxu::VertexShader::~VertexShader'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1VertexShader@gfxu@@QEAA@XZ@4HA ENDP	; `gfxu::VertexShader::~VertexShader'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd
;	COMDAT ??1FragmentShader@gfxu@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1FragmentShader@gfxu@@QEAA@XZ PROC			; gfxu::FragmentShader::~FragmentShader, COMDAT
$LN42:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.cpp

; 354  : {

  00016	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7Shader@gfxu@@6B@
  0001d	48 89 01	 mov	 QWORD PTR [rcx], rax

; 355  : 	if(compiled)

  00020	80 79 2c 00	 cmp	 BYTE PTR [rcx+44], 0
  00024	74 0a		 je	 SHORT $LN4@FragmentSh

; 356  : 	{
; 357  : 		glDeleteShader(object);

  00026	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __glewDeleteShader
  0002f	90		 npad	 1
$LN4@FragmentSh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2256 : 		else if (this->_BUF_SIZE <= this->_Myres)

  00030	48 83 7b 20 08	 cmp	 QWORD PTR [rbx+32], 8
  00035	72 09		 jb	 SHORT $LN30@FragmentSh
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 586  : 		::operator delete(_Ptr);

  00037	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0003b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN30@FragmentSh:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring

; 2265 : 		this->_Myres = this->_BUF_SIZE - 1;

  00040	48 c7 43 20 07
	00 00 00	 mov	 QWORD PTR [rbx+32], 7

; 2218 : 		_Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\iosfwd

; 347  : 		_Left = _Right;

  0004e	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5b		 pop	 rbx
  00057	c3		 ret	 0
??1FragmentShader@gfxu@@QEAA@XZ ENDP			; gfxu::FragmentShader::~FragmentShader
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA PROC	; `gfxu::FragmentShader::~FragmentShader'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 83 c1 08	 add	 rcx, 8
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
?dtor$1@?0???1FragmentShader@gfxu@@QEAA@XZ@4HA ENDP	; `gfxu::FragmentShader::~FragmentShader'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT

; 970  : 		{	// assign _Right

$LN59:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 971  : 		if (this != &_Right)

  00009	48 3b ca	 cmp	 rcx, rdx
  0000c	74 0c		 je	 SHORT $LN57@operator

; 986  : 
; 987  : 	_Myt& operator=(const _Elem *_Ptr)
; 988  : 		{	// assign [_Ptr, <null>)
; 989  : 		return (assign(_Ptr));
; 990  : 		}
; 991  : 
; 992  : 	_Myt& operator=(_Elem _Ch)
; 993  : 		{	// assign 1 * _Ch
; 994  : 		return (assign(1, _Ch));
; 995  : 		}
; 996  : 
; 997  : 	_Myt& operator+=(const _Myt& _Right)
; 998  : 		{	// append _Right
; 999  : 		return (append(_Right));
; 1000 : 		}
; 1001 : 
; 1002 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1003 : 		{	// append [_Ptr, <null>)
; 1004 : 		return (append(_Ptr));
; 1005 : 		}
; 1006 : 
; 1007 : 	_Myt& operator+=(_Elem _Ch)
; 1008 : 		{	// append 1 * _Ch
; 1009 : 		return (append((size_type)1, _Ch));
; 1010 : 		}
; 1011 : 
; 1012 : 	_Myt& append(const _Myt& _Right)
; 1013 : 		{	// append _Right
; 1014 : 		return (append(_Right, 0, npos));
; 1015 : 		}
; 1016 : 
; 1017 : 	_Myt& append(const _Myt& _Right,
; 1018 : 		size_type _Roff, size_type _Count)
; 1019 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1020 : 		if (_Right.size() < _Roff)
; 1021 : 			_Xran();	// _Roff off end
; 1022 : 		size_type _Num = _Right.size() - _Roff;
; 1023 : 		if (_Num < _Count)
; 1024 : 			_Count = _Num;	// trim _Count to size
; 1025 : 		if (npos - this->_Mysize <= _Count)
; 1026 : 			_Xlen();	// result too long
; 1027 : 
; 1028 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1029 : 			{	// make room and append new stuff
; 1030 : 			_Traits::copy(this->_Myptr() + this->_Mysize,
; 1031 : 				_Right._Myptr() + _Roff, _Count);
; 1032 : 			_Eos(_Num);
; 1033 : 			}
; 1034 : 		return (*this);
; 1035 : 		}
; 1036 : 
; 1037 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1038 : 		{	// append [_Ptr, _Ptr + _Count)
; 1039 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1040 : 		if (_Count != 0)
; 1041 : 			_DEBUG_POINTER(_Ptr);
; 1042 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1043 : 
; 1044 : 		if (_Inside(_Ptr))
; 1045 : 			return (append(*this,
; 1046 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1047 : 		if (npos - this->_Mysize <= _Count)
; 1048 : 			_Xlen();	// result too long
; 1049 : 
; 1050 : 		size_type _Num;
; 1051 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1052 : 			{	// make room and append new stuff
; 1053 : 			_Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
; 1054 : 			_Eos(_Num);
; 1055 : 			}
; 1056 : 		return (*this);
; 1057 : 		}
; 1058 : 
; 1059 : 	_Myt& append(const _Elem *_Ptr)
; 1060 : 		{	// append [_Ptr, <null>)
; 1061 : 		_DEBUG_POINTER(_Ptr);
; 1062 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1063 : 		}
; 1064 : 
; 1065 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1066 : 		{	// append _Count * _Ch
; 1067 : 		if (npos - this->_Mysize <= _Count)
; 1068 : 			_Xlen();	// result too long
; 1069 : 
; 1070 : 		size_type _Num;
; 1071 : 		if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
; 1072 : 			{	// make room and append new stuff using assign
; 1073 : 			_Chassign(this->_Mysize, _Count, _Ch);
; 1074 : 			_Eos(_Num);
; 1075 : 			}
; 1076 : 		return (*this);
; 1077 : 		}
; 1078 : 
; 1079 : 	template<class _Iter>
; 1080 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1081 : 			_Myt&>::type
; 1082 : 		append(_Iter _First, _Iter _Last)
; 1083 : 		{	// append [_First, _Last), input iterators
; 1084 : 		return (replace(end(), end(), _First, _Last));
; 1085 : 		}
; 1086 : 
; 1087 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1088 : 		{	// append [_First, _Last), const pointers
; 1089 : 		return (replace(end(), end(), _First, _Last));
; 1090 : 		}
; 1091 : 
; 1092 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1093 : 		{	// append [_First, _Last), const_iterators
; 1094 : 		return (replace(end(), end(), _First, _Last));
; 1095 : 		}
; 1096 : 
; 1097 : 	_Myt& assign(const _Myt& _Right)
; 1098 : 		{	// assign _Right
; 1099 : 		return (assign(_Right, 0, npos));

  0000e	49 83 c9 ff	 or	 r9, -1
  00012	45 33 c0	 xor	 r8d, r8d
  00015	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
$LN57@operator:

; 972  : 			{	// different, assign it
; 973  :  #if _HAS_CPP0X
; 974  : 			if (this->_Getal() != _Right._Getal()
; 975  : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 976  : 				{	// change allocator before copying
; 977  : 				_Tidy(true);
; 978  : 				this->_Change_alloc(_Right._Getal());
; 979  : 				}
; 980  :  #endif /* _HAS_CPP0X */
; 981  : 
; 982  : 			assign(_Right);
; 983  : 			}
; 984  : 		return (*this);

  0001a	48 8b c3	 mov	 rax, rbx

; 985  : 		}

  0001d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
;	COMDAT ?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z
_TEXT	SEGMENT
this$ = 8
value$ = 16
?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z PROC ; gfxu::Uniform<geom::Vector>::set, COMDAT

; 304  : 			val = value;

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	89 01		 mov	 DWORD PTR [rcx], eax
  00004	8b 42 04	 mov	 eax, DWORD PTR [rdx+4]
  00007	89 41 04	 mov	 DWORD PTR [rcx+4], eax
  0000a	8b 42 08	 mov	 eax, DWORD PTR [rdx+8]
  0000d	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  00010	8b 42 0c	 mov	 eax, DWORD PTR [rdx+12]

; 305  : 			changed = true;

  00013	c6 41 10 01	 mov	 BYTE PTR [rcx+16], 1
  00017	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 306  : 		}

  0001a	c3		 ret	 0
?set@?$Uniform@VVector@geom@@@gfxu@@QEAAXVVector@geom@@@Z ENDP ; gfxu::Uniform<geom::Vector>::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\graphics.h
;	COMDAT ?set@?$Uniform@M@gfxu@@QEAAXM@Z
_TEXT	SEGMENT
this$dead$ = 8
value$ = 16
?set@?$Uniform@M@gfxu@@QEAAXM@Z PROC			; gfxu::Uniform<float>::set, COMDAT

; 304  : 			val = value;

  00000	f3 0f 11 0d 00
	00 00 00	 movss	 DWORD PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A, xmm1

; 305  : 			changed = true;

  00008	c6 05 04 00 00
	00 01		 mov	 BYTE PTR ?fogDist@Uniforms@gfxu@@2V?$Uniform@M@2@A+4, 1

; 306  : 		}

  0000f	c3		 ret	 0
?set@?$Uniform@M@gfxu@@QEAAXM@Z ENDP			; gfxu::Uniform<float>::set
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ
_TEXT	SEGMENT
this$ = 8
??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ PROC ; std::shared_ptr<gfxu::VertexStream>::operator->, COMDAT

; 691  : 		return (this->_Get());

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 692  : 		}

  00003	c3		 ret	 0
??C?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ENDP ; std::shared_ptr<gfxu::VertexStream>::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ
_TEXT	SEGMENT
this$ = 8
??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ PROC ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64, COMDAT

; 703  : 		return (this->_Get() != 0 ? _CONVERTIBLE_TO_TRUE : 0);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 f7 d8	 neg	 rax
  00006	1b c0		 sbb	 eax, eax
  00008	f7 d8		 neg	 eax
  0000a	ff c8		 dec	 eax

; 704  : 		}

  0000c	c3		 ret	 0
??B?$shared_ptr@VVertexStream@gfxu@@@std@@QEBAPEQ?$_Bool_struct@V?$shared_ptr@VVertexStream@gfxu@@@std@@@1@HXZ ENDP ; std::shared_ptr<gfxu::VertexStream>::operator int std::_Bool_struct<std::shared_ptr<gfxu::VertexStream> >::* __ptr64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 44   : 		{	// construct with node pointer _Pnode

  00003	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 429  : 		return (_List.begin());

  00006	48 8b c2	 mov	 rax, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00009	48 89 0a	 mov	 QWORD PTR [rdx], rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 430  : 		}

  0000c	c3		 ret	 0
?begin@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash
;	COMDAT ?end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xhash

; 439  : 		return (_List.end());

  00006	48 8b c2	 mov	 rax, rdx

; 440  : 		}

  00009	c3		 ret	 0
?end@?$_Hash@V?$_Umap_traits@VChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@V?$_Uhash_compare@VChunkPosition@@U?$hash@VChunkPosition@@@std@@U?$equal_to@VChunkPosition@@@3@@3@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@3@$0A@@std@@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Hash<std::_Umap_traits<ChunkPosition,std::shared_ptr<ChunkBase>,std::_Uhash_compare<ChunkPosition,std::hash<ChunkPosition>,std::equal_to<ChunkPosition> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z PROC ; VirtualList<Tasks::Task,256,4098>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 63 c2	 movsxd	 rax, edx

; 53   : 		return List::operator[](index);

  00003	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]

; 54   : 	}

  00007	c3		 ret	 0
??A?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAPEAVTask@Tasks@@H@Z ENDP ; VirtualList<Tasks::Task,256,4098>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ PROC ; VirtualList<Tasks::Task,256,4098>::getSize, COMDAT

; 66   : 		return List::getSize();

  00000	8b 81 00 08 00
	00		 mov	 eax, DWORD PTR [rcx+2048]

; 67   : 	}

  00006	c3		 ret	 0
?getSize@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAHXZ ENDP ; VirtualList<Tasks::Task,256,4098>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ PROC ; VirtualList<Tasks::Task,256,4098>::clear, COMDAT

; 37   : 		count = 0;

  00000	33 c0		 xor	 eax, eax
  00002	89 81 00 08 00
	00		 mov	 DWORD PTR [rcx+2048], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\memutil.cpp

; 18   : 	pos = 0;

  00008	89 81 14 08 00
	00		 mov	 DWORD PTR [rcx+2068], eax
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h

; 73   : 	}

  0000e	c3		 ret	 0
?clear@?$VirtualList@VTask@Tasks@@$0BAA@$0BAAC@@@QEAAXXZ ENDP ; VirtualList<Tasks::Task,256,4098>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 686  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >, COMDAT

; 900  : 		_Tidy();

  00000	e9 00 00 00 00	 jmp	 ?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
??1?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAA@XZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::~vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size, COMDAT

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 04	 sar	 rax, 4

; 1088 : 		}

  0000b	c3		 ret	 0
?size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z
_TEXT	SEGMENT
this$ = 8
_Pos$ = 16
??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[], COMDAT

; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));

  00000	48 c1 e2 04	 shl	 rdx, 4
  00004	48 03 11	 add	 rdx, QWORD PTR [rcx]
  00007	48 8b c2	 mov	 rax, rdx

; 1149 : 		}

  0000a	c3		 ret	 0
??A?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAAEAV?$shared_ptr@VChunkBase@@@1@_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Val$ = 56
?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back, COMDAT

; 1184 : 		{	// insert element at end

$LN80:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 1184 : 		{	// insert element at end

  0000e	48 8b fa	 mov	 rdi, rdx
  00011	48 8b d9	 mov	 rbx, rcx

; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1489 : 		if (_Capacity < _Count)
; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);
; 1492 : 		}
; 1493 : 
; 1494 : 	bool _Inside(const value_type *_Ptr) const
; 1495 : 		{	// test if _Ptr points inside vector
; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00014	48 3b d0	 cmp	 rdx, rax
  00017	73 22		 jae	 SHORT $LN4@push_back
  00019	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001c	48 3b ca	 cmp	 rcx, rdx
  0001f	77 1a		 ja	 SHORT $LN4@push_back

; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)

  00021	48 2b f9	 sub	 rdi, rcx
  00024	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  00028	75 08		 jne	 SHORT $LN3@push_back

; 1189 : 				_Reserve(1);

  0002a	48 8b cb	 mov	 rcx, rbx
  0002d	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
$LN3@push_back:

; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);

  00032	48 83 e7 f0	 and	 rdi, -16
  00036	48 03 3b	 add	 rdi, QWORD PTR [rbx]

; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else

  00039	eb 0e		 jmp	 SHORT $LN1@push_back
$LN4@push_back:

; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)

  0003b	48 3b 43 10	 cmp	 rax, QWORD PTR [rbx+16]
  0003f	75 08		 jne	 SHORT $LN1@push_back

; 1198 : 				_Reserve(1);

  00041	48 8b cb	 mov	 rcx, rbx
  00044	e8 00 00 00 00	 call	 ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
$LN1@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 606  : 		::new ((void *)_Ptr) _Ty(_Val);

  00049	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0004d	48 85 c9	 test	 rcx, rcx
  00050	74 1f		 je	 SHORT $LN60@push_back
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  00052	33 c0		 xor	 eax, eax
  00054	48 89 01	 mov	 QWORD PTR [rcx], rax
  00057	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  0005b	4c 8b 47 08	 mov	 r8, QWORD PTR [rdi+8]
  0005f	48 8b 17	 mov	 rdx, QWORD PTR [rdi]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  00062	4d 85 c0	 test	 r8, r8
  00065	74 05		 je	 SHORT $LN73@push_back

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00067	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN73@push_back:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  0006c	e8 00 00 00 00	 call	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN60@push_back:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1202 : 			++this->_Mylast;

  00071	48 83 43 08 10	 add	 QWORD PTR [rbx+8], 16

; 1203 : 			}
; 1204 : 		}

  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
?push_back@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEAAXAEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->, COMDAT

; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}

  00007	c3		 ret	 0
??C?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00003	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);

  00006	48 8b c1	 mov	 rax, rcx

; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00009	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 375  : 		}

  0000c	c3		 ret	 0
??E?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=, COMDAT

; 298  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx

; 303  : 		return (!(*this == _Right));

  00006	0f 95 c0	 setne	 al

; 304  : 		}

  00009	c3		 ret	 0
??9?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT

; 1099 : 		return (assign(_Right, 0, npos));

  00000	49 83 c9 ff	 or	 r9, -1
  00004	45 33 c0	 xor	 r8d, r8d
  00007	e9 00 00 00 00	 jmp	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@_K1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstring
;	COMDAT ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z PROC ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc, COMDAT

; 641  : 		}

  00000	c2 00 00	 ret	 0
?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QEAAXAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ENDP ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::_Change_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ
_TEXT	SEGMENT
this$ = 8
?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ PROC ; std::_Ptr_base<gfxu::VertexStream>::_Get, COMDAT

; 335  : 		return (_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 336  : 		}

  00003	c3		 ret	 0
?_Get@?$_Ptr_base@VVertexStream@gfxu@@@std@@QEBAPEAVVertexStream@gfxu@@XZ ENDP ; std::_Ptr_base<gfxu::VertexStream>::_Get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::begin, COMDAT

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}
; 47   : 
; 48   : 	reference operator*() const
; 49   : 		{	// return designated value
; 50   : 		return (_Mylist::_Myval(_Ptr));
; 51   : 		}
; 52   : 
; 53   : 	pointer operator->() const
; 54   : 		{	// return pointer to class object
; 55   : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 56   : 		}
; 57   : 
; 58   : 	_Myiter& operator++()
; 59   : 		{	// preincrement
; 60   : 		_Ptr = _Mylist::_Nextnode(_Ptr);
; 61   : 		return (*this);
; 62   : 		}
; 63   : 
; 64   : 	_Myiter operator++(int)
; 65   : 		{	// postincrement
; 66   : 		_Myiter _Tmp = *this;
; 67   : 		++*this;
; 68   : 		return (_Tmp);
; 69   : 		}
; 70   : 
; 71   : 	_Myiter& operator--()
; 72   : 		{	// predecrement
; 73   : 		_Ptr = _Mylist::_Prevnode(_Ptr);
; 74   : 		return (*this);
; 75   : 		}
; 76   : 
; 77   : 	_Myiter operator--(int)
; 78   : 		{	// postdecrement
; 79   : 		_Myiter _Tmp = *this;
; 80   : 		--*this;
; 81   : 		return (_Tmp);
; 82   : 		}
; 83   : 
; 84   : 	bool operator==(const _Myiter& _Right) const
; 85   : 		{	// test for iterator equality
; 86   : 		return (_Ptr == _Right._Ptr);
; 87   : 		}
; 88   : 
; 89   : 	bool operator!=(const _Myiter& _Right) const
; 90   : 		{	// test for iterator inequality
; 91   : 		return (!(*this == _Right));
; 92   : 		}
; 93   : 
; 94   : 	_Nodeptr _Mynode() const
; 95   : 		{	// return node pointer
; 96   : 		return (_Ptr);
; 97   : 		}
; 98   : 
; 99   : 	_Nodeptr _Ptr;	// pointer to node
; 100  : 	};
; 101  : 
; 102  : 	// TEMPLATE CLASS _List_unchecked_iterator
; 103  : template<class _Mylist>
; 104  : 	class _List_unchecked_iterator
; 105  : 		: public _List_unchecked_const_iterator<_Mylist>
; 106  : 	{	// unchecked iterator for mutable list
; 107  : public:
; 108  : 	typedef _List_unchecked_iterator<_Mylist> _Myiter;
; 109  : 	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
; 110  : 	typedef bidirectional_iterator_tag iterator_category;
; 111  : 
; 112  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 113  : 	typedef typename _Mylist::value_type value_type;
; 114  : 	typedef typename _Mylist::difference_type difference_type;
; 115  : 	typedef typename _Mylist::pointer pointer;
; 116  : 	typedef typename _Mylist::reference reference;
; 117  : 
; 118  : 	_List_unchecked_iterator()
; 119  : 		{	// construct with null node
; 120  : 		}
; 121  : 
; 122  : 	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 123  : 		: _Mybase(_Pnode, _Plist)
; 124  : 		{	// construct with node pointer _Pnode
; 125  : 		}
; 126  : 
; 127  : 	reference operator*() const
; 128  : 		{	// return designated value
; 129  : 		return ((reference)**(_Mybase *)this);
; 130  : 		}
; 131  : 
; 132  : 	pointer operator->() const
; 133  : 		{	// return pointer to class object
; 134  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 135  : 		}
; 136  : 
; 137  : 	_Myiter& operator++()
; 138  : 		{	// preincrement
; 139  : 		++(*(_Mybase *)this);
; 140  : 		return (*this);
; 141  : 		}
; 142  : 
; 143  : 	_Myiter operator++(int)
; 144  : 		{	// postincrement
; 145  : 		_Myiter _Tmp = *this;
; 146  : 		++*this;
; 147  : 		return (_Tmp);
; 148  : 		}
; 149  : 
; 150  : 	_Myiter& operator--()
; 151  : 		{	// predecrement
; 152  : 		--(*(_Mybase *)this);
; 153  : 		return (*this);
; 154  : 		}
; 155  : 
; 156  : 	_Myiter operator--(int)
; 157  : 		{	// postdecrement
; 158  : 		_Myiter _Tmp = *this;
; 159  : 		--*this;
; 160  : 		return (_Tmp);
; 161  : 		}
; 162  : 	};
; 163  : 
; 164  : 	// TEMPLATE CLASS _List_const_iterator
; 165  : template<class _Mylist>
; 166  : 	class _List_const_iterator
; 167  : 		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
; 168  : 	{	// iterator for nonmutable list
; 169  : public:
; 170  : 	typedef _List_const_iterator<_Mylist> _Myiter;
; 171  : 	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
; 172  : 	typedef bidirectional_iterator_tag iterator_category;
; 173  : 
; 174  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 175  : 	typedef typename _Mylist::value_type value_type;
; 176  : 	typedef typename _Mylist::difference_type difference_type;
; 177  : 	typedef typename _Mylist::const_pointer pointer;
; 178  : 	typedef typename _Mylist::const_reference reference;
; 179  : 
; 180  : 	_List_const_iterator()
; 181  : 		: _Mybase()
; 182  : 		{	// construct with null node pointer
; 183  : 		}
; 184  : 
; 185  : 	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 186  : 		: _Mybase(_Pnode, _Plist)
; 187  : 		{	// construct with node pointer _Pnode
; 188  : 		}
; 189  : 
; 190  : 	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;
; 191  : 
; 192  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 193  : 		{	// reset from unchecked iterator
; 194  : 		this->_Ptr = _Right._Ptr;
; 195  : 		return (*this);
; 196  : 		}
; 197  : 
; 198  : 	_Unchecked_type _Unchecked() const
; 199  : 		{	// make an unchecked iterator
; 200  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 201  : 		}
; 202  : 
; 203  : 	reference operator*() const
; 204  : 		{	// return designated value
; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}
; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 44   : 		{	// construct with node pointer _Pnode

  00003	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 1115 : 		return (iterator(this->_Nextnode(this->_Myhead), this));

  00006	48 8b c2	 mov	 rax, rdx

; 44   : 		{	// construct with node pointer _Pnode

  00009	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 1116 : 		}

  0000c	c3		 ret	 0
?begin@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ PROC ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::end, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1125 : 		return (iterator(this->_Myhead, this));

  00006	48 8b c2	 mov	 rax, rdx

; 1126 : 		}

  00009	c3		 ret	 0
?end@?$list@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@V?$allocator@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@QEAA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@2@XZ ENDP ; std::list<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> >,std::allocator<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z
_TEXT	SEGMENT
this$ = 8
index$ = 16
??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z PROC ; List<Tasks::Task * __ptr64,256>::operator[], COMDAT

; 19   : 		return content[index];

  00000	48 63 c2	 movsxd	 rax, edx
  00003	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]

; 20   : 	}

  00007	c3		 ret	 0
??A?$List@PEAVTask@Tasks@@$0BAA@@@QEAAAEAPEAVTask@Tasks@@H@Z ENDP ; List<Tasks::Task * __ptr64,256>::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ
_TEXT	SEGMENT
this$ = 8
?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ PROC	; List<Tasks::Task * __ptr64,256>::getSize, COMDAT

; 32   : 		return count;

  00000	8b 81 00 08 00
	00		 mov	 eax, DWORD PTR [rcx+2048]

; 33   : 	}

  00006	c3		 ret	 0
?getSize@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAHXZ ENDP	; List<Tasks::Task * __ptr64,256>::getSize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\glenn\documents\github\wind\project\wind\wind\list.h
;	COMDAT ?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ PROC	; List<Tasks::Task * __ptr64,256>::clear, COMDAT

; 37   : 		count = 0;

  00000	c7 81 00 08 00
	00 00 00 00 00	 mov	 DWORD PTR [rcx+2048], 0

; 38   : 	}

  0000a	c3		 ret	 0
?clear@?$List@PEAVTask@Tasks@@$0BAA@@@QEAAXXZ ENDP	; List<Tasks::Task * __ptr64,256>::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside, COMDAT

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  00000	48 3b 51 08	 cmp	 rdx, QWORD PTR [rcx+8]
  00004	73 08		 jae	 SHORT $LN3@Inside
  00006	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00009	77 03		 ja	 SHORT $LN3@Inside
  0000b	b0 01		 mov	 al, 1

; 1497 : 		}

  0000d	c3		 ret	 0
$LN3@Inside:

; 1496 : 		return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);

  0000e	32 c0		 xor	 al, al

; 1497 : 		}

  00010	c3		 ret	 0
?_Inside@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_NPEBV?$shared_ptr@VChunkBase@@@2@@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve, COMDAT

; 1525 : 		{	// ensure room for _Count new elements, grow exponentially

$LN44:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 968  : 		}
; 969  : 
; 970  : 	size_type _Unused_capacity() const _NOEXCEPT
; 971  : 		{	// micro-optimization for capacity() - size()
; 972  : 		return (this->_Myend - this->_Mylast);

  00004	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  00008	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0000c	48 8b c2	 mov	 rax, rdx
  0000f	49 2b c0	 sub	 rax, r8
  00012	48 c1 f8 04	 sar	 rax, 4

; 1526 : 		if (_Unused_capacity() < _Count)

  00016	48 83 f8 01	 cmp	 rax, 1
  0001a	73 5d		 jae	 SHORT $LN2@Reserve

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0001c	4c 8b 11	 mov	 r10, QWORD PTR [rcx]

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0001f	49 b9 ff ff ff
	ff ff ff ff 0f	 mov	 r9, 1152921504606846975	; 0fffffffffffffffH

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00029	4d 2b c2	 sub	 r8, r10

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  0002c	49 8b c1	 mov	 rax, r9

; 973  : 		}
; 974  : 
; 975  : 	size_type _Has_unused_capacity() const _NOEXCEPT
; 976  : 		{	// micro-optimization for capacity() != size()
; 977  : 		return (this->_Myend != this->_Mylast);
; 978  : 		}
; 979  : 
; 980  : 	iterator begin() _NOEXCEPT
; 981  : 		{	// return iterator for beginning of mutable sequence
; 982  : 		return (iterator(this->_Myfirst, this));
; 983  : 		}
; 984  : 
; 985  : 	const_iterator begin() const _NOEXCEPT
; 986  : 		{	// return iterator for beginning of nonmutable sequence
; 987  : 		return (const_iterator(this->_Myfirst, this));
; 988  : 		}
; 989  : 
; 990  : 	iterator end() _NOEXCEPT
; 991  : 		{	// return iterator for end of mutable sequence
; 992  : 		return (iterator(this->_Mylast, this));
; 993  : 		}
; 994  : 
; 995  : 	const_iterator end() const _NOEXCEPT
; 996  : 		{	// return iterator for end of nonmutable sequence
; 997  : 		return (const_iterator(this->_Mylast, this));
; 998  : 		}
; 999  : 
; 1000 : 	iterator _Make_iter(const_iterator _Where) const
; 1001 : 		{	// make iterator from const_iterator
; 1002 : 		return (iterator(_Where._Ptr, this));
; 1003 : 		}
; 1004 : 
; 1005 : 	reverse_iterator rbegin() _NOEXCEPT
; 1006 : 		{	// return iterator for beginning of reversed mutable sequence
; 1007 : 		return (reverse_iterator(end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1011 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1012 : 		return (const_reverse_iterator(end()));
; 1013 : 		}
; 1014 : 
; 1015 : 	reverse_iterator rend() _NOEXCEPT
; 1016 : 		{	// return iterator for end of reversed mutable sequence
; 1017 : 		return (reverse_iterator(begin()));
; 1018 : 		}
; 1019 : 
; 1020 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1021 : 		{	// return iterator for end of reversed nonmutable sequence
; 1022 : 		return (const_reverse_iterator(begin()));
; 1023 : 		}
; 1024 : 
; 1025 :  #if _HAS_CPP0X
; 1026 : 	const_iterator cbegin() const _NOEXCEPT
; 1027 : 		{	// return iterator for beginning of nonmutable sequence
; 1028 : 		return (((const _Myt *)this)->begin());
; 1029 : 		}
; 1030 : 
; 1031 : 	const_iterator cend() const _NOEXCEPT
; 1032 : 		{	// return iterator for end of nonmutable sequence
; 1033 : 		return (((const _Myt *)this)->end());
; 1034 : 		}
; 1035 : 
; 1036 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1037 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1038 : 		return (((const _Myt *)this)->rbegin());
; 1039 : 		}
; 1040 : 
; 1041 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1042 : 		{	// return iterator for end of reversed nonmutable sequence
; 1043 : 		return (((const _Myt *)this)->rend());
; 1044 : 		}
; 1045 : 
; 1046 : 	void shrink_to_fit()
; 1047 : 		{	// reduce capacity
; 1048 : 		if (_Has_unused_capacity())
; 1049 : 			{	// worth shrinking, do it
; 1050 : 			if (empty())
; 1051 : 				_Tidy();
; 1052 : 			else
; 1053 : 				_Reallocate(size());
; 1054 : 			}
; 1055 : 		}
; 1056 :  #endif /* _HAS_CPP0X */
; 1057 : 
; 1058 : 	void resize(size_type _Newsize)
; 1059 : 		{	// determine new length, padding as needed
; 1060 : 		if (_Newsize < size())
; 1061 : 			erase(begin() + _Newsize, end());
; 1062 : 		else if (size() < _Newsize)
; 1063 : 			{	// pad as needed
; 1064 : 			_Alty _Alval(this->_Getal());
; 1065 : 			_Reserve(_Newsize - size());
; 1066 : 			_TRY_BEGIN
; 1067 : 			_Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
; 1068 : 				_Alval);
; 1069 : 			_CATCH_ALL
; 1070 : 			_Tidy();
; 1071 : 			_RERAISE;
; 1072 : 			_CATCH_END
; 1073 : 			this->_Mylast += _Newsize - size();
; 1074 : 			}
; 1075 : 		}
; 1076 : 
; 1077 : 	void resize(size_type _Newsize, const value_type& _Val)
; 1078 : 		{	// determine new length, padding with _Val elements as needed
; 1079 : 		if (_Newsize < size())
; 1080 : 			erase(begin() + _Newsize, end());
; 1081 : 		else if (size() < _Newsize)
; 1082 : 			_Insert_n(end(), _Newsize - size(), _Val);
; 1083 : 		}
; 1084 : 
; 1085 : 	size_type size() const _NOEXCEPT
; 1086 : 		{	// return length of sequence
; 1087 : 		return (this->_Mylast - this->_Myfirst);

  0002f	49 c1 f8 04	 sar	 r8, 4

; 1527 : 			{	// need more room, try to get it
; 1528 : 			if (max_size() - size() < _Count)

  00033	49 2b c0	 sub	 rax, r8
  00036	48 83 f8 01	 cmp	 rax, 1
  0003a	72 42		 jb	 SHORT $LN42@Reserve

; 967  : 		return (this->_Myend - this->_Myfirst);

  0003c	49 2b d2	 sub	 rdx, r10

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  0003f	49 ff c0	 inc	 r8

; 967  : 		return (this->_Myend - this->_Myfirst);

  00042	48 c1 fa 04	 sar	 rdx, 4

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00046	48 8b c2	 mov	 rax, rdx
  00049	48 d1 e8	 shr	 rax, 1
  0004c	4c 2b c8	 sub	 r9, rax
  0004f	4c 3b ca	 cmp	 r9, rdx
  00052	73 12		 jae	 SHORT $LN27@Reserve
  00054	33 d2		 xor	 edx, edx

; 1489 : 		if (_Capacity < _Count)

  00056	49 3b d0	 cmp	 rdx, r8
  00059	49 0f 42 d0	 cmovb	 rdx, r8

; 1531 : 			}
; 1532 : 		}

  0005d	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00061	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
$LN27@Reserve:

; 1088 : 		}
; 1089 : 
; 1090 : 	size_type max_size() const _NOEXCEPT
; 1091 : 		{	// return maximum possible length of sequence
; 1092 : 		return (this->_Getal().max_size());
; 1093 : 		}
; 1094 : 
; 1095 : 	bool empty() const _NOEXCEPT
; 1096 : 		{	// test if sequence is empty
; 1097 : 		return (this->_Myfirst == this->_Mylast);
; 1098 : 		}
; 1099 : 
; 1100 : 	_Alloc get_allocator() const _NOEXCEPT
; 1101 : 		{	// return allocator object for values
; 1102 : 		return (this->_Getal());
; 1103 : 		}
; 1104 : 
; 1105 : 	const_reference at(size_type _Pos) const
; 1106 : 		{	// subscript nonmutable sequence with checking
; 1107 : 		if (size() <= _Pos)
; 1108 : 			_Xran();
; 1109 : 		return (*(this->_Myfirst + _Pos));
; 1110 : 		}
; 1111 : 
; 1112 : 	reference at(size_type _Pos)
; 1113 : 		{	// subscript mutable sequence with checking
; 1114 : 		if (size() <= _Pos)
; 1115 : 			_Xran();
; 1116 : 		return (*(this->_Myfirst + _Pos));
; 1117 : 		}
; 1118 : 
; 1119 : 	const_reference operator[](size_type _Pos) const
; 1120 : 		{	// subscript nonmutable sequence
; 1121 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1122 : 		if (size() <= _Pos)
; 1123 : 			{	// report error
; 1124 : 			_DEBUG_ERROR("vector subscript out of range");
; 1125 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1126 : 			}
; 1127 : 
; 1128 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1129 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1130 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1131 : 
; 1132 : 		return (*(this->_Myfirst + _Pos));
; 1133 : 		}
; 1134 : 
; 1135 : 	reference operator[](size_type _Pos)
; 1136 : 		{	// subscript mutable sequence
; 1137 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 : 		if (size() <= _Pos)
; 1139 : 			{	// report error
; 1140 : 			_DEBUG_ERROR("vector subscript out of range");
; 1141 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1142 : 			}
; 1143 : 
; 1144 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1145 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1146 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1147 : 
; 1148 : 		return (*(this->_Myfirst + _Pos));
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_CPP0X
; 1152 : 	pointer data() _NOEXCEPT
; 1153 : 		{	// return address of first element
; 1154 : 		return (this->_Myfirst);
; 1155 : 		}
; 1156 : 
; 1157 : 	const_pointer data() const _NOEXCEPT
; 1158 : 		{	// return address of first element
; 1159 : 		return (this->_Myfirst);
; 1160 : 		}
; 1161 :  #endif /* _HAS_CPP0X */
; 1162 : 
; 1163 : 	reference front()
; 1164 : 		{	// return first element of mutable sequence
; 1165 : 		return (*begin());
; 1166 : 		}
; 1167 : 
; 1168 : 	const_reference front() const
; 1169 : 		{	// return first element of nonmutable sequence
; 1170 : 		return (*begin());
; 1171 : 		}
; 1172 : 
; 1173 : 	reference back()
; 1174 : 		{	// return last element of mutable sequence
; 1175 : 		return (*(end() - 1));
; 1176 : 		}
; 1177 : 
; 1178 : 	const_reference back() const
; 1179 : 		{	// return last element of nonmutable sequence
; 1180 : 		return (*(end() - 1));
; 1181 : 		}
; 1182 : 
; 1183 : 	void push_back(const value_type& _Val)
; 1184 : 		{	// insert element at end
; 1185 : 		if (_Inside(_STD addressof(_Val)))
; 1186 : 			{	// push back an element
; 1187 : 			size_type _Idx = _STD addressof(_Val) - this->_Myfirst;
; 1188 : 			if (this->_Mylast == this->_Myend)
; 1189 : 				_Reserve(1);
; 1190 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1191 : 			this->_Getal().construct(this->_Mylast,
; 1192 : 				this->_Myfirst[_Idx]);
; 1193 : 			++this->_Mylast;
; 1194 : 			}
; 1195 : 		else
; 1196 : 			{	// push back a non-element
; 1197 : 			if (this->_Mylast == this->_Myend)
; 1198 : 				_Reserve(1);
; 1199 : 			_Orphan_range(this->_Mylast, this->_Mylast);
; 1200 : 			this->_Getal().construct(this->_Mylast,
; 1201 : 				_Val);
; 1202 : 			++this->_Mylast;
; 1203 : 			}
; 1204 : 		}
; 1205 : 
; 1206 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1207 : 	void pop_back()
; 1208 : 		{	// erase element at end
; 1209 : 		if (empty())
; 1210 : 			_DEBUG_ERROR("vector empty before pop");
; 1211 : 		else
; 1212 : 			{	// erase last element
; 1213 : 			_Orphan_range(this->_Mylast - 1, this->_Mylast);
; 1214 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1215 : 			--this->_Mylast;
; 1216 : 			}
; 1217 : 		}
; 1218 : 
; 1219 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1220 : 	void pop_back()
; 1221 : 		{	// erase element at end
; 1222 : 		if (!empty())
; 1223 : 			{	// erase last element
; 1224 : 			this->_Getal().destroy(this->_Mylast - 1);
; 1225 : 			--this->_Mylast;
; 1226 : 			}
; 1227 : 		}
; 1228 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1229 : 
; 1230 : 	template<class _Iter>
; 1231 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1232 : 			void>::type
; 1233 : 		assign(_Iter _First, _Iter _Last)
; 1234 : 		{	// assign [_First, _Last), input iterators
; 1235 : 		erase(begin(), end());
; 1236 : 		insert(begin(), _First, _Last);
; 1237 : 		}
; 1238 : 
; 1239 : 	void assign(size_type _Count, const value_type& _Val)
; 1240 : 		{	// assign _Count * _Val
; 1241 : 		_Assign_n(_Count, _Val);
; 1242 : 		}
; 1243 : 
; 1244 : 	iterator insert(const_iterator _Where, const _Ty& _Val)
; 1245 : 		{	// insert _Val at _Where
; 1246 : 		return (_Insert_n(_Where, (size_type)1, _Val));
; 1247 : 		}
; 1248 : 
; 1249 : 	iterator insert(const_iterator _Where, size_type _Count,
; 1250 : 		const _Ty& _Val)
; 1251 : 		{	// insert _Count * _Val at _Where
; 1252 : 		return (_Insert_n(_Where, _Count, _Val));
; 1253 : 		}
; 1254 : 
; 1255 : 	template<class _Iter>
; 1256 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1257 : 			iterator>::type
; 1258 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1259 : 		{	// insert [_First, _Last) at _Where
; 1260 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1261 : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));
; 1262 : 		return (begin() + _Off);
; 1263 : 		}
; 1264 : 
; 1265 : 	template<class _Iter>
; 1266 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1267 : 			input_iterator_tag)
; 1268 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1269 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1270 : 
; 1271 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1272 : 		if (size() < _Off)
; 1273 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1274 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1275 : 
; 1276 : 		if (_First != _Last)
; 1277 : 			{	// worth doing, gather at end and rotate into place
; 1278 : 			size_type _Oldsize = size();
; 1279 : 
; 1280 : 			_TRY_BEGIN
; 1281 : 			for (; _First != _Last; ++_First)
; 1282 : 				push_back(*_First);	// append
; 1283 : 
; 1284 : 			_CATCH_ALL
; 1285 : 			erase(begin() + _Oldsize, end());
; 1286 : 			_RERAISE;
; 1287 : 			_CATCH_END
; 1288 : 
; 1289 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());
; 1290 : 			}
; 1291 : 		}
; 1292 : 
; 1293 : 	template<class _Iter>
; 1294 : 		void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
; 1295 : 			forward_iterator_tag)
; 1296 : 		{	// insert [_First, _Last) at _Where, forward iterators
; 1297 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1298 : 		if (_VICONT(_Where) != this
; 1299 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1300 : 			|| this->_Mylast < _VIPTR(_Where))
; 1301 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1302 : 		_DEBUG_RANGE(_First, _Last);
; 1303 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1304 : 
; 1305 : 		size_type _Count = 0;
; 1306 : 		_Distance(_First, _Last, _Count);
; 1307 : 
; 1308 : 		if (_Count == 0)
; 1309 : 			;
; 1310 : 		else if (_Unused_capacity() < _Count)
; 1311 : 			{	// not enough room, reallocate
; 1312 : 			if (max_size() - size() < _Count)
; 1313 : 				_Xlen();	// result too long
; 1314 : 
; 1315 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1316 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1317 : 			pointer _Ptr = _Newvec;
; 1318 : 
; 1319 : 			_TRY_BEGIN
; 1320 : 			_Ptr = _Umove(this->_Myfirst, _VIPTR(_Where),
; 1321 : 				_Newvec);	// copy prefix
; 1322 : 			_Ptr = _Ucopy(_First, _Last, _Ptr);	// add new stuff
; 1323 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1324 : 				_Ptr);	// copy suffix
; 1325 : 			_CATCH_ALL
; 1326 : 			_Destroy(_Newvec, _Ptr);
; 1327 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1328 : 			_RERAISE;
; 1329 : 			_CATCH_END
; 1330 : 
; 1331 : 			_Count += size();
; 1332 : 			if (this->_Myfirst != pointer())
; 1333 : 				{	// destroy and deallocate old array
; 1334 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1335 : 				this->_Getal().deallocate(this->_Myfirst,
; 1336 : 					this->_Myend - this->_Myfirst);
; 1337 : 				}
; 1338 : 
; 1339 : 			this->_Orphan_all();
; 1340 : 			this->_Myend = _Newvec + _Capacity;
; 1341 : 			this->_Mylast = _Newvec + _Count;
; 1342 : 			this->_Myfirst = _Newvec;
; 1343 : 			}
; 1344 : 		else
; 1345 : 			{	// new stuff fits, append and rotate into place
; 1346 : 			_Ucopy(_First, _Last, this->_Mylast);
; 1347 : 			_STD rotate(_VIPTR(_Where), this->_Mylast,
; 1348 : 				this->_Mylast + _Count);
; 1349 : 			this->_Mylast += _Count;
; 1350 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1351 : 			}
; 1352 : 		}
; 1353 : 
; 1354 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1355 : 	iterator erase(const_iterator _Where)
; 1356 : 		{	// erase element at where
; 1357 : 		if (_VICONT(_Where) != this
; 1358 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1359 : 			|| this->_Mylast <= _VIPTR(_Where))
; 1360 : 			_DEBUG_ERROR("vector erase iterator outside range");
; 1361 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast, _VIPTR(_Where));
; 1362 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1363 : 		_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1364 : 		--this->_Mylast;
; 1365 : 		return (_Make_iter(_Where));
; 1366 : 		}
; 1367 : 
; 1368 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1369 : 	iterator erase(const_iterator _Where)
; 1370 : 		{	// erase element at where
; 1371 : 		_Move(_VIPTR(_Where) + 1, this->_Mylast,
; 1372 : 			_VIPTR(_Where));
; 1373 : 		_Destroy(this->_Mylast - 1, this->_Mylast);
; 1374 : 		--this->_Mylast;
; 1375 : 		return (_Make_iter(_Where));
; 1376 : 		}
; 1377 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1378 : 
; 1379 : 	iterator erase(const_iterator _First_arg,
; 1380 : 		const_iterator _Last_arg)
; 1381 : 		{	// erase [_First, _Last)
; 1382 : 		if (_First_arg == begin() && _Last_arg == end())
; 1383 : 			clear();
; 1384 : 		else if (_First_arg != _Last_arg)
; 1385 : 			{	// clear partial
; 1386 : 			iterator _First = _Make_iter(_First_arg);
; 1387 : 			iterator _Last = _Make_iter(_Last_arg);
; 1388 : 
; 1389 : 			if (_First != _Last)
; 1390 : 				{	// worth doing, copy down over hole
; 1391 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1392 : 				if (_Last < _First || _VICONT(_First) != this
; 1393 : 					|| _VIPTR(_First) < this->_Myfirst
; 1394 : 					|| this->_Mylast < _VIPTR(_Last))
; 1395 : 					_DEBUG_ERROR("vector erase iterator outside range");
; 1396 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1397 : 					_VIPTR(_First));
; 1398 : 				_Orphan_range(_VIPTR(_First), this->_Mylast);
; 1399 : 
; 1400 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1401 : 				pointer _Ptr = _Move(_VIPTR(_Last), this->_Mylast,
; 1402 : 					_VIPTR(_First));
; 1403 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1404 : 
; 1405 : 				_Destroy(_Ptr, this->_Mylast);
; 1406 : 				this->_Mylast = _Ptr;
; 1407 : 				}
; 1408 : 			}
; 1409 : 		return (_Make_iter(_First_arg));
; 1410 : 		}
; 1411 : 
; 1412 : 	void clear() _NOEXCEPT
; 1413 : 		{	// erase all
; 1414 : 		this->_Orphan_all();
; 1415 : 		_Destroy(this->_Myfirst, this->_Mylast);
; 1416 : 		this->_Mylast = this->_Myfirst;
; 1417 : 		}
; 1418 : 
; 1419 : 	void swap(_Myt& _Right)
; 1420 : 		{	// exchange contents with _Right
; 1421 : 		if (this == &_Right)
; 1422 : 			;	// same object, do nothing
; 1423 : 		else if (this->_Getal() == _Right._Getal())
; 1424 : 			{	// same allocator, swap control information
; 1425 : 			this->_Swap_all(_Right);
; 1426 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1427 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1428 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1429 : 			}
; 1430 : 
; 1431 :  #if _HAS_CPP0X
; 1432 : 		else if (_Alty::propagate_on_container_swap::value)
; 1433 : 			{	// swap allocators and control information
; 1434 : 			this->_Swap_alloc(_Right);
; 1435 : 			_Swap_adl(this->_Myfirst, _Right._Myfirst);
; 1436 : 			_Swap_adl(this->_Mylast, _Right._Mylast);
; 1437 : 			_Swap_adl(this->_Myend, _Right._Myend);
; 1438 : 			}
; 1439 :  #endif /* _HAS_CPP0X */
; 1440 : 
; 1441 : 		else
; 1442 : 			{	// different allocator, do multiple moves
; 1443 : 			_Myt _Ts = _Move(*this);
; 1444 : 
; 1445 : 			*this = _Move(_Right);
; 1446 : 			_Right = _Move(_Ts);
; 1447 : 			}
; 1448 : 		}
; 1449 : 
; 1450 : protected:
; 1451 : 	void _Assign_n(size_type _Count, const value_type& _Val)
; 1452 : 		{	// assign _Count * _Val
; 1453 : 		value_type _Tmp = _Val;	// in case _Val is in sequence
; 1454 : 		erase(begin(), end());
; 1455 : 		insert(begin(), _Count, _Tmp);
; 1456 : 		}
; 1457 : 
; 1458 : 	bool _Buy(size_type _Capacity)
; 1459 : 		{	// allocate array with _Capacity elements
; 1460 : 		this->_Myfirst = pointer();
; 1461 : 		this->_Mylast = pointer();
; 1462 : 		this->_Myend = pointer();
; 1463 : 
; 1464 : 		if (_Capacity == 0)
; 1465 : 			return (false);
; 1466 : 		else if (max_size() < _Capacity)
; 1467 : 			_Xlen();	// result too long
; 1468 : 		else
; 1469 : 			{	// nonempty array, allocate storage
; 1470 : 			this->_Myfirst = this->_Getal().allocate(_Capacity);
; 1471 : 			this->_Mylast = this->_Myfirst;
; 1472 : 			this->_Myend = this->_Myfirst + _Capacity;
; 1473 : 			}
; 1474 : 		return (true);
; 1475 : 		}
; 1476 : 
; 1477 : 	void _Destroy(pointer _First, pointer _Last)
; 1478 : 		{	// destroy [_First, _Last) using allocator
; 1479 : 		_Alty _Alval(this->_Getal());
; 1480 : 		_Destroy_range(_First, _Last, _Alval);
; 1481 : 		}
; 1482 : 
; 1483 : 	size_type _Grow_to(size_type _Count) const
; 1484 : 		{	// grow by 50% or at least to _Count
; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00066	48 03 d0	 add	 rdx, rax

; 1489 : 		if (_Capacity < _Count)

  00069	49 3b d0	 cmp	 rdx, r8
  0006c	49 0f 42 d0	 cmovb	 rdx, r8

; 1531 : 			}
; 1532 : 		}

  00070	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 1529 : 				_Xlen();
; 1530 : 			_Reallocate(_Grow_to(size() + _Count));

  00074	e9 00 00 00 00	 jmp	 ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
$LN2@Reserve:

; 1531 : 			}
; 1532 : 		}

  00079	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007d	c3		 ret	 0
$LN42@Reserve:

; 1533 : 
; 1534 : 	void _Tidy()
; 1535 : 		{	// free all storage
; 1536 : 		if (this->_Myfirst != pointer())
; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);
; 1540 : 			this->_Getal().deallocate(this->_Myfirst,
; 1541 : 				this->_Myend - this->_Myfirst);
; 1542 : 			this->_Myfirst = pointer();
; 1543 : 			this->_Mylast = pointer();
; 1544 : 			this->_Myend = pointer();
; 1545 : 			}
; 1546 : 		}
; 1547 : 
; 1548 : 	template<class _Iter>
; 1549 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
; 1550 : 		{	// copy initializing [_First, _Last), using allocator
; 1551 : 		_Alty _Alval(this->_Getal());
; 1552 : 		return (_Uninitialized_copy(_First, _Last,
; 1553 : 			_Ptr, _Alval));
; 1554 : 		}
; 1555 : 
; 1556 : 	template<class _Iter>
; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
; 1558 : 		{	// move initializing [_First, _Last), using allocator
; 1559 : 		_Alty _Alval(this->_Getal());
; 1560 : 		return (_Uninitialized_move(_First, _Last,
; 1561 : 			_Ptr, _Alval));
; 1562 : 		}
; 1563 : 
; 1564 : 	iterator _Insert_n(const_iterator _Where,
; 1565 : 		size_type _Count, const value_type& _Val)
; 1566 : 		{	// insert _Count * _Val at _Where
; 1567 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1568 : 		if (_VICONT(_Where) != this
; 1569 : 			|| _VIPTR(_Where) < this->_Myfirst
; 1570 : 			|| this->_Mylast < _VIPTR(_Where))
; 1571 : 			_DEBUG_ERROR("vector insert iterator outside range");
; 1572 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1573 : 
; 1574 : 		size_type _Off = _VIPTR(_Where) - this->_Myfirst;
; 1575 : 		if (_Count == 0)
; 1576 : 			;
; 1577 : 		else if (_Unused_capacity() < _Count)
; 1578 : 			{	// not enough room, reallocate
; 1579 : 			if (max_size() - size() < _Count)
; 1580 : 				_Xlen();	// result too long
; 1581 : 
; 1582 : 			size_type _Capacity = _Grow_to(size() + _Count);
; 1583 : 			pointer _Newvec = this->_Getal().allocate(_Capacity);
; 1584 : 			size_type _Whereoff = _VIPTR(_Where) - this->_Myfirst;
; 1585 : 			int _Ncopied = 0;
; 1586 : 
; 1587 : 			_TRY_BEGIN
; 1588 : 			_Ufill(_Newvec + _Whereoff, _Count,
; 1589 : 				_STD addressof(_Val));	// add new stuff
; 1590 : 			++_Ncopied;
; 1591 : 			_Umove(this->_Myfirst, _VIPTR(_Where),
; 1592 : 				_Newvec);	// copy prefix
; 1593 : 			++_Ncopied;
; 1594 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1595 : 				_Newvec + (_Whereoff + _Count));	// copy suffix
; 1596 : 			_CATCH_ALL
; 1597 : 			if (1 < _Ncopied)
; 1598 : 				_Destroy(_Newvec, _Newvec + _Whereoff);
; 1599 : 			if (0 < _Ncopied)
; 1600 : 				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
; 1601 : 			this->_Getal().deallocate(_Newvec, _Capacity);
; 1602 : 			_RERAISE;
; 1603 : 			_CATCH_END
; 1604 : 
; 1605 : 			_Count += size();
; 1606 : 			if (this->_Myfirst != pointer())
; 1607 : 				{	// destroy and deallocate old array
; 1608 : 				_Destroy(this->_Myfirst, this->_Mylast);
; 1609 : 				this->_Getal().deallocate(this->_Myfirst,
; 1610 : 					this->_Myend - this->_Myfirst);
; 1611 : 				}
; 1612 : 
; 1613 : 			this->_Orphan_all();
; 1614 : 			this->_Myend = _Newvec + _Capacity;
; 1615 : 			this->_Mylast = _Newvec + _Count;
; 1616 : 			this->_Myfirst = _Newvec;
; 1617 : 			}
; 1618 : 		else if ((size_type)(this->_Mylast - _VIPTR(_Where))
; 1619 : 			< _Count)
; 1620 : 			{	// new stuff spills off end
; 1621 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1622 : 
; 1623 : 			_Umove(_VIPTR(_Where), this->_Mylast,
; 1624 : 				_VIPTR(_Where) + _Count);	// copy suffix
; 1625 : 
; 1626 : 			_TRY_BEGIN
; 1627 : 			_Ufill(this->_Mylast,
; 1628 : 				_Count - (this->_Mylast - _VIPTR(_Where)),
; 1629 : 				_STD addressof(_Tmp));	// insert new stuff off end
; 1630 : 			_CATCH_ALL
; 1631 : 			_Destroy(_VIPTR(_Where) + _Count,
; 1632 : 				this->_Mylast + _Count);
; 1633 : 			_RERAISE;
; 1634 : 			_CATCH_END
; 1635 : 
; 1636 : 			this->_Mylast += _Count;
; 1637 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1638 : 			_STD fill(_VIPTR(_Where), this->_Mylast - _Count,
; 1639 : 				_Tmp);	// insert up to old end
; 1640 : 			}
; 1641 : 		else
; 1642 : 			{	// new stuff can all be assigned
; 1643 : 			value_type _Tmp = _Val;	// in case _Val is in sequence
; 1644 : 
; 1645 : 			pointer _Oldend = this->_Mylast;
; 1646 : 			this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
; 1647 : 				this->_Mylast);	// copy suffix
; 1648 : 
; 1649 : 			_Orphan_range(_VIPTR(_Where), this->_Mylast);
; 1650 : 			_Copy_backward(_VIPTR(_Where), _Oldend - _Count,
; 1651 : 				_Oldend);	// copy hole
; 1652 : 			_STD fill(_VIPTR(_Where),
; 1653 : 				_VIPTR(_Where) + _Count, _Tmp);	// insert into hole
; 1654 : 			}
; 1655 : 		return (begin() + _Off);
; 1656 : 		}
; 1657 : 
; 1658 : 	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
; 1659 : 		{	// copy initializing _Count * _Val, using allocator
; 1660 : 		_Alty _Alval(this->_Getal());
; 1661 : 		_Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
; 1662 : 		return (_Ptr + _Count);
; 1663 : 		}
; 1664 : 
; 1665 : 	__declspec(noreturn) void _Xlen() const
; 1666 : 		{	// report a length_error
; 1667 : 		_Xlength_error("vector<T> too long");

  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  00085	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  0008a	cc		 int	 3
$LN41@Reserve:
?_Reserve@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy, COMDAT

; 1535 : 		{	// free all storage

$LN47:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1536 : 		if (this->_Myfirst != pointer())

  0000a	48 8b 39	 mov	 rdi, QWORD PTR [rcx]
  0000d	48 8b f1	 mov	 rsi, rcx
  00010	48 85 ff	 test	 rdi, rdi
  00013	74 69		 je	 SHORT $LN1@Tidy

; 1537 : 			{	// something to free, destroy and deallocate it
; 1538 : 			this->_Orphan_all();
; 1539 : 			_Destroy(this->_Myfirst, this->_Mylast);

  00015	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  0001a	48 8b 69 08	 mov	 rbp, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  0001e	48 3b fd	 cmp	 rdi, rbp
  00021	74 41		 je	 SHORT $LN12@Tidy
  00023	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00028	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL14@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00030	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00034	48 85 db	 test	 rbx, rbx
  00037	74 1d		 je	 SHORT $LN34@Tidy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00039	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0003d	75 17		 jne	 SHORT $LN34@Tidy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0003f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00042	48 8b cb	 mov	 rcx, rbx
  00045	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00047	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0004b	75 09		 jne	 SHORT $LN34@Tidy

; 128  : 			_Delete_this();

  0004d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00050	48 8b cb	 mov	 rcx, rbx
  00053	ff 50 08	 call	 QWORD PTR [rax+8]
$LN34@Tidy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00056	48 83 c7 10	 add	 rdi, 16
  0005a	48 3b fd	 cmp	 rdi, rbp
  0005d	75 d1		 jne	 SHORT $LL14@Tidy
  0005f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
$LN12@Tidy:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  00064	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00067	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  0006c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1542 : 			this->_Myfirst = pointer();

  00071	33 c0		 xor	 eax, eax
  00073	48 89 06	 mov	 QWORD PTR [rsi], rax

; 1543 : 			this->_Mylast = pointer();

  00076	48 89 46 08	 mov	 QWORD PTR [rsi+8], rax

; 1544 : 			this->_Myend = pointer();

  0007a	48 89 46 10	 mov	 QWORD PTR [rsi+16], rax
$LN1@Tidy:

; 1545 : 			}
; 1546 : 		}

  0007e	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00083	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
?_Tidy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range, COMDAT

; 1694 : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_range@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 594  : 		{	// construct allocator from _Al
; 595  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEAA@AEBV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@@Z ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ PROC ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal, COMDAT

; 647  : 		return (_Alty());

  00000	48 8b c2	 mov	 rax, rdx

; 648  : 		}

  00003	c3		 ret	 0
?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@@std@@QEBA?AU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@XZ ENDP ; std::_Vector_alloc<0,std::_Vec_base_types<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*, COMDAT

; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}

  00007	c3		 ret	 0
??D?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ
_TEXT	SEGMENT
this$ = 8
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++, COMDAT

; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);

  00003	48 8b 10	 mov	 rdx, QWORD PTR [rax]

; 241  : 		return (*this);

  00006	48 8b c1	 mov	 rax, rcx
  00009	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 242  : 		}

  0000c	c3		 ret	 0
??E?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAAAEAV01@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==, COMDAT

; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);

  00000	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00003	48 39 11	 cmp	 QWORD PTR [rcx], rdx
  00006	0f 94 c0	 sete	 al

; 299  : 		}

  00009	c3		 ret	 0
??8?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBA_NAEBV01@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z PROC ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to, COMDAT

; 233  : 		return (_STD addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 234  : 		}

  00003	c3		 ret	 0
?pointer_to@?$pointer_traits@PEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@AEAU32@@Z ENDP ; std::pointer_traits<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Nextnode, COMDAT

; 537  : 		return ((_Nodepref)_Pnode->_Next);

  00000	48 8b c1	 mov	 rax, rcx

; 538  : 		}

  00003	c3		 ret	 0
?_Nextnode@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAPEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@PEAU32@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Nextnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_Count$dead$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity, COMDAT

; 972  : 		return (this->_Myend - this->_Mylast);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 41 08	 sub	 rax, QWORD PTR [rcx+8]
  00008	48 c1 f8 04	 sar	 rax, 4

; 973  : 		}

  0000c	c3		 ret	 0
?_Unused_capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size, COMDAT

; 1092 : 		return (this->_Getal().max_size());

  00000	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 1093 : 		}

  0000a	c3		 ret	 0
?max_size@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy, COMDAT

; 1478 : 		{	// destroy [_First, _Last) using allocator

$LN37:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00000	49 3b d0	 cmp	 rdx, r8
  00003	74 5c		 je	 SHORT $LN35@Destroy
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1478 : 		{	// destroy [_First, _Last) using allocator

  00014	49 8b f0	 mov	 rsi, r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	48 8d 7a 08	 lea	 rdi, QWORD PTR [rdx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL9@Destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN29@Destroy

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN29@Destroy

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN29@Destroy

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN29@Destroy:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL9@Destroy
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1481 : 		}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN35@Destroy:
  00061	f3 c3		 fatret	 0
?_Destroy@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAXPEAV?$shared_ptr@VChunkBase@@@2@0@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00004	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH

; 967  : 		return (this->_Myend - this->_Myfirst);

  0000e	4c 2b 01	 sub	 r8, QWORD PTR [rcx]
  00011	49 c1 f8 04	 sar	 r8, 4

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00015	49 8b c8	 mov	 rcx, r8
  00018	48 d1 e9	 shr	 rcx, 1
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	49 3b c0	 cmp	 rax, r8
  00021	73 0e		 jae	 SHORT $LN4@Grow_to
  00023	45 33 c0	 xor	 r8d, r8d

; 1489 : 		if (_Capacity < _Count)

  00026	4c 3b c2	 cmp	 r8, rdx
  00029	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0002d	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  00030	c3		 ret	 0
$LN4@Grow_to:

; 1485 : 		size_type _Capacity = capacity();
; 1486 : 
; 1487 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity
; 1488 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

  00031	4c 03 c1	 add	 r8, rcx

; 1489 : 		if (_Capacity < _Count)

  00034	4c 3b c2	 cmp	 r8, rdx
  00037	4c 0f 42 c2	 cmovb	 r8, rdx

; 1490 : 			_Capacity = _Count;
; 1491 : 		return (_Capacity);

  0003b	49 8b c0	 mov	 rax, r8

; 1492 : 		}

  0003e	c3		 ret	 0
?_Grow_to@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBA_K_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z
_TEXT	SEGMENT
this$ = 80
_Count$ = 88
?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate, COMDAT

; 1500 : 		{	// move to array of exactly _Count elements

$LN85:
  00000	40 56		 push	 rsi
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 23   : 	void *_Ptr = 0;

  0000a	45 33 ff	 xor	 r15d, r15d
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1500 : 		{	// move to array of exactly _Count elements

  0000d	48 8b f2	 mov	 rsi, rdx
  00010	4c 8b f1	 mov	 r14, rcx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 25   : 	if (_Count == 0)

  00013	48 85 d2	 test	 rdx, rdx
  00016	74 2b		 je	 SHORT $LN16@Reallocate

; 26   : 		;
; 27   : 	else if (((size_t)(-1) / sizeof (_Ty) < _Count)
; 28   : 		|| (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)

  00018	48 b8 ff ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846975 ; 0fffffffffffffffH
  00022	48 3b d0	 cmp	 rdx, rax
  00025	0f 87 c3 00 00
	00		 ja	 $LN83@Reallocate
  0002b	48 8b ca	 mov	 rcx, rdx
  0002e	48 c1 e1 04	 shl	 rcx, 4
  00032	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00037	4c 8b f8	 mov	 r15, rax
  0003a	48 85 c0	 test	 rax, rax
  0003d	0f 84 ab 00 00
	00		 je	 $LN83@Reallocate
$LN16@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00043	49 8b 56 08	 mov	 rdx, QWORD PTR [r14+8]
  00047	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  0004a	48 89 6c 24 58	 mov	 QWORD PTR [rsp+88], rbp
  0004f	4d 8b c7	 mov	 r8, r15
  00052	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
  00057	4c 89 64 24 68	 mov	 QWORD PTR [rsp+104], r12
  0005c	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1087 : 		return (this->_Mylast - this->_Myfirst);

  00061	49 8b 3e	 mov	 rdi, QWORD PTR [r14]
  00064	4d 8b 66 08	 mov	 r12, QWORD PTR [r14+8]
  00068	49 8b ec	 mov	 rbp, r12
  0006b	48 2b ef	 sub	 rbp, rdi

; 1501 : 		pointer _Ptr = this->_Getal().allocate(_Count);
; 1502 : 
; 1503 : 		_TRY_BEGIN
; 1504 : 		_Umove(this->_Myfirst, this->_Mylast, _Ptr);
; 1505 : 		_CATCH_ALL
; 1506 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1507 : 		_RERAISE;
; 1508 : 		_CATCH_END
; 1509 : 
; 1510 : 		size_type _Size = size();
; 1511 : 		if (this->_Myfirst != pointer())

  0006e	48 85 ff	 test	 rdi, rdi
  00071	74 49		 je	 SHORT $LN75@Reallocate
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00073	49 3b fc	 cmp	 rdi, r12
  00076	74 3c		 je	 SHORT $LN46@Reallocate
  00078	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  0007d	0f 1f 00	 npad	 3
$LL48@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00080	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  00084	48 85 db	 test	 rbx, rbx
  00087	74 1d		 je	 SHORT $LN68@Reallocate

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00089	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0008d	75 17		 jne	 SHORT $LN68@Reallocate

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0008f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00092	48 8b cb	 mov	 rcx, rbx
  00095	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00097	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0009b	75 09		 jne	 SHORT $LN68@Reallocate

; 128  : 			_Delete_this();

  0009d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000a0	48 8b cb	 mov	 rcx, rbx
  000a3	ff 50 08	 call	 QWORD PTR [rax+8]
$LN68@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  000a6	48 83 c7 10	 add	 rdi, 16
  000aa	49 3b fc	 cmp	 rdi, r12
  000ad	75 d1		 jne	 SHORT $LL48@Reallocate
  000af	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
$LN46@Reallocate:

; 89   : 		_Al.destroy(_First);
; 90   : 	}
; 91   : 
; 92   : template<class _Alloc> inline
; 93   : 	void _Destroy_range(typename _Alloc::pointer _First,
; 94   : 		typename _Alloc::pointer _Last, _Alloc& _Al,
; 95   : 		_Scalar_ptr_iterator_tag)
; 96   : 	{	// destroy [_First, _Last), scalar type (do nothing)
; 97   : 	}
; 98   : 
; 99   : 		// TEMPLATE CLASS _Is_simple_alloc
; 100  : template<class _Alty>
; 101  : 	struct _Is_simple_alloc
; 102  : 		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
; 103  : 		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
; 104  : 		&& is_same<typename _Alty::pointer,
; 105  : 			typename _Alty::value_type *>::value
; 106  : 		&& is_same<typename _Alty::const_pointer,
; 107  : 			const typename _Alty::value_type *>::value
; 108  : 		&& is_same<typename _Alty::reference,
; 109  : 			typename _Alty::value_type&>::value
; 110  : 		&& is_same<typename _Alty::const_reference,
; 111  : 			const typename _Alty::value_type&>::value>
; 112  : 	{	// tests if allocator has simple addressing
; 113  : 	};
; 114  : 
; 115  : 		// TEMPLATE CLASS _Simple_types
; 116  : template<class _Value_type>
; 117  : 	struct _Simple_types
; 118  : 	{	// wraps types needed by iterators
; 119  : 	typedef _Value_type value_type;
; 120  : 	typedef size_t size_type;
; 121  : 	typedef ptrdiff_t difference_type;
; 122  : 	typedef value_type *pointer;
; 123  : 	typedef const value_type *const_pointer;
; 124  : 	typedef value_type& reference;
; 125  : 	typedef const value_type& const_reference;
; 126  : 	};
; 127  : 
; 128  :  #if _HAS_CPP0X
; 129  : 		// TEMPLATE CLASS _Get_voidptr
; 130  : template<class _Alty,
; 131  : 	class _Pointer>
; 132  : 	struct _Get_voidptr
; 133  : 	{	// get void pointer for allocator
; 134  : 	typedef typename _Alty::template rebind<void>::other _Alvoid;
; 135  : 	typedef typename _Alvoid::pointer type;
; 136  : 	};
; 137  : 
; 138  : template<class _Alty,
; 139  : 	class _Ty>
; 140  : 	struct _Get_voidptr<_Alty, _Ty *>
; 141  : 	{	// get raw void pointer for allocator
; 142  : 	typedef void *type;
; 143  : 	};
; 144  : 
; 145  : 		// TEMPLATE CLASS _Is_iterator
; 146  : template<class _Iter>
; 147  : 	struct _Is_iterator
; 148  : 	: public integral_constant<bool, !is_integral<_Iter>::value>
; 149  : 	{	// tests for reasonable iterator candidate
; 150  : 	};
; 151  : 
; 152  : 		// TEMPLATE CLASS pointer_traits
; 153  : template<class _Ty>
; 154  : 	struct pointer_traits;
; 155  : 
; 156  : template<class _Ty>
; 157  : 	struct _Get_first_parameter
; 158  : 	{	// get _Ty::element_type
; 159  : 	typedef typename _Ty::element_type type;
; 160  : 	};
; 161  : 
; 162  : 		// TEMPLATE STRUCT _Replace_first_parameter
; 163  : template<class _Newfirst,
; 164  : 	class _Ty>
; 165  : 	struct _Replace_first_parameter
; 166  : 	{	// get _Ty::element_type
; 167  : 	typedef typename _Ty::template rebind<_Newfirst>::other type;
; 168  : 	};
; 169  : 
; 170  : 		// TEMPLATE STRUCT _Get_element_type
; 171  : template<class _Ty>
; 172  : 	struct _Get_element_type
; 173  : 	_GET_TYPE_OR_DEFAULT(element_type,
; 174  : 		typename _Get_first_parameter<_Ty>::type);
; 175  : 
; 176  : 		// TEMPLATE STRUCT _Get_ptr_difference_type
; 177  : template<class _Ty>
; 178  : 	struct _Get_ptr_difference_type
; 179  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 180  : 		ptrdiff_t);
; 181  : 
; 182  : 		// TEMPLATE STRUCT _Get_rebind_type
; 183  : template<class _Ty,
; 184  : 	class _Other>
; 185  : 	struct _Get_rebind_type
; 186  : 	_GET_TYPE_OR_DEFAULT(template rebind<_Other>::other,
; 187  : 		typename _Replace_first_parameter<_Other _COMMA _Uty>::type);
; 188  : 
; 189  : 		// TEMPLATE CLASS pointer_traits
; 190  : template<class _Ty>
; 191  : 	struct pointer_traits
; 192  : 	{	// defines traits for arbitrary pointers
; 193  : 	typedef pointer_traits<_Ty> other;
; 194  : 
; 195  : 	typedef typename _Get_element_type<_Ty>::type element_type;
; 196  : 	typedef _Ty pointer;
; 197  : 	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;
; 198  : 
; 199  : 	template<class _Other>
; 200  : 		struct rebind
; 201  : 		{	// converts X<element_type> to X<_Other>
; 202  : 		typedef typename _Get_rebind_type<_Ty, _Other>::type other;
; 203  : 		};
; 204  : 
; 205  : 	static pointer pointer_to(element_type& _Val)
; 206  : 		{	// convert raw reference to pointer
; 207  : 		return (_Ty::pointer_to(_Val));
; 208  : 		}
; 209  : 	};
; 210  : 
; 211  : 		// TEMPLATE CLASS pointer_traits<_Ty *>
; 212  : template<class _Ty>
; 213  : 	struct pointer_traits<_Ty *>
; 214  : 	{	// defines traits for raw pointers
; 215  : 	typedef pointer_traits<_Ty *> other;
; 216  : 
; 217  : 	typedef _Ty element_type;
; 218  : 	typedef _Ty *pointer;
; 219  : 	typedef ptrdiff_t difference_type;
; 220  : 
; 221  : 	template<class _Other>
; 222  : 		struct rebind
; 223  : 		{	// converts to a pointer to _Other
; 224  : 		typedef _Other *other;
; 225  : 		};
; 226  : 
; 227  : 	typedef typename _If<is_void<_Ty>::value,
; 228  : 		char&,
; 229  : 		typename add_reference<_Ty>::type>::type _Reftype;
; 230  : 
; 231  : 	static pointer pointer_to(_Reftype _Val)
; 232  : 		{	// convert raw reference to pointer
; 233  : 		return (_STD addressof(_Val));
; 234  : 		}
; 235  : 	};
; 236  : 
; 237  : 		// TEMPLATE STRUCT _Get_pointer_type
; 238  : template<class _Ty>
; 239  : 	struct _Get_pointer_type
; 240  : 	_GET_TYPE_OR_DEFAULT(pointer,
; 241  : 		typename _Ty::value_type *);
; 242  : 
; 243  : 		// TEMPLATE STRUCT _Get_const_pointer_type
; 244  : template<class _Ty>
; 245  : 	struct _Get_const_pointer_type
; 246  : 	_GET_TYPE_OR_DEFAULT(const_pointer,
; 247  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 248  : 			::template rebind<const typename _Ty::value_type>::other);
; 249  : 
; 250  : 		// TEMPLATE STRUCT _Get_void_pointer_type
; 251  : template<class _Ty>
; 252  : 	struct _Get_void_pointer_type
; 253  : 	_GET_TYPE_OR_DEFAULT(void_pointer,
; 254  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 255  : 			::template rebind<void>::other);
; 256  : 
; 257  : 		// TEMPLATE STRUCT _Get_const_void_pointer_type
; 258  : template<class _Ty>
; 259  : 	struct _Get_const_void_pointer_type
; 260  : 	_GET_TYPE_OR_DEFAULT(const_void_pointer,
; 261  : 		typename pointer_traits<typename _Get_pointer_type<_Ty>::type>
; 262  : 			::template rebind<const void>::other);
; 263  : 
; 264  : 		// TEMPLATE STRUCT _Get_difference_type
; 265  : template<class _Ty>
; 266  : 	struct _Get_difference_type
; 267  : 	_GET_TYPE_OR_DEFAULT(difference_type,
; 268  : 		typename _Get_ptr_difference_type<
; 269  : 			typename _Get_pointer_type<_Ty>::type>::type);
; 270  : 
; 271  : 		// TEMPLATE STRUCT _Get_size_type
; 272  : template<class _Ty>
; 273  : 	struct _Get_size_type
; 274  : 	_GET_TYPE_OR_DEFAULT(size_type,
; 275  : 		typename make_unsigned<
; 276  : 			typename _Get_difference_type<_Ty>::type>::type);
; 277  : 
; 278  : 		// TEMPLATE STRUCT _Get_propagate_on_container_copy
; 279  : template<class _Ty>
; 280  : 	struct _Get_propagate_on_container_copy
; 281  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_copy_assignment,
; 282  : 		false_type);
; 283  : 
; 284  : 		// TEMPLATE STRUCT _Get_propagate_on_container_move
; 285  : template<class _Ty>
; 286  : 	struct _Get_propagate_on_container_move
; 287  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_move_assignment,
; 288  : 		false_type);
; 289  : 
; 290  : 		// TEMPLATE STRUCT _Get_propagate_on_container_swap
; 291  : template<class _Ty>
; 292  : 	struct _Get_propagate_on_container_swap
; 293  : 	_GET_TYPE_OR_DEFAULT(propagate_on_container_swap,
; 294  : 		false_type);
; 295  : 
; 296  : 		// STRUCT _Alloc_allocate
; 297  : struct _Alloc_allocate
; 298  : 	{	// determines allocator_traits<_Alloc>
; 299  : 		// ::allocate(size_type, const_void_pointer)
; 300  : 
; 301  : 	template<class _Alloc,
; 302  : 		class _Size_type,
; 303  : 		class _Const_void_pointer>
; 304  : 		static auto _Fn(int, _Alloc& _Al,
; 305  : 			_Size_type _Count,
; 306  : 			_Const_void_pointer _Hint)
; 307  : 			-> decltype(_Al.allocate(_Count, _Hint))
; 308  : 		{	// call allocator supplied version
; 309  : 		return (_Al.allocate(_Count, _Hint));
; 310  : 		}
; 311  : 
; 312  : 	template<class _Alloc,
; 313  : 		class _Size_type,
; 314  : 		class _Const_void_pointer>
; 315  : 		static auto _Fn(_Wrap_int, _Alloc& _Al,
; 316  : 			_Size_type _Count,
; 317  : 			_Const_void_pointer)
; 318  : 			-> decltype(_Al.allocate(_Count))
; 319  : 		{	// call default version
; 320  : 		return (_Al.allocate(_Count));
; 321  : 		}
; 322  : 	};
; 323  : 
; 324  : 		// STRUCT _Alloc_construct
; 325  : struct _Alloc_construct
; 326  : 	{	// determines allocator_traits<_Ty>
; 327  : 		// ::construct(_Ty&, _Objty *, _Types...)
; 328  : 
; 329  : #define _ALLOC_CONSTRUCT( \
; 330  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 331  : 	template<class _Ty, \
; 332  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 333  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr \
; 334  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 335  : 			-> decltype( \
; 336  : 				_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG))) \
; 337  : 		{	/* call allocator supplied version */ \
; 338  : 		_Al.construct(_Ptr COMMA LIST(_FORWARD_ARG)); \
; 339  : 		} \
; 340  : 	template<class _Ty, \
; 341  : 		class _Objty COMMA LIST(_CLASS_TYPE)> \
; 342  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr \
; 343  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 344  : 			-> void \
; 345  : 		{	/* call default version */ \
; 346  : 		::new (static_cast<void *>(_Ptr)) \
; 347  : 			_Objty(LIST(_FORWARD_ARG)); \
; 348  : 		}
; 349  : 
; 350  : _VARIADIC_EXPAND_0X(_ALLOC_CONSTRUCT, , , , )
; 351  : #undef _ALLOC_CONSTRUCT
; 352  : 	};
; 353  : 
; 354  : 		// STRUCT _Alloc_destroy
; 355  : struct _Alloc_destroy
; 356  : 	{	// determines allocator_traits<_Ty>::destroy(_Ty&, _Objty *)
; 357  : 	template<class _Ty,
; 358  : 		class _Objty>
; 359  : 		static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
; 360  : 			-> decltype(_Al.destroy(_Ptr))
; 361  : 		{	// call allocator supplied version
; 362  : 		_Al.destroy(_Ptr);
; 363  : 		}
; 364  : 
; 365  : 	template<class _Ty,
; 366  : 		class _Objty>
; 367  : 		static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
; 368  : 			-> void
; 369  : 		{	// call default version
; 370  : 		_Ptr->~_Objty();
; 371  : 		}
; 372  : 	};
; 373  : 
; 374  : 		// STRUCT _Alloc_max_size
; 375  : struct _Alloc_max_size
; 376  : 	{	// determines allocator_traits<_Ty>::max_size(const _Ty&)
; 377  : 	template<class _Ty>
; 378  : 		static auto _Fn(int, const _Ty& _Al)
; 379  : 			-> decltype(_Al.max_size())
; 380  : 		{	// call allocator supplied version
; 381  : 		return (_Al.max_size());
; 382  : 		}
; 383  : 
; 384  : 	template<class _Ty>
; 385  : 		static auto _Fn(_Wrap_int, const _Ty&)
; 386  : 			-> typename _Get_size_type<_Ty>::type
; 387  : 		{	// call default version
; 388  : 		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
; 389  : 		}
; 390  : 	};
; 391  : 
; 392  : 		// STRUCT _Alloc_select
; 393  : struct _Alloc_select
; 394  : 	{	// determines allocator_traits<_Ty>
; 395  : 		// ::select_on_container_copy_construction(const _Alloc&)
; 396  : 
; 397  : 	template<class _Ty>
; 398  : 		static auto _Fn(int, const _Ty& _Al)
; 399  : 			-> decltype((_Ty)_Al.select_on_container_copy_construction())
; 400  : 		{	// call allocator supplied version
; 401  : 		return (_Al.select_on_container_copy_construction());
; 402  : 		}
; 403  : 
; 404  : 	template<class _Ty>
; 405  : 		static auto _Fn(_Wrap_int, const _Ty& _Al)
; 406  : 			-> _Ty
; 407  : 		{	// call default version
; 408  : 		return (_Al);
; 409  : 		}
; 410  : 	};
; 411  : 
; 412  : 		// TEMPLATE CLASS allocator_traits
; 413  : template<class _Alloc>
; 414  : 	struct allocator_traits
; 415  : 	{	// defines traits for allocators
; 416  : 	typedef allocator_traits<_Alloc> other;
; 417  : 
; 418  : 	typedef _Alloc allocator_type;
; 419  : 	typedef typename _Alloc::value_type value_type;
; 420  : 
; 421  : 	typedef typename _Get_pointer_type<_Alloc>::type
; 422  : 		pointer;
; 423  : 	typedef typename _Get_const_pointer_type<_Alloc>::type
; 424  : 		const_pointer;
; 425  : 	typedef typename _Get_void_pointer_type<_Alloc>::type
; 426  : 		void_pointer;
; 427  : 	typedef typename _Get_const_void_pointer_type<_Alloc>::type
; 428  : 		const_void_pointer;
; 429  : 
; 430  : 	typedef typename _Get_size_type<_Alloc>::type size_type;
; 431  : 	typedef typename _Get_difference_type<_Alloc>::type difference_type;
; 432  : 
; 433  : 	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
; 434  : 		propagate_on_container_copy_assignment;
; 435  : 	typedef typename _Get_propagate_on_container_move<_Alloc>::type
; 436  : 		propagate_on_container_move_assignment;
; 437  : 	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
; 438  : 		propagate_on_container_swap;
; 439  : 
; 440  : 	template<class _Other>
; 441  : 		struct rebind_alloc
; 442  : 		{	// converts allocator<element_type> to allocator<_Other>
; 443  : 		typedef typename _Get_rebind_type<_Alloc, _Other>::type other;
; 444  : 		};
; 445  : 
; 446  : 	template<class _Other>
; 447  : 		struct rebind_traits
; 448  : 		{	// converts allocator_traits<X<element_type>>
; 449  : 			// to allocator_traits<X<_Other>>
; 450  : 		typedef typename rebind_alloc<_Other>::other _Other_alloc;
; 451  : 		typedef allocator_traits<_Other_alloc> other;
; 452  : 		};
; 453  : 
; 454  : 	static pointer allocate(_Alloc& _Al, size_type _Count)
; 455  : 		{	// allocate array of _Count elements
; 456  : 		return (_Al.allocate(_Count));
; 457  : 		}
; 458  : 
; 459  : 	static pointer allocate(_Alloc& _Al, size_type _Count,
; 460  : 		const_void_pointer _Hint)
; 461  : 		{	// allocate array of _Count elements, with hint
; 462  : 		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
; 463  : 		}
; 464  : 
; 465  : 	static void deallocate(_Alloc& _Al,
; 466  : 		pointer _Ptr, size_type _Count)
; 467  : 		{	// deallocate _Count elements at _Ptr
; 468  : 		_Al.deallocate(_Ptr, _Count);
; 469  : 		}
; 470  : 
; 471  : #define _ALLOC_TRAITS_CONSTRUCT( \
; 472  : 	TEMPLATE_LIST, PADDING_LIST, LIST, COMMA, CALL_OPT, X2, X3, X4) \
; 473  : 	template<class _Ty COMMA LIST(_CLASS_TYPE)> \
; 474  : 		static void construct(_Alloc& _Al, _Ty *_Ptr \
; 475  : 			COMMA LIST(_TYPE_REFREF_ARG)) \
; 476  : 		{	/* construct _Ty(_Types...) at _Ptr */ \
; 477  : 		_Alloc_construct::_Fn(0, _Al, _Ptr COMMA LIST(_FORWARD_ARG)); \
; 478  : 		}
; 479  : 
; 480  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_CONSTRUCT, , , , )
; 481  : #undef _ALLOC_TRAITS_CONSTRUCT
; 482  : 
; 483  : 	template<class _Ty>
; 484  : 		static void destroy(_Alloc& _Al, _Ty *_Ptr)
; 485  : 		{	// destroy object at _Ptr
; 486  : 		_Alloc_destroy::_Fn(0, _Al, _Ptr);
; 487  : 		}
; 488  : 
; 489  : 	static size_type max_size(const _Alloc& _Al)
; 490  : 		{	// get maximum size
; 491  : 		return (_Alloc_max_size::_Fn(0, _Al));
; 492  : 		}
; 493  : 
; 494  : 	static _Alloc select_on_container_copy_construction(
; 495  : 		const _Alloc& _Al)
; 496  : 		{	// get allocator to use
; 497  : 		return (_Alloc_select::_Fn(0, _Al));
; 498  : 		}
; 499  : 	};
; 500  :  #endif /* _HAS_CPP0X */
; 501  : 
; 502  : 		// TEMPLATE CLASS _Allocator_base
; 503  : template<class _Ty>
; 504  : 	struct _Allocator_base
; 505  : 	{	// base class for generic allocators
; 506  : 	typedef _Ty value_type;
; 507  : 	};
; 508  : 
; 509  : 		// TEMPLATE CLASS _Allocator_base<const _Ty>
; 510  : template<class _Ty>
; 511  : 	struct _Allocator_base<const _Ty>
; 512  : 	{	// base class for generic allocators for const _Ty
; 513  : 	typedef _Ty value_type;
; 514  : 	};
; 515  : 
; 516  : 		// TEMPLATE CLASS allocator
; 517  : template<class _Ty>
; 518  : 	class allocator
; 519  : 		: public _Allocator_base<_Ty>
; 520  : 	{	// generic allocator for objects of class _Ty
; 521  : public:
; 522  : 	typedef allocator<_Ty> other;
; 523  : 
; 524  : 	typedef _Allocator_base<_Ty> _Mybase;
; 525  : 	typedef typename _Mybase::value_type value_type;
; 526  : 
; 527  : 	typedef value_type *pointer;
; 528  : 	typedef const value_type *const_pointer;
; 529  : 	typedef void *void_pointer;
; 530  : 	typedef const void *const_void_pointer;
; 531  : 
; 532  : 	typedef value_type& reference;
; 533  : 	typedef const value_type& const_reference;
; 534  : 
; 535  : 	typedef size_t size_type;
; 536  : 	typedef ptrdiff_t difference_type;
; 537  : 
; 538  :  #if _HAS_CPP0X
; 539  : 	typedef false_type propagate_on_container_copy_assignment;
; 540  : 	typedef false_type propagate_on_container_move_assignment;
; 541  : 	typedef false_type propagate_on_container_swap;
; 542  : 
; 543  : 	allocator<_Ty> select_on_container_copy_construction() const
; 544  : 		{	// return this allocator
; 545  : 		return (*this);
; 546  : 		}
; 547  :  #endif /* _HAS_CPP0X */
; 548  : 
; 549  : 	template<class _Other>
; 550  : 		struct rebind
; 551  : 		{	// convert this type to allocator<_Other>
; 552  : 		typedef allocator<_Other> other;
; 553  : 		};
; 554  : 
; 555  : 	pointer address(reference _Val) const _NOEXCEPT
; 556  : 		{	// return address of mutable _Val
; 557  : 		return (_STD addressof(_Val));
; 558  : 		}
; 559  : 
; 560  : 	const_pointer address(const_reference _Val) const _NOEXCEPT
; 561  : 		{	// return address of nonmutable _Val
; 562  : 		return (_STD addressof(_Val));
; 563  : 		}
; 564  : 
; 565  : 	allocator() _THROW0()
; 566  : 		{	// construct default allocator (do nothing)
; 567  : 		}
; 568  : 
; 569  : 	allocator(const allocator<_Ty>&) _THROW0()
; 570  : 		{	// construct by copying (do nothing)
; 571  : 		}
; 572  : 
; 573  : 	template<class _Other>
; 574  : 		allocator(const allocator<_Other>&) _THROW0()
; 575  : 		{	// construct from a related allocator (do nothing)
; 576  : 		}
; 577  : 
; 578  : 	template<class _Other>
; 579  : 		allocator<_Ty>& operator=(const allocator<_Other>&)
; 580  : 		{	// assign from a related allocator (do nothing)
; 581  : 		return (*this);
; 582  : 		}
; 583  : 
; 584  : 	void deallocate(pointer _Ptr, size_type)
; 585  : 		{	// deallocate object at _Ptr, ignore size
; 586  : 		::operator delete(_Ptr);

  000b4	49 8b 0e	 mov	 rcx, QWORD PTR [r14]
  000b7	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN75@Reallocate:
  000bc	4c 8b 64 24 68	 mov	 r12, QWORD PTR [rsp+104]
  000c1	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1519 : 		this->_Myend = _Ptr + _Count;

  000c6	48 c1 e6 04	 shl	 rsi, 4

; 1520 : 		this->_Mylast = _Ptr + _Size;

  000ca	48 83 e5 f0	 and	 rbp, -16
  000ce	49 03 f7	 add	 rsi, r15

; 1521 : 		this->_Myfirst = _Ptr;

  000d1	4d 89 3e	 mov	 QWORD PTR [r14], r15
  000d4	49 03 ef	 add	 rbp, r15
  000d7	49 89 76 10	 mov	 QWORD PTR [r14+16], rsi
  000db	49 89 6e 08	 mov	 QWORD PTR [r14+8], rbp
  000df	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]

; 1522 : 		}

  000e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e8	41 5f		 pop	 r15
  000ea	41 5e		 pop	 r14
  000ec	5e		 pop	 rsi
  000ed	c3		 ret	 0
$LN83@Reallocate:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 29   : 		_Xbad_alloc();	// report no memory

  000ee	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  000f3	cc		 int	 3
$LN82@Reallocate:
?_Reallocate@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAX_K@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ
_TEXT	SEGMENT
this$dead$ = 48
?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen, COMDAT

; 1666 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1667 : 		_Xlength_error("vector<T> too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
  0000b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPEBD@Z ; std::_Xlength_error
  00010	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEBAXXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >, COMDAT

; 485  : 		{	// initialize values
; 486  : 		_Myfirst = pointer();

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax

; 487  : 		_Mylast = pointer();

  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 488  : 		_Myend = pointer();

  00009	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 489  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >::_Vector_val<std::_Simple_types<std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 346  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_List_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*, COMDAT

; 222  : 
; 223  : 	_Myiter& operator++()
; 224  : 		{	// preincrement
; 225  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 226  : 		if (this->_Getcont() == 0
; 227  : 			|| this->_Ptr == 0
; 228  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 229  : 			{	// report error
; 230  : 			_DEBUG_ERROR("list iterator not incrementable");
; 231  : 			_SCL_SECURE_OUT_OF_RANGE;
; 232  : 			}
; 233  : 
; 234  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 235  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 236  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 237  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 238  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 239  : 
; 240  : 		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
; 241  : 		return (*this);
; 242  : 		}
; 243  : 
; 244  : 	_Myiter operator++(int)
; 245  : 		{	// postincrement
; 246  : 		_Myiter _Tmp = *this;
; 247  : 		++*this;
; 248  : 		return (_Tmp);
; 249  : 		}
; 250  : 
; 251  : 	_Myiter& operator--()
; 252  : 		{	// predecrement
; 253  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 254  : 		if (this->_Getcont() == 0
; 255  : 			|| this->_Ptr == 0
; 256  : 			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr))
; 257  : 				== ((_Mylist *)this->_Getcont())->_Myhead)
; 258  : 			{	// report error
; 259  : 			_DEBUG_ERROR("list iterator not decrementable");
; 260  : 			_SCL_SECURE_OUT_OF_RANGE;
; 261  : 			}
; 262  : 
; 263  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 264  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 265  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 266  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 267  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 268  : 
; 269  :  #else /* _ITERATOR_DEBUG_LEVEL */
; 270  : 		this->_Ptr = _Mylist::_Prevnode(this->_Ptr);
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		return (*this);
; 274  : 		}
; 275  : 
; 276  : 	_Myiter operator--(int)
; 277  : 		{	// postdecrement
; 278  : 		_Myiter _Tmp = *this;
; 279  : 		--*this;
; 280  : 		return (_Tmp);
; 281  : 		}
; 282  : 
; 283  : 	bool operator==(const _Myiter& _Right) const
; 284  : 		{	// test for iterator equality
; 285  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 286  : 		if (this->_Getcont() == 0
; 287  : 			|| this->_Getcont() != _Right._Getcont())
; 288  : 			{	// report error
; 289  : 			_DEBUG_ERROR("list iterators incompatible");
; 290  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 291  : 			}
; 292  : 
; 293  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 294  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0
; 295  : 			&& this->_Getcont() == _Right._Getcont());
; 296  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 297  : 
; 298  : 		return (this->_Ptr == _Right._Ptr);
; 299  : 		}
; 300  : 
; 301  : 	bool operator!=(const _Myiter& _Right) const
; 302  : 		{	// test for iterator inequality
; 303  : 		return (!(*this == _Right));
; 304  : 		}
; 305  : 	};
; 306  : 
; 307  : template<class _Mylist> inline
; 308  : 	typename _List_const_iterator<_Mylist>::_Unchecked_type
; 309  : 		_Unchecked(_List_const_iterator<_Mylist> _Iter)
; 310  : 	{	// convert to unchecked
; 311  : 	return (_Iter._Unchecked());
; 312  : 	}
; 313  : 
; 314  : template<class _Mylist> inline
; 315  : 	_List_const_iterator<_Mylist>&
; 316  : 		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
; 317  : 			typename _List_const_iterator<_Mylist>
; 318  : 				::_Unchecked_type _Right)
; 319  : 	{	// convert to checked
; 320  : 	return (_Iter._Rechecked(_Right));
; 321  : 	}
; 322  : 
; 323  : 	// TEMPLATE CLASS _List_iterator
; 324  : template<class _Mylist>
; 325  : 	class _List_iterator
; 326  : 		: public _List_const_iterator<_Mylist>
; 327  : 	{	// iterator for mutable list
; 328  : public:
; 329  : 	typedef _List_iterator<_Mylist> _Myiter;
; 330  : 	typedef _List_const_iterator<_Mylist> _Mybase;
; 331  : 	typedef bidirectional_iterator_tag iterator_category;
; 332  : 
; 333  : 	typedef typename _Mylist::_Nodeptr _Nodeptr;
; 334  : 	typedef typename _Mylist::value_type value_type;
; 335  : 	typedef typename _Mylist::difference_type difference_type;
; 336  : 	typedef typename _Mylist::pointer pointer;
; 337  : 	typedef typename _Mylist::reference reference;
; 338  : 
; 339  : 	_List_iterator()
; 340  : 		{	// construct with null node
; 341  : 		}
; 342  : 
; 343  : 	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
; 344  : 		: _Mybase(_Pnode, _Plist)
; 345  : 		{	// construct with node pointer _Pnode
; 346  : 		}
; 347  : 
; 348  : 	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;
; 349  : 
; 350  : 	_Myiter& _Rechecked(_Unchecked_type _Right)
; 351  : 		{	// reset from unchecked iterator
; 352  : 		this->_Ptr = _Right._Ptr;
; 353  : 		return (*this);
; 354  : 		}
; 355  : 
; 356  : 	_Unchecked_type _Unchecked() const
; 357  : 		{	// make an unchecked iterator
; 358  : 		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
; 359  : 		}
; 360  : 
; 361  : 	reference operator*() const
; 362  : 		{	// return designated value
; 363  : 		return ((reference)**(_Mybase *)this);
; 364  : 		}
; 365  : 
; 366  : 	pointer operator->() const
; 367  : 		{	// return pointer to class object
; 368  : 		return (_STD pointer_traits<pointer>::pointer_to(**this));
; 369  : 		}
; 370  : 
; 371  : 	_Myiter& operator++()
; 372  : 		{	// preincrement
; 373  : 		++(*(_Mybase *)this);
; 374  : 		return (*this);
; 375  : 		}
; 376  : 
; 377  : 	_Myiter operator++(int)
; 378  : 		{	// postincrement
; 379  : 		_Myiter _Tmp = *this;
; 380  : 		++*this;
; 381  : 		return (_Tmp);
; 382  : 		}
; 383  : 
; 384  : 	_Myiter& operator--()
; 385  : 		{	// predecrement
; 386  : 		--(*(_Mybase *)this);
; 387  : 		return (*this);
; 388  : 		}
; 389  : 
; 390  : 	_Myiter operator--(int)
; 391  : 		{	// postdecrement
; 392  : 		_Myiter _Tmp = *this;
; 393  : 		--*this;
; 394  : 		return (_Tmp);
; 395  : 		}
; 396  : 	};
; 397  : 
; 398  : template<class _Mylist> inline
; 399  : 	typename _List_iterator<_Mylist>::_Unchecked_type
; 400  : 		_Unchecked(_List_iterator<_Mylist> _Iter)
; 401  : 	{	// convert to unchecked
; 402  : 	return (_Iter._Unchecked());
; 403  : 	}
; 404  : 
; 405  : template<class _Mylist> inline
; 406  : 	_List_iterator<_Mylist>&
; 407  : 		_Rechecked(_List_iterator<_Mylist>& _Iter,
; 408  : 			typename _List_iterator<_Mylist>
; 409  : 				::_Unchecked_type _Right)
; 410  : 	{	// convert to checked
; 411  : 	return (_Iter._Rechecked(_Right));
; 412  : 	}
; 413  : 
; 414  : 		// list TYPE WRAPPERS
; 415  : template<class _Value_type,
; 416  : 	class _Size_type,
; 417  : 	class _Difference_type,
; 418  : 	class _Pointer,
; 419  : 	class _Const_pointer,
; 420  : 	class _Reference,
; 421  : 	class _Const_reference,
; 422  : 	class _Nodeptr_type>
; 423  : 	struct _List_iter_types
; 424  : 	{	// wraps types needed by iterators
; 425  : 	typedef _Value_type value_type;
; 426  : 	typedef _Size_type size_type;
; 427  : 	typedef _Difference_type difference_type;
; 428  : 	typedef _Pointer pointer;
; 429  : 	typedef _Const_pointer const_pointer;
; 430  : 	typedef _Reference reference;
; 431  : 	typedef _Const_reference const_reference;
; 432  : 	typedef _Nodeptr_type _Nodeptr;
; 433  : 	};
; 434  : 
; 435  : template<class _Value_type,
; 436  : 	class _Voidptr>
; 437  : 	struct _List_node
; 438  : 		{	// list node
; 439  : 		_Voidptr _Next;	// successor node, or first element if head
; 440  : 		_Voidptr _Prev;	// predecessor node, or last element if head
; 441  : 		_Value_type _Myval;	// the stored value, unused if head
; 442  : 
; 443  : 	private:
; 444  : 		_List_node& operator=(const _List_node&);
; 445  : 		};
; 446  : 
; 447  : template<class _Value_type>
; 448  : 	struct _List_node<_Value_type, void *>
; 449  : 		{	// list node
; 450  : 		typedef _List_node<_Value_type, void *> *_Nodeptr;
; 451  : 		_Nodeptr _Next;	// successor node, or first element if head
; 452  : 		_Nodeptr _Prev;	// predecessor node, or last element if head
; 453  : 		_Value_type _Myval;	// the stored value, unused if head
; 454  : 
; 455  : 	private:
; 456  : 		_List_node& operator=(const _List_node&);
; 457  : 		};
; 458  : 
; 459  : template<class _Ty>
; 460  : 	struct _List_simple_types
; 461  : 		: public _Simple_types<_Ty>
; 462  : 	{	// wraps types needed by iterators
; 463  : 	typedef _List_node<_Ty, void *> _Node;
; 464  : 	typedef _Node *_Nodeptr;
; 465  : 	};
; 466  : 
; 467  : template<class _Ty,
; 468  : 	class _Alloc0>
; 469  : 	struct _List_base_types
; 470  : 	{	// types needed for a container base
; 471  : 	typedef _Alloc0 _Alloc;
; 472  : 	typedef _List_base_types<_Ty, _Alloc> _Myt;
; 473  : 
; 474  :  #if _HAS_CPP0X
; 475  : 	typedef _Wrap_alloc<_Alloc> _Alty0;
; 476  : 	typedef typename _Alty0::template rebind<_Ty>::other _Alty;
; 477  : 
; 478  :  #else /* _HAS_CPP0X */
; 479  : 	typedef typename _Alloc::template rebind<_Ty>::other _Alty;
; 480  :  #endif /* _HAS_CPP0X */
; 481  : 
; 482  : 	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
; 483  : 		_Voidptr;
; 484  : 	typedef _List_node<typename _Alty::value_type,
; 485  : 		_Voidptr> _Node;
; 486  : 
; 487  : 	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
; 488  : 	typedef typename _Alnod_type::pointer _Nodeptr;
; 489  : 	typedef _Nodeptr& _Nodepref;
; 490  : 
; 491  : 	typedef typename _If<_Is_simple_alloc<_Alty>::value,
; 492  : 		_List_simple_types<typename _Alty::value_type>,
; 493  : 		_List_iter_types<typename _Alty::value_type,
; 494  : 			typename _Alty::size_type,
; 495  : 			typename _Alty::difference_type,
; 496  : 			typename _Alty::pointer,
; 497  : 			typename _Alty::const_pointer,
; 498  : 			typename _Alty::reference,
; 499  : 			typename _Alty::const_reference,
; 500  : 			_Nodeptr> >::type
; 501  : 		_Val_types;
; 502  : 	};
; 503  : 
; 504  : 		// TEMPLATE CLASS _List_val
; 505  : template<class _Val_types>
; 506  : 	class _List_val
; 507  : 		: public _Container_base
; 508  : 	{	// base class for list to hold data
; 509  : public:
; 510  : 	typedef _List_val<_Val_types> _Myt;
; 511  : 
; 512  : 	typedef typename _Val_types::_Nodeptr _Nodeptr;
; 513  : 	typedef _Nodeptr& _Nodepref;
; 514  : 
; 515  : 	typedef typename _Val_types::value_type value_type;
; 516  : 	typedef typename _Val_types::size_type size_type;
; 517  : 	typedef typename _Val_types::difference_type difference_type;
; 518  : 	typedef typename _Val_types::pointer pointer;
; 519  : 	typedef typename _Val_types::const_pointer const_pointer;
; 520  : 	typedef typename _Val_types::reference reference;
; 521  : 	typedef typename _Val_types::const_reference const_reference;
; 522  : 
; 523  : 	typedef _List_const_iterator<_Myt> const_iterator;
; 524  : 	typedef _List_iterator<_Myt> iterator;
; 525  : 
; 526  : 	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
; 527  : 	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;
; 528  : 
; 529  : 	_List_val()
; 530  : 		{	// initialize data
; 531  : 		this->_Myhead = 0;
; 532  : 		this->_Mysize = 0;
; 533  : 		}
; 534  : 
; 535  : 	static _Nodepref _Nextnode(_Nodeptr _Pnode)
; 536  : 		{	// return reference to successor pointer in node
; 537  : 		return ((_Nodepref)_Pnode->_Next);
; 538  : 		}
; 539  : 
; 540  : 	static _Nodepref _Prevnode(_Nodeptr _Pnode)
; 541  : 		{	// return reference to predecessor pointer in node
; 542  : 		return ((_Nodepref)_Pnode->_Prev);
; 543  : 		}
; 544  : 
; 545  : 	static reference _Myval(_Nodeptr _Pnode)
; 546  : 		{	// return reference to value in node
; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 83 c0 10	 add	 rax, 16

; 205  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 206  : 		if (this->_Getcont() == 0
; 207  : 			|| this->_Ptr == 0
; 208  : 			|| this->_Ptr == ((_Mylist *)this->_Getcont())->_Myhead)
; 209  : 			{	// report error
; 210  : 			_DEBUG_ERROR("list iterator not dereferencable");
; 211  : 			_SCL_SECURE_OUT_OF_RANGE;
; 212  : 			}
; 213  : 
; 214  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 215  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != 0);
; 216  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr !=
; 217  : 			((_Mylist *)this->_Getcont())->_Myhead);
; 218  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 219  : 
; 220  : 		return (_Mylist::_Myval(this->_Ptr));
; 221  : 		}

  00007	c3		 ret	 0
??D?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEBAAEBU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@1@XZ ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z
_TEXT	SEGMENT
_Pnode$ = 8
?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z PROC ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval, COMDAT

; 547  : 		return ((reference)_Pnode->_Myval);

  00000	48 8d 41 10	 lea	 rax, QWORD PTR [rcx+16]

; 548  : 		}

  00004	c3		 ret	 0
?_Myval@?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@SAAEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@2@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@2@@Z ENDP ; std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
__formal$dead$ = 24
?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate, COMDAT

; 586  : 		::operator delete(_Ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?deallocate@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@2@_K@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity, COMDAT

; 967  : 		return (this->_Myend - this->_Myfirst);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00007	48 c1 f8 04	 sar	 rax, 4

; 968  : 		}

  0000b	c3		 ret	 0
?capacity@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@QEBA_KXZ ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 188  : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >::_List_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\list
;	COMDAT ??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Pnode$ = 16
_Plist$dead$ = 24
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z PROC ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>, COMDAT

; 44   : 		{	// construct with node pointer _Pnode

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_List_unchecked_const_iterator@V?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QEAA@PEAU?$_List_node@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@PEAX@1@PEBV?$_List_val@U?$_List_simple_types@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@1@@Z ENDP ; std::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>::_List_unchecked_const_iterator<std::_List_val<std::_List_simple_types<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 931  : 	return (!(_Left == _Right));

  00000	32 c0		 xor	 al, al

; 932  : 	}

  00002	c3		 ret	 0
??$?9V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z PROC ; std::addressof<std::shared_ptr<ChunkBase> const >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@$$CBV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEBV?$shared_ptr@VChunkBase@@@0@AEBV10@@Z ENDP ; std::addressof<std::shared_ptr<ChunkBase> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN11@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN26@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN26@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN11@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z PROC ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >, COMDAT

; 86   : 	return (reinterpret_cast<_Ty *>(
; 87   : 		(&const_cast<char&>(
; 88   : 		reinterpret_cast<const volatile char&>(_Val)))));

  00000	48 8b c1	 mov	 rax, rcx

; 89   : 	}

  00003	c3		 ret	 0
??$addressof@U?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@YAPEAU?$pair@$$CBVChunkPosition@@V?$shared_ptr@VChunkBase@@@std@@@0@AEAU10@@Z ENDP ; std::addressof<std::pair<ChunkPosition const ,std::shared_ptr<ChunkBase> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 79   : 	{	// destroy [_First, _Last)

$LN35:

; 88   : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5c		 je	 SHORT $LN33@Destroy_ra
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 79   : 	{	// destroy [_First, _Last)

  00014	48 8b f2	 mov	 rsi, rdx

; 80   : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

  00017	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL7@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN27@Destroy_ra

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN27@Destroy_ra

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN27@Destroy_ra

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN27@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL7@Destroy_ra
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 81   : 	}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN33@Destroy_ra:
  00061	f3 c3		 fatret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector
;	COMDAT ??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z
_TEXT	SEGMENT
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Ptr$ = 88
??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z PROC ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 1557 : 		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)

$LN10:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	49 8b c0	 mov	 rax, r8
  00007	48 8b ca	 mov	 rcx, rdx
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  0000a	4d 8b c1	 mov	 r8, r9
  0000d	48 8b d0	 mov	 rdx, rax
  00010	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\vector

; 1562 : 		}

  00015	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00019	c3		 ret	 0
??$_Umove@PEAV?$shared_ptr@VChunkBase@@@std@@@?$vector@V?$shared_ptr@VChunkBase@@@std@@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@@std@@IEAAPEAV?$shared_ptr@VChunkBase@@@1@PEAV21@00@Z ENDP ; std::vector<std::shared_ptr<ChunkBase>,std::allocator<std::shared_ptr<ChunkBase> > >::_Umove<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z PROC ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 923  : 	return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));

  00000	b0 01		 mov	 al, 1

; 924  : 	}

  00002	c3		 ret	 0
??$?8V?$allocator@_W@std@@V01@@std@@YA_NAEBU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ENDP ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@AEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAAEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN7@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN22@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN22@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@AEAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z PROC	; std::operator==<wchar_t,wchar_t>, COMDAT

; 677  : 	return (true);

  00000	b0 01		 mov	 al, 1

; 678  : 	}

  00002	c3		 ret	 0
??$?8_W_W@std@@YA_NAEBV?$allocator@_W@0@0@Z ENDP	; std::operator==<wchar_t,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
_Cat$ = 16
??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z PROC ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 437  : 	{	// return pointer category from pointers

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx

; 438  : 	typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
; 439  : 	return (_Cat);

  00005	0f b6 44 24 10	 movzx	 eax, BYTE PTR _Cat$[rsp]

; 440  : 	}

  0000a	c3		 ret	 0
??$_Ptr_cat@V?$shared_ptr@VChunkBase@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PEAV?$shared_ptr@VChunkBase@@@0@0@Z ENDP ; std::_Ptr_cat<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Al$dead$ = 64
__formal$dead$ = 72
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 87   : 	{	// destroy [_First, _Last), arbitrary type

$LN31:

; 88   : 	for (; _First != _Last; ++_First)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 5c		 je	 SHORT $LN29@Destroy_ra
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0000f	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 87   : 	{	// destroy [_First, _Last), arbitrary type

  00014	48 8b f2	 mov	 rsi, rdx

; 88   : 	for (; _First != _Last; ++_First)

  00017	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0001b	0f 1f 44 00 00	 npad	 5
$LL3@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 345  : 		if (_Rep != 0)

  00020	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00023	48 85 db	 test	 rbx, rbx
  00026	74 1d		 je	 SHORT $LN23@Destroy_ra

; 118  : 		if (_MT_DECR(_Ignored, _Uses) == 0)

  00028	f0 ff 4b 08	 lock dec DWORD PTR [rbx+8]
  0002c	75 17		 jne	 SHORT $LN23@Destroy_ra

; 119  : 			{	// destroy managed resource, decrement weak reference count
; 120  : 			_Destroy();

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00031	48 8b cb	 mov	 rcx, rbx
  00034	ff 10		 call	 QWORD PTR [rax]

; 121  : 			_Decwref();
; 122  : 			}
; 123  : 		}
; 124  : 
; 125  : 	void _Decwref()
; 126  : 		{	// decrement weak reference count
; 127  : 		if (_MT_DECR(_Ignored, _Weaks) == 0)

  00036	f0 ff 4b 0c	 lock dec DWORD PTR [rbx+12]
  0003a	75 09		 jne	 SHORT $LN23@Destroy_ra

; 128  : 			_Delete_this();

  0003c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	ff 50 08	 call	 QWORD PTR [rax+8]
$LN23@Destroy_ra:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 88   : 	for (; _First != _Last; ++_First)

  00045	48 83 c7 10	 add	 rdi, 16
  00049	48 8d 47 f8	 lea	 rax, QWORD PTR [rdi-8]
  0004d	48 3b c6	 cmp	 rax, rsi
  00050	75 ce		 jne	 SHORT $LL3@Destroy_ra
  00052	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
  00057	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]

; 89   : 		_Al.destroy(_First);
; 90   : 	}

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5e		 pop	 rsi
$LN29@Destroy_ra:
  00061	f3 c3		 fatret	 0
??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@@std@@YAXPEAV?$shared_ptr@VChunkBase@@@0@0AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
_First$ = 64
_Last$ = 72
_Dest$ = 80
_Al$dead$ = 88
??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >, COMDAT

; 471  : 	{	// move [_First, _Last) to raw _Dest, using _Al

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 472  : 	return (_Uninit_move(_First, _Last, _Dest, _Al,
; 473  : 		_Val_type(_First), _Ptr_cat(_First, _Dest)));

  00004	e8 00 00 00 00	 call	 ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >

; 474  : 	}

  00009	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0000d	c3		 ret	 0
??$_Uninitialized_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@U?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@2@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	4d 8b c8	 mov	 r9, r8
  00003	48 8b c2	 mov	 rax, rdx
  00006	48 85 d2	 test	 rdx, rdx
  00009	74 22		 je	 SHORT $LN3@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 282  : 		{	// construct

  0000b	33 c9		 xor	 ecx, ecx
  0000d	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  00010	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 283  : 		}
; 284  : 
; 285  : 	_Ptr_base(_Myt&& _Right)
; 286  : 		: _Ptr(0), _Rep(0)
; 287  : 		{	// construct _Ptr_base object that takes resource from _Right
; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)
; 308  : 			_Swap(_Right);
; 309  : 		}
; 310  : 
; 311  : 	long use_count() const _NOEXCEPT
; 312  : 		{	// return use count
; 313  : 		return (_Rep ? _Rep->_Use_count() : 0);
; 314  : 		}
; 315  : 
; 316  : 	void _Swap(_Ptr_base& _Right)
; 317  : 		{	// swap pointers
; 318  : 		_STD swap(_Rep, _Right._Rep);
; 319  : 		_STD swap(_Ptr, _Right._Ptr);
; 320  : 		}
; 321  : 
; 322  : 	template<class _Ty2>
; 323  : 		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
; 324  : 		{	// compare addresses of manager objects
; 325  : 		return (_Rep < _Right._Rep);
; 326  : 		}
; 327  : 
; 328  : 	void *_Get_deleter(const _XSTD2 type_info& _Typeid) const
; 329  : 		{	// return pointer to deleter object if its type is _Typeid
; 330  : 		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
; 331  : 		}
; 332  : 
; 333  : 	_Ty *_Get() const
; 334  : 		{	// return pointer to resource
; 335  : 		return (_Ptr);
; 336  : 		}
; 337  : 
; 338  : 	bool _Expired() const
; 339  : 		{	// test if expired
; 340  : 		return (!_Rep || _Rep->_Expired());
; 341  : 		}
; 342  : 
; 343  : 	void _Decref()
; 344  : 		{	// decrement reference count
; 345  : 		if (_Rep != 0)
; 346  : 			_Rep->_Decref();
; 347  : 		}
; 348  : 
; 349  : 	void _Reset()
; 350  : 		{	// release resource
; 351  : 		_Reset(0, 0);
; 352  : 		}
; 353  : 
; 354  : 	template<class _Ty2>
; 355  : 		void _Reset(const _Ptr_base<_Ty2>& _Other)
; 356  : 		{	// release resource and take ownership of _Other._Ptr
; 357  : 		_Reset(_Other._Ptr, _Other._Rep);

  00014	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00018	49 8b 11	 mov	 rdx, QWORD PTR [r9]

; 358  : 		}
; 359  : 
; 360  : 	template<class _Ty2>
; 361  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
; 362  : 		{	// release resource and take ownership from weak_ptr _Other._Ptr
; 363  : 		_Reset(_Other._Ptr, _Other._Rep, _Throw);
; 364  : 		}
; 365  : 
; 366  : 	template<class _Ty2>
; 367  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Static_tag&)
; 368  : 		{	// release resource and take ownership of _Other._Ptr
; 369  : 		_Reset(static_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 370  : 		}
; 371  : 
; 372  : 	template<class _Ty2>
; 373  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Const_tag&)
; 374  : 		{	// release resource and take ownership of _Other._Ptr
; 375  : 		_Reset(const_cast<_Elem *>(_Other._Ptr), _Other._Rep);
; 376  : 		}
; 377  : 
; 378  : 	template<class _Ty2>
; 379  : 		void _Reset(const _Ptr_base<_Ty2>& _Other, const _Dynamic_tag&)
; 380  : 		{	// release resource and take ownership of _Other._Ptr
; 381  : 		_Elem *_Ptr = dynamic_cast<_Elem *>(_Other._Ptr);
; 382  : 		if (_Ptr)
; 383  : 			_Reset(_Ptr, _Other._Rep);
; 384  : 		else
; 385  : 			_Reset();
; 386  : 		}
; 387  : 
; 388  : 	template<class _Ty2>
; 389  : 		void _Reset(auto_ptr<_Ty2>&& _Other)
; 390  : 		{	// release resource and take _Other.get()
; 391  : 		_Ty2 *_Px = _Other.get();
; 392  : 		_Reset0(_Px, new _Ref_count<_Elem>(_Px));
; 393  : 		_Other.release();
; 394  : 		_Enable_shared(_Px, _Rep);
; 395  : 		}
; 396  : 
; 397  :  #if _HAS_CPP0X
; 398  : 	template<class _Ty2>
; 399  : 		void _Reset(_Ty *_Ptr, const _Ptr_base<_Ty2>& _Other)
; 400  : 		{	// release resource and alias _Ptr with _Other_rep
; 401  : 		_Reset(_Ptr, _Other._Rep);
; 402  : 		}
; 403  :  #endif /* _HAS_CPP0X */
; 404  : 
; 405  : 	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
; 406  : 		{	// release resource and take _Other_ptr through _Other_rep
; 407  : 		if (_Other_rep)

  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 05		 je	 SHORT $LN18@construct

; 108  : 		_MT_INCR(_Ignored, _Uses);

  00020	f0 41 ff 40 08	 lock inc DWORD PTR [r8+8]
$LN18@construct:

; 408  : 			_Other_rep->_Incref();
; 409  : 		_Reset0(_Other_ptr, _Other_rep);

  00025	48 8b c8	 mov	 rcx, rax
  00028	e9 00 00 00 00	 jmp	 ?_Reset0@?$_Ptr_base@VChunkBase@@@std@@QEAAXPEAVChunkBase@@PEAV_Ref_count_base@2@@Z ; std::_Ptr_base<ChunkBase>::_Reset0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0002d	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@AEAV12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@AEAV21@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xutility
;	COMDAT ??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z PROC ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>, COMDAT

; 711  : 	return (0);

  00000	33 c0		 xor	 eax, eax

; 712  : 	}

  00002	c3		 ret	 0
??$_Val_type@PEAV?$shared_ptr@VChunkBase@@@std@@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@@Z ENDP ; std::_Val_type<std::shared_ptr<ChunkBase> * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory
;	COMDAT ??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
_Dest$ = 24
_Al$dead$ = 32
__formal$dead$ = 40
__formal$dead$ = 48
??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >, COMDAT

; 426  : 	{	// move [_First, _Last) to raw _Dest, using _Al, arbitrary type

  00000	4c 8b c9	 mov	 r9, rcx

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00003	48 3b ca	 cmp	 rcx, rdx
  00006	74 3e		 je	 SHORT $LN4@Uninit_mov
  00008	45 33 d2	 xor	 r10d, r10d
  0000b	0f 1f 44 00 00	 npad	 5
$LL6@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00010	4d 85 c0	 test	 r8, r8
  00013	74 24		 je	 SHORT $LN51@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00015	4d 89 10	 mov	 QWORD PTR [r8], r10
  00018	4d 89 50 08	 mov	 QWORD PTR [r8+8], r10

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0001c	4d 3b c1	 cmp	 r8, r9
  0001f	74 18		 je	 SHORT $LN51@Uninit_mov
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00021	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  00025	49 89 40 08	 mov	 QWORD PTR [r8+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00029	4d 89 51 08	 mov	 QWORD PTR [r9+8], r10

; 48   : 	_Left = _Move(_Right);

  0002d	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00030	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  00033	49 89 00	 mov	 QWORD PTR [r8], rax

; 49   : 	_Right = _Move(_Tmp);

  00036	49 89 09	 mov	 QWORD PTR [r9], rcx
$LN51@Uninit_mov:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory

; 432  : 	for (; _First != _Last; ++_Dest, ++_First)

  00039	49 83 c1 10	 add	 r9, 16
  0003d	49 83 c0 10	 add	 r8, 16
  00041	4c 3b ca	 cmp	 r9, rdx
  00044	75 ca		 jne	 SHORT $LL6@Uninit_mov
$LN4@Uninit_mov:

; 433  : 		_Al.construct(_Dest, (_Valty&&)*_First);
; 434  : 	_CATCH_ALL
; 435  : 	for (; _Next != _Dest; ++_Next)
; 436  : 		_Al.destroy(_Next);
; 437  : 	_RERAISE;
; 438  : 	_CATCH_END
; 439  : 	return (_Dest);

  00046	49 8b c0	 mov	 rax, r8

; 440  : 	}

  00049	c3		 ret	 0
??$_Uninit_move@PEAV?$shared_ptr@VChunkBase@@@std@@PEAV12@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@2@V12@@std@@YAPEAV?$shared_ptr@VChunkBase@@@0@PEAV10@00AEAU?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_move<std::shared_ptr<ChunkBase> * __ptr64,std::shared_ptr<ChunkBase> * __ptr64,std::allocator<std::shared_ptr<ChunkBase> >,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN38@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN38@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN38@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 903  : _VARIADIC_EXPAND_0X(_WRAP_ALLOC_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::shared_ptr<ChunkBase> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$shared_ptr@VChunkBase@@@std@@@std@@YA$$QEAV?$shared_ptr@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z
_TEXT	SEGMENT
_Al$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z PROC ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN34@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN34@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN34@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 751  : _VARIADIC_EXPAND_0X(_ALLOC_TRAITS_SPECIAL_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator_traits@V?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@@std@@SAXAEAV?$allocator@V?$shared_ptr@VChunkBase@@@std@@@1@PEAV?$shared_ptr@VChunkBase@@@1@$$QEAV31@@Z ENDP ; std::allocator_traits<std::allocator<std::shared_ptr<ChunkBase> > >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0
;	COMDAT ??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Ptr$ = 16
_V0$ = 24
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z PROC ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >, COMDAT

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 26		 je	 SHORT $LN30@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00005	33 c9		 xor	 ecx, ecx
  00007	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0000a	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000e	49 3b d0	 cmp	 rdx, r8
  00011	74 18		 je	 SHORT $LN30@construct
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00013	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00017	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0001b	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx

; 48   : 	_Left = _Move(_Right);

  0001f	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00022	48 8b 0a	 mov	 rcx, QWORD PTR [rdx]
  00025	48 89 02	 mov	 QWORD PTR [rdx], rax

; 49   : 	_Right = _Move(_Tmp);

  00028	49 89 08	 mov	 QWORD PTR [r8], rcx
$LN30@construct:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\xmemory0

; 617  : _VARIADIC_EXPAND_0X(_ALLOC_MEMBER_CONSTRUCT, , , , )

  0002b	f3 c3		 fatret	 0
??$construct@V?$shared_ptr@VChunkBase@@@std@@V12@@?$allocator@V?$shared_ptr@VChunkBase@@@std@@@std@@QEAAXPEAV?$shared_ptr@VChunkBase@@@1@$$QEAV21@@Z ENDP ; std::allocator<std::shared_ptr<ChunkBase> >::construct<std::shared_ptr<ChunkBase>,std::shared_ptr<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z PROC	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>, COMDAT

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 89 01	 mov	 QWORD PTR [rcx], r8
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 288  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 289  : 		}
; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000a	48 3b ca	 cmp	 rcx, rdx
  0000d	74 18		 je	 SHORT $LN30@shared_ptr
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00013	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00017	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  0001b	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0001e	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00021	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00024	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN30@shared_ptr:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 581  : 		}

  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$shared_ptr@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ENDP	; std::shared_ptr<ChunkBase>::shared_ptr<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z PROC	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>, COMDAT

; 287  : 		{	// construct _Ptr_base object that takes resource from _Right

  00000	45 33 c0	 xor	 r8d, r8d
  00003	4c 89 01	 mov	 QWORD PTR [rcx], r8
  00006	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8

; 290  : 
; 291  : 	template<class _Ty2>
; 292  : 		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
; 293  : 		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
; 294  : 		{	// construct _Ptr_base object that takes resource from _Right
; 295  : 		_Right._Ptr = 0;
; 296  : 		_Right._Rep = 0;
; 297  : 		}
; 298  : 
; 299  : 	_Myt& operator=(_Myt&& _Right)
; 300  : 		{	// construct _Ptr_base object that takes resource from _Right
; 301  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 302  : 		return (*this);
; 303  : 		}
; 304  : 
; 305  : 	void _Assign_rv(_Myt&& _Right)
; 306  : 		{	// assign by moving _Right
; 307  : 		if (this != &_Right)

  0000a	48 3b ca	 cmp	 rcx, rdx
  0000d	74 18		 je	 SHORT $LN26@Ptr_base
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  0000f	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00013	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00017	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  0001b	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0001e	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00021	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00024	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN26@Ptr_base:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 289  : 		}

  00027	48 8b c1	 mov	 rax, rcx
  0002a	c3		 ret	 0
??0?$_Ptr_base@VChunkBase@@@std@@QEAA@$$QEAV01@@Z ENDP	; std::_Ptr_base<ChunkBase>::_Ptr_base<ChunkBase>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z PROC ; std::_Ptr_base<ChunkBase>::_Assign_rv, COMDAT

; 307  : 		if (this != &_Right)

  00000	48 3b ca	 cmp	 rcx, rdx
  00003	74 1c		 je	 SHORT $LN14@Assign_rv
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00005	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00009	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  0000d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  00011	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00015	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00018	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  0001b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  0001e	4c 89 02	 mov	 QWORD PTR [rdx], r8
$LN14@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 309  : 		}

  00021	f3 c3		 fatret	 0
?_Assign_rv@?$_Ptr_base@VChunkBase@@@std@@QEAAX$$QEAV12@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z PROC ; std::_Ptr_base<ChunkBase>::_Swap, COMDAT
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility

; 48   : 	_Left = _Move(_Right);

  00000	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00004	4c 8b 41 08	 mov	 r8, QWORD PTR [rcx+8]
  00008	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 49   : 	_Right = _Move(_Tmp);

  0000c	4c 89 42 08	 mov	 QWORD PTR [rdx+8], r8

; 48   : 	_Left = _Move(_Right);

  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00016	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00019	4c 89 02	 mov	 QWORD PTR [rdx], r8
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\memory

; 320  : 		}

  0001c	c3		 ret	 0
?_Swap@?$_Ptr_base@VChunkBase@@@std@@QEAAXAEAV12@@Z ENDP ; std::_Ptr_base<ChunkBase>::_Swap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z PROC ; std::forward<std::_Ptr_base<ChunkBase> >, COMDAT

; 1776 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1777 : 	}

  00003	c3		 ret	 0
??$forward@V?$_Ptr_base@VChunkBase@@@std@@@std@@YA$$QEAV?$_Ptr_base@VChunkBase@@@0@AEAV10@@Z ENDP ; std::forward<std::_Ptr_base<ChunkBase> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\utility
;	COMDAT ??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z PROC ; std::swap<ChunkBase * __ptr64>, COMDAT

; 47   : 	_Ty _Tmp = _Move(_Left);
; 48   : 	_Left = _Move(_Right);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	4c 8b 01	 mov	 r8, QWORD PTR [rcx]
  00006	48 89 01	 mov	 QWORD PTR [rcx], rax

; 49   : 	_Right = _Move(_Tmp);

  00009	4c 89 02	 mov	 QWORD PTR [rdx], r8

; 50   : 	}

  0000c	c3		 ret	 0
??$swap@PEAVChunkBase@@@std@@YAXAEAPEAVChunkBase@@0@Z ENDP ; std::swap<ChunkBase * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 11.0\vc\include\type_traits
;	COMDAT ??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z PROC ; std::_Move<ChunkBase * __ptr64 & __ptr64>, COMDAT

; 1799 : 	return ((typename remove_reference<_Ty>::type&&)_Arg);

  00000	48 8b c1	 mov	 rax, rcx

; 1800 : 	}

  00003	c3		 ret	 0
??$_Move@AEAPEAVChunkBase@@@std@@YA$$QEAPEAVChunkBase@@AEAPEAV1@@Z ENDP ; std::_Move<ChunkBase * __ptr64 & __ptr64>
_TEXT	ENDS
END
